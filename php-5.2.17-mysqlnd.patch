--- a/configure
+++ b/configure
@@ -967,17 +967,21 @@
   --with-mssql[=DIR]      Include MSSQL-DB support.  DIR is the FreeTDS home
                           directory [/usr/local/freetds]"
 ac_help="$ac_help
-  --with-mysql[=DIR]      Include MySQL support. DIR is the MySQL base directory"
+  --with-mysql[=DIR]      Include MySQL support.  DIR is the MySQL base
+                          directory.  If mysqlnd is passed as DIR, 
+                          the MySQL native driver will be used [/usr/local]"
 ac_help="$ac_help
-  --with-mysql-sock[=DIR]   MySQL: Location of the MySQL unix socket pointer.
+  --with-mysql-sock[=DIR]   MySQL/MySQLi/PDO_MYSQL: Location of the MySQL unix socket pointer.
                             If unspecified, the default locations are searched"
 ac_help="$ac_help
   --with-zlib-dir[=DIR]     MySQL: Set the path to libz install prefix"
 ac_help="$ac_help
-  --with-mysqli[=FILE]    Include MySQLi support.  FILE is the optional pathname 
-                          to mysql_config [mysql_config]"
+  --with-mysqli[=FILE]    Include MySQLi support.  FILE is the path
+                          to mysql_config.  If mysqlnd is passed as FILE,
+                          the MySQL native driver will be used [mysql_config]"
 ac_help="$ac_help
-  --enable-embedded-mysqli  MYSQLi: Enable embedded support"
+  --enable-embedded-mysqli  MYSQLi: Enable embedded support
+                            Note: Does not work with MySQL native driver!"
 ac_help="$ac_help
   --with-ncurses[=DIR]    Include ncurses support (CLI/CGI only)"
 ac_help="$ac_help
@@ -1032,7 +1036,9 @@
   --with-pdo-firebird[=DIR] PDO: Firebird support.  DIR is the Firebird base
                             install directory [/opt/firebird]"
 ac_help="$ac_help
-  --with-pdo-mysql[=DIR]    PDO: MySQL support. DIR is the MySQL base directory"
+  --with-pdo-mysql[=DIR]    PDO: MySQL support. DIR is the MySQL base directory
+                                 If mysqlnd is passed as DIR, the MySQL native
+                                 native driver will be used [/usr/local]"
 ac_help="$ac_help
   --with-zlib-dir[=DIR]       PDO_MySQL: Set the path to libz install prefix"
 ac_help="$ac_help
@@ -1166,6 +1172,14 @@
 ac_help="$ac_help
   --with-zlib-dir[=DIR]     ZIP: Set the path to libz install prefix"
 ac_help="$ac_help
+  --enable-mysqlnd        Enable mysqlnd explicitly, will be done implicitly
+                          when required by other extensions"
+ac_help="$ac_help
+  --disable-mysqlnd-compression-support
+                            Disable support for the MySQL compressed protocol in mysqlnd"
+ac_help="$ac_help
+  --with-zlib-dir[=DIR]       mysqlnd: Set the path to libz install prefix"
+ac_help="$ac_help
 
 PEAR:
 "
@@ -1884,12 +1898,12 @@
 
 
 echo $ac_n "checking for Cygwin environment""... $ac_c" 1>&6
-echo "configure:1888: checking for Cygwin environment" >&5
+echo "configure:1902: checking for Cygwin environment" >&5
 if eval "test \"`echo '$''{'ac_cv_cygwin'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1893 "configure"
+#line 1907 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -1900,7 +1914,7 @@
 return __CYGWIN__;
 ; return 0; }
 EOF
-if { (eval echo configure:1904: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1918: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_cygwin=yes
 else
@@ -1917,19 +1931,19 @@
 CYGWIN=
 test "$ac_cv_cygwin" = yes && CYGWIN=yes
 echo $ac_n "checking for mingw32 environment""... $ac_c" 1>&6
-echo "configure:1921: checking for mingw32 environment" >&5
+echo "configure:1935: checking for mingw32 environment" >&5
 if eval "test \"`echo '$''{'ac_cv_mingw32'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1926 "configure"
+#line 1940 "configure"
 #include "confdefs.h"
 
 int main() {
 return __MINGW32__;
 ; return 0; }
 EOF
-if { (eval echo configure:1933: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1947: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_mingw32=yes
 else
@@ -1948,7 +1962,7 @@
 
 
 echo $ac_n "checking for egrep""... $ac_c" 1>&6
-echo "configure:1952: checking for egrep" >&5
+echo "configure:1966: checking for egrep" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_egrep'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1963,7 +1977,7 @@
  
 
 echo $ac_n "checking for a sed that does not truncate output""... $ac_c" 1>&6
-echo "configure:1967: checking for a sed that does not truncate output" >&5
+echo "configure:1981: checking for a sed that does not truncate output" >&5
 if eval "test \"`echo '$''{'lt_cv_path_SED'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2113,7 +2127,7 @@
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:2117: checking host system type" >&5
+echo "configure:2131: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -2134,7 +2148,7 @@
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:2138: checking target system type" >&5
+echo "configure:2152: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
@@ -2246,7 +2260,7 @@
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2250: checking for $ac_word" >&5
+echo "configure:2264: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2276,7 +2290,7 @@
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2280: checking for $ac_word" >&5
+echo "configure:2294: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2327,7 +2341,7 @@
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2331: checking for $ac_word" >&5
+echo "configure:2345: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2359,7 +2373,7 @@
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:2363: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:2377: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -2370,12 +2384,12 @@
 
 cat > conftest.$ac_ext << EOF
 
-#line 2374 "configure"
+#line 2388 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:2379: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2393: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -2401,12 +2415,12 @@
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:2405: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2419: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:2410: checking whether we are using GNU C" >&5
+echo "configure:2424: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2415,7 +2429,7 @@
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2419: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2433: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -2434,7 +2448,7 @@
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:2438: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:2452: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2466,7 +2480,7 @@
 fi
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:2470: checking how to run the C preprocessor" >&5
+echo "configure:2484: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -2481,13 +2495,13 @@
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 2485 "configure"
+#line 2499 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2491: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2505: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2498,13 +2512,13 @@
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 2502 "configure"
+#line 2516 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2508: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2522: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2515,13 +2529,13 @@
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 2519 "configure"
+#line 2533 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2525: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2539: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2548,9 +2562,9 @@
 
   ICC="no"
   echo $ac_n "checking for icc""... $ac_c" 1>&6
-echo "configure:2552: checking for icc" >&5
+echo "configure:2566: checking for icc" >&5
   cat > conftest.$ac_ext <<EOF
-#line 2554 "configure"
+#line 2568 "configure"
 #include "confdefs.h"
 __INTEL_COMPILER
 EOF
@@ -2572,9 +2586,9 @@
 
   SUNCC="no"
   echo $ac_n "checking for suncc""... $ac_c" 1>&6
-echo "configure:2576: checking for suncc" >&5
+echo "configure:2590: checking for suncc" >&5
   cat > conftest.$ac_ext <<EOF
-#line 2578 "configure"
+#line 2592 "configure"
 #include "confdefs.h"
 __SUNPRO_C
 EOF
@@ -2597,10 +2611,10 @@
 
 if test "x$CC" != xcc; then
   echo $ac_n "checking whether $CC and cc understand -c and -o together""... $ac_c" 1>&6
-echo "configure:2601: checking whether $CC and cc understand -c and -o together" >&5
+echo "configure:2615: checking whether $CC and cc understand -c and -o together" >&5
 else
   echo $ac_n "checking whether cc understands -c and -o together""... $ac_c" 1>&6
-echo "configure:2604: checking whether cc understands -c and -o together" >&5
+echo "configure:2618: checking whether cc understands -c and -o together" >&5
 fi
 set dummy $CC; ac_cc="`echo $2 |
 		       sed -e 's/[^a-zA-Z0-9_]/_/g' -e 's/^[0-9]/_/'`"
@@ -2612,16 +2626,16 @@
 # We do the test twice because some compilers refuse to overwrite an
 # existing .o file with -o, though they will create one.
 ac_try='${CC-cc} -c conftest.c -o conftest.o 1>&5'
-if { (eval echo configure:2616: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; } &&
-   test -f conftest.o && { (eval echo configure:2617: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; };
+if { (eval echo configure:2630: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; } &&
+   test -f conftest.o && { (eval echo configure:2631: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; };
 then
   eval ac_cv_prog_cc_${ac_cc}_c_o=yes
   if test "x$CC" != xcc; then
     # Test first that cc exists at all.
-    if { ac_try='cc -c conftest.c 1>&5'; { (eval echo configure:2622: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; }; then
+    if { ac_try='cc -c conftest.c 1>&5'; { (eval echo configure:2636: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; }; then
       ac_try='cc -c conftest.c -o conftest.o 1>&5'
-      if { (eval echo configure:2624: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; } &&
-	 test -f conftest.o && { (eval echo configure:2625: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; };
+      if { (eval echo configure:2638: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; } &&
+	 test -f conftest.o && { (eval echo configure:2639: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; };
       then
         # cc works too.
         :
@@ -2648,7 +2662,7 @@
 fi
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:2652: checking how to run the C preprocessor" >&5
+echo "configure:2666: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -2663,13 +2677,13 @@
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 2667 "configure"
+#line 2681 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2673: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2687: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2680,13 +2694,13 @@
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 2684 "configure"
+#line 2698 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2690: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2704: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2697,13 +2711,13 @@
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 2701 "configure"
+#line 2715 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2707: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2721: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2728,9 +2742,9 @@
 echo "$ac_t""$CPP" 1>&6
 
 echo $ac_n "checking for AIX""... $ac_c" 1>&6
-echo "configure:2732: checking for AIX" >&5
+echo "configure:2746: checking for AIX" >&5
 cat > conftest.$ac_ext <<EOF
-#line 2734 "configure"
+#line 2748 "configure"
 #include "confdefs.h"
 #ifdef _AIX
   yes
@@ -2752,7 +2766,7 @@
 
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:2756: checking whether ln -s works" >&5
+echo "configure:2770: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2777,7 +2791,7 @@
 php_with_libdir=lib
 
 echo $ac_n "checking for system library directory""... $ac_c" 1>&6
-echo "configure:2781: checking for system library directory" >&5
+echo "configure:2795: checking for system library directory" >&5
 # Check whether --with-libdir or --without-libdir was given.
 if test "${with_libdir+set}" = set; then
   withval="$with_libdir"
@@ -2803,7 +2817,7 @@
 php_enable_rpath=yes
 
 echo $ac_n "checking whether to enable runpaths""... $ac_c" 1>&6
-echo "configure:2807: checking whether to enable runpaths" >&5
+echo "configure:2821: checking whether to enable runpaths" >&5
 # Check whether --enable-rpath or --disable-rpath was given.
 if test "${enable_rpath+set}" = set; then
   enableval="$enable_rpath"
@@ -2827,7 +2841,7 @@
 
 
 echo $ac_n "checking if compiler supports -R""... $ac_c" 1>&6
-echo "configure:2831: checking if compiler supports -R" >&5
+echo "configure:2845: checking if compiler supports -R" >&5
 if eval "test \"`echo '$''{'php_cv_cc_dashr'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2835,14 +2849,14 @@
   SAVE_LIBS=$LIBS
   LIBS="-R /usr/$PHP_LIBDIR $LIBS"
   cat > conftest.$ac_ext <<EOF
-#line 2839 "configure"
+#line 2853 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:2846: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   php_cv_cc_dashr=yes
 else
@@ -2860,7 +2874,7 @@
   ld_runpath_switch=-R
 else
   echo $ac_n "checking if compiler supports -Wl,-rpath,""... $ac_c" 1>&6
-echo "configure:2864: checking if compiler supports -Wl,-rpath," >&5
+echo "configure:2878: checking if compiler supports -Wl,-rpath," >&5
   if eval "test \"`echo '$''{'php_cv_cc_rpath'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2868,14 +2882,14 @@
     SAVE_LIBS=$LIBS
     LIBS="-Wl,-rpath,/usr/$PHP_LIBDIR $LIBS"
     cat > conftest.$ac_ext <<EOF
-#line 2872 "configure"
+#line 2886 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:2879: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2893: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   php_cv_cc_rpath=yes
 else
@@ -2906,7 +2920,7 @@
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2910: checking for $ac_word" >&5
+echo "configure:2924: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AWK'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2947,7 +2961,7 @@
       ;;
     *)
       echo $ac_n "checking if $AWK is broken""... $ac_c" 1>&6
-echo "configure:2951: checking if $AWK is broken" >&5
+echo "configure:2965: checking if $AWK is broken" >&5
       if ! $AWK 'function foo() {}' >/dev/null 2>&1 ; then
         echo "$ac_t""yes" 1>&6
         { echo "configure: error: You should install GNU awk" 1>&2; exit 1; }
@@ -2966,7 +2980,7 @@
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2970: checking for $ac_word" >&5
+echo "configure:2984: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3006,7 +3020,7 @@
   bison_version=none
   if test "$YACC"; then
     echo $ac_n "checking for bison version""... $ac_c" 1>&6
-echo "configure:3010: checking for bison version" >&5
+echo "configure:3024: checking for bison version" >&5
 if eval "test \"`echo '$''{'php_cv_bison_version'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3046,7 +3060,7 @@
   # Extract the first word of "flex", so it can be a program name with args.
 set dummy flex; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3050: checking for $ac_word" >&5
+echo "configure:3064: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LEX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3080,7 +3094,7 @@
   *) ac_lib=l ;;
   esac
   echo $ac_n "checking for yywrap in -l$ac_lib""... $ac_c" 1>&6
-echo "configure:3084: checking for yywrap in -l$ac_lib" >&5
+echo "configure:3098: checking for yywrap in -l$ac_lib" >&5
 ac_lib_var=`echo $ac_lib'_'yywrap | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3088,7 +3102,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$ac_lib  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3092 "configure"
+#line 3106 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3099,7 +3113,7 @@
 yywrap()
 ; return 0; }
 EOF
-if { (eval echo configure:3103: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3117: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3123,7 +3137,7 @@
 
   if test "$LEX" = "flex"; then
     echo $ac_n "checking lex output file root""... $ac_c" 1>&6
-echo "configure:3127: checking lex output file root" >&5
+echo "configure:3141: checking lex output file root" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_lex_root'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3144,7 +3158,7 @@
 LEX_OUTPUT_ROOT=$ac_cv_prog_lex_root
 
 echo $ac_n "checking whether yytext is a pointer""... $ac_c" 1>&6
-echo "configure:3148: checking whether yytext is a pointer" >&5
+echo "configure:3162: checking whether yytext is a pointer" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_lex_yytext_pointer'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3156,14 +3170,14 @@
 ac_save_LIBS="$LIBS"
 LIBS="$LIBS $LEXLIB"
 cat > conftest.$ac_ext <<EOF
-#line 3160 "configure"
+#line 3174 "configure"
 #include "confdefs.h"
 `cat $LEX_OUTPUT_ROOT.c`
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:3167: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3181: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_prog_lex_yytext_pointer=yes
 else
@@ -3187,12 +3201,12 @@
     :
   fi
         echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:3191: checking for working const" >&5
+echo "configure:3205: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3196 "configure"
+#line 3210 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -3241,7 +3255,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:3245: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3259: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -3267,7 +3281,7 @@
 
   if test "$LEX" = "flex"; then
     echo $ac_n "checking for flex version""... $ac_c" 1>&6
-echo "configure:3271: checking for flex version" >&5
+echo "configure:3285: checking for flex version" >&5
 if eval "test \"`echo '$''{'php_cv_flex_version'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3311,7 +3325,7 @@
   # Extract the first word of "re2c", so it can be a program name with args.
 set dummy re2c; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:3315: checking for $ac_word" >&5
+echo "configure:3329: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RE2C'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3339,7 +3353,7 @@
 
   if test -n "$RE2C"; then
     echo $ac_n "checking for re2c version""... $ac_c" 1>&6
-echo "configure:3343: checking for re2c version" >&5
+echo "configure:3357: checking for re2c version" >&5
 if eval "test \"`echo '$''{'php_cv_re2c_version'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3405,7 +3419,7 @@
       
   gcc_arg_name=ac_cv_gcc_arg_no_cpp_precomp
   echo $ac_n "checking whether $CC supports -no-cpp-precomp""... $ac_c" 1>&6
-echo "configure:3409: checking whether $CC supports -no-cpp-precomp" >&5
+echo "configure:3423: checking whether $CC supports -no-cpp-precomp" >&5
 if eval "test \"`echo '$''{'ac_cv_gcc_arg_no_cpp_precomp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3617,7 +3631,7 @@
 # Disable PIC mode by default where it is known to be safe to do so,
 # to avoid the performance hit from the lost register
 echo $ac_n "checking whether to force non-PIC code in shared modules""... $ac_c" 1>&6
-echo "configure:3621: checking whether to force non-PIC code in shared modules" >&5
+echo "configure:3635: checking whether to force non-PIC code in shared modules" >&5
 case $host_alias in
   i?86-*-linux*|i?86-*-freebsd*)
     if test "${with_pic+set}" != "set" || test "$with_pic" = "no"; then
@@ -3647,7 +3661,7 @@
 
 
 echo $ac_n "checking whether /dev/urandom exists""... $ac_c" 1>&6
-echo "configure:3651: checking whether /dev/urandom exists" >&5 
+echo "configure:3665: checking whether /dev/urandom exists" >&5 
 if test -r "/dev/urandom" && test -c "/dev/urandom"; then 
   cat >> confdefs.h <<\EOF
 #define HAVE_DEV_URANDOM 1
@@ -3708,7 +3722,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 3712 "configure"
+#line 3726 "configure"
 #include "confdefs.h"
 
 #include <pthread.h>
@@ -3726,7 +3740,7 @@
     return pthread_create(&thd, NULL, thread_routine, &data);
 } 
 EOF
-if { (eval echo configure:3730: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3744: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   pthreads_working=yes
@@ -3746,7 +3760,7 @@
   CFLAGS=$save_CFLAGS
 
   echo $ac_n "checking for pthreads_cflags""... $ac_c" 1>&6
-echo "configure:3750: checking for pthreads_cflags" >&5
+echo "configure:3764: checking for pthreads_cflags" >&5
 if eval "test \"`echo '$''{'ac_cv_pthreads_cflags'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3768,7 +3782,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 3772 "configure"
+#line 3786 "configure"
 #include "confdefs.h"
 
 #include <pthread.h>
@@ -3786,7 +3800,7 @@
     return pthread_create(&thd, NULL, thread_routine, &data);
 } 
 EOF
-if { (eval echo configure:3790: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3804: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   pthreads_working=yes
@@ -3816,7 +3830,7 @@
 echo "$ac_t""$ac_cv_pthreads_cflags" 1>&6
 
 echo $ac_n "checking for pthreads_lib""... $ac_c" 1>&6
-echo "configure:3820: checking for pthreads_lib" >&5
+echo "configure:3834: checking for pthreads_lib" >&5
 if eval "test \"`echo '$''{'ac_cv_pthreads_lib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3838,7 +3852,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 3842 "configure"
+#line 3856 "configure"
 #include "confdefs.h"
 
 #include <pthread.h>
@@ -3856,7 +3870,7 @@
     return pthread_create(&thd, NULL, thread_routine, &data);
 } 
 EOF
-if { (eval echo configure:3860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3874: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   pthreads_working=yes
@@ -3990,7 +4004,7 @@
 
 
 echo $ac_n "checking for AOLserver support""... $ac_c" 1>&6
-echo "configure:3994: checking for AOLserver support" >&5
+echo "configure:4008: checking for AOLserver support" >&5
 
 if test "$PHP_AOLSERVER" != "no"; then
   if test -d "$PHP_AOLSERVER/include"; then
@@ -4247,7 +4261,7 @@
 
 
 echo $ac_n "checking for Apache 1.x module support via DSO through APXS""... $ac_c" 1>&6
-echo "configure:4251: checking for Apache 1.x module support via DSO through APXS" >&5
+echo "configure:4265: checking for Apache 1.x module support via DSO through APXS" >&5
 
 if test "$PHP_APXS" != "no"; then
   if test "$PHP_APXS" = "yes"; then
@@ -4570,7 +4584,7 @@
 
 
 echo $ac_n "checking for Apache 1.x module support""... $ac_c" 1>&6
-echo "configure:4574: checking for Apache 1.x module support" >&5
+echo "configure:4588: checking for Apache 1.x module support" >&5
 
 if test "$PHP_SAPI" != "apache" && test "$PHP_APACHE" != "no"; then
   
@@ -5403,7 +5417,7 @@
 php_enable_mod_charset=no
 
 echo $ac_n "checking whether to enable Apache charset compatibility option""... $ac_c" 1>&6
-echo "configure:5407: checking whether to enable Apache charset compatibility option" >&5
+echo "configure:5421: checking whether to enable Apache charset compatibility option" >&5
 # Check whether --enable-mod-charset or --disable-mod-charset was given.
 if test "${enable_mod_charset+set}" = set; then
   enableval="$enable_mod_charset"
@@ -5438,7 +5452,7 @@
         
   gcc_arg_name=ac_cv_gcc_arg_rdynamic
   echo $ac_n "checking whether $CC supports -rdynamic""... $ac_c" 1>&6
-echo "configure:5442: checking whether $CC supports -rdynamic" >&5
+echo "configure:5456: checking whether $CC supports -rdynamic" >&5
 if eval "test \"`echo '$''{'ac_cv_gcc_arg_rdynamic'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5481,7 +5495,7 @@
 
   
 echo $ac_n "checking for member fd in BUFF *""... $ac_c" 1>&6
-echo "configure:5485: checking for member fd in BUFF *" >&5
+echo "configure:5499: checking for member fd in BUFF *" >&5
 if eval "test \"`echo '$''{'ac_cv_php_fd_in_buff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5493,14 +5507,14 @@
     CPPFLAGS="$CPPFLAGS $APACHE_INCLUDE"
   fi
   cat > conftest.$ac_ext <<EOF
-#line 5497 "configure"
+#line 5511 "configure"
 #include "confdefs.h"
 #include <httpd.h>
 int main() {
 conn_rec *c; int fd = c->client->fd;
 ; return 0; }
 EOF
-if { (eval echo configure:5504: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5518: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     ac_cv_php_fd_in_buff=yes
@@ -5576,7 +5590,7 @@
 
 
 echo $ac_n "checking for Apache 2.0 filter-module support via DSO through APXS""... $ac_c" 1>&6
-echo "configure:5580: checking for Apache 2.0 filter-module support via DSO through APXS" >&5
+echo "configure:5594: checking for Apache 2.0 filter-module support via DSO through APXS" >&5
 
 if test "$PHP_APXS2FILTER" != "no"; then
   if test "$PHP_APXS2FILTER" = "yes"; then
@@ -6424,7 +6438,7 @@
 
 
 echo $ac_n "checking for Apache 2.0 handler-module support via DSO through APXS""... $ac_c" 1>&6
-echo "configure:6428: checking for Apache 2.0 handler-module support via DSO through APXS" >&5
+echo "configure:6442: checking for Apache 2.0 handler-module support via DSO through APXS" >&5
 
 if test "$PHP_APXS2" != "no"; then
   if test "$PHP_APXS2" = "yes"; then
@@ -7273,7 +7287,7 @@
 
 
 echo $ac_n "checking for Apache 1.x (hooks) module support via DSO through APXS""... $ac_c" 1>&6
-echo "configure:7277: checking for Apache 1.x (hooks) module support via DSO through APXS" >&5
+echo "configure:7291: checking for Apache 1.x (hooks) module support via DSO through APXS" >&5
 
 if test "$PHP_APACHE_HOOKS" != "no"; then
   if test "$PHP_APACHE_HOOKS" = "yes"; then
@@ -7596,7 +7610,7 @@
 
 
 echo $ac_n "checking for Apache 1.x (hooks) module support""... $ac_c" 1>&6
-echo "configure:7600: checking for Apache 1.x (hooks) module support" >&5
+echo "configure:7614: checking for Apache 1.x (hooks) module support" >&5
 
 if test "$PHP_SAPI" != "apache" && test "$PHP_SAPI" != "apache_hooks" && test "$PHP_APACHE_HOOKS_STATIC" != "no"; then
 
@@ -8429,7 +8443,7 @@
 php_enable_mod_charset=no
 
 echo $ac_n "checking whether to enable Apache charset compatibility option""... $ac_c" 1>&6
-echo "configure:8433: checking whether to enable Apache charset compatibility option" >&5
+echo "configure:8447: checking whether to enable Apache charset compatibility option" >&5
 # Check whether --enable-mod-charset or --disable-mod-charset was given.
 if test "${enable_mod_charset+set}" = set; then
   enableval="$enable_mod_charset"
@@ -8464,7 +8478,7 @@
         
   gcc_arg_name=ac_cv_gcc_arg_rdynamic
   echo $ac_n "checking whether $CC supports -rdynamic""... $ac_c" 1>&6
-echo "configure:8468: checking whether $CC supports -rdynamic" >&5
+echo "configure:8482: checking whether $CC supports -rdynamic" >&5
 if eval "test \"`echo '$''{'ac_cv_gcc_arg_rdynamic'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8507,7 +8521,7 @@
 
   
 echo $ac_n "checking for member fd in BUFF *""... $ac_c" 1>&6
-echo "configure:8511: checking for member fd in BUFF *" >&5
+echo "configure:8525: checking for member fd in BUFF *" >&5
 if eval "test \"`echo '$''{'ac_cv_php_fd_in_buff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8519,14 +8533,14 @@
     CPPFLAGS="$CPPFLAGS $APACHE_INCLUDE"
   fi
   cat > conftest.$ac_ext <<EOF
-#line 8523 "configure"
+#line 8537 "configure"
 #include "confdefs.h"
 #include <httpd.h>
 int main() {
 conn_rec *c; int fd = c->client->fd;
 ; return 0; }
 EOF
-if { (eval echo configure:8530: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:8544: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     ac_cv_php_fd_in_buff=yes
@@ -8603,7 +8617,7 @@
 
 
 echo $ac_n "checking for Caudium support""... $ac_c" 1>&6
-echo "configure:8607: checking for Caudium support" >&5
+echo "configure:8621: checking for Caudium support" >&5
 
 if test "$PHP_CAUDIUM" != "no"; then
   if test "$prefix" = "NONE"; then CPREF=/usr/local/; fi
@@ -8673,7 +8687,7 @@
       PIKE_C_INCLUDE=/usr/local/include/`basename $PIKE`
     fi
     echo $ac_n "checking for C includes in $PIKE_C_INCLUDE""... $ac_c" 1>&6
-echo "configure:8677: checking for C includes in $PIKE_C_INCLUDE" >&5
+echo "configure:8691: checking for C includes in $PIKE_C_INCLUDE" >&5
     if test -f $PIKE_C_INCLUDE/version.h; then
       PIKE_TEST_VER=`$PIKE -e 'string v; int rel;sscanf(version(), "Pike v%s release %d", v, rel); write(v+"."+rel);'`
       ###### VERSION MATCH CHECK #######
@@ -8954,7 +8968,7 @@
 
 
 echo $ac_n "checking for CLI build""... $ac_c" 1>&6
-echo "configure:8958: checking for CLI build" >&5
+echo "configure:8972: checking for CLI build" >&5
 if test "$PHP_CLI" != "no"; then
   
   src=$abs_srcdir/sapi/cli/Makefile.frag
@@ -9004,7 +9018,7 @@
 php_with_continuity=no
 
 echo $ac_n "checking for Continuity support""... $ac_c" 1>&6
-echo "configure:9008: checking for Continuity support" >&5
+echo "configure:9022: checking for Continuity support" >&5
 # Check whether --with-continuity or --without-continuity was given.
 if test "${with_continuity+set}" = set; then
   withval="$with_continuity"
@@ -9031,7 +9045,7 @@
     { echo "configure: error: Please specify the path to the root of your Continuity server using --with-continuity=DIR" 1>&2; exit 1; }
   fi
   echo $ac_n "checking for Continuity include files""... $ac_c" 1>&6
-echo "configure:9035: checking for Continuity include files" >&5
+echo "configure:9049: checking for Continuity include files" >&5
   if test -d $PHP_CONTINUITY/include ; then
     CAPI_INCLUDE=$PHP_CONTINUITY/include
     echo "$ac_t""Continuity Binary Distribution" 1>&6
@@ -9281,7 +9295,7 @@
 
 
 echo $ac_n "checking for embedded SAPI library support""... $ac_c" 1>&6
-echo "configure:9285: checking for embedded SAPI library support" >&5
+echo "configure:9299: checking for embedded SAPI library support" >&5
 
 if test "$PHP_EMBED" != "no"; then
   case "$PHP_EMBED" in
@@ -9498,7 +9512,7 @@
 php_with_isapi=no
 
 echo $ac_n "checking for Zeus ISAPI support""... $ac_c" 1>&6
-echo "configure:9502: checking for Zeus ISAPI support" >&5
+echo "configure:9516: checking for Zeus ISAPI support" >&5
 # Check whether --with-isapi or --without-isapi was given.
 if test "${with_isapi+set}" = set; then
   withval="$with_isapi"
@@ -9747,7 +9761,7 @@
 php_with_milter=no
 
 echo $ac_n "checking for Milter support""... $ac_c" 1>&6
-echo "configure:9751: checking for Milter support" >&5
+echo "configure:9765: checking for Milter support" >&5
 # Check whether --with-milter or --without-milter was given.
 if test "${with_milter+set}" = set; then
   withval="$with_milter"
@@ -10031,7 +10045,7 @@
 php_with_nsapi=no
 
 echo $ac_n "checking for NSAPI support""... $ac_c" 1>&6
-echo "configure:10035: checking for NSAPI support" >&5
+echo "configure:10049: checking for NSAPI support" >&5
 # Check whether --with-nsapi or --without-nsapi was given.
 if test "${with_nsapi+set}" = set; then
   withval="$with_nsapi"
@@ -10058,7 +10072,7 @@
     { echo "configure: error: Please specify the path to the root of your Netscape/iPlanet/Sun Webserver using --with-nsapi=DIR" 1>&2; exit 1; }
   fi
   echo $ac_n "checking for NSAPI include files""... $ac_c" 1>&6
-echo "configure:10062: checking for NSAPI include files" >&5
+echo "configure:10076: checking for NSAPI include files" >&5
   if test -d $PHP_NSAPI/include ; then
     NSAPI_INC_DIR="$PHP_NSAPI/include"
     echo "$ac_t""Netscape 3.x / Sun 7.x style" 1>&6
@@ -10066,17 +10080,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:10070: checking for $ac_hdr" >&5
+echo "configure:10084: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 10075 "configure"
+#line 10089 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:10080: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:10094: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -10111,17 +10125,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:10115: checking for $ac_hdr" >&5
+echo "configure:10129: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 10120 "configure"
+#line 10134 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:10125: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:10139: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -10383,7 +10397,7 @@
 php_with_phttpd=no
 
 echo $ac_n "checking for PHTTPD support""... $ac_c" 1>&6
-echo "configure:10387: checking for PHTTPD support" >&5
+echo "configure:10401: checking for PHTTPD support" >&5
 # Check whether --with-phttpd or --without-phttpd was given.
 if test "${with_phttpd+set}" = set; then
   withval="$with_phttpd"
@@ -10629,7 +10643,7 @@
 php_with_pi3web=no
 
 echo $ac_n "checking for Pi3Web support""... $ac_c" 1>&6
-echo "configure:10633: checking for Pi3Web support" >&5
+echo "configure:10647: checking for Pi3Web support" >&5
 # Check whether --with-pi3web or --without-pi3web was given.
 if test "${with_pi3web+set}" = set; then
   withval="$with_pi3web"
@@ -10996,7 +11010,7 @@
 php_enable_roxen_zts=no
 
 echo $ac_n "checking whether Roxen module is build using ZTS""... $ac_c" 1>&6
-echo "configure:11000: checking whether Roxen module is build using ZTS" >&5
+echo "configure:11014: checking whether Roxen module is build using ZTS" >&5
 # Check whether --enable-roxen-zts or --disable-roxen-zts was given.
 if test "${enable_roxen_zts+set}" = set; then
   enableval="$enable_roxen_zts"
@@ -11020,7 +11034,7 @@
 
 RESULT=
 echo $ac_n "checking for Roxen/Pike support""... $ac_c" 1>&6
-echo "configure:11024: checking for Roxen/Pike support" >&5
+echo "configure:11038: checking for Roxen/Pike support" >&5
 if test "$PHP_ROXEN" != "no"; then
   if test ! -d $PHP_ROXEN ; then
     { echo "configure: error: You did not specify a directory" 1>&2; exit 1; }
@@ -11298,7 +11312,7 @@
 
 
 echo $ac_n "checking for thttpd""... $ac_c" 1>&6
-echo "configure:11302: checking for thttpd" >&5
+echo "configure:11316: checking for thttpd" >&5
 
 if test "$PHP_THTTPD" != "no"; then
   if test ! -d $PHP_THTTPD; then
@@ -11331,7 +11345,7 @@
         
   gcc_arg_name=ac_cv_gcc_arg_rdynamic
   echo $ac_n "checking whether $CC supports -rdynamic""... $ac_c" 1>&6
-echo "configure:11335: checking whether $CC supports -rdynamic" >&5
+echo "configure:11349: checking whether $CC supports -rdynamic" >&5
 if eval "test \"`echo '$''{'ac_cv_gcc_arg_rdynamic'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -11559,24 +11573,24 @@
 
 
 echo $ac_n "checking for TUX""... $ac_c" 1>&6
-echo "configure:11563: checking for TUX" >&5
+echo "configure:11577: checking for TUX" >&5
 if test "$PHP_TUX" != "no"; then
   INSTALL_IT="\$(INSTALL) -m 0755 $SAPI_SHARED $PHP_TUX/php5.tux.so"
   for ac_hdr in tuxmodule.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:11570: checking for $ac_hdr" >&5
+echo "configure:11584: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 11575 "configure"
+#line 11589 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:11580: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:11594: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -11805,7 +11819,7 @@
 
 
 echo $ac_n "checking for webjames""... $ac_c" 1>&6
-echo "configure:11809: checking for webjames" >&5
+echo "configure:11823: checking for webjames" >&5
 
 if test "$PHP_WEBJAMES" != "no"; then
   
@@ -12157,7 +12171,7 @@
 
 if test "$PHP_SAPI" = "default"; then
   echo $ac_n "checking whether to build CGI binary""... $ac_c" 1>&6
-echo "configure:12161: checking whether to build CGI binary" >&5
+echo "configure:12175: checking whether to build CGI binary" >&5
   if test "$PHP_CGI" != "no"; then
     echo "$ac_t""yes" 1>&6
     
@@ -12180,7 +12194,7 @@
 
 
         echo $ac_n "checking whether to enable fastcgi support""... $ac_c" 1>&6
-echo "configure:12184: checking whether to enable fastcgi support" >&5
+echo "configure:12198: checking whether to enable fastcgi support" >&5
     if test "$PHP_FASTCGI" = "yes"; then
       PHP_ENABLE_FASTCGI=1
       PHP_FCGI_FILES="fastcgi.c"
@@ -12195,7 +12209,7 @@
     echo "$ac_t""$PHP_FASTCGI" 1>&6
 
         echo $ac_n "checking whether to force Apache CGI redirect""... $ac_c" 1>&6
-echo "configure:12199: checking whether to force Apache CGI redirect" >&5
+echo "configure:12213: checking whether to force Apache CGI redirect" >&5
     if test "$PHP_FORCE_CGI_REDIRECT" = "yes"; then
       CGI_REDIRECT=1
     else
@@ -12208,7 +12222,7 @@
     echo "$ac_t""$PHP_FORCE_CGI_REDIRECT" 1>&6
 
         echo $ac_n "checking whether to discard path_info + path_translated""... $ac_c" 1>&6
-echo "configure:12212: checking whether to discard path_info + path_translated" >&5
+echo "configure:12226: checking whether to discard path_info + path_translated" >&5
     if test "$PHP_DISCARD_PATH" = "yes"; then
       DISCARD_PATH=1
     else
@@ -12221,7 +12235,7 @@
     echo "$ac_t""$PHP_DISCARD_PATH" 1>&6
 
         echo $ac_n "checking whether to enable path info checking""... $ac_c" 1>&6
-echo "configure:12225: checking whether to enable path info checking" >&5
+echo "configure:12239: checking whether to enable path info checking" >&5
     if test "$PHP_PATH_INFO_CHECK" = "yes"; then
       ENABLE_PATHINFO_CHECK=1
     else
@@ -12433,7 +12447,7 @@
 
 
 echo $ac_n "checking for chosen SAPI module""... $ac_c" 1>&6
-echo "configure:12437: checking for chosen SAPI module" >&5
+echo "configure:12451: checking for chosen SAPI module" >&5
 echo "$ac_t""$PHP_SAPI" 1>&6
 
 if test "$enable_maintainer_zts" = "yes"; then
@@ -12490,7 +12504,7 @@
   # Extract the first word of "sendmail", so it can be a program name with args.
 set dummy sendmail; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:12494: checking for $ac_word" >&5
+echo "configure:12508: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PROG_SENDMAIL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -12529,7 +12543,7 @@
 
 
   echo $ac_n "checking whether system uses EBCDIC""... $ac_c" 1>&6
-echo "configure:12533: checking whether system uses EBCDIC" >&5
+echo "configure:12547: checking whether system uses EBCDIC" >&5
 if eval "test \"`echo '$''{'ac_cv_ebcdic'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -12540,7 +12554,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 12544 "configure"
+#line 12558 "configure"
 #include "confdefs.h"
 
 int main(void) { 
@@ -12548,7 +12562,7 @@
 } 
 
 EOF
-if { (eval echo configure:12552: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:12566: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_ebcdic=yes
@@ -12576,7 +12590,7 @@
 
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:12580: checking whether byte ordering is bigendian" >&5
+echo "configure:12594: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian_php'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -12586,7 +12600,7 @@
   ac_cv_c_bigendian_php=unknown
 else
   cat > conftest.$ac_ext <<EOF
-#line 12590 "configure"
+#line 12604 "configure"
 #include "confdefs.h"
 
 int main(void)
@@ -12602,7 +12616,7 @@
 }
   
 EOF
-if { (eval echo configure:12606: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:12620: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian_php=yes
 else
@@ -12628,7 +12642,7 @@
 
 
   echo $ac_n "checking whether writing to stdout works""... $ac_c" 1>&6
-echo "configure:12632: checking whether writing to stdout works" >&5
+echo "configure:12646: checking whether writing to stdout works" >&5
 if eval "test \"`echo '$''{'ac_cv_write_stdout'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -12639,7 +12653,7 @@
     
 else
   cat > conftest.$ac_ext <<EOF
-#line 12643 "configure"
+#line 12657 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -12657,7 +12671,7 @@
 }
     
 EOF
-if { (eval echo configure:12661: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:12675: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       ac_cv_write_stdout=yes
@@ -12732,12 +12746,12 @@
   unset found
   
   echo $ac_n "checking for socket""... $ac_c" 1>&6
-echo "configure:12736: checking for socket" >&5
+echo "configure:12750: checking for socket" >&5
 if eval "test \"`echo '$''{'ac_cv_func_socket'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 12741 "configure"
+#line 12755 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char socket(); below.  */
@@ -12760,7 +12774,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:12764: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:12778: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_socket=yes"
 else
@@ -12778,12 +12792,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __socket""... $ac_c" 1>&6
-echo "configure:12782: checking for __socket" >&5
+echo "configure:12796: checking for __socket" >&5
 if eval "test \"`echo '$''{'ac_cv_func___socket'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 12787 "configure"
+#line 12801 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __socket(); below.  */
@@ -12806,7 +12820,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:12810: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:12824: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___socket=yes"
 else
@@ -12844,7 +12858,7 @@
   unset ac_cv_lib_socket___socket
   unset found
   echo $ac_n "checking for socket in -lsocket""... $ac_c" 1>&6
-echo "configure:12848: checking for socket in -lsocket" >&5
+echo "configure:12862: checking for socket in -lsocket" >&5
 ac_lib_var=`echo socket'_'socket | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -12852,7 +12866,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 12856 "configure"
+#line 12870 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -12863,7 +12877,7 @@
 socket()
 ; return 0; }
 EOF
-if { (eval echo configure:12867: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:12881: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -12883,7 +12897,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __socket in -lsocket""... $ac_c" 1>&6
-echo "configure:12887: checking for __socket in -lsocket" >&5
+echo "configure:12901: checking for __socket in -lsocket" >&5
 ac_lib_var=`echo socket'_'__socket | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -12891,7 +12905,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 12895 "configure"
+#line 12909 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -12902,7 +12916,7 @@
 __socket()
 ; return 0; }
 EOF
-if { (eval echo configure:12906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:12920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -12934,11 +12948,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 12938 "configure"
+#line 12952 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:12942: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:12956: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -12989,12 +13003,12 @@
   unset found
   
   echo $ac_n "checking for socketpair""... $ac_c" 1>&6
-echo "configure:12993: checking for socketpair" >&5
+echo "configure:13007: checking for socketpair" >&5
 if eval "test \"`echo '$''{'ac_cv_func_socketpair'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 12998 "configure"
+#line 13012 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char socketpair(); below.  */
@@ -13017,7 +13031,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13021: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13035: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_socketpair=yes"
 else
@@ -13035,12 +13049,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __socketpair""... $ac_c" 1>&6
-echo "configure:13039: checking for __socketpair" >&5
+echo "configure:13053: checking for __socketpair" >&5
 if eval "test \"`echo '$''{'ac_cv_func___socketpair'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13044 "configure"
+#line 13058 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __socketpair(); below.  */
@@ -13063,7 +13077,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13067: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13081: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___socketpair=yes"
 else
@@ -13101,7 +13115,7 @@
   unset ac_cv_lib_socket___socketpair
   unset found
   echo $ac_n "checking for socketpair in -lsocket""... $ac_c" 1>&6
-echo "configure:13105: checking for socketpair in -lsocket" >&5
+echo "configure:13119: checking for socketpair in -lsocket" >&5
 ac_lib_var=`echo socket'_'socketpair | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13109,7 +13123,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13113 "configure"
+#line 13127 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13120,7 +13134,7 @@
 socketpair()
 ; return 0; }
 EOF
-if { (eval echo configure:13124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13138: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13140,7 +13154,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __socketpair in -lsocket""... $ac_c" 1>&6
-echo "configure:13144: checking for __socketpair in -lsocket" >&5
+echo "configure:13158: checking for __socketpair in -lsocket" >&5
 ac_lib_var=`echo socket'_'__socketpair | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13148,7 +13162,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13152 "configure"
+#line 13166 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13159,7 +13173,7 @@
 __socketpair()
 ; return 0; }
 EOF
-if { (eval echo configure:13163: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13177: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13191,11 +13205,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 13195 "configure"
+#line 13209 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:13199: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:13213: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -13246,12 +13260,12 @@
   unset found
   
   echo $ac_n "checking for htonl""... $ac_c" 1>&6
-echo "configure:13250: checking for htonl" >&5
+echo "configure:13264: checking for htonl" >&5
 if eval "test \"`echo '$''{'ac_cv_func_htonl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13255 "configure"
+#line 13269 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char htonl(); below.  */
@@ -13274,7 +13288,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13278: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13292: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_htonl=yes"
 else
@@ -13292,12 +13306,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __htonl""... $ac_c" 1>&6
-echo "configure:13296: checking for __htonl" >&5
+echo "configure:13310: checking for __htonl" >&5
 if eval "test \"`echo '$''{'ac_cv_func___htonl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13301 "configure"
+#line 13315 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __htonl(); below.  */
@@ -13320,7 +13334,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13324: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___htonl=yes"
 else
@@ -13358,7 +13372,7 @@
   unset ac_cv_lib_socket___htonl
   unset found
   echo $ac_n "checking for htonl in -lsocket""... $ac_c" 1>&6
-echo "configure:13362: checking for htonl in -lsocket" >&5
+echo "configure:13376: checking for htonl in -lsocket" >&5
 ac_lib_var=`echo socket'_'htonl | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13366,7 +13380,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13370 "configure"
+#line 13384 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13377,7 +13391,7 @@
 htonl()
 ; return 0; }
 EOF
-if { (eval echo configure:13381: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13395: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13397,7 +13411,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __htonl in -lsocket""... $ac_c" 1>&6
-echo "configure:13401: checking for __htonl in -lsocket" >&5
+echo "configure:13415: checking for __htonl in -lsocket" >&5
 ac_lib_var=`echo socket'_'__htonl | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13405,7 +13419,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13409 "configure"
+#line 13423 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13416,7 +13430,7 @@
 __htonl()
 ; return 0; }
 EOF
-if { (eval echo configure:13420: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13434: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13448,11 +13462,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 13452 "configure"
+#line 13466 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:13456: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:13470: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -13503,12 +13517,12 @@
   unset found
   
   echo $ac_n "checking for gethostname""... $ac_c" 1>&6
-echo "configure:13507: checking for gethostname" >&5
+echo "configure:13521: checking for gethostname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13512 "configure"
+#line 13526 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostname(); below.  */
@@ -13531,7 +13545,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13535: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13549: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostname=yes"
 else
@@ -13549,12 +13563,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __gethostname""... $ac_c" 1>&6
-echo "configure:13553: checking for __gethostname" >&5
+echo "configure:13567: checking for __gethostname" >&5
 if eval "test \"`echo '$''{'ac_cv_func___gethostname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13558 "configure"
+#line 13572 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __gethostname(); below.  */
@@ -13577,7 +13591,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13581: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13595: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___gethostname=yes"
 else
@@ -13615,7 +13629,7 @@
   unset ac_cv_lib_nsl___gethostname
   unset found
   echo $ac_n "checking for gethostname in -lnsl""... $ac_c" 1>&6
-echo "configure:13619: checking for gethostname in -lnsl" >&5
+echo "configure:13633: checking for gethostname in -lnsl" >&5
 ac_lib_var=`echo nsl'_'gethostname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13623,7 +13637,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13627 "configure"
+#line 13641 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13634,7 +13648,7 @@
 gethostname()
 ; return 0; }
 EOF
-if { (eval echo configure:13638: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13652: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13654,7 +13668,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __gethostname in -lnsl""... $ac_c" 1>&6
-echo "configure:13658: checking for __gethostname in -lnsl" >&5
+echo "configure:13672: checking for __gethostname in -lnsl" >&5
 ac_lib_var=`echo nsl'_'__gethostname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13662,7 +13676,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13666 "configure"
+#line 13680 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13673,7 +13687,7 @@
 __gethostname()
 ; return 0; }
 EOF
-if { (eval echo configure:13677: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13691: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13705,11 +13719,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 13709 "configure"
+#line 13723 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:13713: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:13727: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -13760,12 +13774,12 @@
   unset found
   
   echo $ac_n "checking for gethostbyaddr""... $ac_c" 1>&6
-echo "configure:13764: checking for gethostbyaddr" >&5
+echo "configure:13778: checking for gethostbyaddr" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostbyaddr'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13769 "configure"
+#line 13783 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyaddr(); below.  */
@@ -13788,7 +13802,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13792: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13806: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostbyaddr=yes"
 else
@@ -13806,12 +13820,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __gethostbyaddr""... $ac_c" 1>&6
-echo "configure:13810: checking for __gethostbyaddr" >&5
+echo "configure:13824: checking for __gethostbyaddr" >&5
 if eval "test \"`echo '$''{'ac_cv_func___gethostbyaddr'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 13815 "configure"
+#line 13829 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __gethostbyaddr(); below.  */
@@ -13834,7 +13848,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:13838: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13852: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___gethostbyaddr=yes"
 else
@@ -13872,7 +13886,7 @@
   unset ac_cv_lib_nsl___gethostbyaddr
   unset found
   echo $ac_n "checking for gethostbyaddr in -lnsl""... $ac_c" 1>&6
-echo "configure:13876: checking for gethostbyaddr in -lnsl" >&5
+echo "configure:13890: checking for gethostbyaddr in -lnsl" >&5
 ac_lib_var=`echo nsl'_'gethostbyaddr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13880,7 +13894,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13884 "configure"
+#line 13898 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13891,7 +13905,7 @@
 gethostbyaddr()
 ; return 0; }
 EOF
-if { (eval echo configure:13895: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13909: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13911,7 +13925,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __gethostbyaddr in -lnsl""... $ac_c" 1>&6
-echo "configure:13915: checking for __gethostbyaddr in -lnsl" >&5
+echo "configure:13929: checking for __gethostbyaddr in -lnsl" >&5
 ac_lib_var=`echo nsl'_'__gethostbyaddr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -13919,7 +13933,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 13923 "configure"
+#line 13937 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -13930,7 +13944,7 @@
 __gethostbyaddr()
 ; return 0; }
 EOF
-if { (eval echo configure:13934: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:13948: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -13962,11 +13976,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 13966 "configure"
+#line 13980 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:13970: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:13984: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -14017,12 +14031,12 @@
   unset found
   
   echo $ac_n "checking for yp_get_default_domain""... $ac_c" 1>&6
-echo "configure:14021: checking for yp_get_default_domain" >&5
+echo "configure:14035: checking for yp_get_default_domain" >&5
 if eval "test \"`echo '$''{'ac_cv_func_yp_get_default_domain'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 14026 "configure"
+#line 14040 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char yp_get_default_domain(); below.  */
@@ -14045,7 +14059,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:14049: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14063: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_yp_get_default_domain=yes"
 else
@@ -14063,12 +14077,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __yp_get_default_domain""... $ac_c" 1>&6
-echo "configure:14067: checking for __yp_get_default_domain" >&5
+echo "configure:14081: checking for __yp_get_default_domain" >&5
 if eval "test \"`echo '$''{'ac_cv_func___yp_get_default_domain'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 14072 "configure"
+#line 14086 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __yp_get_default_domain(); below.  */
@@ -14091,7 +14105,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:14095: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14109: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___yp_get_default_domain=yes"
 else
@@ -14129,7 +14143,7 @@
   unset ac_cv_lib_nsl___yp_get_default_domain
   unset found
   echo $ac_n "checking for yp_get_default_domain in -lnsl""... $ac_c" 1>&6
-echo "configure:14133: checking for yp_get_default_domain in -lnsl" >&5
+echo "configure:14147: checking for yp_get_default_domain in -lnsl" >&5
 ac_lib_var=`echo nsl'_'yp_get_default_domain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14137,7 +14151,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14141 "configure"
+#line 14155 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14148,7 +14162,7 @@
 yp_get_default_domain()
 ; return 0; }
 EOF
-if { (eval echo configure:14152: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14166: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14168,7 +14182,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __yp_get_default_domain in -lnsl""... $ac_c" 1>&6
-echo "configure:14172: checking for __yp_get_default_domain in -lnsl" >&5
+echo "configure:14186: checking for __yp_get_default_domain in -lnsl" >&5
 ac_lib_var=`echo nsl'_'__yp_get_default_domain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14176,7 +14190,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14180 "configure"
+#line 14194 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14187,7 +14201,7 @@
 __yp_get_default_domain()
 ; return 0; }
 EOF
-if { (eval echo configure:14191: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14205: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14219,11 +14233,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 14223 "configure"
+#line 14237 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:14227: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:14241: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -14275,12 +14289,12 @@
   unset found
   
   echo $ac_n "checking for dlopen""... $ac_c" 1>&6
-echo "configure:14279: checking for dlopen" >&5
+echo "configure:14293: checking for dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 14284 "configure"
+#line 14298 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen(); below.  */
@@ -14303,7 +14317,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:14307: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14321: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dlopen=yes"
 else
@@ -14321,12 +14335,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __dlopen""... $ac_c" 1>&6
-echo "configure:14325: checking for __dlopen" >&5
+echo "configure:14339: checking for __dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func___dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 14330 "configure"
+#line 14344 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __dlopen(); below.  */
@@ -14349,7 +14363,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:14353: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14367: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___dlopen=yes"
 else
@@ -14387,7 +14401,7 @@
   unset ac_cv_lib_dl___dlopen
   unset found
   echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:14391: checking for dlopen in -ldl" >&5
+echo "configure:14405: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14395,7 +14409,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14399 "configure"
+#line 14413 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14406,7 +14420,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:14410: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14424: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14426,7 +14440,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:14430: checking for __dlopen in -ldl" >&5
+echo "configure:14444: checking for __dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'__dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14434,7 +14448,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14438 "configure"
+#line 14452 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14445,7 +14459,7 @@
 __dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:14449: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14463: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14477,11 +14491,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 14481 "configure"
+#line 14495 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:14485: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:14499: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -14533,7 +14547,7 @@
 
 fi
 echo $ac_n "checking for sin in -lm""... $ac_c" 1>&6
-echo "configure:14537: checking for sin in -lm" >&5
+echo "configure:14551: checking for sin in -lm" >&5
 ac_lib_var=`echo m'_'sin | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14541,7 +14555,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14545 "configure"
+#line 14559 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14552,7 +14566,7 @@
 sin()
 ; return 0; }
 EOF
-if { (eval echo configure:14556: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14570: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14586,12 +14600,12 @@
   unset found
   
   echo $ac_n "checking for res_search""... $ac_c" 1>&6
-echo "configure:14590: checking for res_search" >&5
+echo "configure:14604: checking for res_search" >&5
 if eval "test \"`echo '$''{'ac_cv_func_res_search'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 14595 "configure"
+#line 14609 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char res_search(); below.  */
@@ -14614,7 +14628,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:14618: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14632: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_res_search=yes"
 else
@@ -14632,12 +14646,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __res_search""... $ac_c" 1>&6
-echo "configure:14636: checking for __res_search" >&5
+echo "configure:14650: checking for __res_search" >&5
 if eval "test \"`echo '$''{'ac_cv_func___res_search'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 14641 "configure"
+#line 14655 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __res_search(); below.  */
@@ -14660,7 +14674,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:14664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14678: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___res_search=yes"
 else
@@ -14698,7 +14712,7 @@
   unset ac_cv_lib_resolv___res_search
   unset found
   echo $ac_n "checking for res_search in -lresolv""... $ac_c" 1>&6
-echo "configure:14702: checking for res_search in -lresolv" >&5
+echo "configure:14716: checking for res_search in -lresolv" >&5
 ac_lib_var=`echo resolv'_'res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14706,7 +14720,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14710 "configure"
+#line 14724 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14717,7 +14731,7 @@
 res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:14721: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14735: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14737,7 +14751,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_search in -lresolv""... $ac_c" 1>&6
-echo "configure:14741: checking for __res_search in -lresolv" >&5
+echo "configure:14755: checking for __res_search in -lresolv" >&5
 ac_lib_var=`echo resolv'_'__res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14745,7 +14759,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14749 "configure"
+#line 14763 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14756,7 +14770,7 @@
 __res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:14760: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14774: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14788,11 +14802,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 14792 "configure"
+#line 14806 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:14796: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:14810: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -14834,7 +14848,7 @@
   unset ac_cv_lib_bind___res_search
   unset found
   echo $ac_n "checking for res_search in -lbind""... $ac_c" 1>&6
-echo "configure:14838: checking for res_search in -lbind" >&5
+echo "configure:14852: checking for res_search in -lbind" >&5
 ac_lib_var=`echo bind'_'res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14842,7 +14856,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14846 "configure"
+#line 14860 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14853,7 +14867,7 @@
 res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:14857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14871: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14873,7 +14887,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_search in -lbind""... $ac_c" 1>&6
-echo "configure:14877: checking for __res_search in -lbind" >&5
+echo "configure:14891: checking for __res_search in -lbind" >&5
 ac_lib_var=`echo bind'_'__res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14881,7 +14895,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14885 "configure"
+#line 14899 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14892,7 +14906,7 @@
 __res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:14896: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:14910: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -14924,11 +14938,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 14928 "configure"
+#line 14942 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:14932: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:14946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -14970,7 +14984,7 @@
   unset ac_cv_lib_socket___res_search
   unset found
   echo $ac_n "checking for res_search in -lsocket""... $ac_c" 1>&6
-echo "configure:14974: checking for res_search in -lsocket" >&5
+echo "configure:14988: checking for res_search in -lsocket" >&5
 ac_lib_var=`echo socket'_'res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -14978,7 +14992,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 14982 "configure"
+#line 14996 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -14989,7 +15003,7 @@
 res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:14993: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15007: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15009,7 +15023,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_search in -lsocket""... $ac_c" 1>&6
-echo "configure:15013: checking for __res_search in -lsocket" >&5
+echo "configure:15027: checking for __res_search in -lsocket" >&5
 ac_lib_var=`echo socket'_'__res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15017,7 +15031,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15021 "configure"
+#line 15035 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15028,7 +15042,7 @@
 __res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:15032: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15046: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15060,11 +15074,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 15064 "configure"
+#line 15078 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:15068: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:15082: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -15122,12 +15136,12 @@
   unset found
   
   echo $ac_n "checking for inet_aton""... $ac_c" 1>&6
-echo "configure:15126: checking for inet_aton" >&5
+echo "configure:15140: checking for inet_aton" >&5
 if eval "test \"`echo '$''{'ac_cv_func_inet_aton'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 15131 "configure"
+#line 15145 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char inet_aton(); below.  */
@@ -15150,7 +15164,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:15154: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_inet_aton=yes"
 else
@@ -15168,12 +15182,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __inet_aton""... $ac_c" 1>&6
-echo "configure:15172: checking for __inet_aton" >&5
+echo "configure:15186: checking for __inet_aton" >&5
 if eval "test \"`echo '$''{'ac_cv_func___inet_aton'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 15177 "configure"
+#line 15191 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __inet_aton(); below.  */
@@ -15196,7 +15210,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:15200: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15214: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___inet_aton=yes"
 else
@@ -15234,7 +15248,7 @@
   unset ac_cv_lib_resolv___inet_aton
   unset found
   echo $ac_n "checking for inet_aton in -lresolv""... $ac_c" 1>&6
-echo "configure:15238: checking for inet_aton in -lresolv" >&5
+echo "configure:15252: checking for inet_aton in -lresolv" >&5
 ac_lib_var=`echo resolv'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15242,7 +15256,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15246 "configure"
+#line 15260 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15253,7 +15267,7 @@
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:15257: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15271: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15273,7 +15287,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __inet_aton in -lresolv""... $ac_c" 1>&6
-echo "configure:15277: checking for __inet_aton in -lresolv" >&5
+echo "configure:15291: checking for __inet_aton in -lresolv" >&5
 ac_lib_var=`echo resolv'_'__inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15281,7 +15295,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15285 "configure"
+#line 15299 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15292,7 +15306,7 @@
 __inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:15296: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15310: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15324,11 +15338,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 15328 "configure"
+#line 15342 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:15332: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:15346: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -15370,7 +15384,7 @@
   unset ac_cv_lib_bind___inet_aton
   unset found
   echo $ac_n "checking for inet_aton in -lbind""... $ac_c" 1>&6
-echo "configure:15374: checking for inet_aton in -lbind" >&5
+echo "configure:15388: checking for inet_aton in -lbind" >&5
 ac_lib_var=`echo bind'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15378,7 +15392,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15382 "configure"
+#line 15396 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15389,7 +15403,7 @@
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:15393: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15407: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15409,7 +15423,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __inet_aton in -lbind""... $ac_c" 1>&6
-echo "configure:15413: checking for __inet_aton in -lbind" >&5
+echo "configure:15427: checking for __inet_aton in -lbind" >&5
 ac_lib_var=`echo bind'_'__inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15417,7 +15431,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15421 "configure"
+#line 15435 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15428,7 +15442,7 @@
 __inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:15432: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15446: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15460,11 +15474,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 15464 "configure"
+#line 15478 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:15468: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:15482: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -15518,12 +15532,12 @@
   unset found
   
   echo $ac_n "checking for dn_skipname""... $ac_c" 1>&6
-echo "configure:15522: checking for dn_skipname" >&5
+echo "configure:15536: checking for dn_skipname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dn_skipname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 15527 "configure"
+#line 15541 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dn_skipname(); below.  */
@@ -15546,7 +15560,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:15550: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15564: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dn_skipname=yes"
 else
@@ -15564,12 +15578,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __dn_skipname""... $ac_c" 1>&6
-echo "configure:15568: checking for __dn_skipname" >&5
+echo "configure:15582: checking for __dn_skipname" >&5
 if eval "test \"`echo '$''{'ac_cv_func___dn_skipname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 15573 "configure"
+#line 15587 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __dn_skipname(); below.  */
@@ -15592,7 +15606,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:15596: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15610: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___dn_skipname=yes"
 else
@@ -15630,7 +15644,7 @@
   unset ac_cv_lib_resolv___dn_skipname
   unset found
   echo $ac_n "checking for dn_skipname in -lresolv""... $ac_c" 1>&6
-echo "configure:15634: checking for dn_skipname in -lresolv" >&5
+echo "configure:15648: checking for dn_skipname in -lresolv" >&5
 ac_lib_var=`echo resolv'_'dn_skipname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15638,7 +15652,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15642 "configure"
+#line 15656 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15649,7 +15663,7 @@
 dn_skipname()
 ; return 0; }
 EOF
-if { (eval echo configure:15653: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15667: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15669,7 +15683,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __dn_skipname in -lresolv""... $ac_c" 1>&6
-echo "configure:15673: checking for __dn_skipname in -lresolv" >&5
+echo "configure:15687: checking for __dn_skipname in -lresolv" >&5
 ac_lib_var=`echo resolv'_'__dn_skipname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15677,7 +15691,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15681 "configure"
+#line 15695 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15688,7 +15702,7 @@
 __dn_skipname()
 ; return 0; }
 EOF
-if { (eval echo configure:15692: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15706: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15720,11 +15734,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 15724 "configure"
+#line 15738 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:15728: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:15742: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -15766,7 +15780,7 @@
   unset ac_cv_lib_bind___dn_skipname
   unset found
   echo $ac_n "checking for dn_skipname in -lbind""... $ac_c" 1>&6
-echo "configure:15770: checking for dn_skipname in -lbind" >&5
+echo "configure:15784: checking for dn_skipname in -lbind" >&5
 ac_lib_var=`echo bind'_'dn_skipname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15774,7 +15788,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15778 "configure"
+#line 15792 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15785,7 +15799,7 @@
 dn_skipname()
 ; return 0; }
 EOF
-if { (eval echo configure:15789: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15803: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15805,7 +15819,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __dn_skipname in -lbind""... $ac_c" 1>&6
-echo "configure:15809: checking for __dn_skipname in -lbind" >&5
+echo "configure:15823: checking for __dn_skipname in -lbind" >&5
 ac_lib_var=`echo bind'_'__dn_skipname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -15813,7 +15827,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 15817 "configure"
+#line 15831 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -15824,7 +15838,7 @@
 __dn_skipname()
 ; return 0; }
 EOF
-if { (eval echo configure:15828: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:15842: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -15856,11 +15870,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 15860 "configure"
+#line 15874 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:15864: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:15878: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -15911,12 +15925,12 @@
 
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:15915: checking for ANSI C header files" >&5
+echo "configure:15929: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 15920 "configure"
+#line 15934 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -15924,7 +15938,7 @@
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:15928: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:15942: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -15941,7 +15955,7 @@
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 15945 "configure"
+#line 15959 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -15959,7 +15973,7 @@
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 15963 "configure"
+#line 15977 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -15980,7 +15994,7 @@
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 15984 "configure"
+#line 15998 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -15991,7 +16005,7 @@
 exit (0); }
 
 EOF
-if { (eval echo configure:15995: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:16009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -16019,12 +16033,12 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:16023: checking for $ac_hdr that defines DIR" >&5
+echo "configure:16037: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16028 "configure"
+#line 16042 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
@@ -16032,7 +16046,7 @@
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:16036: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16050: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -16057,7 +16071,7 @@
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:16061: checking for opendir in -ldir" >&5
+echo "configure:16075: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -16065,7 +16079,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 16069 "configure"
+#line 16083 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -16076,7 +16090,7 @@
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:16080: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:16094: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -16098,7 +16112,7 @@
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:16102: checking for opendir in -lx" >&5
+echo "configure:16116: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -16106,7 +16120,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 16110 "configure"
+#line 16124 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -16117,7 +16131,7 @@
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:16121: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:16135: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -16198,17 +16212,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:16202: checking for $ac_hdr" >&5
+echo "configure:16216: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16207 "configure"
+#line 16221 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:16212: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:16226: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -16243,17 +16257,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:16247: checking for $ac_hdr" >&5
+echo "configure:16261: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16252 "configure"
+#line 16266 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:16257: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:16271: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -16284,12 +16298,12 @@
 
 
   echo $ac_n "checking for fopencookie""... $ac_c" 1>&6
-echo "configure:16288: checking for fopencookie" >&5
+echo "configure:16302: checking for fopencookie" >&5
 if eval "test \"`echo '$''{'ac_cv_func_fopencookie'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16293 "configure"
+#line 16307 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char fopencookie(); below.  */
@@ -16312,7 +16326,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:16316: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:16330: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_fopencookie=yes"
 else
@@ -16334,7 +16348,7 @@
 
   if test "$have_glibc_fopencookie" = "yes"; then
 cat > conftest.$ac_ext <<EOF
-#line 16338 "configure"
+#line 16352 "configure"
 #include "confdefs.h"
 
 #define _GNU_SOURCE
@@ -16344,7 +16358,7 @@
 cookie_io_functions_t cookie;
 ; return 0; }
 EOF
-if { (eval echo configure:16348: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16362: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   have_cookie_io_functions_t=yes
 else
@@ -16363,7 +16377,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 16367 "configure"
+#line 16381 "configure"
 #include "confdefs.h"
 
 #define _GNU_SOURCE
@@ -16395,7 +16409,7 @@
 
 
 EOF
-if { (eval echo configure:16399: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:16413: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   cookie_io_functions_use_off64_t=yes
@@ -16415,7 +16429,7 @@
     else
 
 cat > conftest.$ac_ext <<EOF
-#line 16419 "configure"
+#line 16433 "configure"
 #include "confdefs.h"
 
 #define _GNU_SOURCE
@@ -16425,7 +16439,7 @@
  _IO_cookie_io_functions_t cookie; 
 ; return 0; }
 EOF
-if { (eval echo configure:16429: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16443: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   have_IO_cookie_io_functions_t=yes
 else
@@ -16459,7 +16473,7 @@
 
 
   echo $ac_n "checking for broken getcwd""... $ac_c" 1>&6
-echo "configure:16463: checking for broken getcwd" >&5
+echo "configure:16477: checking for broken getcwd" >&5
   os=`uname -sr 2>/dev/null`
   case $os in
     SunOS*)
@@ -16474,14 +16488,14 @@
 
 
   echo $ac_n "checking for broken libc stdio""... $ac_c" 1>&6
-echo "configure:16478: checking for broken libc stdio" >&5
+echo "configure:16492: checking for broken libc stdio" >&5
   if eval "test \"`echo '$''{'_cv_have_broken_glibc_fopen_append'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   if test "$cross_compiling" = yes; then
   cat > conftest.$ac_ext <<EOF
-#line 16485 "configure"
+#line 16499 "configure"
 #include "confdefs.h"
 
 #include <features.h>
@@ -16494,7 +16508,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:16498: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16512: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   _cv_have_broken_glibc_fopen_append=yes
 else
@@ -16507,7 +16521,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 16511 "configure"
+#line 16525 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -16535,7 +16549,7 @@
 }
 
 EOF
-if { (eval echo configure:16539: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:16553: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   _cv_have_broken_glibc_fopen_append=no
 else
@@ -16563,12 +16577,12 @@
 
 
 echo $ac_n "checking whether struct tm is in sys/time.h or time.h""... $ac_c" 1>&6
-echo "configure:16567: checking whether struct tm is in sys/time.h or time.h" >&5
+echo "configure:16581: checking whether struct tm is in sys/time.h or time.h" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_tm'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16572 "configure"
+#line 16586 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <time.h>
@@ -16576,7 +16590,7 @@
 struct tm *tp; tp->tm_sec;
 ; return 0; }
 EOF
-if { (eval echo configure:16580: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16594: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_tm=time.h
 else
@@ -16597,12 +16611,12 @@
 fi
 
 echo $ac_n "checking for tm_zone in struct tm""... $ac_c" 1>&6
-echo "configure:16601: checking for tm_zone in struct tm" >&5
+echo "configure:16615: checking for tm_zone in struct tm" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_tm_zone'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16606 "configure"
+#line 16620 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_cv_struct_tm>
@@ -16610,7 +16624,7 @@
 struct tm tm; tm.tm_zone;
 ; return 0; }
 EOF
-if { (eval echo configure:16614: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16628: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_tm_zone=yes
 else
@@ -16630,12 +16644,12 @@
 
 else
   echo $ac_n "checking for tzname""... $ac_c" 1>&6
-echo "configure:16634: checking for tzname" >&5
+echo "configure:16648: checking for tzname" >&5
 if eval "test \"`echo '$''{'ac_cv_var_tzname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16639 "configure"
+#line 16653 "configure"
 #include "confdefs.h"
 #include <time.h>
 #ifndef tzname /* For SGI.  */
@@ -16645,7 +16659,7 @@
 atoi(*tzname);
 ; return 0; }
 EOF
-if { (eval echo configure:16649: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:16663: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_var_tzname=yes
 else
@@ -16669,16 +16683,16 @@
 
 
   echo $ac_n "checking for missing declarations of reentrant functions""... $ac_c" 1>&6
-echo "configure:16673: checking for missing declarations of reentrant functions" >&5
+echo "configure:16687: checking for missing declarations of reentrant functions" >&5
   cat > conftest.$ac_ext <<EOF
-#line 16675 "configure"
+#line 16689 "configure"
 #include "confdefs.h"
 #include <time.h>
 int main() {
 struct tm *(*func)() = localtime_r
 ; return 0; }
 EOF
-if { (eval echo configure:16682: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16696: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     :
@@ -16696,14 +16710,14 @@
 fi
 rm -f conftest*
   cat > conftest.$ac_ext <<EOF
-#line 16700 "configure"
+#line 16714 "configure"
 #include "confdefs.h"
 #include <time.h>
 int main() {
 struct tm *(*func)() = gmtime_r
 ; return 0; }
 EOF
-if { (eval echo configure:16707: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16721: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     :
@@ -16721,14 +16735,14 @@
 fi
 rm -f conftest*
   cat > conftest.$ac_ext <<EOF
-#line 16725 "configure"
+#line 16739 "configure"
 #include "confdefs.h"
 #include <time.h>
 int main() {
 char *(*func)() = asctime_r
 ; return 0; }
 EOF
-if { (eval echo configure:16732: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16746: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     :
@@ -16746,14 +16760,14 @@
 fi
 rm -f conftest*
   cat > conftest.$ac_ext <<EOF
-#line 16750 "configure"
+#line 16764 "configure"
 #include "confdefs.h"
 #include <time.h>
 int main() {
 char *(*func)() = ctime_r
 ; return 0; }
 EOF
-if { (eval echo configure:16757: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16771: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     :
@@ -16771,14 +16785,14 @@
 fi
 rm -f conftest*
   cat > conftest.$ac_ext <<EOF
-#line 16775 "configure"
+#line 16789 "configure"
 #include "confdefs.h"
 #include <string.h>
 int main() {
 char *(*func)() = strtok_r
 ; return 0; }
 EOF
-if { (eval echo configure:16782: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16796: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     :
@@ -16799,16 +16813,16 @@
 
 
   echo $ac_n "checking for fclose declaration""... $ac_c" 1>&6
-echo "configure:16803: checking for fclose declaration" >&5
+echo "configure:16817: checking for fclose declaration" >&5
   cat > conftest.$ac_ext <<EOF
-#line 16805 "configure"
+#line 16819 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 int main() {
 int (*func)() = fclose
 ; return 0; }
 EOF
-if { (eval echo configure:16812: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16826: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     cat >> confdefs.h <<\EOF
@@ -16834,12 +16848,12 @@
 
 
 echo $ac_n "checking for tm_gmtoff in struct tm""... $ac_c" 1>&6
-echo "configure:16838: checking for tm_gmtoff in struct tm" >&5
+echo "configure:16852: checking for tm_gmtoff in struct tm" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_tm_gmtoff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16843 "configure"
+#line 16857 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_cv_struct_tm>
@@ -16847,7 +16861,7 @@
 struct tm tm; tm.tm_gmtoff;
 ; return 0; }
 EOF
-if { (eval echo configure:16851: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16865: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_tm_gmtoff=yes
 else
@@ -16870,12 +16884,12 @@
 
 
 echo $ac_n "checking for struct flock""... $ac_c" 1>&6
-echo "configure:16874: checking for struct flock" >&5
+echo "configure:16888: checking for struct flock" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_flock'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16879 "configure"
+#line 16893 "configure"
 #include "confdefs.h"
 
 #include <unistd.h>
@@ -16885,7 +16899,7 @@
 struct flock x;
 ; return 0; }
 EOF
-if { (eval echo configure:16889: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16903: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
           ac_cv_struct_flock=yes
@@ -16912,12 +16926,12 @@
 
 
 echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
-echo "configure:16916: checking for socklen_t" >&5
+echo "configure:16930: checking for socklen_t" >&5
 if eval "test \"`echo '$''{'ac_cv_socklen_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 16921 "configure"
+#line 16935 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -16929,7 +16943,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:16933: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:16947: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
   ac_cv_socklen_t=yes
@@ -16955,7 +16969,7 @@
 
 
 echo $ac_n "checking size of size_t""... $ac_c" 1>&6
-echo "configure:16959: checking size of size_t" >&5
+echo "configure:16973: checking size of size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -16963,18 +16977,19 @@
   ac_cv_sizeof_size_t=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 16967 "configure"
+#line 16981 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(size_t));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:16978: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:16993: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_size_t=`cat conftestval`
 else
@@ -16994,7 +17009,7 @@
 
 
 echo $ac_n "checking size of long long""... $ac_c" 1>&6
-echo "configure:16998: checking size of long long" >&5
+echo "configure:17013: checking size of long long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -17002,18 +17017,19 @@
   ac_cv_sizeof_long_long=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 17006 "configure"
+#line 17021 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:17017: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17033: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long=`cat conftestval`
 else
@@ -17033,7 +17049,7 @@
 
 
 echo $ac_n "checking size of long long int""... $ac_c" 1>&6
-echo "configure:17037: checking size of long long int" >&5
+echo "configure:17053: checking size of long long int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -17041,18 +17057,19 @@
   ac_cv_sizeof_long_long_int=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 17045 "configure"
+#line 17061 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long long int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:17056: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17073: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long_int=`cat conftestval`
 else
@@ -17072,7 +17089,7 @@
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:17076: checking size of long" >&5
+echo "configure:17093: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -17080,18 +17097,19 @@
   ac_cv_sizeof_long=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 17084 "configure"
+#line 17101 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:17095: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17113: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -17111,7 +17129,7 @@
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:17115: checking size of int" >&5
+echo "configure:17133: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -17119,18 +17137,19 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 17123 "configure"
+#line 17141 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:17134: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17153: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -17152,7 +17171,7 @@
 
 
   echo $ac_n "checking size of intmax_t""... $ac_c" 1>&6
-echo "configure:17156: checking size of intmax_t" >&5
+echo "configure:17175: checking size of intmax_t" >&5
   
   php_cache_value=php_cv_sizeof_intmax_t
   if eval "test \"`echo '$''{'php_cv_sizeof_intmax_t'+set}'`\" = set"; then
@@ -17169,7 +17188,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 17173 "configure"
+#line 17192 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #if STDC_HEADERS
@@ -17193,7 +17212,7 @@
 }
   
 EOF
-if { (eval echo configure:17197: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17216: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     eval $php_cache_value=`cat conftestval`
@@ -17232,7 +17251,7 @@
 
 
   echo $ac_n "checking size of ssize_t""... $ac_c" 1>&6
-echo "configure:17236: checking size of ssize_t" >&5
+echo "configure:17255: checking size of ssize_t" >&5
   
   php_cache_value=php_cv_sizeof_ssize_t
   if eval "test \"`echo '$''{'php_cv_sizeof_ssize_t'+set}'`\" = set"; then
@@ -17249,7 +17268,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 17253 "configure"
+#line 17272 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #if STDC_HEADERS
@@ -17273,7 +17292,7 @@
 }
   
 EOF
-if { (eval echo configure:17277: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17296: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     eval $php_cache_value=`cat conftestval`
@@ -17312,7 +17331,7 @@
 
 
   echo $ac_n "checking size of ptrdiff_t""... $ac_c" 1>&6
-echo "configure:17316: checking size of ptrdiff_t" >&5
+echo "configure:17335: checking size of ptrdiff_t" >&5
   
   php_cache_value=php_cv_sizeof_ptrdiff_t
   if eval "test \"`echo '$''{'php_cv_sizeof_ptrdiff_t'+set}'`\" = set"; then
@@ -17329,7 +17348,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 17333 "configure"
+#line 17352 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #if STDC_HEADERS
@@ -17353,7 +17372,7 @@
 }
   
 EOF
-if { (eval echo configure:17357: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:17376: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     eval $php_cache_value=`cat conftestval`
@@ -17392,12 +17411,12 @@
 
 
 echo $ac_n "checking for st_blksize in struct stat""... $ac_c" 1>&6
-echo "configure:17396: checking for st_blksize in struct stat" >&5
+echo "configure:17415: checking for st_blksize in struct stat" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_st_blksize'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17401 "configure"
+#line 17420 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -17405,7 +17424,7 @@
 struct stat s; s.st_blksize;
 ; return 0; }
 EOF
-if { (eval echo configure:17409: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:17428: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_st_blksize=yes
 else
@@ -17427,12 +17446,12 @@
 
 if test "`uname -s 2>/dev/null`" != "QNX"; then
   echo $ac_n "checking for st_blocks in struct stat""... $ac_c" 1>&6
-echo "configure:17431: checking for st_blocks in struct stat" >&5
+echo "configure:17450: checking for st_blocks in struct stat" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_st_blocks'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17436 "configure"
+#line 17455 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -17440,7 +17459,7 @@
 struct stat s; s.st_blocks;
 ; return 0; }
 EOF
-if { (eval echo configure:17444: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:17463: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_st_blocks=yes
 else
@@ -17467,12 +17486,12 @@
   WARNING_LEVEL=0
 fi
 echo $ac_n "checking for st_rdev in struct stat""... $ac_c" 1>&6
-echo "configure:17471: checking for st_rdev in struct stat" >&5
+echo "configure:17490: checking for st_rdev in struct stat" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_st_rdev'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17476 "configure"
+#line 17495 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -17480,7 +17499,7 @@
 struct stat s; s.st_rdev;
 ; return 0; }
 EOF
-if { (eval echo configure:17484: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:17503: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_st_rdev=yes
 else
@@ -17502,12 +17521,12 @@
 
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:17506: checking for size_t" >&5
+echo "configure:17525: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17511 "configure"
+#line 17530 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -17535,12 +17554,12 @@
 fi
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:17539: checking for uid_t in sys/types.h" >&5
+echo "configure:17558: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17544 "configure"
+#line 17563 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
@@ -17571,12 +17590,12 @@
 
 
     echo $ac_n "checking for struct sockaddr_storage""... $ac_c" 1>&6
-echo "configure:17575: checking for struct sockaddr_storage" >&5
+echo "configure:17594: checking for struct sockaddr_storage" >&5
 if eval "test \"`echo '$''{'ac_cv_sockaddr_storage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17580 "configure"
+#line 17599 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -17584,7 +17603,7 @@
 struct sockaddr_storage s; s
 ; return 0; }
 EOF
-if { (eval echo configure:17588: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:17607: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sockaddr_storage=yes
 else
@@ -17605,13 +17624,13 @@
 
   fi
     echo $ac_n "checking for field sa_len in struct sockaddr""... $ac_c" 1>&6
-echo "configure:17609: checking for field sa_len in struct sockaddr" >&5
+echo "configure:17628: checking for field sa_len in struct sockaddr" >&5
 if eval "test \"`echo '$''{'ac_cv_sockaddr_sa_len'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     cat > conftest.$ac_ext <<EOF
-#line 17615 "configure"
+#line 17634 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -17619,7 +17638,7 @@
 static struct sockaddr sa; int n = (int) sa.sa_len; return n;
 ; return 0; }
 EOF
-if { (eval echo configure:17623: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:17642: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sockaddr_sa_len=yes
 else
@@ -17642,12 +17661,12 @@
 
 
 echo $ac_n "checking for IPv6 support""... $ac_c" 1>&6
-echo "configure:17646: checking for IPv6 support" >&5
+echo "configure:17665: checking for IPv6 support" >&5
 if eval "test \"`echo '$''{'ac_cv_ipv6_support'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17651 "configure"
+#line 17670 "configure"
 #include "confdefs.h"
  #include <sys/types.h>
 #include <sys/socket.h>
@@ -17656,7 +17675,7 @@
 struct sockaddr_in6 s; struct in6_addr t=in6addr_any; int i=AF_INET6; s; t.s6_addr[0] = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:17660: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:17679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_ipv6_support=yes
 else
@@ -17672,12 +17691,12 @@
 
 
 echo $ac_n "checking for vprintf""... $ac_c" 1>&6
-echo "configure:17676: checking for vprintf" >&5
+echo "configure:17695: checking for vprintf" >&5
 if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17681 "configure"
+#line 17700 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char vprintf(); below.  */
@@ -17700,7 +17719,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:17704: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:17723: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_vprintf=yes"
 else
@@ -17724,12 +17743,12 @@
 
 if test "$ac_cv_func_vprintf" != yes; then
 echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
-echo "configure:17728: checking for _doprnt" >&5
+echo "configure:17747: checking for _doprnt" >&5
 if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17733 "configure"
+#line 17752 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char _doprnt(); below.  */
@@ -17752,7 +17771,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:17756: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:17775: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func__doprnt=yes"
 else
@@ -17859,12 +17878,12 @@
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:17863: checking for $ac_func" >&5
+echo "configure:17882: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 17868 "configure"
+#line 17887 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -17887,7 +17906,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:17891: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:17910: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -17913,7 +17932,7 @@
 
 
 echo $ac_n "checking for nanosleep""... $ac_c" 1>&6
-echo "configure:17917: checking for nanosleep" >&5
+echo "configure:17936: checking for nanosleep" >&5
 if eval "test \"`echo '$''{'ac_cv_func_nanosleep'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -17923,7 +17942,7 @@
   unset ac_cv_lib_rt___nanosleep
   unset found
   echo $ac_n "checking for nanosleep in -lrt""... $ac_c" 1>&6
-echo "configure:17927: checking for nanosleep in -lrt" >&5
+echo "configure:17946: checking for nanosleep in -lrt" >&5
 ac_lib_var=`echo rt'_'nanosleep | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -17931,7 +17950,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lrt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 17935 "configure"
+#line 17954 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -17942,7 +17961,7 @@
 nanosleep()
 ; return 0; }
 EOF
-if { (eval echo configure:17946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:17965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -17962,7 +17981,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __nanosleep in -lrt""... $ac_c" 1>&6
-echo "configure:17966: checking for __nanosleep in -lrt" >&5
+echo "configure:17985: checking for __nanosleep in -lrt" >&5
 ac_lib_var=`echo rt'_'__nanosleep | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -17970,7 +17989,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lrt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 17974 "configure"
+#line 17993 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -17981,7 +18000,7 @@
 __nanosleep()
 ; return 0; }
 EOF
-if { (eval echo configure:17985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18004: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -18013,11 +18032,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 18017 "configure"
+#line 18036 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:18021: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18040: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -18064,25 +18083,25 @@
 echo "$ac_t""$ac_cv_func_nanosleep" 1>&6
 
 echo $ac_n "checking for getaddrinfo""... $ac_c" 1>&6
-echo "configure:18068: checking for getaddrinfo" >&5
+echo "configure:18087: checking for getaddrinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_func_getaddrinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18073 "configure"
+#line 18092 "configure"
 #include "confdefs.h"
 #include <netdb.h>
 int main() {
 struct addrinfo *g,h;g=&h;getaddrinfo("","",g,&g);
 ; return 0; }
 EOF
-if { (eval echo configure:18080: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18099: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   if test "$cross_compiling" = yes; then
   ac_cv_func_getaddrinfo=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 18086 "configure"
+#line 18105 "configure"
 #include "confdefs.h"
 
 #include <netdb.h>
@@ -18122,7 +18141,7 @@
 }
   
 EOF
-if { (eval echo configure:18126: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18145: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_getaddrinfo=yes
 else
@@ -18154,12 +18173,12 @@
 for ac_func in strlcat strlcpy getopt
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:18158: checking for $ac_func" >&5
+echo "configure:18177: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18163 "configure"
+#line 18182 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -18182,7 +18201,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18186: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18205: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -18209,7 +18228,7 @@
 
 
 echo $ac_n "checking whether utime accepts a null argument""... $ac_c" 1>&6
-echo "configure:18213: checking whether utime accepts a null argument" >&5
+echo "configure:18232: checking whether utime accepts a null argument" >&5
 if eval "test \"`echo '$''{'ac_cv_func_utime_null'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -18219,7 +18238,7 @@
   ac_cv_func_utime_null=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 18223 "configure"
+#line 18242 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -18230,7 +18249,7 @@
 && t.st_mtime - s.st_mtime < 120));
 }
 EOF
-if { (eval echo configure:18234: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_utime_null=yes
 else
@@ -18256,19 +18275,19 @@
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:18260: checking for working alloca.h" >&5
+echo "configure:18279: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18265 "configure"
+#line 18284 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:18272: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18291: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -18289,12 +18308,12 @@
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:18293: checking for alloca" >&5
+echo "configure:18312: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18298 "configure"
+#line 18317 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -18322,7 +18341,7 @@
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:18326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18345: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -18354,12 +18373,12 @@
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:18358: checking whether alloca needs Cray hooks" >&5
+echo "configure:18377: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18363 "configure"
+#line 18382 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -18384,12 +18403,12 @@
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:18388: checking for $ac_func" >&5
+echo "configure:18407: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18393 "configure"
+#line 18412 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -18412,7 +18431,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18416: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18435: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -18439,7 +18458,7 @@
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:18443: checking stack direction for C alloca" >&5
+echo "configure:18462: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -18447,7 +18466,7 @@
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 18451 "configure"
+#line 18470 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -18466,7 +18485,7 @@
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:18470: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18489: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -18489,13 +18508,13 @@
 
 
   echo $ac_n "checking for declared timezone""... $ac_c" 1>&6
-echo "configure:18493: checking for declared timezone" >&5
+echo "configure:18512: checking for declared timezone" >&5
 if eval "test \"`echo '$''{'ac_cv_declared_timezone'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     cat > conftest.$ac_ext <<EOF
-#line 18499 "configure"
+#line 18518 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -18510,7 +18529,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18514: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:18533: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
   ac_cv_declared_timezone=yes
@@ -18536,7 +18555,7 @@
 
 
 echo $ac_n "checking for type of reentrant time-related functions""... $ac_c" 1>&6
-echo "configure:18540: checking for type of reentrant time-related functions" >&5
+echo "configure:18559: checking for type of reentrant time-related functions" >&5
 if eval "test \"`echo '$''{'ac_cv_time_r_type'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -18547,7 +18566,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 18551 "configure"
+#line 18570 "configure"
 #include "confdefs.h"
 
 #include <time.h>
@@ -18565,7 +18584,7 @@
 }
 
 EOF
-if { (eval echo configure:18569: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18588: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_time_r_type=hpux
@@ -18581,7 +18600,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 18585 "configure"
+#line 18604 "configure"
 #include "confdefs.h"
 
 #include <time.h>
@@ -18597,7 +18616,7 @@
 }
   
 EOF
-if { (eval echo configure:18601: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18620: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     ac_cv_time_r_type=irix
@@ -18635,12 +18654,12 @@
 
 
     echo $ac_n "checking for readdir_r""... $ac_c" 1>&6
-echo "configure:18639: checking for readdir_r" >&5
+echo "configure:18658: checking for readdir_r" >&5
 if eval "test \"`echo '$''{'ac_cv_func_readdir_r'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18644 "configure"
+#line 18663 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char readdir_r(); below.  */
@@ -18663,7 +18682,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18667: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18686: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_readdir_r=yes"
 else
@@ -18685,7 +18704,7 @@
 
   if test "$ac_cv_func_readdir_r" = "yes"; then
   echo $ac_n "checking for type of readdir_r""... $ac_c" 1>&6
-echo "configure:18689: checking for type of readdir_r" >&5
+echo "configure:18708: checking for type of readdir_r" >&5
 if eval "test \"`echo '$''{'ac_cv_what_readdir_r'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -18696,7 +18715,7 @@
    
 else
   cat > conftest.$ac_ext <<EOF
-#line 18700 "configure"
+#line 18719 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
@@ -18721,7 +18740,7 @@
 }
     
 EOF
-if { (eval echo configure:18725: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:18744: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       ac_cv_what_readdir_r=POSIX
@@ -18732,7 +18751,7 @@
   rm -fr conftest*
   
       cat > conftest.$ac_ext <<EOF
-#line 18736 "configure"
+#line 18755 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
@@ -18742,7 +18761,7 @@
         
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:18746: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:18765: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -18784,12 +18803,12 @@
 
 
 echo $ac_n "checking for in_addr_t""... $ac_c" 1>&6
-echo "configure:18788: checking for in_addr_t" >&5
+echo "configure:18807: checking for in_addr_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_in_addr_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18793 "configure"
+#line 18812 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -18823,12 +18842,12 @@
 for ac_func in crypt_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:18827: checking for $ac_func" >&5
+echo "configure:18846: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 18832 "configure"
+#line 18851 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -18851,7 +18870,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18855: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:18874: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -18879,14 +18898,14 @@
 if test "x$php_crypt_r" = "x1"; then
   
   echo $ac_n "checking which data struct is used by crypt_r""... $ac_c" 1>&6
-echo "configure:18883: checking which data struct is used by crypt_r" >&5
+echo "configure:18902: checking which data struct is used by crypt_r" >&5
 if eval "test \"`echo '$''{'php_cv_crypt_r_style'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     php_cv_crypt_r_style=none
     cat > conftest.$ac_ext <<EOF
-#line 18890 "configure"
+#line 18909 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT 1
@@ -18899,7 +18918,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18903: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:18922: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   php_cv_crypt_r_style=cryptd
 else
@@ -18910,7 +18929,7 @@
 
     if test "$php_cv_crypt_r_style" = "none"; then
       cat > conftest.$ac_ext <<EOF
-#line 18914 "configure"
+#line 18933 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT 1
@@ -18923,7 +18942,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18927: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:18946: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   php_cv_crypt_r_style=struct_crypt_data
 else
@@ -18935,7 +18954,7 @@
 
     if test "$php_cv_crypt_r_style" = "none"; then
       cat > conftest.$ac_ext <<EOF
-#line 18939 "configure"
+#line 18958 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT 1
@@ -18949,7 +18968,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:18953: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:18972: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   php_cv_crypt_r_style=struct_crypt_data_gnu_source
 else
@@ -19008,7 +19027,7 @@
 php_enable_gcov=no
 
 echo $ac_n "checking whether to include gcov symbols""... $ac_c" 1>&6
-echo "configure:19012: checking whether to include gcov symbols" >&5
+echo "configure:19031: checking whether to include gcov symbols" >&5
 # Check whether --enable-gcov or --disable-gcov was given.
 if test "${enable_gcov+set}" = set; then
   enableval="$enable_gcov"
@@ -19050,7 +19069,7 @@
   # Extract the first word of "lcov", so it can be a program name with args.
 set dummy lcov; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:19054: checking for $ac_word" >&5
+echo "configure:19073: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LTP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -19079,7 +19098,7 @@
   # Extract the first word of "genhtml", so it can be a program name with args.
 set dummy genhtml; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:19083: checking for $ac_word" >&5
+echo "configure:19102: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LTP_GENHTML'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -19114,7 +19133,7 @@
 
   if test "$LTP"; then
     echo $ac_n "checking for ltp version""... $ac_c" 1>&6
-echo "configure:19118: checking for ltp version" >&5
+echo "configure:19137: checking for ltp version" >&5
 if eval "test \"`echo '$''{'php_cv_ltp_version'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -19171,7 +19190,7 @@
 php_enable_debug=no
 
 echo $ac_n "checking whether to include debugging symbols""... $ac_c" 1>&6
-echo "configure:19175: checking whether to include debugging symbols" >&5
+echo "configure:19194: checking whether to include debugging symbols" >&5
 # Check whether --enable-debug or --disable-debug was given.
 if test "${enable_debug+set}" = set; then
   enableval="$enable_debug"
@@ -19222,7 +19241,7 @@
 php_with_layout=PHP
 
 echo $ac_n "checking layout of installed files""... $ac_c" 1>&6
-echo "configure:19226: checking layout of installed files" >&5
+echo "configure:19245: checking layout of installed files" >&5
 # Check whether --with-layout or --without-layout was given.
 if test "${with_layout+set}" = set; then
   withval="$with_layout"
@@ -19257,7 +19276,7 @@
 php_with_config_file_path=DEFAULT
 
 echo $ac_n "checking path to configuration file""... $ac_c" 1>&6
-echo "configure:19261: checking path to configuration file" >&5
+echo "configure:19280: checking path to configuration file" >&5
 # Check whether --with-config-file-path or --without-config-file-path was given.
 if test "${with_config_file_path+set}" = set; then
   withval="$with_config_file_path"
@@ -19291,7 +19310,7 @@
 fi
 
 echo $ac_n "checking where to scan for configuration files""... $ac_c" 1>&6
-echo "configure:19295: checking where to scan for configuration files" >&5
+echo "configure:19314: checking where to scan for configuration files" >&5
 
 php_with_config_file_scan_dir=DEFAULT
 
@@ -19327,7 +19346,7 @@
 php_enable_safe_mode=no
 
 echo $ac_n "checking whether to enable safe mode by default""... $ac_c" 1>&6
-echo "configure:19331: checking whether to enable safe mode by default" >&5
+echo "configure:19350: checking whether to enable safe mode by default" >&5
 # Check whether --enable-safe-mode or --disable-safe-mode was given.
 if test "${enable_safe_mode+set}" = set; then
   enableval="$enable_safe_mode"
@@ -19362,7 +19381,7 @@
 fi
 
 echo $ac_n "checking for safe mode exec dir""... $ac_c" 1>&6
-echo "configure:19366: checking for safe mode exec dir" >&5
+echo "configure:19385: checking for safe mode exec dir" >&5
 
 php_with_exec_dir=no
 
@@ -19406,7 +19425,7 @@
 php_enable_sigchild=no
 
 echo $ac_n "checking whether to enable PHP's own SIGCHLD handler""... $ac_c" 1>&6
-echo "configure:19410: checking whether to enable PHP's own SIGCHLD handler" >&5
+echo "configure:19429: checking whether to enable PHP's own SIGCHLD handler" >&5
 # Check whether --enable-sigchild or --disable-sigchild was given.
 if test "${enable_sigchild+set}" = set; then
   enableval="$enable_sigchild"
@@ -19444,7 +19463,7 @@
 php_enable_magic_quotes=no
 
 echo $ac_n "checking whether to enable magic quotes by default""... $ac_c" 1>&6
-echo "configure:19448: checking whether to enable magic quotes by default" >&5
+echo "configure:19467: checking whether to enable magic quotes by default" >&5
 # Check whether --enable-magic-quotes or --disable-magic-quotes was given.
 if test "${enable_magic_quotes+set}" = set; then
   enableval="$enable_magic_quotes"
@@ -19482,7 +19501,7 @@
 php_enable_libgcc=no
 
 echo $ac_n "checking whether to explicitly link against libgcc""... $ac_c" 1>&6
-echo "configure:19486: checking whether to explicitly link against libgcc" >&5
+echo "configure:19505: checking whether to explicitly link against libgcc" >&5
 # Check whether --enable-libgcc or --disable-libgcc was given.
 if test "${enable_libgcc+set}" = set; then
   enableval="$enable_libgcc"
@@ -19562,7 +19581,7 @@
 php_enable_short_tags=yes
 
 echo $ac_n "checking whether to enable short tags by default""... $ac_c" 1>&6
-echo "configure:19566: checking whether to enable short tags by default" >&5
+echo "configure:19585: checking whether to enable short tags by default" >&5
 # Check whether --enable-short-tags or --disable-short-tags was given.
 if test "${enable_short_tags+set}" = set; then
   enableval="$enable_short_tags"
@@ -19600,7 +19619,7 @@
 php_enable_dmalloc=no
 
 echo $ac_n "checking whether to enable dmalloc""... $ac_c" 1>&6
-echo "configure:19604: checking whether to enable dmalloc" >&5
+echo "configure:19623: checking whether to enable dmalloc" >&5
 # Check whether --enable-dmalloc or --disable-dmalloc was given.
 if test "${enable_dmalloc+set}" = set; then
   enableval="$enable_dmalloc"
@@ -19624,7 +19643,7 @@
 
 if test "$PHP_DMALLOC" = "yes"; then
   echo $ac_n "checking for dmalloc_error in -ldmalloc""... $ac_c" 1>&6
-echo "configure:19628: checking for dmalloc_error in -ldmalloc" >&5
+echo "configure:19647: checking for dmalloc_error in -ldmalloc" >&5
 ac_lib_var=`echo dmalloc'_'dmalloc_error | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -19632,7 +19651,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 19636 "configure"
+#line 19655 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -19643,7 +19662,7 @@
 dmalloc_error()
 ; return 0; }
 EOF
-if { (eval echo configure:19647: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:19666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -19688,7 +19707,7 @@
 php_enable_ipv6=yes
 
 echo $ac_n "checking whether to enable IPv6 support""... $ac_c" 1>&6
-echo "configure:19692: checking whether to enable IPv6 support" >&5
+echo "configure:19711: checking whether to enable IPv6 support" >&5
 # Check whether --enable-ipv6 or --disable-ipv6 was given.
 if test "${enable_ipv6+set}" = set; then
   enableval="$enable_ipv6"
@@ -19718,7 +19737,7 @@
 fi
 
 echo $ac_n "checking how big to make fd sets""... $ac_c" 1>&6
-echo "configure:19722: checking how big to make fd sets" >&5
+echo "configure:19741: checking how big to make fd sets" >&5
 
 php_enable_fd_setsize=no
 
@@ -19789,7 +19808,7 @@
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:19793: checking size of long" >&5
+echo "configure:19812: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -19797,18 +19816,19 @@
   ac_cv_sizeof_long=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 19801 "configure"
+#line 19820 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:19812: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:19832: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -19828,7 +19848,7 @@
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:19832: checking size of int" >&5
+echo "configure:19852: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -19836,18 +19856,19 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 19840 "configure"
+#line 19860 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:19851: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:19872: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -19868,13 +19889,13 @@
 
 
 echo $ac_n "checking for int32_t""... $ac_c" 1>&6
-echo "configure:19872: checking for int32_t" >&5
+echo "configure:19893: checking for int32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_int_type_int32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 19878 "configure"
+#line 19899 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H
@@ -19893,7 +19914,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:19897: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:19918: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_int_type_int32_t=yes
 else
@@ -19916,13 +19937,13 @@
 
 
 echo $ac_n "checking for uint32_t""... $ac_c" 1>&6
-echo "configure:19920: checking for uint32_t" >&5
+echo "configure:19941: checking for uint32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_int_type_uint32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 19926 "configure"
+#line 19947 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H
@@ -19941,7 +19962,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:19945: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:19966: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_int_type_uint32_t=yes
 else
@@ -19973,17 +19994,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:19977: checking for $ac_hdr" >&5
+echo "configure:19998: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 19982 "configure"
+#line 20003 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:19987: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:20008: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -20013,12 +20034,12 @@
 for ac_func in strtoll atoll strftime
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:20017: checking for $ac_func" >&5
+echo "configure:20038: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 20022 "configure"
+#line 20043 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -20041,7 +20062,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:20045: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:20066: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -20467,7 +20488,7 @@
 php_enable_libxml=yes
 
 echo $ac_n "checking whether to enable LIBXML support""... $ac_c" 1>&6
-echo "configure:20471: checking whether to enable LIBXML support" >&5
+echo "configure:20492: checking whether to enable LIBXML support" >&5
 # Check whether --enable-libxml or --disable-libxml was given.
 if test "${enable_libxml+set}" = set; then
   enableval="$enable_libxml"
@@ -20515,7 +20536,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:20519: checking libxml2 install dir" >&5
+echo "configure:20540: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -20544,7 +20565,7 @@
 
   
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:20548: checking for xml2-config path" >&5
+echo "configure:20569: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -20702,7 +20723,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:20706: checking whether libxml build works" >&5
+echo "configure:20727: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -20718,7 +20739,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 20722 "configure"
+#line 20743 "configure"
 #include "confdefs.h"
 
     
@@ -20729,7 +20750,7 @@
     }
   
 EOF
-if { (eval echo configure:20733: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:20754: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -21094,7 +21115,7 @@
 php_with_openssl=no
 
 echo $ac_n "checking for OpenSSL support""... $ac_c" 1>&6
-echo "configure:21098: checking for OpenSSL support" >&5
+echo "configure:21119: checking for OpenSSL support" >&5
 # Check whether --with-openssl or --without-openssl was given.
 if test "${with_openssl+set}" = set; then
   withval="$with_openssl"
@@ -21141,7 +21162,7 @@
 php_with_kerberos=no
 
 echo $ac_n "checking for Kerberos support""... $ac_c" 1>&6
-echo "configure:21145: checking for Kerberos support" >&5
+echo "configure:21166: checking for Kerberos support" >&5
 # Check whether --with-kerberos or --without-kerberos was given.
 if test "${with_kerberos+set}" = set; then
   withval="$with_kerberos"
@@ -21470,7 +21491,7 @@
     # Extract the first word of "krb5-config", so it can be a program name with args.
 set dummy krb5-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:21474: checking for $ac_word" >&5
+echo "configure:21495: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_KRB5_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -21830,7 +21851,7 @@
   fi
 
   echo $ac_n "checking for DSA_get_default_method in -lssl""... $ac_c" 1>&6
-echo "configure:21834: checking for DSA_get_default_method in -lssl" >&5
+echo "configure:21855: checking for DSA_get_default_method in -lssl" >&5
 ac_lib_var=`echo ssl'_'DSA_get_default_method | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -21838,7 +21859,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 21842 "configure"
+#line 21863 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -21849,7 +21870,7 @@
 DSA_get_default_method()
 ; return 0; }
 EOF
-if { (eval echo configure:21853: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:21874: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -21891,7 +21912,7 @@
     # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:21895: checking for $ac_word" >&5
+echo "configure:21916: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PKG_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -22096,9 +22117,9 @@
     old_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=-I$OPENSSL_INCDIR
     echo $ac_n "checking for OpenSSL version""... $ac_c" 1>&6
-echo "configure:22100: checking for OpenSSL version" >&5
+echo "configure:22121: checking for OpenSSL version" >&5
     cat > conftest.$ac_ext <<EOF
-#line 22102 "configure"
+#line 22123 "configure"
 #include "confdefs.h"
 
 #include <openssl/opensslv.h>
@@ -22253,7 +22274,7 @@
   done
 
   echo $ac_n "checking for CRYPTO_free in -lcrypto""... $ac_c" 1>&6
-echo "configure:22257: checking for CRYPTO_free in -lcrypto" >&5
+echo "configure:22278: checking for CRYPTO_free in -lcrypto" >&5
 ac_lib_var=`echo crypto'_'CRYPTO_free | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -22261,7 +22282,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 22265 "configure"
+#line 22286 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -22272,7 +22293,7 @@
 CRYPTO_free()
 ; return 0; }
 EOF
-if { (eval echo configure:22276: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:22297: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -22429,7 +22450,7 @@
   done
 
   echo $ac_n "checking for SSL_CTX_set_ssl_version in -lssl""... $ac_c" 1>&6
-echo "configure:22433: checking for SSL_CTX_set_ssl_version in -lssl" >&5
+echo "configure:22454: checking for SSL_CTX_set_ssl_version in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_CTX_set_ssl_version | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -22437,7 +22458,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 22441 "configure"
+#line 22462 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -22448,7 +22469,7 @@
 SSL_CTX_set_ssl_version()
 ; return 0; }
 EOF
-if { (eval echo configure:22452: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:22473: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -22570,7 +22591,7 @@
 php_with_pcre_regex=yes
 
 echo $ac_n "checking for PCRE support""... $ac_c" 1>&6
-echo "configure:22574: checking for PCRE support" >&5
+echo "configure:22595: checking for PCRE support" >&5
 # Check whether --with-pcre-regex or --without-pcre-regex was given.
 if test "${with_pcre_regex+set}" = set; then
   withval="$with_pcre_regex"
@@ -23424,7 +23445,7 @@
 php_with_zlib=no
 
 echo $ac_n "checking for ZLIB support""... $ac_c" 1>&6
-echo "configure:23428: checking for ZLIB support" >&5
+echo "configure:23449: checking for ZLIB support" >&5
 # Check whether --with-zlib or --without-zlib was given.
 if test "${with_zlib+set}" = set; then
   withval="$with_zlib"
@@ -23471,7 +23492,7 @@
 php_with_zlib_dir=no
 
 echo $ac_n "checking if the location of ZLIB install directory is defined""... $ac_c" 1>&6
-echo "configure:23475: checking if the location of ZLIB install directory is defined" >&5
+echo "configure:23496: checking if the location of ZLIB install directory is defined" >&5
 # Check whether --with-zlib-dir or --without-zlib-dir was given.
 if test "${with_zlib_dir+set}" = set; then
   withval="$with_zlib_dir"
@@ -23917,7 +23938,7 @@
   done
 
   echo $ac_n "checking for gzgets in -lz""... $ac_c" 1>&6
-echo "configure:23921: checking for gzgets in -lz" >&5
+echo "configure:23942: checking for gzgets in -lz" >&5
 ac_lib_var=`echo z'_'gzgets | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -23925,7 +23946,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lz  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 23929 "configure"
+#line 23950 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -23936,7 +23957,7 @@
 gzgets()
 ; return 0; }
 EOF
-if { (eval echo configure:23940: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:23961: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -24076,7 +24097,7 @@
 php_enable_bcmath=no
 
 echo $ac_n "checking whether to enable bc style precision math functions""... $ac_c" 1>&6
-echo "configure:24080: checking whether to enable bc style precision math functions" >&5
+echo "configure:24101: checking whether to enable bc style precision math functions" >&5
 # Check whether --enable-bcmath or --disable-bcmath was given.
 if test "${enable_bcmath+set}" = set; then
   enableval="$enable_bcmath"
@@ -24444,7 +24465,7 @@
 php_with_bz2=no
 
 echo $ac_n "checking for BZip2 support""... $ac_c" 1>&6
-echo "configure:24448: checking for BZip2 support" >&5
+echo "configure:24469: checking for BZip2 support" >&5
 # Check whether --with-bz2 or --without-bz2 was given.
 if test "${with_bz2+set}" = set; then
   withval="$with_bz2"
@@ -24492,7 +24513,7 @@
     BZIP_DIR=$PHP_BZ2
   else
     echo $ac_n "checking for BZip2 in default path""... $ac_c" 1>&6
-echo "configure:24496: checking for BZip2 in default path" >&5
+echo "configure:24517: checking for BZip2 in default path" >&5
     for i in /usr/local /usr; do
       if test -r $i/include/bzlib.h; then
         BZIP_DIR=$i
@@ -24605,7 +24626,7 @@
   done
 
   echo $ac_n "checking for BZ2_bzerror in -lbz2""... $ac_c" 1>&6
-echo "configure:24609: checking for BZ2_bzerror in -lbz2" >&5
+echo "configure:24630: checking for BZ2_bzerror in -lbz2" >&5
 ac_lib_var=`echo bz2'_'BZ2_bzerror | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -24613,7 +24634,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbz2  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 24617 "configure"
+#line 24638 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -24624,7 +24645,7 @@
 BZ2_bzerror()
 ; return 0; }
 EOF
-if { (eval echo configure:24628: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:24649: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -25092,7 +25113,7 @@
 php_enable_calendar=no
 
 echo $ac_n "checking whether to enable calendar conversion support""... $ac_c" 1>&6
-echo "configure:25096: checking whether to enable calendar conversion support" >&5
+echo "configure:25117: checking whether to enable calendar conversion support" >&5
 # Check whether --enable-calendar or --disable-calendar was given.
 if test "${enable_calendar+set}" = set; then
   enableval="$enable_calendar"
@@ -25439,7 +25460,7 @@
 php_enable_ctype=yes
 
 echo $ac_n "checking whether to enable ctype functions""... $ac_c" 1>&6
-echo "configure:25443: checking whether to enable ctype functions" >&5
+echo "configure:25464: checking whether to enable ctype functions" >&5
 # Check whether --enable-ctype or --disable-ctype was given.
 if test "${enable_ctype+set}" = set; then
   enableval="$enable_ctype"
@@ -25786,7 +25807,7 @@
 php_with_curl=no
 
 echo $ac_n "checking for cURL support""... $ac_c" 1>&6
-echo "configure:25790: checking for cURL support" >&5
+echo "configure:25811: checking for cURL support" >&5
 # Check whether --with-curl or --without-curl was given.
 if test "${with_curl+set}" = set; then
   withval="$with_curl"
@@ -25833,7 +25854,7 @@
 php_with_curlwrappers=no
 
 echo $ac_n "checking if we should use cURL for url streams""... $ac_c" 1>&6
-echo "configure:25837: checking if we should use cURL for url streams" >&5
+echo "configure:25858: checking if we should use cURL for url streams" >&5
 # Check whether --with-curlwrappers or --without-curlwrappers was given.
 if test "${with_curlwrappers+set}" = set; then
   withval="$with_curlwrappers"
@@ -25860,7 +25881,7 @@
     CURL_DIR=$PHP_CURL
   else
     echo $ac_n "checking for cURL in default path""... $ac_c" 1>&6
-echo "configure:25864: checking for cURL in default path" >&5
+echo "configure:25885: checking for cURL in default path" >&5
     for i in /usr/local /usr; do
       if test -r $i/include/curl/easy.h; then
         CURL_DIR=$i
@@ -25878,7 +25899,7 @@
 
   CURL_CONFIG="curl-config"
   echo $ac_n "checking for cURL 7.10.5 or greater""... $ac_c" 1>&6
-echo "configure:25882: checking for cURL 7.10.5 or greater" >&5
+echo "configure:25903: checking for cURL 7.10.5 or greater" >&5
 
   if ${CURL_DIR}/bin/curl-config --libs > /dev/null 2>&1; then
     CURL_CONFIG=${CURL_DIR}/bin/curl-config
@@ -26116,7 +26137,7 @@
 
   
   echo $ac_n "checking for SSL support in libcurl""... $ac_c" 1>&6
-echo "configure:26120: checking for SSL support in libcurl" >&5
+echo "configure:26141: checking for SSL support in libcurl" >&5
   CURL_SSL=`$CURL_CONFIG --feature | $EGREP SSL`
   if test "$CURL_SSL" = "SSL"; then
     echo "$ac_t""yes" 1>&6
@@ -26129,7 +26150,7 @@
     CFLAGS="`$CURL_CONFIG --cflags`"
    
     echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:26133: checking how to run the C preprocessor" >&5
+echo "configure:26154: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -26144,13 +26165,13 @@
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 26148 "configure"
+#line 26169 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:26154: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:26175: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -26161,13 +26182,13 @@
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 26165 "configure"
+#line 26186 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:26171: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:26192: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -26178,13 +26199,13 @@
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 26182 "configure"
+#line 26203 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:26188: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:26209: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -26209,14 +26230,14 @@
 echo "$ac_t""$CPP" 1>&6
 
     echo $ac_n "checking for openssl support in libcurl""... $ac_c" 1>&6
-echo "configure:26213: checking for openssl support in libcurl" >&5
+echo "configure:26234: checking for openssl support in libcurl" >&5
     if test "$cross_compiling" = yes; then
   
       echo "$ac_t""no" 1>&6
     
 else
   cat > conftest.$ac_ext <<EOF
-#line 26220 "configure"
+#line 26241 "configure"
 #include "confdefs.h"
 
 #include <curl/curl.h>
@@ -26235,7 +26256,7 @@
 }
     
 EOF
-if { (eval echo configure:26239: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:26260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       echo "$ac_t""yes" 1>&6
@@ -26243,17 +26264,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:26247: checking for $ac_hdr" >&5
+echo "configure:26268: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 26252 "configure"
+#line 26273 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:26257: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:26278: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -26298,14 +26319,14 @@
 
    
     echo $ac_n "checking for gnutls support in libcurl""... $ac_c" 1>&6
-echo "configure:26302: checking for gnutls support in libcurl" >&5
+echo "configure:26323: checking for gnutls support in libcurl" >&5
     if test "$cross_compiling" = yes; then
   
       echo "$ac_t""no" 1>&6
     
 else
   cat > conftest.$ac_ext <<EOF
-#line 26309 "configure"
+#line 26330 "configure"
 #include "confdefs.h"
 
 #include <curl/curl.h>
@@ -26324,23 +26345,23 @@
 }
 
 EOF
-if { (eval echo configure:26328: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:26349: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       echo "$ac_t""yes" 1>&6
       ac_safe=`echo "gcrypt.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for gcrypt.h""... $ac_c" 1>&6
-echo "configure:26334: checking for gcrypt.h" >&5
+echo "configure:26355: checking for gcrypt.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 26339 "configure"
+#line 26360 "configure"
 #include "confdefs.h"
 #include <gcrypt.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:26344: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:26365: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -26482,7 +26503,7 @@
   done
 
   echo $ac_n "checking for curl_easy_perform in -lcurl""... $ac_c" 1>&6
-echo "configure:26486: checking for curl_easy_perform in -lcurl" >&5
+echo "configure:26507: checking for curl_easy_perform in -lcurl" >&5
 ac_lib_var=`echo curl'_'curl_easy_perform | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -26490,7 +26511,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 26494 "configure"
+#line 26515 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -26501,7 +26522,7 @@
 curl_easy_perform()
 ; return 0; }
 EOF
-if { (eval echo configure:26505: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:26526: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -26637,7 +26658,7 @@
   done
 
   echo $ac_n "checking for curl_version_info in -lcurl""... $ac_c" 1>&6
-echo "configure:26641: checking for curl_version_info in -lcurl" >&5
+echo "configure:26662: checking for curl_version_info in -lcurl" >&5
 ac_lib_var=`echo curl'_'curl_version_info | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -26645,7 +26666,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 26649 "configure"
+#line 26670 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -26656,7 +26677,7 @@
 curl_version_info()
 ; return 0; }
 EOF
-if { (eval echo configure:26660: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:26681: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -26790,7 +26811,7 @@
   done
 
   echo $ac_n "checking for curl_easy_strerror in -lcurl""... $ac_c" 1>&6
-echo "configure:26794: checking for curl_easy_strerror in -lcurl" >&5
+echo "configure:26815: checking for curl_easy_strerror in -lcurl" >&5
 ac_lib_var=`echo curl'_'curl_easy_strerror | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -26798,7 +26819,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 26802 "configure"
+#line 26823 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -26809,7 +26830,7 @@
 curl_easy_strerror()
 ; return 0; }
 EOF
-if { (eval echo configure:26813: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:26834: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -26943,7 +26964,7 @@
   done
 
   echo $ac_n "checking for curl_multi_strerror in -lcurl""... $ac_c" 1>&6
-echo "configure:26947: checking for curl_multi_strerror in -lcurl" >&5
+echo "configure:26968: checking for curl_multi_strerror in -lcurl" >&5
 ac_lib_var=`echo curl'_'curl_multi_strerror | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -26951,7 +26972,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 26955 "configure"
+#line 26976 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -26962,7 +26983,7 @@
 curl_multi_strerror()
 ; return 0; }
 EOF
-if { (eval echo configure:26966: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:26987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -27675,7 +27696,7 @@
   done
 
   echo $ac_n "checking for dpopen in -l$LIB""... $ac_c" 1>&6
-echo "configure:27679: checking for dpopen in -l$LIB" >&5
+echo "configure:27700: checking for dpopen in -l$LIB" >&5
 ac_lib_var=`echo $LIB'_'dpopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -27683,7 +27704,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 27687 "configure"
+#line 27708 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -27694,7 +27715,7 @@
 dpopen()
 ; return 0; }
 EOF
-if { (eval echo configure:27698: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:27719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -27863,7 +27884,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:27867: checking for $THIS_FULL_NAME support" >&5
+echo "configure:27888: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -27891,7 +27912,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:27895: checking for $THIS_FULL_NAME support" >&5
+echo "configure:27916: checking for $THIS_FULL_NAME support" >&5
   if test -n "You cannot combine --with-gdbm with --with-qdbm"; then
     { echo "configure: error: You cannot combine --with-gdbm with --with-qdbm" 1>&2; exit 1; }
   fi
@@ -28010,7 +28031,7 @@
   done
 
   echo $ac_n "checking for gdbm_open in -lgdbm""... $ac_c" 1>&6
-echo "configure:28014: checking for gdbm_open in -lgdbm" >&5
+echo "configure:28035: checking for gdbm_open in -lgdbm" >&5
 ac_lib_var=`echo gdbm'_'gdbm_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -28018,7 +28039,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgdbm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 28022 "configure"
+#line 28043 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -28029,7 +28050,7 @@
 gdbm_open()
 ; return 0; }
 EOF
-if { (eval echo configure:28033: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:28054: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -28194,7 +28215,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:28198: checking for $THIS_FULL_NAME support" >&5
+echo "configure:28219: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -28323,7 +28344,7 @@
   done
 
   echo $ac_n "checking for dbm_open in -l$LIB""... $ac_c" 1>&6
-echo "configure:28327: checking for dbm_open in -l$LIB" >&5
+echo "configure:28348: checking for dbm_open in -l$LIB" >&5
 ac_lib_var=`echo $LIB'_'dbm_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -28331,7 +28352,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 28335 "configure"
+#line 28356 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -28342,7 +28363,7 @@
 dbm_open()
 ; return 0; }
 EOF
-if { (eval echo configure:28346: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:28367: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -28511,7 +28532,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:28515: checking for $THIS_FULL_NAME support" >&5
+echo "configure:28536: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -28586,7 +28607,7 @@
   LIBS="-l$LIB $LIBS"
   
         cat > conftest.$ac_ext <<EOF
-#line 28590 "configure"
+#line 28611 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28597,11 +28618,11 @@
         
 ; return 0; }
 EOF
-if { (eval echo configure:28601: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:28622: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
           cat > conftest.$ac_ext <<EOF
-#line 28605 "configure"
+#line 28626 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28638,14 +28659,14 @@
   done
   if test -z "$THIS_LIBS"; then
     echo $ac_n "checking for DB4 major version""... $ac_c" 1>&6
-echo "configure:28642: checking for DB4 major version" >&5
+echo "configure:28663: checking for DB4 major version" >&5
     { echo "configure: error: Header contains different version" 1>&2; exit 1; }
   fi
   if test "4" = "4"; then
     echo $ac_n "checking for DB4 minor version and patch level""... $ac_c" 1>&6
-echo "configure:28647: checking for DB4 minor version and patch level" >&5
+echo "configure:28668: checking for DB4 minor version and patch level" >&5
     cat > conftest.$ac_ext <<EOF
-#line 28649 "configure"
+#line 28670 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28671,9 +28692,9 @@
   fi
   if test "$ext_shared" = "yes"; then
     echo $ac_n "checking if dba can be used as shared extension""... $ac_c" 1>&6
-echo "configure:28675: checking if dba can be used as shared extension" >&5
+echo "configure:28696: checking if dba can be used as shared extension" >&5
     cat > conftest.$ac_ext <<EOF
-#line 28677 "configure"
+#line 28698 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28830,7 +28851,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:28834: checking for $THIS_FULL_NAME support" >&5
+echo "configure:28855: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -28858,7 +28879,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:28862: checking for $THIS_FULL_NAME support" >&5
+echo "configure:28883: checking for $THIS_FULL_NAME support" >&5
   if test -n "You cannot combine --with-db3 with --with-db4"; then
     { echo "configure: error: You cannot combine --with-db3 with --with-db4" 1>&2; exit 1; }
   fi
@@ -28909,7 +28930,7 @@
   LIBS="-l$LIB $LIBS"
   
         cat > conftest.$ac_ext <<EOF
-#line 28913 "configure"
+#line 28934 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28920,11 +28941,11 @@
         
 ; return 0; }
 EOF
-if { (eval echo configure:28924: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:28945: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
           cat > conftest.$ac_ext <<EOF
-#line 28928 "configure"
+#line 28949 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28961,14 +28982,14 @@
   done
   if test -z "$THIS_LIBS"; then
     echo $ac_n "checking for DB3 major version""... $ac_c" 1>&6
-echo "configure:28965: checking for DB3 major version" >&5
+echo "configure:28986: checking for DB3 major version" >&5
     { echo "configure: error: Header contains different version" 1>&2; exit 1; }
   fi
   if test "3" = "4"; then
     echo $ac_n "checking for DB4 minor version and patch level""... $ac_c" 1>&6
-echo "configure:28970: checking for DB4 minor version and patch level" >&5
+echo "configure:28991: checking for DB4 minor version and patch level" >&5
     cat > conftest.$ac_ext <<EOF
-#line 28972 "configure"
+#line 28993 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -28994,9 +29015,9 @@
   fi
   if test "$ext_shared" = "yes"; then
     echo $ac_n "checking if dba can be used as shared extension""... $ac_c" 1>&6
-echo "configure:28998: checking if dba can be used as shared extension" >&5
+echo "configure:29019: checking if dba can be used as shared extension" >&5
     cat > conftest.$ac_ext <<EOF
-#line 29000 "configure"
+#line 29021 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -29153,7 +29174,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:29157: checking for $THIS_FULL_NAME support" >&5
+echo "configure:29178: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -29181,7 +29202,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:29185: checking for $THIS_FULL_NAME support" >&5
+echo "configure:29206: checking for $THIS_FULL_NAME support" >&5
   if test -n "You cannot combine --with-db2 with --with-db3 or --with-db4"; then
     { echo "configure: error: You cannot combine --with-db2 with --with-db3 or --with-db4" 1>&2; exit 1; }
   fi
@@ -29232,7 +29253,7 @@
   LIBS="-l$LIB $LIBS"
   
         cat > conftest.$ac_ext <<EOF
-#line 29236 "configure"
+#line 29257 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -29243,11 +29264,11 @@
         
 ; return 0; }
 EOF
-if { (eval echo configure:29247: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:29268: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
           cat > conftest.$ac_ext <<EOF
-#line 29251 "configure"
+#line 29272 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -29284,14 +29305,14 @@
   done
   if test -z "$THIS_LIBS"; then
     echo $ac_n "checking for DB2 major version""... $ac_c" 1>&6
-echo "configure:29288: checking for DB2 major version" >&5
+echo "configure:29309: checking for DB2 major version" >&5
     { echo "configure: error: Header contains different version" 1>&2; exit 1; }
   fi
   if test "2" = "4"; then
     echo $ac_n "checking for DB4 minor version and patch level""... $ac_c" 1>&6
-echo "configure:29293: checking for DB4 minor version and patch level" >&5
+echo "configure:29314: checking for DB4 minor version and patch level" >&5
     cat > conftest.$ac_ext <<EOF
-#line 29295 "configure"
+#line 29316 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -29317,9 +29338,9 @@
   fi
   if test "$ext_shared" = "yes"; then
     echo $ac_n "checking if dba can be used as shared extension""... $ac_c" 1>&6
-echo "configure:29321: checking if dba can be used as shared extension" >&5
+echo "configure:29342: checking if dba can be used as shared extension" >&5
     cat > conftest.$ac_ext <<EOF
-#line 29323 "configure"
+#line 29344 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -29476,7 +29497,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:29480: checking for $THIS_FULL_NAME support" >&5
+echo "configure:29501: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -29496,7 +29517,7 @@
   unset THIS_INCLUDE THIS_LIBS THIS_LFLAGS THIS_PREFIX THIS_RESULT
 
   echo $ac_n "checking for DB1 in library""... $ac_c" 1>&6
-echo "configure:29500: checking for DB1 in library" >&5
+echo "configure:29521: checking for DB1 in library" >&5
   if test "$HAVE_DB4" = "1"; then
     THIS_VERSION=4
     THIS_LIBS=$DB4_LIBS
@@ -29544,7 +29565,7 @@
   fi
   echo "$ac_t""$THIS_LIBS" 1>&6
   echo $ac_n "checking for DB1 in header""... $ac_c" 1>&6
-echo "configure:29548: checking for DB1 in header" >&5
+echo "configure:29569: checking for DB1 in header" >&5
   echo "$ac_t""$THIS_INCLUDE" 1>&6
   if test -n "$THIS_INCLUDE"; then
     
@@ -29554,7 +29575,7 @@
   LIBS="-l$THIS_LIBS $LIBS"
   
       cat > conftest.$ac_ext <<EOF
-#line 29558 "configure"
+#line 29579 "configure"
 #include "confdefs.h"
 
 #include "$THIS_INCLUDE"
@@ -29565,7 +29586,7 @@
       
 ; return 0; }
 EOF
-if { (eval echo configure:29569: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:29590: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
         cat >> confdefs.h <<EOF
@@ -29715,7 +29736,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:29719: checking for $THIS_FULL_NAME support" >&5
+echo "configure:29740: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -29743,7 +29764,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:29747: checking for $THIS_FULL_NAME support" >&5
+echo "configure:29768: checking for $THIS_FULL_NAME support" >&5
   if test -n "You cannot combine --with-dbm with --with-qdbm"; then
     { echo "configure: error: You cannot combine --with-dbm with --with-qdbm" 1>&2; exit 1; }
   fi
@@ -29867,7 +29888,7 @@
   done
 
   echo $ac_n "checking for dbminit in -l$LIB""... $ac_c" 1>&6
-echo "configure:29871: checking for dbminit in -l$LIB" >&5
+echo "configure:29892: checking for dbminit in -l$LIB" >&5
 ac_lib_var=`echo $LIB'_'dbminit | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -29875,7 +29896,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 29879 "configure"
+#line 29900 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -29886,7 +29907,7 @@
 dbminit()
 ; return 0; }
 EOF
-if { (eval echo configure:29890: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:29911: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -29906,7 +29927,7 @@
     ext_shared=$save_ext_shared
     
         echo $ac_n "checking for DBM using GDBM""... $ac_c" 1>&6
-echo "configure:29910: checking for DBM using GDBM" >&5
+echo "configure:29931: checking for DBM using GDBM" >&5
         cat >> confdefs.h <<EOF
 #define DBM_INCLUDE_FILE "$THIS_INCLUDE"
 EOF
@@ -30070,7 +30091,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:30074: checking for $THIS_FULL_NAME support" >&5
+echo "configure:30095: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -30291,7 +30312,7 @@
   done
 
   echo $ac_n "checking for cdb_read in -l$LIB""... $ac_c" 1>&6
-echo "configure:30295: checking for cdb_read in -l$LIB" >&5
+echo "configure:30316: checking for cdb_read in -l$LIB" >&5
 ac_lib_var=`echo $LIB'_'cdb_read | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -30299,7 +30320,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 30303 "configure"
+#line 30324 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -30310,7 +30331,7 @@
 cdb_read()
 ; return 0; }
 EOF
-if { (eval echo configure:30314: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:30335: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -30479,7 +30500,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:30483: checking for $THIS_FULL_NAME support" >&5
+echo "configure:30504: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -30510,7 +30531,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:30514: checking for $THIS_FULL_NAME support" >&5
+echo "configure:30535: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -30541,7 +30562,7 @@
     THIS_FULL_NAME="$THIS_NAME"
   fi
   echo $ac_n "checking for $THIS_FULL_NAME support""... $ac_c" 1>&6
-echo "configure:30545: checking for $THIS_FULL_NAME support" >&5
+echo "configure:30566: checking for $THIS_FULL_NAME support" >&5
   if test -n ""; then
     { echo "configure: error: " 1>&2; exit 1; }
   fi
@@ -30556,7 +30577,7 @@
 
 
 echo $ac_n "checking whether to enable DBA interface""... $ac_c" 1>&6
-echo "configure:30560: checking whether to enable DBA interface" >&5
+echo "configure:30581: checking whether to enable DBA interface" >&5
 if test "$HAVE_DBA" = "1"; then
   if test "$ext_shared" = "yes"; then
     echo "$ac_t""yes, shared" 1>&6
@@ -30886,7 +30907,7 @@
 php_enable_dbase=no
 
 echo $ac_n "checking whether to enable dbase support""... $ac_c" 1>&6
-echo "configure:30890: checking whether to enable dbase support" >&5
+echo "configure:30911: checking whether to enable dbase support" >&5
 # Check whether --enable-dbase or --disable-dbase was given.
 if test "${enable_dbase+set}" = set; then
   enableval="$enable_dbase"
@@ -31233,7 +31254,7 @@
 php_enable_dom=yes
 
 echo $ac_n "checking whether to enable DOM support""... $ac_c" 1>&6
-echo "configure:31237: checking whether to enable DOM support" >&5
+echo "configure:31258: checking whether to enable DOM support" >&5
 # Check whether --enable-dom or --disable-dom was given.
 if test "${enable_dom+set}" = set; then
   enableval="$enable_dom"
@@ -31281,7 +31302,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:31285: checking libxml2 install dir" >&5
+echo "configure:31306: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -31312,7 +31333,7 @@
 
   
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:31316: checking for xml2-config path" >&5
+echo "configure:31337: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -31470,7 +31491,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:31474: checking whether libxml build works" >&5
+echo "configure:31495: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -31486,7 +31507,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 31490 "configure"
+#line 31511 "configure"
 #include "confdefs.h"
 
     
@@ -31497,7 +31518,7 @@
     }
   
 EOF
-if { (eval echo configure:31501: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:31522: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -31920,7 +31941,7 @@
 php_enable_exif=no
 
 echo $ac_n "checking whether to enable EXIF (metadata from images) support""... $ac_c" 1>&6
-echo "configure:31924: checking whether to enable EXIF (metadata from images) support" >&5
+echo "configure:31945: checking whether to enable EXIF (metadata from images) support" >&5
 # Check whether --enable-exif or --disable-exif was given.
 if test "${enable_exif+set}" = set; then
   enableval="$enable_exif"
@@ -32267,7 +32288,7 @@
 php_with_fbsql=no
 
 echo $ac_n "checking for FrontBase SQL92 (fbsql) support""... $ac_c" 1>&6
-echo "configure:32271: checking for FrontBase SQL92 (fbsql) support" >&5
+echo "configure:32292: checking for FrontBase SQL92 (fbsql) support" >&5
 # Check whether --with-fbsql or --without-fbsql was given.
 if test "${with_fbsql+set}" = set; then
   withval="$with_fbsql"
@@ -32774,7 +32795,7 @@
 php_with_fdftk=no
 
 echo $ac_n "checking for FDF support""... $ac_c" 1>&6
-echo "configure:32778: checking for FDF support" >&5
+echo "configure:32799: checking for FDF support" >&5
 # Check whether --with-fdftk or --without-fdftk was given.
 if test "${with_fdftk+set}" = set; then
   withval="$with_fdftk"
@@ -32992,7 +33013,7 @@
   done
 
   echo $ac_n "checking for FDFOpen in -l$file""... $ac_c" 1>&6
-echo "configure:32996: checking for FDFOpen in -l$file" >&5
+echo "configure:33017: checking for FDFOpen in -l$file" >&5
 ac_lib_var=`echo $file'_'FDFOpen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -33000,7 +33021,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$file  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 33004 "configure"
+#line 33025 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -33011,7 +33032,7 @@
 FDFOpen()
 ; return 0; }
 EOF
-if { (eval echo configure:33015: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:33036: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -33138,7 +33159,7 @@
   done
 
   echo $ac_n "checking for FDFGetFDFVersion in -l$file""... $ac_c" 1>&6
-echo "configure:33142: checking for FDFGetFDFVersion in -l$file" >&5
+echo "configure:33163: checking for FDFGetFDFVersion in -l$file" >&5
 ac_lib_var=`echo $file'_'FDFGetFDFVersion | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -33146,7 +33167,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$file  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 33150 "configure"
+#line 33171 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -33157,7 +33178,7 @@
 FDFGetFDFVersion()
 ; return 0; }
 EOF
-if { (eval echo configure:33161: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:33182: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -33605,7 +33626,7 @@
 php_enable_filter=yes
 
 echo $ac_n "checking whether to enable input filter support""... $ac_c" 1>&6
-echo "configure:33609: checking whether to enable input filter support" >&5
+echo "configure:33630: checking whether to enable input filter support" >&5
 # Check whether --enable-filter or --disable-filter was given.
 if test "${enable_filter+set}" = set; then
   enableval="$enable_filter"
@@ -33652,7 +33673,7 @@
 php_with_pcre_dir=no
 
 echo $ac_n "checking pcre install prefix""... $ac_c" 1>&6
-echo "configure:33656: checking pcre install prefix" >&5
+echo "configure:33677: checking pcre install prefix" >&5
 # Check whether --with-pcre-dir or --without-pcre-dir was given.
 if test "${with_pcre_dir+set}" = set; then
   withval="$with_pcre_dir"
@@ -33682,7 +33703,7 @@
         old_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=$INCLUDES
     cat > conftest.$ac_ext <<EOF
-#line 33686 "configure"
+#line 33707 "configure"
 #include "confdefs.h"
 
 #include <main/php_config.h>
@@ -33701,7 +33722,7 @@
   rm -rf conftest*
   
       cat > conftest.$ac_ext <<EOF
-#line 33705 "configure"
+#line 33726 "configure"
 #include "confdefs.h"
 
 #include <main/php_config.h>
@@ -34071,7 +34092,7 @@
 php_enable_ftp=no
 
 echo $ac_n "checking whether to enable FTP support""... $ac_c" 1>&6
-echo "configure:34075: checking whether to enable FTP support" >&5
+echo "configure:34096: checking whether to enable FTP support" >&5
 # Check whether --enable-ftp or --disable-ftp was given.
 if test "${enable_ftp+set}" = set; then
   enableval="$enable_ftp"
@@ -34118,7 +34139,7 @@
 php_with_openssl_dir=no
 
 echo $ac_n "checking OpenSSL dir for FTP""... $ac_c" 1>&6
-echo "configure:34122: checking OpenSSL dir for FTP" >&5
+echo "configure:34143: checking OpenSSL dir for FTP" >&5
 # Check whether --with-openssl-dir or --without-openssl-dir was given.
 if test "${with_openssl_dir+set}" = set; then
   withval="$with_openssl_dir"
@@ -34459,7 +34480,7 @@
     # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:34463: checking for $ac_word" >&5
+echo "configure:34484: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PKG_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -34664,9 +34685,9 @@
     old_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=-I$OPENSSL_INCDIR
     echo $ac_n "checking for OpenSSL version""... $ac_c" 1>&6
-echo "configure:34668: checking for OpenSSL version" >&5
+echo "configure:34689: checking for OpenSSL version" >&5
     cat > conftest.$ac_ext <<EOF
-#line 34670 "configure"
+#line 34691 "configure"
 #include "confdefs.h"
 
 #include <openssl/opensslv.h>
@@ -34821,7 +34842,7 @@
   done
 
   echo $ac_n "checking for CRYPTO_free in -lcrypto""... $ac_c" 1>&6
-echo "configure:34825: checking for CRYPTO_free in -lcrypto" >&5
+echo "configure:34846: checking for CRYPTO_free in -lcrypto" >&5
 ac_lib_var=`echo crypto'_'CRYPTO_free | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -34829,7 +34850,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 34833 "configure"
+#line 34854 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -34840,7 +34861,7 @@
 CRYPTO_free()
 ; return 0; }
 EOF
-if { (eval echo configure:34844: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:34865: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -34997,7 +35018,7 @@
   done
 
   echo $ac_n "checking for SSL_CTX_set_ssl_version in -lssl""... $ac_c" 1>&6
-echo "configure:35001: checking for SSL_CTX_set_ssl_version in -lssl" >&5
+echo "configure:35022: checking for SSL_CTX_set_ssl_version in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_CTX_set_ssl_version | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -35005,7 +35026,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 35009 "configure"
+#line 35030 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -35016,7 +35037,7 @@
 SSL_CTX_set_ssl_version()
 ; return 0; }
 EOF
-if { (eval echo configure:35020: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:35041: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -35135,7 +35156,7 @@
 php_with_gd=no
 
 echo $ac_n "checking for GD support""... $ac_c" 1>&6
-echo "configure:35139: checking for GD support" >&5
+echo "configure:35160: checking for GD support" >&5
 # Check whether --with-gd or --without-gd was given.
 if test "${with_gd+set}" = set; then
   withval="$with_gd"
@@ -35183,7 +35204,7 @@
 php_with_jpeg_dir=no
 
 echo $ac_n "checking for the location of libjpeg""... $ac_c" 1>&6
-echo "configure:35187: checking for the location of libjpeg" >&5
+echo "configure:35208: checking for the location of libjpeg" >&5
 # Check whether --with-jpeg-dir or --without-jpeg-dir was given.
 if test "${with_jpeg_dir+set}" = set; then
   withval="$with_jpeg_dir"
@@ -35211,7 +35232,7 @@
 php_with_png_dir=no
 
 echo $ac_n "checking for the location of libpng""... $ac_c" 1>&6
-echo "configure:35215: checking for the location of libpng" >&5
+echo "configure:35236: checking for the location of libpng" >&5
 # Check whether --with-png-dir or --without-png-dir was given.
 if test "${with_png_dir+set}" = set; then
   withval="$with_png_dir"
@@ -35239,7 +35260,7 @@
 php_with_zlib_dir=no
 
 echo $ac_n "checking for the location of libz""... $ac_c" 1>&6
-echo "configure:35243: checking for the location of libz" >&5
+echo "configure:35264: checking for the location of libz" >&5
 # Check whether --with-zlib-dir or --without-zlib-dir was given.
 if test "${with_zlib_dir+set}" = set; then
   withval="$with_zlib_dir"
@@ -35266,7 +35287,7 @@
 php_with_xpm_dir=no
 
 echo $ac_n "checking for the location of libXpm""... $ac_c" 1>&6
-echo "configure:35270: checking for the location of libXpm" >&5
+echo "configure:35291: checking for the location of libXpm" >&5
 # Check whether --with-xpm-dir or --without-xpm-dir was given.
 if test "${with_xpm_dir+set}" = set; then
   withval="$with_xpm_dir"
@@ -35292,7 +35313,7 @@
 php_with_ttf=no
 
 echo $ac_n "checking for FreeType 1.x support""... $ac_c" 1>&6
-echo "configure:35296: checking for FreeType 1.x support" >&5
+echo "configure:35317: checking for FreeType 1.x support" >&5
 # Check whether --with-ttf or --without-ttf was given.
 if test "${with_ttf+set}" = set; then
   withval="$with_ttf"
@@ -35318,7 +35339,7 @@
 php_with_freetype_dir=no
 
 echo $ac_n "checking for FreeType 2""... $ac_c" 1>&6
-echo "configure:35322: checking for FreeType 2" >&5
+echo "configure:35343: checking for FreeType 2" >&5
 # Check whether --with-freetype-dir or --without-freetype-dir was given.
 if test "${with_freetype_dir+set}" = set; then
   withval="$with_freetype_dir"
@@ -35344,7 +35365,7 @@
 php_with_t1lib=no
 
 echo $ac_n "checking for T1lib support""... $ac_c" 1>&6
-echo "configure:35348: checking for T1lib support" >&5
+echo "configure:35369: checking for T1lib support" >&5
 # Check whether --with-t1lib or --without-t1lib was given.
 if test "${with_t1lib+set}" = set; then
   withval="$with_t1lib"
@@ -35370,7 +35391,7 @@
 php_enable_gd_native_ttf=no
 
 echo $ac_n "checking whether to enable truetype string function in GD""... $ac_c" 1>&6
-echo "configure:35374: checking whether to enable truetype string function in GD" >&5
+echo "configure:35395: checking whether to enable truetype string function in GD" >&5
 # Check whether --enable-gd-native-ttf or --disable-gd-native-ttf was given.
 if test "${enable_gd_native_ttf+set}" = set; then
   enableval="$enable_gd_native_ttf"
@@ -35396,7 +35417,7 @@
 php_enable_gd_jis_conv=no
 
 echo $ac_n "checking whether to enable JIS-mapped Japanese font support in GD""... $ac_c" 1>&6
-echo "configure:35400: checking whether to enable JIS-mapped Japanese font support in GD" >&5
+echo "configure:35421: checking whether to enable JIS-mapped Japanese font support in GD" >&5
 # Check whether --enable-gd-jis-conv or --disable-gd-jis-conv was given.
 if test "${enable_gd_jis_conv+set}" = set; then
   enableval="$enable_gd_jis_conv"
@@ -35452,12 +35473,12 @@
   for ac_func in fabsf floorf
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:35456: checking for $ac_func" >&5
+echo "configure:35477: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 35461 "configure"
+#line 35482 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -35480,7 +35501,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:35484: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:35505: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -35652,7 +35673,7 @@
   done
 
   echo $ac_n "checking for jpeg_read_header in -ljpeg""... $ac_c" 1>&6
-echo "configure:35656: checking for jpeg_read_header in -ljpeg" >&5
+echo "configure:35677: checking for jpeg_read_header in -ljpeg" >&5
 ac_lib_var=`echo jpeg'_'jpeg_read_header | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -35660,7 +35681,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ljpeg  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 35664 "configure"
+#line 35685 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -35671,7 +35692,7 @@
 jpeg_read_header()
 ; return 0; }
 EOF
-if { (eval echo configure:35675: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:35696: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -35953,7 +35974,7 @@
   done
 
   echo $ac_n "checking for png_write_image in -lpng""... $ac_c" 1>&6
-echo "configure:35957: checking for png_write_image in -lpng" >&5
+echo "configure:35978: checking for png_write_image in -lpng" >&5
 ac_lib_var=`echo png'_'png_write_image | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -35961,7 +35982,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpng  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 35965 "configure"
+#line 35986 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -35972,7 +35993,7 @@
 png_write_image()
 ; return 0; }
 EOF
-if { (eval echo configure:35976: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:35997: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -36352,7 +36373,7 @@
   done
 
   echo $ac_n "checking for XpmFreeXpmImage in -lXpm""... $ac_c" 1>&6
-echo "configure:36356: checking for XpmFreeXpmImage in -lXpm" >&5
+echo "configure:36377: checking for XpmFreeXpmImage in -lXpm" >&5
 ac_lib_var=`echo Xpm'_'XpmFreeXpmImage | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -36360,7 +36381,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lXpm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 36364 "configure"
+#line 36385 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -36371,7 +36392,7 @@
 XpmFreeXpmImage()
 ; return 0; }
 EOF
-if { (eval echo configure:36375: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:36396: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -36746,7 +36767,7 @@
   done
 
   echo $ac_n "checking for FT_New_Face in -lfreetype""... $ac_c" 1>&6
-echo "configure:36750: checking for FT_New_Face in -lfreetype" >&5
+echo "configure:36771: checking for FT_New_Face in -lfreetype" >&5
 ac_lib_var=`echo freetype'_'FT_New_Face | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -36754,7 +36775,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lfreetype  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 36758 "configure"
+#line 36779 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -36765,7 +36786,7 @@
 FT_New_Face()
 ; return 0; }
 EOF
-if { (eval echo configure:36769: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:36790: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -37128,7 +37149,7 @@
 
     else
       echo $ac_n "checking for FreeType 1 support""... $ac_c" 1>&6
-echo "configure:37132: checking for FreeType 1 support" >&5
+echo "configure:37153: checking for FreeType 1 support" >&5
       echo "$ac_t""no - FreeType 2.x is to be used instead" 1>&6
     fi
   fi
@@ -37242,7 +37263,7 @@
   done
 
   echo $ac_n "checking for T1_StrError in -lt1""... $ac_c" 1>&6
-echo "configure:37246: checking for T1_StrError in -lt1" >&5
+echo "configure:37267: checking for T1_StrError in -lt1" >&5
 ac_lib_var=`echo t1'_'T1_StrError | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -37250,7 +37271,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lt1  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 37254 "configure"
+#line 37275 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -37261,7 +37282,7 @@
 T1_StrError()
 ; return 0; }
 EOF
-if { (eval echo configure:37265: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:37286: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -37703,7 +37724,7 @@
   done
 
   echo $ac_n "checking for jpeg_read_header in -ljpeg""... $ac_c" 1>&6
-echo "configure:37707: checking for jpeg_read_header in -ljpeg" >&5
+echo "configure:37728: checking for jpeg_read_header in -ljpeg" >&5
 ac_lib_var=`echo jpeg'_'jpeg_read_header | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -37711,7 +37732,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ljpeg  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 37715 "configure"
+#line 37736 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -37722,7 +37743,7 @@
 jpeg_read_header()
 ; return 0; }
 EOF
-if { (eval echo configure:37726: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:37747: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -38004,7 +38025,7 @@
   done
 
   echo $ac_n "checking for png_write_image in -lpng""... $ac_c" 1>&6
-echo "configure:38008: checking for png_write_image in -lpng" >&5
+echo "configure:38029: checking for png_write_image in -lpng" >&5
 ac_lib_var=`echo png'_'png_write_image | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -38012,7 +38033,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpng  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 38016 "configure"
+#line 38037 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -38023,7 +38044,7 @@
 png_write_image()
 ; return 0; }
 EOF
-if { (eval echo configure:38027: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:38048: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -38403,7 +38424,7 @@
   done
 
   echo $ac_n "checking for XpmFreeXpmImage in -lXpm""... $ac_c" 1>&6
-echo "configure:38407: checking for XpmFreeXpmImage in -lXpm" >&5
+echo "configure:38428: checking for XpmFreeXpmImage in -lXpm" >&5
 ac_lib_var=`echo Xpm'_'XpmFreeXpmImage | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -38411,7 +38432,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lXpm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 38415 "configure"
+#line 38436 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -38422,7 +38443,7 @@
 XpmFreeXpmImage()
 ; return 0; }
 EOF
-if { (eval echo configure:38426: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:38447: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -38797,7 +38818,7 @@
   done
 
   echo $ac_n "checking for FT_New_Face in -lfreetype""... $ac_c" 1>&6
-echo "configure:38801: checking for FT_New_Face in -lfreetype" >&5
+echo "configure:38822: checking for FT_New_Face in -lfreetype" >&5
 ac_lib_var=`echo freetype'_'FT_New_Face | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -38805,7 +38826,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lfreetype  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 38809 "configure"
+#line 38830 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -38816,7 +38837,7 @@
 FT_New_Face()
 ; return 0; }
 EOF
-if { (eval echo configure:38820: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:38841: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -39179,7 +39200,7 @@
 
     else
       echo $ac_n "checking for FreeType 1 support""... $ac_c" 1>&6
-echo "configure:39183: checking for FreeType 1 support" >&5
+echo "configure:39204: checking for FreeType 1 support" >&5
       echo "$ac_t""no - FreeType 2.x is to be used instead" 1>&6
     fi
   fi
@@ -39293,7 +39314,7 @@
   done
 
   echo $ac_n "checking for T1_StrError in -lt1""... $ac_c" 1>&6
-echo "configure:39297: checking for T1_StrError in -lt1" >&5
+echo "configure:39318: checking for T1_StrError in -lt1" >&5
 ac_lib_var=`echo t1'_'T1_StrError | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -39301,7 +39322,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lt1  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 39305 "configure"
+#line 39326 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -39312,7 +39333,7 @@
 T1_StrError()
 ; return 0; }
 EOF
-if { (eval echo configure:39316: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:39337: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -39687,7 +39708,7 @@
   done
 
   echo $ac_n "checking for gdImageString16 in -lgd""... $ac_c" 1>&6
-echo "configure:39691: checking for gdImageString16 in -lgd" >&5
+echo "configure:39712: checking for gdImageString16 in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageString16 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -39695,7 +39716,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 39699 "configure"
+#line 39720 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -39706,7 +39727,7 @@
 gdImageString16()
 ; return 0; }
 EOF
-if { (eval echo configure:39710: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:39731: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -39835,7 +39856,7 @@
   done
 
   echo $ac_n "checking for gdImagePaletteCopy in -lgd""... $ac_c" 1>&6
-echo "configure:39839: checking for gdImagePaletteCopy in -lgd" >&5
+echo "configure:39860: checking for gdImagePaletteCopy in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImagePaletteCopy | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -39843,7 +39864,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 39847 "configure"
+#line 39868 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -39854,7 +39875,7 @@
 gdImagePaletteCopy()
 ; return 0; }
 EOF
-if { (eval echo configure:39858: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:39879: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -39983,7 +40004,7 @@
   done
 
   echo $ac_n "checking for gdImageCreateFromPng in -lgd""... $ac_c" 1>&6
-echo "configure:39987: checking for gdImageCreateFromPng in -lgd" >&5
+echo "configure:40008: checking for gdImageCreateFromPng in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreateFromPng | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -39991,7 +40012,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 39995 "configure"
+#line 40016 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40002,7 +40023,7 @@
 gdImageCreateFromPng()
 ; return 0; }
 EOF
-if { (eval echo configure:40006: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40027: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -40131,7 +40152,7 @@
   done
 
   echo $ac_n "checking for gdImageCreateFromGif in -lgd""... $ac_c" 1>&6
-echo "configure:40135: checking for gdImageCreateFromGif in -lgd" >&5
+echo "configure:40156: checking for gdImageCreateFromGif in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreateFromGif | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -40139,7 +40160,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 40143 "configure"
+#line 40164 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40150,7 +40171,7 @@
 gdImageCreateFromGif()
 ; return 0; }
 EOF
-if { (eval echo configure:40154: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40175: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -40279,7 +40300,7 @@
   done
 
   echo $ac_n "checking for gdImageGif in -lgd""... $ac_c" 1>&6
-echo "configure:40283: checking for gdImageGif in -lgd" >&5
+echo "configure:40304: checking for gdImageGif in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageGif | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -40287,7 +40308,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 40291 "configure"
+#line 40312 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40298,7 +40319,7 @@
 gdImageGif()
 ; return 0; }
 EOF
-if { (eval echo configure:40302: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40323: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -40427,7 +40448,7 @@
   done
 
   echo $ac_n "checking for gdImageWBMP in -lgd""... $ac_c" 1>&6
-echo "configure:40431: checking for gdImageWBMP in -lgd" >&5
+echo "configure:40452: checking for gdImageWBMP in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageWBMP | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -40435,7 +40456,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 40439 "configure"
+#line 40460 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40446,7 +40467,7 @@
 gdImageWBMP()
 ; return 0; }
 EOF
-if { (eval echo configure:40450: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40471: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -40575,7 +40596,7 @@
   done
 
   echo $ac_n "checking for gdImageCreateFromJpeg in -lgd""... $ac_c" 1>&6
-echo "configure:40579: checking for gdImageCreateFromJpeg in -lgd" >&5
+echo "configure:40600: checking for gdImageCreateFromJpeg in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreateFromJpeg | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -40583,7 +40604,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 40587 "configure"
+#line 40608 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40594,7 +40615,7 @@
 gdImageCreateFromJpeg()
 ; return 0; }
 EOF
-if { (eval echo configure:40598: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40619: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -40723,7 +40744,7 @@
   done
 
   echo $ac_n "checking for gdImageCreateFromXpm in -lgd""... $ac_c" 1>&6
-echo "configure:40727: checking for gdImageCreateFromXpm in -lgd" >&5
+echo "configure:40748: checking for gdImageCreateFromXpm in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreateFromXpm | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -40731,7 +40752,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 40735 "configure"
+#line 40756 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40742,7 +40763,7 @@
 gdImageCreateFromXpm()
 ; return 0; }
 EOF
-if { (eval echo configure:40746: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40767: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -40871,7 +40892,7 @@
   done
 
   echo $ac_n "checking for gdImageCreateFromGd2 in -lgd""... $ac_c" 1>&6
-echo "configure:40875: checking for gdImageCreateFromGd2 in -lgd" >&5
+echo "configure:40896: checking for gdImageCreateFromGd2 in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreateFromGd2 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -40879,7 +40900,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 40883 "configure"
+#line 40904 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -40890,7 +40911,7 @@
 gdImageCreateFromGd2()
 ; return 0; }
 EOF
-if { (eval echo configure:40894: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:40915: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41019,7 +41040,7 @@
   done
 
   echo $ac_n "checking for gdImageCreateTrueColor in -lgd""... $ac_c" 1>&6
-echo "configure:41023: checking for gdImageCreateTrueColor in -lgd" >&5
+echo "configure:41044: checking for gdImageCreateTrueColor in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreateTrueColor | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41027,7 +41048,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41031 "configure"
+#line 41052 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41038,7 +41059,7 @@
 gdImageCreateTrueColor()
 ; return 0; }
 EOF
-if { (eval echo configure:41042: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41063: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41167,7 +41188,7 @@
   done
 
   echo $ac_n "checking for gdImageSetTile in -lgd""... $ac_c" 1>&6
-echo "configure:41171: checking for gdImageSetTile in -lgd" >&5
+echo "configure:41192: checking for gdImageSetTile in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageSetTile | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41175,7 +41196,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41179 "configure"
+#line 41200 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41186,7 +41207,7 @@
 gdImageSetTile()
 ; return 0; }
 EOF
-if { (eval echo configure:41190: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41211: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41315,7 +41336,7 @@
   done
 
   echo $ac_n "checking for gdImageEllipse in -lgd""... $ac_c" 1>&6
-echo "configure:41319: checking for gdImageEllipse in -lgd" >&5
+echo "configure:41340: checking for gdImageEllipse in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageEllipse | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41323,7 +41344,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41327 "configure"
+#line 41348 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41334,7 +41355,7 @@
 gdImageEllipse()
 ; return 0; }
 EOF
-if { (eval echo configure:41338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41359: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41463,7 +41484,7 @@
   done
 
   echo $ac_n "checking for gdImageSetBrush in -lgd""... $ac_c" 1>&6
-echo "configure:41467: checking for gdImageSetBrush in -lgd" >&5
+echo "configure:41488: checking for gdImageSetBrush in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageSetBrush | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41471,7 +41492,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41475 "configure"
+#line 41496 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41482,7 +41503,7 @@
 gdImageSetBrush()
 ; return 0; }
 EOF
-if { (eval echo configure:41486: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41507: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41611,7 +41632,7 @@
   done
 
   echo $ac_n "checking for gdImageStringTTF in -lgd""... $ac_c" 1>&6
-echo "configure:41615: checking for gdImageStringTTF in -lgd" >&5
+echo "configure:41636: checking for gdImageStringTTF in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageStringTTF | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41619,7 +41640,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41623 "configure"
+#line 41644 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41630,7 +41651,7 @@
 gdImageStringTTF()
 ; return 0; }
 EOF
-if { (eval echo configure:41634: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41655: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41759,7 +41780,7 @@
   done
 
   echo $ac_n "checking for gdImageStringFT in -lgd""... $ac_c" 1>&6
-echo "configure:41763: checking for gdImageStringFT in -lgd" >&5
+echo "configure:41784: checking for gdImageStringFT in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageStringFT | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41767,7 +41788,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41771 "configure"
+#line 41792 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41778,7 +41799,7 @@
 gdImageStringFT()
 ; return 0; }
 EOF
-if { (eval echo configure:41782: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41803: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -41907,7 +41928,7 @@
   done
 
   echo $ac_n "checking for gdImageStringFTEx in -lgd""... $ac_c" 1>&6
-echo "configure:41911: checking for gdImageStringFTEx in -lgd" >&5
+echo "configure:41932: checking for gdImageStringFTEx in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageStringFTEx | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -41915,7 +41936,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 41919 "configure"
+#line 41940 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -41926,7 +41947,7 @@
 gdImageStringFTEx()
 ; return 0; }
 EOF
-if { (eval echo configure:41930: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:41951: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42055,7 +42076,7 @@
   done
 
   echo $ac_n "checking for gdImageColorClosestHWB in -lgd""... $ac_c" 1>&6
-echo "configure:42059: checking for gdImageColorClosestHWB in -lgd" >&5
+echo "configure:42080: checking for gdImageColorClosestHWB in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageColorClosestHWB | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42063,7 +42084,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42067 "configure"
+#line 42088 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42074,7 +42095,7 @@
 gdImageColorClosestHWB()
 ; return 0; }
 EOF
-if { (eval echo configure:42078: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42099: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42203,7 +42224,7 @@
   done
 
   echo $ac_n "checking for gdImageColorResolve in -lgd""... $ac_c" 1>&6
-echo "configure:42207: checking for gdImageColorResolve in -lgd" >&5
+echo "configure:42228: checking for gdImageColorResolve in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageColorResolve | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42211,7 +42232,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42215 "configure"
+#line 42236 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42222,7 +42243,7 @@
 gdImageColorResolve()
 ; return 0; }
 EOF
-if { (eval echo configure:42226: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42247: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42351,7 +42372,7 @@
   done
 
   echo $ac_n "checking for gdImageGifCtx in -lgd""... $ac_c" 1>&6
-echo "configure:42355: checking for gdImageGifCtx in -lgd" >&5
+echo "configure:42376: checking for gdImageGifCtx in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageGifCtx | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42359,7 +42380,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42363 "configure"
+#line 42384 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42370,7 +42391,7 @@
 gdImageGifCtx()
 ; return 0; }
 EOF
-if { (eval echo configure:42374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42395: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42499,7 +42520,7 @@
   done
 
   echo $ac_n "checking for gdCacheCreate in -lgd""... $ac_c" 1>&6
-echo "configure:42503: checking for gdCacheCreate in -lgd" >&5
+echo "configure:42524: checking for gdCacheCreate in -lgd" >&5
 ac_lib_var=`echo gd'_'gdCacheCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42507,7 +42528,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42511 "configure"
+#line 42532 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42518,7 +42539,7 @@
 gdCacheCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:42522: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42543: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42647,7 +42668,7 @@
   done
 
   echo $ac_n "checking for gdFontCacheShutdown in -lgd""... $ac_c" 1>&6
-echo "configure:42651: checking for gdFontCacheShutdown in -lgd" >&5
+echo "configure:42672: checking for gdFontCacheShutdown in -lgd" >&5
 ac_lib_var=`echo gd'_'gdFontCacheShutdown | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42655,7 +42676,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42659 "configure"
+#line 42680 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42666,7 +42687,7 @@
 gdFontCacheShutdown()
 ; return 0; }
 EOF
-if { (eval echo configure:42670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42691: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42795,7 +42816,7 @@
   done
 
   echo $ac_n "checking for gdFreeFontCache in -lgd""... $ac_c" 1>&6
-echo "configure:42799: checking for gdFreeFontCache in -lgd" >&5
+echo "configure:42820: checking for gdFreeFontCache in -lgd" >&5
 ac_lib_var=`echo gd'_'gdFreeFontCache | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42803,7 +42824,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42807 "configure"
+#line 42828 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42814,7 +42835,7 @@
 gdFreeFontCache()
 ; return 0; }
 EOF
-if { (eval echo configure:42818: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42839: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -42943,7 +42964,7 @@
   done
 
   echo $ac_n "checking for gdFontCacheMutexSetup in -lgd""... $ac_c" 1>&6
-echo "configure:42947: checking for gdFontCacheMutexSetup in -lgd" >&5
+echo "configure:42968: checking for gdFontCacheMutexSetup in -lgd" >&5
 ac_lib_var=`echo gd'_'gdFontCacheMutexSetup | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -42951,7 +42972,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 42955 "configure"
+#line 42976 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -42962,7 +42983,7 @@
 gdFontCacheMutexSetup()
 ; return 0; }
 EOF
-if { (eval echo configure:42966: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:42987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -43091,7 +43112,7 @@
   done
 
   echo $ac_n "checking for gdNewDynamicCtxEx in -lgd""... $ac_c" 1>&6
-echo "configure:43095: checking for gdNewDynamicCtxEx in -lgd" >&5
+echo "configure:43116: checking for gdNewDynamicCtxEx in -lgd" >&5
 ac_lib_var=`echo gd'_'gdNewDynamicCtxEx | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -43099,7 +43120,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 43103 "configure"
+#line 43124 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -43110,7 +43131,7 @@
 gdNewDynamicCtxEx()
 ; return 0; }
 EOF
-if { (eval echo configure:43114: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:43135: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -43165,7 +43186,7 @@
         old_CPPFLAGS=$CPPFLAGS
   CPPFLAGS=-I$GD_INCLUDE
   cat > conftest.$ac_ext <<EOF
-#line 43169 "configure"
+#line 43190 "configure"
 #include "confdefs.h"
 
 #include <gd.h>
@@ -43179,7 +43200,7 @@
   
 ; return 0; }
 EOF
-if { (eval echo configure:43183: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:43204: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     cat >> confdefs.h <<\EOF
@@ -43509,7 +43530,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 43513 "configure"
+#line 43534 "configure"
 #include "confdefs.h"
 
     char foobar () {}
@@ -43520,7 +43541,7 @@
     }
   
 EOF
-if { (eval echo configure:43524: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:43545: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -43672,7 +43693,7 @@
   done
 
   echo $ac_n "checking for gdImageCreate in -lgd""... $ac_c" 1>&6
-echo "configure:43676: checking for gdImageCreate in -lgd" >&5
+echo "configure:43697: checking for gdImageCreate in -lgd" >&5
 ac_lib_var=`echo gd'_'gdImageCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -43680,7 +43701,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 43684 "configure"
+#line 43705 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -43691,7 +43712,7 @@
 gdImageCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:43695: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:43716: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -43756,7 +43777,7 @@
 php_with_gettext=no
 
 echo $ac_n "checking for GNU gettext support""... $ac_c" 1>&6
-echo "configure:43760: checking for GNU gettext support" >&5
+echo "configure:43781: checking for GNU gettext support" >&5
 # Check whether --with-gettext or --without-gettext was given.
 if test "${with_gettext+set}" = set; then
   withval="$with_gettext"
@@ -43814,7 +43835,7 @@
   O_LDFLAGS=$LDFLAGS
   LDFLAGS="$LDFLAGS -L$GETTEXT_LIBDIR"
   echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
-echo "configure:43818: checking for bindtextdomain in -lintl" >&5
+echo "configure:43839: checking for bindtextdomain in -lintl" >&5
 ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -43822,7 +43843,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 43826 "configure"
+#line 43847 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -43833,7 +43854,7 @@
 bindtextdomain()
 ; return 0; }
 EOF
-if { (eval echo configure:43837: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:43858: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -43855,7 +43876,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for bindtextdomain in -lc""... $ac_c" 1>&6
-echo "configure:43859: checking for bindtextdomain in -lc" >&5
+echo "configure:43880: checking for bindtextdomain in -lc" >&5
 ac_lib_var=`echo c'_'bindtextdomain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -43863,7 +43884,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 43867 "configure"
+#line 43888 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -43874,7 +43895,7 @@
 bindtextdomain()
 ; return 0; }
 EOF
-if { (eval echo configure:43878: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:43899: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -44338,7 +44359,7 @@
 
 
   echo $ac_n "checking for ngettext in -l$GETTEXT_CHECK_IN_LIB""... $ac_c" 1>&6
-echo "configure:44342: checking for ngettext in -l$GETTEXT_CHECK_IN_LIB" >&5
+echo "configure:44363: checking for ngettext in -l$GETTEXT_CHECK_IN_LIB" >&5
 ac_lib_var=`echo $GETTEXT_CHECK_IN_LIB'_'ngettext | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -44346,7 +44367,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$GETTEXT_CHECK_IN_LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 44350 "configure"
+#line 44371 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -44357,7 +44378,7 @@
 ngettext()
 ; return 0; }
 EOF
-if { (eval echo configure:44361: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:44382: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -44381,7 +44402,7 @@
 fi
 
   echo $ac_n "checking for dngettext in -l$GETTEXT_CHECK_IN_LIB""... $ac_c" 1>&6
-echo "configure:44385: checking for dngettext in -l$GETTEXT_CHECK_IN_LIB" >&5
+echo "configure:44406: checking for dngettext in -l$GETTEXT_CHECK_IN_LIB" >&5
 ac_lib_var=`echo $GETTEXT_CHECK_IN_LIB'_'dngettext | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -44389,7 +44410,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$GETTEXT_CHECK_IN_LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 44393 "configure"
+#line 44414 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -44400,7 +44421,7 @@
 dngettext()
 ; return 0; }
 EOF
-if { (eval echo configure:44404: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:44425: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -44424,7 +44445,7 @@
 fi
 
   echo $ac_n "checking for dcngettext in -l$GETTEXT_CHECK_IN_LIB""... $ac_c" 1>&6
-echo "configure:44428: checking for dcngettext in -l$GETTEXT_CHECK_IN_LIB" >&5
+echo "configure:44449: checking for dcngettext in -l$GETTEXT_CHECK_IN_LIB" >&5
 ac_lib_var=`echo $GETTEXT_CHECK_IN_LIB'_'dcngettext | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -44432,7 +44453,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$GETTEXT_CHECK_IN_LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 44436 "configure"
+#line 44457 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -44443,7 +44464,7 @@
 dcngettext()
 ; return 0; }
 EOF
-if { (eval echo configure:44447: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:44468: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -44467,7 +44488,7 @@
 fi
 
   echo $ac_n "checking for bind_textdomain_codeset in -l$GETTEXT_CHECK_IN_LIB""... $ac_c" 1>&6
-echo "configure:44471: checking for bind_textdomain_codeset in -l$GETTEXT_CHECK_IN_LIB" >&5
+echo "configure:44492: checking for bind_textdomain_codeset in -l$GETTEXT_CHECK_IN_LIB" >&5
 ac_lib_var=`echo $GETTEXT_CHECK_IN_LIB'_'bind_textdomain_codeset | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -44475,7 +44496,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$GETTEXT_CHECK_IN_LIB  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 44479 "configure"
+#line 44500 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -44486,7 +44507,7 @@
 bind_textdomain_codeset()
 ; return 0; }
 EOF
-if { (eval echo configure:44490: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:44511: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -44517,7 +44538,7 @@
 php_with_gmp=no
 
 echo $ac_n "checking for GNU MP support""... $ac_c" 1>&6
-echo "configure:44521: checking for GNU MP support" >&5
+echo "configure:44542: checking for GNU MP support" >&5
 # Check whether --with-gmp or --without-gmp was given.
 if test "${with_gmp+set}" = set; then
   withval="$with_gmp"
@@ -44668,7 +44689,7 @@
   done
 
   echo $ac_n "checking for __gmp_randinit_lc_2exp_size in -lgmp""... $ac_c" 1>&6
-echo "configure:44672: checking for __gmp_randinit_lc_2exp_size in -lgmp" >&5
+echo "configure:44693: checking for __gmp_randinit_lc_2exp_size in -lgmp" >&5
 ac_lib_var=`echo gmp'_'__gmp_randinit_lc_2exp_size | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -44676,7 +44697,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgmp  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 44680 "configure"
+#line 44701 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -44687,7 +44708,7 @@
 __gmp_randinit_lc_2exp_size()
 ; return 0; }
 EOF
-if { (eval echo configure:44691: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:44712: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -44812,7 +44833,7 @@
   done
 
   echo $ac_n "checking for gmp_randinit_lc_2exp_size in -lgmp""... $ac_c" 1>&6
-echo "configure:44816: checking for gmp_randinit_lc_2exp_size in -lgmp" >&5
+echo "configure:44837: checking for gmp_randinit_lc_2exp_size in -lgmp" >&5
 ac_lib_var=`echo gmp'_'gmp_randinit_lc_2exp_size | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -44820,7 +44841,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgmp  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 44824 "configure"
+#line 44845 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -44831,7 +44852,7 @@
 gmp_randinit_lc_2exp_size()
 ; return 0; }
 EOF
-if { (eval echo configure:44835: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:44856: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -45303,7 +45324,7 @@
 php_enable_hash=yes
 
 echo $ac_n "checking whether to enable hash support""... $ac_c" 1>&6
-echo "configure:45307: checking whether to enable hash support" >&5
+echo "configure:45328: checking whether to enable hash support" >&5
 # Check whether --enable-hash or --disable-hash was given.
 if test "${enable_hash+set}" = set; then
   enableval="$enable_hash"
@@ -45353,7 +45374,7 @@
 
 
   echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:45357: checking whether byte ordering is bigendian" >&5
+echo "configure:45378: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian_php'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -45363,7 +45384,7 @@
   ac_cv_c_bigendian_php=unknown
 else
   cat > conftest.$ac_ext <<EOF
-#line 45367 "configure"
+#line 45388 "configure"
 #include "confdefs.h"
 
 int main(void)
@@ -45379,7 +45400,7 @@
 }
   
 EOF
-if { (eval echo configure:45383: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:45404: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian_php=yes
 else
@@ -45404,7 +45425,7 @@
 
 
   echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:45408: checking size of short" >&5
+echo "configure:45429: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -45412,18 +45433,19 @@
   ac_cv_sizeof_short=2
 else
   cat > conftest.$ac_ext <<EOF
-#line 45416 "configure"
+#line 45437 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(short));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:45427: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:45449: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
@@ -45443,7 +45465,7 @@
 
 
   echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:45447: checking size of int" >&5
+echo "configure:45469: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -45451,18 +45473,19 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 45455 "configure"
+#line 45477 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:45466: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:45489: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -45482,7 +45505,7 @@
 
 
   echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:45486: checking size of long" >&5
+echo "configure:45509: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -45490,18 +45513,19 @@
   ac_cv_sizeof_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 45494 "configure"
+#line 45517 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:45505: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:45529: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -45521,7 +45545,7 @@
 
 
   echo $ac_n "checking size of long long""... $ac_c" 1>&6
-echo "configure:45525: checking size of long long" >&5
+echo "configure:45549: checking size of long long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -45529,18 +45553,19 @@
   ac_cv_sizeof_long_long=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 45533 "configure"
+#line 45557 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:45544: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:45569: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long=`cat conftestval`
 else
@@ -45888,7 +45913,7 @@
 php_with_iconv=yes
 
 echo $ac_n "checking for iconv support""... $ac_c" 1>&6
-echo "configure:45892: checking for iconv support" >&5
+echo "configure:45917: checking for iconv support" >&5
 # Check whether --with-iconv or --without-iconv was given.
 if test "${with_iconv+set}" = set; then
   withval="$with_iconv"
@@ -45952,12 +45977,12 @@
 
         if test "$PHP_ICONV" = "yes"; then
     echo $ac_n "checking for iconv""... $ac_c" 1>&6
-echo "configure:45956: checking for iconv" >&5
+echo "configure:45981: checking for iconv" >&5
 if eval "test \"`echo '$''{'ac_cv_func_iconv'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 45961 "configure"
+#line 45986 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char iconv(); below.  */
@@ -45980,7 +46005,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:45984: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:46009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_iconv=yes"
 else
@@ -46001,12 +46026,12 @@
   echo "$ac_t""no" 1>&6
 
       echo $ac_n "checking for libiconv""... $ac_c" 1>&6
-echo "configure:46005: checking for libiconv" >&5
+echo "configure:46030: checking for libiconv" >&5
 if eval "test \"`echo '$''{'ac_cv_func_libiconv'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 46010 "configure"
+#line 46035 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char libiconv(); below.  */
@@ -46029,7 +46054,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:46033: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:46058: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_libiconv=yes"
 else
@@ -46185,7 +46210,7 @@
   done
 
   echo $ac_n "checking for libiconv in -l$iconv_lib_name""... $ac_c" 1>&6
-echo "configure:46189: checking for libiconv in -l$iconv_lib_name" >&5
+echo "configure:46214: checking for libiconv in -l$iconv_lib_name" >&5
 ac_lib_var=`echo $iconv_lib_name'_'libiconv | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -46193,7 +46218,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$iconv_lib_name  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 46197 "configure"
+#line 46222 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -46204,7 +46229,7 @@
 libiconv()
 ; return 0; }
 EOF
-if { (eval echo configure:46208: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:46233: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -46345,7 +46370,7 @@
   done
 
   echo $ac_n "checking for iconv in -l$iconv_lib_name""... $ac_c" 1>&6
-echo "configure:46349: checking for iconv in -l$iconv_lib_name" >&5
+echo "configure:46374: checking for iconv in -l$iconv_lib_name" >&5
 ac_lib_var=`echo $iconv_lib_name'_'iconv | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -46353,7 +46378,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$iconv_lib_name  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 46357 "configure"
+#line 46382 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -46364,7 +46389,7 @@
 iconv()
 ; return 0; }
 EOF
-if { (eval echo configure:46368: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:46393: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -46575,16 +46600,16 @@
     fi 
 
     echo $ac_n "checking if iconv is glibc's""... $ac_c" 1>&6
-echo "configure:46579: checking if iconv is glibc's" >&5
+echo "configure:46604: checking if iconv is glibc's" >&5
     cat > conftest.$ac_ext <<EOF
-#line 46581 "configure"
+#line 46606 "configure"
 #include "confdefs.h"
 #include <gnu/libc-version.h>
 int main() {
 gnu_get_libc_version();
 ; return 0; }
 EOF
-if { (eval echo configure:46588: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:46613: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
       echo "$ac_t""yes" 1>&6
@@ -46602,7 +46627,7 @@
 
     if test -z "$iconv_impl_name"; then
       echo $ac_n "checking if using GNU libiconv""... $ac_c" 1>&6
-echo "configure:46606: checking if using GNU libiconv" >&5
+echo "configure:46631: checking if using GNU libiconv" >&5
       php_iconv_old_ld="$LDFLAGS"
       LDFLAGS="-liconv $LDFLAGS"
       if test "$cross_compiling" = yes; then
@@ -46612,7 +46637,7 @@
       
 else
   cat > conftest.$ac_ext <<EOF
-#line 46616 "configure"
+#line 46641 "configure"
 #include "confdefs.h"
 
 #include <$PHP_ICONV_H_PATH>
@@ -46622,7 +46647,7 @@
 }
       
 EOF
-if { (eval echo configure:46626: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:46651: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
         echo "$ac_t""yes" 1>&6
@@ -46644,16 +46669,16 @@
 
     if test -z "$iconv_impl_name"; then
       echo $ac_n "checking if iconv is Konstantin Chuguev's""... $ac_c" 1>&6
-echo "configure:46648: checking if iconv is Konstantin Chuguev's" >&5
+echo "configure:46673: checking if iconv is Konstantin Chuguev's" >&5
       cat > conftest.$ac_ext <<EOF
-#line 46650 "configure"
+#line 46675 "configure"
 #include "confdefs.h"
 #include <iconv.h>
 int main() {
 iconv_ccs_init(NULL, NULL);
 ; return 0; }
 EOF
-if { (eval echo configure:46657: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:46682: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
         echo "$ac_t""yes" 1>&6
@@ -46821,7 +46846,7 @@
     esac
 
     echo $ac_n "checking if iconv supports errno""... $ac_c" 1>&6
-echo "configure:46825: checking if iconv supports errno" >&5
+echo "configure:46850: checking if iconv supports errno" >&5
     if test "$cross_compiling" = yes; then
   
       echo "$ac_t""no" 1>&6
@@ -46835,7 +46860,7 @@
     
 else
   cat > conftest.$ac_ext <<EOF
-#line 46839 "configure"
+#line 46864 "configure"
 #include "confdefs.h"
 
 #include <$PHP_ICONV_H_PATH>
@@ -46856,7 +46881,7 @@
 }
     
 EOF
-if { (eval echo configure:46860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:46885: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       echo "$ac_t""yes" 1>&6
@@ -46888,9 +46913,9 @@
 
 
     echo $ac_n "checking if your cpp allows macro usage in include lines""... $ac_c" 1>&6
-echo "configure:46892: checking if your cpp allows macro usage in include lines" >&5
+echo "configure:46917: checking if your cpp allows macro usage in include lines" >&5
     cat > conftest.$ac_ext <<EOF
-#line 46894 "configure"
+#line 46919 "configure"
 #include "confdefs.h"
 
 #define FOO <$PHP_ICONV_H_PATH>
@@ -46900,7 +46925,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:46904: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:46929: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
       echo "$ac_t""yes" 1>&6
@@ -47256,7 +47281,7 @@
 php_with_imap=no
 
 echo $ac_n "checking for IMAP support""... $ac_c" 1>&6
-echo "configure:47260: checking for IMAP support" >&5
+echo "configure:47285: checking for IMAP support" >&5
 # Check whether --with-imap or --without-imap was given.
 if test "${with_imap+set}" = set; then
   withval="$with_imap"
@@ -47303,7 +47328,7 @@
 php_with_kerberos=no
 
 echo $ac_n "checking for IMAP Kerberos support""... $ac_c" 1>&6
-echo "configure:47307: checking for IMAP Kerberos support" >&5
+echo "configure:47332: checking for IMAP Kerberos support" >&5
 # Check whether --with-kerberos or --without-kerberos was given.
 if test "${with_kerberos+set}" = set; then
   withval="$with_kerberos"
@@ -47329,7 +47354,7 @@
 php_with_imap_ssl=no
 
 echo $ac_n "checking for IMAP SSL support""... $ac_c" 1>&6
-echo "configure:47333: checking for IMAP SSL support" >&5
+echo "configure:47358: checking for IMAP SSL support" >&5
 # Check whether --with-imap-ssl or --without-imap-ssl was given.
 if test "${with_imap_ssl+set}" = set; then
   withval="$with_imap_ssl"
@@ -47736,7 +47761,7 @@
     done
 
         cat > conftest.$ac_ext <<EOF
-#line 47740 "configure"
+#line 47765 "configure"
 #include "confdefs.h"
 #include <$IMAP_INC_DIR/mail.h>
 EOF
@@ -47756,12 +47781,12 @@
         old_CFLAGS=$CFLAGS
     CFLAGS="-I$IMAP_INC_DIR"
     echo $ac_n "checking for utf8_mime2text signature""... $ac_c" 1>&6
-echo "configure:47760: checking for utf8_mime2text signature" >&5
+echo "configure:47785: checking for utf8_mime2text signature" >&5
 if eval "test \"`echo '$''{'ac_cv_utf8_mime2text'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 47765 "configure"
+#line 47790 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -47774,7 +47799,7 @@
       
 ; return 0; }
 EOF
-if { (eval echo configure:47778: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:47803: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
         ac_cv_utf8_mime2text=old
@@ -47803,12 +47828,12 @@
     old_CFLAGS=$CFLAGS
     CFLAGS="-I$IMAP_INC_DIR"
     echo $ac_n "checking for U8T_DECOMPOSE""... $ac_c" 1>&6
-echo "configure:47807: checking for U8T_DECOMPOSE" >&5
+echo "configure:47832: checking for U8T_DECOMPOSE" >&5
 if eval "test \"`echo '$''{'ac_cv_u8t_canonical'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 47812 "configure"
+#line 47837 "configure"
 #include "confdefs.h"
 
 #include <c-client.h>
@@ -47819,7 +47844,7 @@
       
 ; return 0; }
 EOF
-if { (eval echo configure:47823: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:47848: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
          ac_cv_u8t_decompose=yes
@@ -47849,7 +47874,7 @@
         old_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=-I$IMAP_INC_DIR
     cat > conftest.$ac_ext <<EOF
-#line 47853 "configure"
+#line 47878 "configure"
 #include "confdefs.h"
 
 #include "imap4r1.h"
@@ -47968,7 +47993,7 @@
   done
 
   echo $ac_n "checking for pam_start in -lpam""... $ac_c" 1>&6
-echo "configure:47972: checking for pam_start in -lpam" >&5
+echo "configure:47997: checking for pam_start in -lpam" >&5
 ac_lib_var=`echo pam'_'pam_start | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -47976,7 +48001,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpam  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 47980 "configure"
+#line 48005 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -47987,7 +48012,7 @@
 pam_start()
 ; return 0; }
 EOF
-if { (eval echo configure:47991: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:48016: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -48142,7 +48167,7 @@
   done
 
   echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
-echo "configure:48146: checking for crypt in -lcrypt" >&5
+echo "configure:48171: checking for crypt in -lcrypt" >&5
 ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -48150,7 +48175,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 48154 "configure"
+#line 48179 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -48161,7 +48186,7 @@
 crypt()
 ; return 0; }
 EOF
-if { (eval echo configure:48165: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:48190: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -48365,7 +48390,7 @@
     # Extract the first word of "krb5-config", so it can be a program name with args.
 set dummy krb5-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:48369: checking for $ac_word" >&5
+echo "configure:48394: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_KRB5_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -48734,7 +48759,7 @@
 
   else
     cat > conftest.$ac_ext <<EOF
-#line 48738 "configure"
+#line 48763 "configure"
 #include "confdefs.h"
 #include <$IMAP_INC_DIR/linkage.h>
 EOF
@@ -48775,7 +48800,7 @@
     # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:48779: checking for $ac_word" >&5
+echo "configure:48804: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PKG_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -48980,9 +49005,9 @@
     old_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=-I$OPENSSL_INCDIR
     echo $ac_n "checking for OpenSSL version""... $ac_c" 1>&6
-echo "configure:48984: checking for OpenSSL version" >&5
+echo "configure:49009: checking for OpenSSL version" >&5
     cat > conftest.$ac_ext <<EOF
-#line 48986 "configure"
+#line 49011 "configure"
 #include "confdefs.h"
 
 #include <openssl/opensslv.h>
@@ -49137,7 +49162,7 @@
   done
 
   echo $ac_n "checking for CRYPTO_free in -lcrypto""... $ac_c" 1>&6
-echo "configure:49141: checking for CRYPTO_free in -lcrypto" >&5
+echo "configure:49166: checking for CRYPTO_free in -lcrypto" >&5
 ac_lib_var=`echo crypto'_'CRYPTO_free | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -49145,7 +49170,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 49149 "configure"
+#line 49174 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -49156,7 +49181,7 @@
 CRYPTO_free()
 ; return 0; }
 EOF
-if { (eval echo configure:49160: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:49185: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -49313,7 +49338,7 @@
   done
 
   echo $ac_n "checking for SSL_CTX_set_ssl_version in -lssl""... $ac_c" 1>&6
-echo "configure:49317: checking for SSL_CTX_set_ssl_version in -lssl" >&5
+echo "configure:49342: checking for SSL_CTX_set_ssl_version in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_CTX_set_ssl_version | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -49321,7 +49346,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 49325 "configure"
+#line 49350 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -49332,7 +49357,7 @@
 SSL_CTX_set_ssl_version()
 ; return 0; }
 EOF
-if { (eval echo configure:49336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:49361: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -49451,7 +49476,7 @@
 
   elif test -f "$IMAP_INC_DIR/linkage.c"; then
     cat > conftest.$ac_ext <<EOF
-#line 49455 "configure"
+#line 49480 "configure"
 #include "confdefs.h"
 #include <$IMAP_INC_DIR/linkage.c>
 EOF
@@ -49482,7 +49507,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 49486 "configure"
+#line 49511 "configure"
 #include "confdefs.h"
 
     
@@ -49509,7 +49534,7 @@
     }
   
 EOF
-if { (eval echo configure:49513: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:49538: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -49536,7 +49561,7 @@
 
 
     echo $ac_n "checking whether build with IMAP works""... $ac_c" 1>&6
-echo "configure:49540: checking whether build with IMAP works" >&5
+echo "configure:49565: checking whether build with IMAP works" >&5
     
   
   old_LIBS=$LIBS
@@ -49547,7 +49572,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 49551 "configure"
+#line 49576 "configure"
 #include "confdefs.h"
 
     
@@ -49574,7 +49599,7 @@
     }
   
 EOF
-if { (eval echo configure:49578: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:49603: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -49601,7 +49626,7 @@
 
 
     echo $ac_n "checking whether rfc822_output_address_list function present""... $ac_c" 1>&6
-echo "configure:49605: checking whether rfc822_output_address_list function present" >&5
+echo "configure:49630: checking whether rfc822_output_address_list function present" >&5
     
   old_LIBS=$LIBS
   LIBS="
@@ -49613,7 +49638,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 49617 "configure"
+#line 49642 "configure"
 #include "confdefs.h"
 
     
@@ -49643,7 +49668,7 @@
     }
   
 EOF
-if { (eval echo configure:49647: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:49672: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -49678,7 +49703,7 @@
 php_with_interbase=no
 
 echo $ac_n "checking for InterBase support""... $ac_c" 1>&6
-echo "configure:49682: checking for InterBase support" >&5
+echo "configure:49707: checking for InterBase support" >&5
 # Check whether --with-interbase or --without-interbase was given.
 if test "${with_interbase+set}" = set; then
   withval="$with_interbase"
@@ -49828,7 +49853,7 @@
   done
 
   echo $ac_n "checking for isc_detach_database in -lfbclient""... $ac_c" 1>&6
-echo "configure:49832: checking for isc_detach_database in -lfbclient" >&5
+echo "configure:49857: checking for isc_detach_database in -lfbclient" >&5
 ac_lib_var=`echo fbclient'_'isc_detach_database | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -49836,7 +49861,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lfbclient  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 49840 "configure"
+#line 49865 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -49847,7 +49872,7 @@
 isc_detach_database()
 ; return 0; }
 EOF
-if { (eval echo configure:49851: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:49876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -49974,7 +49999,7 @@
   done
 
   echo $ac_n "checking for isc_detach_database in -lgds""... $ac_c" 1>&6
-echo "configure:49978: checking for isc_detach_database in -lgds" >&5
+echo "configure:50003: checking for isc_detach_database in -lgds" >&5
 ac_lib_var=`echo gds'_'isc_detach_database | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -49982,7 +50007,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgds  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 49986 "configure"
+#line 50011 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -49993,7 +50018,7 @@
 isc_detach_database()
 ; return 0; }
 EOF
-if { (eval echo configure:49997: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:50022: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -50120,7 +50145,7 @@
   done
 
   echo $ac_n "checking for isc_detach_database in -lib_util""... $ac_c" 1>&6
-echo "configure:50124: checking for isc_detach_database in -lib_util" >&5
+echo "configure:50149: checking for isc_detach_database in -lib_util" >&5
 ac_lib_var=`echo ib_util'_'isc_detach_database | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -50128,7 +50153,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lib_util  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 50132 "configure"
+#line 50157 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -50139,7 +50164,7 @@
 isc_detach_database()
 ; return 0; }
 EOF
-if { (eval echo configure:50143: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:50168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -50616,7 +50641,7 @@
 php_enable_json=yes
 
 echo $ac_n "checking whether to enable JavaScript Object Serialization support""... $ac_c" 1>&6
-echo "configure:50620: checking whether to enable JavaScript Object Serialization support" >&5
+echo "configure:50645: checking whether to enable JavaScript Object Serialization support" >&5
 # Check whether --enable-json or --disable-json was given.
 if test "${enable_json+set}" = set; then
   enableval="$enable_json"
@@ -50665,12 +50690,12 @@
 EOF
 
   echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:50669: checking for ANSI C header files" >&5
+echo "configure:50694: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 50674 "configure"
+#line 50699 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -50678,7 +50703,7 @@
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:50682: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:50707: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -50695,7 +50720,7 @@
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 50699 "configure"
+#line 50724 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -50713,7 +50738,7 @@
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 50717 "configure"
+#line 50742 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -50734,7 +50759,7 @@
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 50738 "configure"
+#line 50763 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -50745,7 +50770,7 @@
 exit (0); }
 
 EOF
-if { (eval echo configure:50749: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:50774: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -51095,7 +51120,7 @@
 php_with_ldap=no
 
 echo $ac_n "checking for LDAP support""... $ac_c" 1>&6
-echo "configure:51099: checking for LDAP support" >&5
+echo "configure:51124: checking for LDAP support" >&5
 # Check whether --with-ldap or --without-ldap was given.
 if test "${with_ldap+set}" = set; then
   withval="$with_ldap"
@@ -51142,7 +51167,7 @@
 php_with_ldap_sasl=no
 
 echo $ac_n "checking for LDAP Cyrus SASL support""... $ac_c" 1>&6
-echo "configure:51146: checking for LDAP Cyrus SASL support" >&5
+echo "configure:51171: checking for LDAP Cyrus SASL support" >&5
 # Check whether --with-ldap-sasl or --without-ldap-sasl was given.
 if test "${with_ldap_sasl+set}" = set; then
   withval="$with_ldap_sasl"
@@ -53487,19 +53512,19 @@
   LIBS="$LIBS $LDAP_SHARED_LIBADD"
 
     echo $ac_n "checking for 3 arg ldap_set_rebind_proc""... $ac_c" 1>&6
-echo "configure:53491: checking for 3 arg ldap_set_rebind_proc" >&5
+echo "configure:53516: checking for 3 arg ldap_set_rebind_proc" >&5
 if eval "test \"`echo '$''{'ac_cv_3arg_setrebindproc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 53496 "configure"
+#line 53521 "configure"
 #include "confdefs.h"
 #include <ldap.h>
 int main() {
 ldap_set_rebind_proc(0,0,0)
 ; return 0; }
 EOF
-if { (eval echo configure:53503: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:53528: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_3arg_setrebindproc=yes
 else
@@ -53522,12 +53547,12 @@
       for ac_func in ldap_parse_result ldap_parse_reference ldap_start_tls_s
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:53526: checking for $ac_func" >&5
+echo "configure:53551: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 53531 "configure"
+#line 53556 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -53550,7 +53575,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:53554: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:53579: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -53712,7 +53737,7 @@
   done
 
   echo $ac_n "checking for sasl_version in -lldap""... $ac_c" 1>&6
-echo "configure:53716: checking for sasl_version in -lldap" >&5
+echo "configure:53741: checking for sasl_version in -lldap" >&5
 ac_lib_var=`echo ldap'_'sasl_version | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -53720,7 +53745,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lldap  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 53724 "configure"
+#line 53749 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -53731,7 +53756,7 @@
 sasl_version()
 ; return 0; }
 EOF
-if { (eval echo configure:53735: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:53760: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -53900,12 +53925,12 @@
   fi
 
         echo $ac_n "checking for ldap_bind_s""... $ac_c" 1>&6
-echo "configure:53904: checking for ldap_bind_s" >&5
+echo "configure:53929: checking for ldap_bind_s" >&5
 if eval "test \"`echo '$''{'ac_cv_func_ldap_bind_s'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 53909 "configure"
+#line 53934 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char ldap_bind_s(); below.  */
@@ -53928,7 +53953,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:53932: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:53957: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_ldap_bind_s=yes"
 else
@@ -53979,7 +54004,7 @@
 php_enable_mbstring=no
 
 echo $ac_n "checking whether to enable multibyte string support""... $ac_c" 1>&6
-echo "configure:53983: checking whether to enable multibyte string support" >&5
+echo "configure:54008: checking whether to enable multibyte string support" >&5
 # Check whether --enable-mbstring or --disable-mbstring was given.
 if test "${enable_mbstring+set}" = set; then
   enableval="$enable_mbstring"
@@ -54026,7 +54051,7 @@
 php_enable_mbregex=yes
 
 echo $ac_n "checking whether to enable multibyte regex support""... $ac_c" 1>&6
-echo "configure:54030: checking whether to enable multibyte regex support" >&5
+echo "configure:54055: checking whether to enable multibyte regex support" >&5
 # Check whether --enable-mbregex or --disable-mbregex was given.
 if test "${enable_mbregex+set}" = set; then
   enableval="$enable_mbregex"
@@ -54052,7 +54077,7 @@
 php_enable_mbregex_backtrack=yes
 
 echo $ac_n "checking whether to check multibyte regex backtrack""... $ac_c" 1>&6
-echo "configure:54056: checking whether to check multibyte regex backtrack" >&5
+echo "configure:54081: checking whether to check multibyte regex backtrack" >&5
 # Check whether --enable-mbregex_backtrack or --disable-mbregex_backtrack was given.
 if test "${enable_mbregex_backtrack+set}" = set; then
   enableval="$enable_mbregex_backtrack"
@@ -54078,7 +54103,7 @@
 php_with_libmbfl=no
 
 echo $ac_n "checking for external libmbfl""... $ac_c" 1>&6
-echo "configure:54082: checking for external libmbfl" >&5
+echo "configure:54107: checking for external libmbfl" >&5
 # Check whether --with-libmbfl or --without-libmbfl was given.
 if test "${with_libmbfl+set}" = set; then
   withval="$with_libmbfl"
@@ -54114,7 +54139,7 @@
     
   if test "$PHP_MBREGEX" = "yes"; then
     echo $ac_n "checking for variable length prototypes and stdarg.h""... $ac_c" 1>&6
-echo "configure:54118: checking for variable length prototypes and stdarg.h" >&5
+echo "configure:54143: checking for variable length prototypes and stdarg.h" >&5
 if eval "test \"`echo '$''{'php_cv_mbstring_stdarg'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -54132,7 +54157,7 @@
       
 else
   cat > conftest.$ac_ext <<EOF
-#line 54136 "configure"
+#line 54161 "configure"
 #include "confdefs.h"
 
 #include <stdarg.h>
@@ -54147,7 +54172,7 @@
 int main() { return foo(10, "", 3.14); }
       
 EOF
-if { (eval echo configure:54151: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:54176: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   php_cv_mbstring_stdarg=yes
 else
@@ -54168,17 +54193,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:54172: checking for $ac_hdr" >&5
+echo "configure:54197: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54177 "configure"
+#line 54202 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:54182: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:54207: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -54205,7 +54230,7 @@
 done
 
     echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:54209: checking size of int" >&5
+echo "configure:54234: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -54213,18 +54238,19 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 54217 "configure"
+#line 54242 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:54228: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:54254: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -54244,7 +54270,7 @@
 
 
     echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:54248: checking size of short" >&5
+echo "configure:54274: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -54252,18 +54278,19 @@
   ac_cv_sizeof_short=2
 else
   cat > conftest.$ac_ext <<EOF
-#line 54256 "configure"
+#line 54282 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(short));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:54267: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:54294: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
@@ -54283,7 +54310,7 @@
 
 
     echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:54287: checking size of long" >&5
+echo "configure:54314: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -54291,18 +54318,19 @@
   ac_cv_sizeof_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 54295 "configure"
+#line 54322 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:54306: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:54334: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -54322,12 +54350,12 @@
 
 
     echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:54326: checking for working const" >&5
+echo "configure:54354: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54331 "configure"
+#line 54359 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -54376,7 +54404,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:54380: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:54408: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -54397,12 +54425,12 @@
 fi
 
     echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:54401: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:54429: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54406 "configure"
+#line 54434 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
@@ -54411,7 +54439,7 @@
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:54415: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:54443: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
@@ -54434,19 +54462,19 @@
     # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:54438: checking for working alloca.h" >&5
+echo "configure:54466: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54443 "configure"
+#line 54471 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:54450: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:54478: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -54467,12 +54495,12 @@
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:54471: checking for alloca" >&5
+echo "configure:54499: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54476 "configure"
+#line 54504 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -54500,7 +54528,7 @@
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:54504: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:54532: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -54532,12 +54560,12 @@
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:54536: checking whether alloca needs Cray hooks" >&5
+echo "configure:54564: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54541 "configure"
+#line 54569 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -54562,12 +54590,12 @@
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:54566: checking for $ac_func" >&5
+echo "configure:54594: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 54571 "configure"
+#line 54599 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -54590,7 +54618,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:54594: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:54622: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -54617,7 +54645,7 @@
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:54621: checking stack direction for C alloca" >&5
+echo "configure:54649: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -54625,7 +54653,7 @@
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 54629 "configure"
+#line 54657 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -54644,7 +54672,7 @@
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:54648: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:54676: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -54666,7 +54694,7 @@
 fi
 
     echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
-echo "configure:54670: checking for 8-bit clean memcmp" >&5
+echo "configure:54698: checking for 8-bit clean memcmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -54674,7 +54702,7 @@
   ac_cv_func_memcmp_clean=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 54678 "configure"
+#line 54706 "configure"
 #include "confdefs.h"
 
 main()
@@ -54684,7 +54712,7 @@
 }
 
 EOF
-if { (eval echo configure:54688: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:54716: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_memcmp_clean=yes
 else
@@ -55027,7 +55055,7 @@
   done
 
   echo $ac_n "checking for mbfl_buffer_converter_new in -lmbfl""... $ac_c" 1>&6
-echo "configure:55031: checking for mbfl_buffer_converter_new in -lmbfl" >&5
+echo "configure:55059: checking for mbfl_buffer_converter_new in -lmbfl" >&5
 ac_lib_var=`echo mbfl'_'mbfl_buffer_converter_new | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -55035,7 +55063,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lmbfl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 55039 "configure"
+#line 55067 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -55046,7 +55074,7 @@
 mbfl_buffer_converter_new()
 ; return 0; }
 EOF
-if { (eval echo configure:55050: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:55078: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -55680,7 +55708,7 @@
 php_with_mcrypt=no
 
 echo $ac_n "checking for mcrypt support""... $ac_c" 1>&6
-echo "configure:55684: checking for mcrypt support" >&5
+echo "configure:55712: checking for mcrypt support" >&5
 # Check whether --with-mcrypt or --without-mcrypt was given.
 if test "${with_mcrypt+set}" = set; then
   withval="$with_mcrypt"
@@ -55736,9 +55764,9 @@
   old_CPPFLAGS=$CPPFLAGS
   CPPFLAGS=-I$MCRYPT_DIR/include
   echo $ac_n "checking for libmcrypt version""... $ac_c" 1>&6
-echo "configure:55740: checking for libmcrypt version" >&5
+echo "configure:55768: checking for libmcrypt version" >&5
   cat > conftest.$ac_ext <<EOF
-#line 55742 "configure"
+#line 55770 "configure"
 #include "confdefs.h"
 
 #include <mcrypt.h>
@@ -55862,7 +55890,7 @@
   done
 
   echo $ac_n "checking for mcrypt_module_open in -lmcrypt""... $ac_c" 1>&6
-echo "configure:55866: checking for mcrypt_module_open in -lmcrypt" >&5
+echo "configure:55894: checking for mcrypt_module_open in -lmcrypt" >&5
 ac_lib_var=`echo mcrypt'_'mcrypt_module_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -55870,7 +55898,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lmcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 55874 "configure"
+#line 55902 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -55881,7 +55909,7 @@
 mcrypt_module_open()
 ; return 0; }
 EOF
-if { (eval echo configure:55885: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:55913: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -56034,7 +56062,7 @@
   done
 
   echo $ac_n "checking for mcrypt_module_open in -lmcrypt""... $ac_c" 1>&6
-echo "configure:56038: checking for mcrypt_module_open in -lmcrypt" >&5
+echo "configure:56066: checking for mcrypt_module_open in -lmcrypt" >&5
 ac_lib_var=`echo mcrypt'_'mcrypt_module_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -56042,7 +56070,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lmcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 56046 "configure"
+#line 56074 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -56053,7 +56081,7 @@
 mcrypt_module_open()
 ; return 0; }
 EOF
-if { (eval echo configure:56057: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:56085: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -56526,7 +56554,7 @@
 php_with_mhash=no
 
 echo $ac_n "checking for mhash support""... $ac_c" 1>&6
-echo "configure:56530: checking for mhash support" >&5
+echo "configure:56558: checking for mhash support" >&5
 # Check whether --with-mhash or --without-mhash was given.
 if test "${with_mhash+set}" = set; then
   withval="$with_mhash"
@@ -57013,7 +57041,7 @@
 php_with_mime_magic=no
 
 echo $ac_n "checking whether to include mime_magic support""... $ac_c" 1>&6
-echo "configure:57017: checking whether to include mime_magic support" >&5
+echo "configure:57045: checking whether to include mime_magic support" >&5
 # Check whether --with-mime-magic or --without-mime-magic was given.
 if test "${with_mime_magic+set}" = set; then
   withval="$with_mime_magic"
@@ -57382,7 +57410,7 @@
 php_with_ming=no
 
 echo $ac_n "checking for MING support""... $ac_c" 1>&6
-echo "configure:57386: checking for MING support" >&5
+echo "configure:57414: checking for MING support" >&5
 # Check whether --with-ming or --without-ming was given.
 if test "${with_ming+set}" = set; then
   withval="$with_ming"
@@ -57427,7 +57455,7 @@
 
 if test "$PHP_MING" != "no"; then
   echo $ac_n "checking for sin in -lm""... $ac_c" 1>&6
-echo "configure:57431: checking for sin in -lm" >&5
+echo "configure:57459: checking for sin in -lm" >&5
 ac_lib_var=`echo m'_'sin | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -57435,7 +57463,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 57439 "configure"
+#line 57467 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -57446,7 +57474,7 @@
 sin()
 ; return 0; }
 EOF
-if { (eval echo configure:57450: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:57478: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -57593,7 +57621,7 @@
   done
 
   echo $ac_n "checking for Ming_useSWFVersion in -lming""... $ac_c" 1>&6
-echo "configure:57597: checking for Ming_useSWFVersion in -lming" >&5
+echo "configure:57625: checking for Ming_useSWFVersion in -lming" >&5
 ac_lib_var=`echo ming'_'Ming_useSWFVersion | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -57601,7 +57629,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lming  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 57605 "configure"
+#line 57633 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -57612,7 +57640,7 @@
 Ming_useSWFVersion()
 ; return 0; }
 EOF
-if { (eval echo configure:57616: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:57644: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -57875,7 +57903,7 @@
   done
 
   echo $ac_n "checking for SWFPrebuiltClip in -lming""... $ac_c" 1>&6
-echo "configure:57879: checking for SWFPrebuiltClip in -lming" >&5
+echo "configure:57907: checking for SWFPrebuiltClip in -lming" >&5
 ac_lib_var=`echo ming'_'SWFPrebuiltClip | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -57883,7 +57911,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lming  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 57887 "configure"
+#line 57915 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -57894,7 +57922,7 @@
 SWFPrebuiltClip()
 ; return 0; }
 EOF
-if { (eval echo configure:57898: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:57926: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -58023,7 +58051,7 @@
   done
 
   echo $ac_n "checking for SWFMovie_namedAnchor in -lming""... $ac_c" 1>&6
-echo "configure:58027: checking for SWFMovie_namedAnchor in -lming" >&5
+echo "configure:58055: checking for SWFMovie_namedAnchor in -lming" >&5
 ac_lib_var=`echo ming'_'SWFMovie_namedAnchor | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -58031,7 +58059,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lming  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 58035 "configure"
+#line 58063 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -58042,7 +58070,7 @@
 SWFMovie_namedAnchor()
 ; return 0; }
 EOF
-if { (eval echo configure:58046: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:58074: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -58171,7 +58199,7 @@
   done
 
   echo $ac_n "checking for Ming_setSWFCompression in -lming""... $ac_c" 1>&6
-echo "configure:58175: checking for Ming_setSWFCompression in -lming" >&5
+echo "configure:58203: checking for Ming_setSWFCompression in -lming" >&5
 ac_lib_var=`echo ming'_'Ming_setSWFCompression | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -58179,7 +58207,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lming  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 58183 "configure"
+#line 58211 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -58190,7 +58218,7 @@
 Ming_setSWFCompression()
 ; return 0; }
 EOF
-if { (eval echo configure:58194: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:58222: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -58227,14 +58255,14 @@
   old_CPPFLAGS=$CPPFLAGS
   CPPFLAGS=-I$MING_INC_DIR
   echo $ac_n "checking for destroySWFBlock""... $ac_c" 1>&6
-echo "configure:58231: checking for destroySWFBlock" >&5
+echo "configure:58259: checking for destroySWFBlock" >&5
   if test "$cross_compiling" = yes; then
   
     echo "$ac_t""unknown" 1>&6
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 58238 "configure"
+#line 58266 "configure"
 #include "confdefs.h"
 
 #include "ming.h"
@@ -58246,7 +58274,7 @@
 }
   
 EOF
-if { (eval echo configure:58250: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:58278: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     echo "$ac_t""missing" 1>&6
@@ -58268,7 +58296,7 @@
  
 
   cat > conftest.$ac_ext <<EOF
-#line 58272 "configure"
+#line 58300 "configure"
 #include "confdefs.h"
 
 #include <ming.h>
@@ -58295,7 +58323,7 @@
 
 
     cat > conftest.$ac_ext <<EOF
-#line 58299 "configure"
+#line 58327 "configure"
 #include "confdefs.h"
 
 #include <ming.h>
@@ -58306,7 +58334,7 @@
   
 ; return 0; }
 EOF
-if { (eval echo configure:58310: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:58338: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     cat >> confdefs.h <<\EOF
@@ -58625,7 +58653,7 @@
 php_with_msql=no
 
 echo $ac_n "checking for mSQL support""... $ac_c" 1>&6
-echo "configure:58629: checking for mSQL support" >&5
+echo "configure:58657: checking for mSQL support" >&5
 # Check whether --with-msql or --without-msql was given.
 if test "${with_msql+set}" = set; then
   withval="$with_msql"
@@ -59105,11 +59133,11 @@
 
     
   echo $ac_n "checking mSQL version""... $ac_c" 1>&6
-echo "configure:59109: checking mSQL version" >&5
+echo "configure:59137: checking mSQL version" >&5
   ac_php_oldcppflags=$CPPFLAGS
   CPPFLAGS="$INCLUDES $CPPFLAGS"
   cat > conftest.$ac_ext <<EOF
-#line 59113 "configure"
+#line 59141 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include "msql.h"
@@ -59117,7 +59145,7 @@
 int i = IDX_TYPE
 ; return 0; }
 EOF
-if { (eval echo configure:59121: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:59149: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
     cat >> confdefs.h <<\EOF
@@ -59149,7 +59177,7 @@
 php_with_mssql=no
 
 echo $ac_n "checking for MSSQL support via FreeTDS""... $ac_c" 1>&6
-echo "configure:59153: checking for MSSQL support via FreeTDS" >&5
+echo "configure:59181: checking for MSSQL support via FreeTDS" >&5
 # Check whether --with-mssql or --without-mssql was given.
 if test "${with_mssql+set}" = set; then
   withval="$with_mssql"
@@ -59650,7 +59678,7 @@
   fi
 
   echo $ac_n "checking for dnet_addr in -ldnet_stub""... $ac_c" 1>&6
-echo "configure:59654: checking for dnet_addr in -ldnet_stub" >&5
+echo "configure:59682: checking for dnet_addr in -ldnet_stub" >&5
 ac_lib_var=`echo dnet_stub'_'dnet_addr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -59658,7 +59686,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldnet_stub  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 59662 "configure"
+#line 59690 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -59669,7 +59697,7 @@
 dnet_addr()
 ; return 0; }
 EOF
-if { (eval echo configure:59673: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:59701: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -59813,7 +59841,7 @@
 php_with_mysql=no
 
 echo $ac_n "checking for MySQL support""... $ac_c" 1>&6
-echo "configure:59817: checking for MySQL support" >&5
+echo "configure:59845: checking for MySQL support" >&5
 # Check whether --with-mysql or --without-mysql was given.
 if test "${with_mysql+set}" = set; then
   withval="$with_mysql"
@@ -59860,7 +59888,7 @@
 php_with_mysql_sock=no
 
 echo $ac_n "checking for specified location of the MySQL UNIX socket""... $ac_c" 1>&6
-echo "configure:59864: checking for specified location of the MySQL UNIX socket" >&5
+echo "configure:59892: checking for specified location of the MySQL UNIX socket" >&5
 # Check whether --with-mysql-sock or --without-mysql-sock was given.
 if test "${with_mysql_sock+set}" = set; then
   withval="$with_mysql_sock"
@@ -59887,7 +59915,7 @@
 php_with_zlib_dir=no
 
 echo $ac_n "checking for the location of libz""... $ac_c" 1>&6
-echo "configure:59891: checking for the location of libz" >&5
+echo "configure:59919: checking for the location of libz" >&5
 # Check whether --with-zlib-dir or --without-zlib-dir was given.
 if test "${with_zlib_dir+set}" = set; then
   withval="$with_zlib_dir"
@@ -59910,55 +59938,10 @@
 
 fi
 
+if test "$PHP_MYSQL" = "mysqlnd"; then
+    PHP_MYSQLND_ENABLED=yes
 
-if test "$PHP_MYSQL" != "no"; then
-  cat >> confdefs.h <<\EOF
-#define HAVE_MYSQL 1
-EOF
-
-
-  echo $ac_n "checking for MySQL UNIX socket location""... $ac_c" 1>&6
-echo "configure:59922: checking for MySQL UNIX socket location" >&5
-  if test "$PHP_MYSQL_SOCK" != "no" && test "$PHP_MYSQL_SOCK" != "yes"; then
-    MYSQL_SOCK=$PHP_MYSQL_SOCK
-    cat >> confdefs.h <<EOF
-#define MYSQL_UNIX_ADDR "$MYSQL_SOCK"
-EOF
-
-    echo "$ac_t""$MYSQL_SOCK" 1>&6
-  elif test "$PHP_MYSQL" = "yes" || test "$PHP_MYSQL_SOCK" = "yes"; then
-    
-  for i in  \
-    /var/run/mysqld/mysqld.sock \
-    /var/tmp/mysql.sock \
-    /var/run/mysql/mysql.sock \
-    /var/lib/mysql/mysql.sock \
-    /var/mysql/mysql.sock \
-    /usr/local/mysql/var/mysql.sock \
-    /Private/tmp/mysql.sock \
-    /private/tmp/mysql.sock \
-    /tmp/mysql.sock \
-  ; do
-    if test -r $i; then
-      MYSQL_SOCK=$i
-      break 2
-    fi
-  done
-
-  if test -n "$MYSQL_SOCK"; then
-    cat >> confdefs.h <<EOF
-#define MYSQL_UNIX_ADDR "$MYSQL_SOCK"
-EOF
-
-    echo "$ac_t""$MYSQL_SOCK" 1>&6
-  else
-    echo "$ac_t""no" 1>&6
-  fi
-
-  else
-    echo "$ac_t""no" 1>&6
-  fi
-
+elif test "$PHP_MYSQL" != "no"; then
   MYSQL_DIR=
   MYSQL_INC_DIR=
 
@@ -60007,6 +59990,29 @@
   done
 
   if test -z "$MYSQL_LIB_DIR"; then
+    
+  str="$MYSQL_DIR/lib/x86_64-linux-gnu/lib$MYSQL_LIBNAME.*"
+  for j in `echo $str`; do
+    if test -r $j; then
+      MYSQL_LIB_DIR=$MYSQL_DIR/lib/x86_64-linux-gnu
+      break 2
+    fi
+  done
+
+  fi
+  if test -z "$MYSQL_LIB_DIR"; then
+    
+  str="$MYSQL_DIR/lib/i386-linux-gnu/lib$MYSQL_LIBNAME.*"
+  for j in `echo $str`; do
+    if test -r $j; then
+      MYSQL_LIB_DIR=$MYSQL_DIR/lib/i386-linux-gnu
+      break 2
+    fi
+  done
+
+  fi
+
+  if test -z "$MYSQL_LIB_DIR"; then
     { echo "configure: error: Cannot find lib$MYSQL_LIBNAME under $MYSQL_DIR.
 Note that the MySQL client library is not bundled anymore!" 1>&2; exit 1; }
   fi
@@ -60109,7 +60115,7 @@
   done
 
   echo $ac_n "checking for mysql_close in -l$MYSQL_LIBNAME""... $ac_c" 1>&6
-echo "configure:60113: checking for mysql_close in -l$MYSQL_LIBNAME" >&5
+echo "configure:60119: checking for mysql_close in -l$MYSQL_LIBNAME" >&5
 ac_lib_var=`echo $MYSQL_LIBNAME'_'mysql_close | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -60117,7 +60123,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$MYSQL_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 60121 "configure"
+#line 60127 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -60128,7 +60134,7 @@
 mysql_close()
 ; return 0; }
 EOF
-if { (eval echo configure:60132: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:60138: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -60351,7 +60357,7 @@
   done
 
   echo $ac_n "checking for mysql_error in -l$MYSQL_LIBNAME""... $ac_c" 1>&6
-echo "configure:60355: checking for mysql_error in -l$MYSQL_LIBNAME" >&5
+echo "configure:60361: checking for mysql_error in -l$MYSQL_LIBNAME" >&5
 ac_lib_var=`echo $MYSQL_LIBNAME'_'mysql_error | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -60359,7 +60365,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$MYSQL_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 60363 "configure"
+#line 60369 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -60370,7 +60376,7 @@
 mysql_error()
 ; return 0; }
 EOF
-if { (eval echo configure:60374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:60380: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -60525,7 +60531,7 @@
   done
 
   echo $ac_n "checking for mysql_errno in -l$MYSQL_LIBNAME""... $ac_c" 1>&6
-echo "configure:60529: checking for mysql_errno in -l$MYSQL_LIBNAME" >&5
+echo "configure:60535: checking for mysql_errno in -l$MYSQL_LIBNAME" >&5
 ac_lib_var=`echo $MYSQL_LIBNAME'_'mysql_errno | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -60533,7 +60539,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$MYSQL_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 60537 "configure"
+#line 60543 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -60544,7 +60550,7 @@
 mysql_errno()
 ; return 0; }
 EOF
-if { (eval echo configure:60548: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:60554: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -60712,7 +60718,78 @@
   fi
 
 
+  MYSQL_MODULE_TYPE=external
+  MYSQL_LIBS="-L$MYSQL_LIB_DIR -l$MYSQL_LIBNAME $MYSQL_LIBS"
+  MYSQL_INCLUDE=-I$MYSQL_INC_DIR
+ 
   
+  
+  PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_MODULE_TYPE"
+
+  
+
+  
+  
+  PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_LIBS"
+
+  
+
+  
+  
+  PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_INCLUDE"
+
+  
+
+fi
+
+if test "$PHP_MYSQL" != "no"; then
+  echo $ac_n "checking for MySQL UNIX socket location""... $ac_c" 1>&6
+echo "configure:60748: checking for MySQL UNIX socket location" >&5
+  if test "$PHP_MYSQL_SOCK" != "no" && test "$PHP_MYSQL_SOCK" != "yes"; then
+    MYSQL_SOCK=$PHP_MYSQL_SOCK
+    cat >> confdefs.h <<EOF
+#define PHP_MYSQL_UNIX_SOCK_ADDR "$MYSQL_SOCK"
+EOF
+
+    echo "$ac_t""$MYSQL_SOCK" 1>&6
+  elif test "$PHP_MYSQL" = "yes" || test "$PHP_MYSQL_SOCK" = "yes"; then
+    
+  for i in  \
+    /var/run/mysqld/mysqld.sock \
+    /var/tmp/mysql.sock \
+    /var/run/mysql/mysql.sock \
+    /var/lib/mysql/mysql.sock \
+    /var/mysql/mysql.sock \
+    /usr/local/mysql/var/mysql.sock \
+    /Private/tmp/mysql.sock \
+    /private/tmp/mysql.sock \
+    /tmp/mysql.sock \
+  ; do
+    if test -r $i; then
+      MYSQL_SOCK=$i
+      break 2
+    fi
+  done
+
+  if test -n "$MYSQL_SOCK"; then
+    cat >> confdefs.h <<EOF
+#define PHP_MYSQL_UNIX_SOCK_ADDR "$MYSQL_SOCK"
+EOF
+
+    echo "$ac_t""$MYSQL_SOCK" 1>&6
+  else
+    echo "$ac_t""no" 1>&6
+  fi
+
+  else
+    echo "$ac_t""no" 1>&6
+  fi
+
+  cat >> confdefs.h <<\EOF
+#define HAVE_MYSQL 1
+EOF
+
+  
   ext_builddir=ext/mysql
   ext_srcdir=$abs_srcdir/ext/mysql
 
@@ -61004,32 +61081,35 @@
 
   fi
 
-
-  MYSQL_MODULE_TYPE=external
-  MYSQL_LIBS="-L$MYSQL_LIB_DIR -l$MYSQL_LIBNAME $MYSQL_LIBS"
-  MYSQL_INCLUDE=-I$MYSQL_INC_DIR
- 
   
   PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_SHARED_LIBADD"
 
-  
-  
-  PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_MODULE_TYPE"
 
+  if test "$PHP_MYSQL" = "mysqlnd"; then
+    
+  am_i_shared=$PHP_MYSQL_SHARED
+  is_it_shared=$PHP_MYSQLND_SHARED
+  is_it_enabled=$PHP_MYSQLND
+  if test "$am_i_shared" = "no" && test "$is_it_shared" = "yes" ; then
+    { echo "configure: error: 
+You've configured extension mysql to build statically, but it
+depends on extension mysqlnd, which you've configured to build shared.
+You either need to build mysql shared or build mysqlnd statically for the
+build to be successful.
+" 1>&2; exit 1; }
+  fi
+  if test "x$is_it_enabled" = "xno" && test "x" != "xtrue"; then
+    { echo "configure: error: 
+You've configured extension mysql, which depends on extension mysqlnd,
+but you've either not enabled mysqlnd, or have disabled it.
+" 1>&2; exit 1; }
+  fi
   
+    cat >> confdefs.h <<\EOF
+#define MYSQL_USE_MYSQLND 1
+EOF
 
-  
-  
-  PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_LIBS"
-
-  
-
-  
-  
-  PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQL_INCLUDE"
-
-  
-
+  fi
 fi
 
 
@@ -61037,7 +61117,7 @@
 php_with_mysqli=no
 
 echo $ac_n "checking for MySQLi support""... $ac_c" 1>&6
-echo "configure:61041: checking for MySQLi support" >&5
+echo "configure:61121: checking for MySQLi support" >&5
 # Check whether --with-mysqli or --without-mysqli was given.
 if test "${with_mysqli+set}" = set; then
   withval="$with_mysqli"
@@ -61084,7 +61164,7 @@
 php_enable_embedded_mysqli=no
 
 echo $ac_n "checking whether to enable embedded MySQLi support""... $ac_c" 1>&6
-echo "configure:61088: checking whether to enable embedded MySQLi support" >&5
+echo "configure:61168: checking whether to enable embedded MySQLi support" >&5
 # Check whether --enable-embedded_mysqli or --disable-embedded_mysqli was given.
 if test "${enable_embedded_mysqli+set}" = set; then
   enableval="$enable_embedded_mysqli"
@@ -61106,8 +61186,10 @@
 
 
 
-if test "$PHP_MYSQLI" != "no"; then
+if test "$PHP_MYSQLI" = "mysqlnd"; then
+    PHP_MYSQLND_ENABLED=yes
 
+elif test "$PHP_MYSQLI" != "no"; then
 
   if test "$PHP_MYSQLI" = "yes"; then
     MYSQL_CONFIG=`$php_shtool path mysql_config`
@@ -61122,6 +61204,7 @@
 EOF
 
     MYSQL_LIB_CFG='--libmysqld-libs'
+        mysqli_extra_sources="mysqli_embedded.c"
   elif test "$enable_maintainer_zts" = "yes"; then
     MYSQL_LIB_CFG='--libs_r'
     MYSQL_LIB_NAME='mysqlclient_r'
@@ -61235,7 +61318,7 @@
   done
 
   echo $ac_n "checking for mysql_set_server_option in -l$MYSQL_LIB_NAME""... $ac_c" 1>&6
-echo "configure:61239: checking for mysql_set_server_option in -l$MYSQL_LIB_NAME" >&5
+echo "configure:61322: checking for mysql_set_server_option in -l$MYSQL_LIB_NAME" >&5
 ac_lib_var=`echo $MYSQL_LIB_NAME'_'mysql_set_server_option | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -61243,7 +61326,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$MYSQL_LIB_NAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 61247 "configure"
+#line 61330 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -61254,7 +61337,7 @@
 mysql_set_server_option()
 ; return 0; }
 EOF
-if { (eval echo configure:61258: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:61341: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -61501,27 +61584,27 @@
     esac
   done
 
-  echo $ac_n "checking for mysql_stmt_field_count in -l$MYSQL_LIB_NAME""... $ac_c" 1>&6
-echo "configure:61506: checking for mysql_stmt_field_count in -l$MYSQL_LIB_NAME" >&5
-ac_lib_var=`echo $MYSQL_LIB_NAME'_'mysql_stmt_field_count | sed 'y%./+-%__p_%'`
+  echo $ac_n "checking for mysql_set_character_set in -l$MYSQL_LIB_NAME""... $ac_c" 1>&6
+echo "configure:61589: checking for mysql_set_character_set in -l$MYSQL_LIB_NAME" >&5
+ac_lib_var=`echo $MYSQL_LIB_NAME'_'mysql_set_character_set | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-l$MYSQL_LIB_NAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 61514 "configure"
+#line 61597 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
-char mysql_stmt_field_count();
+char mysql_set_character_set();
 
 int main() {
-mysql_stmt_field_count()
+mysql_set_character_set()
 ; return 0; }
 EOF
-if { (eval echo configure:61525: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:61608: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -61546,10 +61629,10 @@
 
     LDFLAGS=$save_old_LDFLAGS
     ext_shared=$save_ext_shared
-    unset ac_cv_lib_$MYSQL_LIB_NAME_mysql_stmt_field_count
+    unset ac_cv_lib_$MYSQL_LIB_NAME_mysql_set_character_set
     
-		{ echo "configure: error: MySQLI doesn't support versions < 4.1.3 (for MySQL 4.1.x) and < 5.0.1 for (MySQL 5.0.x) anymore. Please update your libraries." 1>&2; exit 1; }
-	
+      { echo "configure: error: MySQLI doesn't support versions < 4.1.13 (for MySQL 4.1.x) and < 5.0.7 for (MySQL 5.0.x) anymore. Please update your libraries." 1>&2; exit 1; }
+    
   
 fi
 
@@ -61567,8 +61650,166 @@
   
 fi
 
+        
+  save_old_LDFLAGS=$LDFLAGS
+  ac_stuff="
+    $MYSQLI_LIBLINE
+  "
+  
+  save_ext_shared=$ext_shared
+  ext_shared=yes
+  
+  for ac_i in $ac_stuff; do
+    case $ac_i in
+    -pthread)
+      if test "$ext_shared" = "yes"; then
+        LDFLAGS="$LDFLAGS -pthread"
+      else
+        
+  
+  unique=`echo $ac_i|$SED 's/[^a-zA-Z0-9]/_/g'`
+  
+  cmd="echo $ac_n \"\$EXTRA_LDFLAGS$unique$ac_c\""
+  if test -n "$unique" && test "`eval $cmd`" = "" ; then
+    eval "EXTRA_LDFLAGS$unique=set"
+    EXTRA_LDFLAGS="$EXTRA_LDFLAGS $ac_i"
+  fi
 
+      fi
+    ;;
+    -l*)
+      ac_ii=`echo $ac_i|cut -c 3-`
+      
   
+  case $ac_ii in
+  c|c_r|pthread*) ;;
+  *) 
+    if test "$ext_shared" = "yes"; then
+        LDFLAGS="$LDFLAGS -l$ac_ii" 
+    else
+      
+  
+  case $ac_ii in
+  c|c_r|pthread*) ;;
+  *) 
+      LIBS="$LIBS -l$ac_ii" 
+   ;;
+  esac
+
+
+    fi
+   ;;
+  esac
+
+
+    ;;
+    -L*)
+      ac_ii=`echo $ac_i|cut -c 3-`
+      
+  if test "$ac_ii" != "/usr/$PHP_LIBDIR" && test "$ac_ii" != "/usr/lib"; then
+    
+  if test -z "$ac_ii" || echo "$ac_ii" | grep '^/' >/dev/null ; then
+    ai_p=$ac_ii
+  else
+    
+    ep_dir="`echo $ac_ii|$SED 's%/*[^/][^/]*/*$%%'`"
+    
+    ep_realdir="`(cd \"$ep_dir\" && pwd)`"
+    ai_p="$ep_realdir/`basename \"$ac_ii\"`"
+  fi
+
+    
+      if test "$ext_shared" = "yes"; then
+        LDFLAGS="-L$ai_p $LDFLAGS"
+        test -n "$ld_runpath_switch" && LDFLAGS="$ld_runpath_switch$ai_p $LDFLAGS"
+      else
+        
+  
+  
+  unique=`echo $ai_p|$SED 's/[^a-zA-Z0-9]/_/g'`
+  
+  cmd="echo $ac_n \"\$LIBPATH$unique$ac_c\""
+  if test -n "$unique" && test "`eval $cmd`" = "" ; then
+    eval "LIBPATH$unique=set"
+    
+    test -n "$ld_runpath_switch" && LDFLAGS="$LDFLAGS $ld_runpath_switch$ai_p"
+    LDFLAGS="$LDFLAGS -L$ai_p"
+    PHP_RPATHS="$PHP_RPATHS $ai_p"
+  
+  fi
+
+
+      fi
+    
+  fi
+
+    ;;
+    esac
+  done
+
+  echo $ac_n "checking for mysql_stmt_next_result in -l$MYSQL_LIB_NAME""... $ac_c" 1>&6
+echo "configure:61752: checking for mysql_stmt_next_result in -l$MYSQL_LIB_NAME" >&5
+ac_lib_var=`echo $MYSQL_LIB_NAME'_'mysql_stmt_next_result | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-l$MYSQL_LIB_NAME  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 61760 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char mysql_stmt_next_result();
+
+int main() {
+mysql_stmt_next_result()
+; return 0; }
+EOF
+if { (eval echo configure:61771: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  
+    LDFLAGS=$save_old_LDFLAGS
+    ext_shared=$save_ext_shared
+    
+    cat >> confdefs.h <<\EOF
+#define HAVE_STMT_NEXT_RESULT 1
+EOF
+
+  
+  
+else
+  echo "$ac_t""no" 1>&6
+
+    LDFLAGS=$save_old_LDFLAGS
+    ext_shared=$save_ext_shared
+    unset ac_cv_lib_$MYSQL_LIB_NAME_mysql_stmt_next_result
+    
+  
+  
+fi
+
+fi
+
+if test "$PHP_MYSQLI" != "no"; then
+  mysqli_sources="mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c \
+                  mysqli_fe.c mysqli_report.c mysqli_driver.c mysqli_warning.c \
+                  mysqli_exception.c $mysqli_extra_sources"
+  
   ext_builddir=ext/mysqli
   ext_srcdir=$abs_srcdir/ext/mysqli
 
@@ -61596,7 +61837,7 @@
 
 
   old_IFS=$IFS
-  for ac_src in mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c mysqli_fe.c mysqli_report.c mysqli_repl.c mysqli_driver.c mysqli_warning.c mysqli_exception.c mysqli_embedded.c; do
+  for ac_src in $mysqli_sources; do
   
       IFS=.
       set $ac_src
@@ -61645,7 +61886,7 @@
 
 
   old_IFS=$IFS
-  for ac_src in mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c mysqli_fe.c mysqli_report.c mysqli_repl.c mysqli_driver.c mysqli_warning.c mysqli_exception.c mysqli_embedded.c; do
+  for ac_src in $mysqli_sources; do
   
       IFS=.
       set $ac_src
@@ -61774,7 +62015,7 @@
 
 
   old_IFS=$IFS
-  for ac_src in mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c mysqli_fe.c mysqli_report.c mysqli_repl.c mysqli_driver.c mysqli_warning.c mysqli_exception.c mysqli_embedded.c; do
+  for ac_src in $mysqli_sources; do
   
       IFS=.
       set $ac_src
@@ -61820,7 +62061,7 @@
 
 
   old_IFS=$IFS
-  for ac_src in mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c mysqli_fe.c mysqli_report.c mysqli_repl.c mysqli_driver.c mysqli_warning.c mysqli_exception.c mysqli_embedded.c; do
+  for ac_src in $mysqli_sources; do
   
       IFS=.
       set $ac_src
@@ -61863,6 +62104,50 @@
   
   PHP_VAR_SUBST="$PHP_VAR_SUBST MYSQLI_SHARED_LIBADD"
 
+  
+  
+    for header_file in ext/mysqli/php_mysqli_structs.h; do
+      
+  
+  unique=`echo $header_file|$SED 's/[^a-zA-Z0-9]/_/g'`
+  
+  cmd="echo $ac_n \"\$INSTALLHEADERS$unique$ac_c\""
+  if test -n "$unique" && test "`eval $cmd`" = "" ; then
+    eval "INSTALLHEADERS$unique=set"
+    
+        INSTALL_HEADERS="$INSTALL_HEADERS $header_file"
+      
+  fi
+
+    done 
+  
+
+
+  if test "$PHP_MYSQLI" = "mysqlnd"; then
+    
+  am_i_shared=$PHP_MYSQLI_SHARED
+  is_it_shared=$PHP_MYSQLND_SHARED
+  is_it_enabled=$PHP_MYSQLND
+  if test "$am_i_shared" = "no" && test "$is_it_shared" = "yes" ; then
+    { echo "configure: error: 
+You've configured extension mysqli to build statically, but it
+depends on extension mysqlnd, which you've configured to build shared.
+You either need to build mysqli shared or build mysqlnd statically for the
+build to be successful.
+" 1>&2; exit 1; }
+  fi
+  if test "x$is_it_enabled" = "xno" && test "x" != "xtrue"; then
+    { echo "configure: error: 
+You've configured extension mysqli, which depends on extension mysqlnd,
+but you've either not enabled mysqlnd, or have disabled it.
+" 1>&2; exit 1; }
+  fi
+  
+    cat >> confdefs.h <<\EOF
+#define MYSQLI_USE_MYSQLND 1
+EOF
+
+  fi
 fi
 
 
@@ -61870,7 +62155,7 @@
 php_with_ncurses=no
 
 echo $ac_n "checking for ncurses support""... $ac_c" 1>&6
-echo "configure:61874: checking for ncurses support" >&5
+echo "configure:62159: checking for ncurses support" >&5
 # Check whether --with-ncurses or --without-ncurses was given.
 if test "${with_ncurses+set}" = set; then
   withval="$with_ncurses"
@@ -62077,7 +62362,7 @@
   done
 
   echo $ac_n "checking for $LIBSYMBOL in -l$LIBNAME""... $ac_c" 1>&6
-echo "configure:62081: checking for $LIBSYMBOL in -l$LIBNAME" >&5
+echo "configure:62366: checking for $LIBSYMBOL in -l$LIBNAME" >&5
 ac_lib_var=`echo $LIBNAME'_'$LIBSYMBOL | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -62085,7 +62370,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 62089 "configure"
+#line 62374 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -62096,7 +62381,7 @@
 $LIBSYMBOL()
 ; return 0; }
 EOF
-if { (eval echo configure:62100: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:62385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -62315,7 +62600,7 @@
   done
 
   echo $ac_n "checking for new_panel in -lpanel""... $ac_c" 1>&6
-echo "configure:62319: checking for new_panel in -lpanel" >&5
+echo "configure:62604: checking for new_panel in -lpanel" >&5
 ac_lib_var=`echo panel'_'new_panel | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -62323,7 +62608,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpanel  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 62327 "configure"
+#line 62612 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -62334,7 +62619,7 @@
 new_panel()
 ; return 0; }
 EOF
-if { (eval echo configure:62338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:62623: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -62482,7 +62767,7 @@
 
  
    echo $ac_n "checking for color_set in -l$LIBNAME""... $ac_c" 1>&6
-echo "configure:62486: checking for color_set in -l$LIBNAME" >&5
+echo "configure:62771: checking for color_set in -l$LIBNAME" >&5
 ac_lib_var=`echo $LIBNAME'_'color_set | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -62490,7 +62775,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 62494 "configure"
+#line 62779 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -62501,7 +62786,7 @@
 color_set()
 ; return 0; }
 EOF
-if { (eval echo configure:62505: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:62790: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -62525,7 +62810,7 @@
 fi
 
    echo $ac_n "checking for slk_color in -l$LIBNAME""... $ac_c" 1>&6
-echo "configure:62529: checking for slk_color in -l$LIBNAME" >&5
+echo "configure:62814: checking for slk_color in -l$LIBNAME" >&5
 ac_lib_var=`echo $LIBNAME'_'slk_color | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -62533,7 +62818,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 62537 "configure"
+#line 62822 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -62544,7 +62829,7 @@
 slk_color()
 ; return 0; }
 EOF
-if { (eval echo configure:62548: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:62833: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -62568,7 +62853,7 @@
 fi
 
    echo $ac_n "checking for assume_default_colors in -l$LIBNAME""... $ac_c" 1>&6
-echo "configure:62572: checking for assume_default_colors in -l$LIBNAME" >&5
+echo "configure:62857: checking for assume_default_colors in -l$LIBNAME" >&5
 ac_lib_var=`echo $LIBNAME'_'assume_default_colors | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -62576,7 +62861,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 62580 "configure"
+#line 62865 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -62587,7 +62872,7 @@
 assume_default_colors()
 ; return 0; }
 EOF
-if { (eval echo configure:62591: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:62876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -62611,7 +62896,7 @@
 fi
 
    echo $ac_n "checking for use_extended_names in -l$LIBNAME""... $ac_c" 1>&6
-echo "configure:62615: checking for use_extended_names in -l$LIBNAME" >&5
+echo "configure:62900: checking for use_extended_names in -l$LIBNAME" >&5
 ac_lib_var=`echo $LIBNAME'_'use_extended_names | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -62619,7 +62904,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 62623 "configure"
+#line 62908 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -62630,7 +62915,7 @@
 use_extended_names()
 ; return 0; }
 EOF
-if { (eval echo configure:62634: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:62919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -62973,7 +63258,7 @@
 php_with_oci8=no
 
 echo $ac_n "checking for Oracle (OCI8) support""... $ac_c" 1>&6
-echo "configure:62977: checking for Oracle (OCI8) support" >&5
+echo "configure:63262: checking for Oracle (OCI8) support" >&5
 # Check whether --with-oci8 or --without-oci8 was given.
 if test "${with_oci8+set}" = set; then
   withval="$with_oci8"
@@ -63018,7 +63303,7 @@
 
 if test "$PHP_OCI8" != "no"; then 
   echo $ac_n "checking PHP version""... $ac_c" 1>&6
-echo "configure:63022: checking PHP version" >&5
+echo "configure:63307: checking PHP version" >&5
 
   tmp_version=$PHP_VERSION
   if test -z "$tmp_version"; then
@@ -63074,7 +63359,7 @@
 if test "$PHP_OCI8" != "no" && test "$PHP_OCI8_INSTANT_CLIENT" = "no"; then
 
   echo $ac_n "checking Oracle Install Directory""... $ac_c" 1>&6
-echo "configure:63078: checking Oracle Install Directory" >&5
+echo "configure:63363: checking Oracle Install Directory" >&5
   if test "$PHP_OCI8" = "yes"; then
     OCI8_DIR=$ORACLE_HOME
   else
@@ -63084,7 +63369,7 @@
 
   
   echo $ac_n "checking size of long int""... $ac_c" 1>&6
-echo "configure:63088: checking size of long int" >&5
+echo "configure:63373: checking size of long int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -63092,18 +63377,19 @@
   ac_cv_sizeof_long_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 63096 "configure"
+#line 63381 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:63107: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:63393: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_int=`cat conftestval`
 else
@@ -63123,7 +63409,7 @@
 
 
   echo $ac_n "checking if we're on a 64-bit platform""... $ac_c" 1>&6
-echo "configure:63127: checking if we're on a 64-bit platform" >&5
+echo "configure:63413: checking if we're on a 64-bit platform" >&5
   if test "$ac_cv_sizeof_long_int" = "4" ; then
     echo "$ac_t""no" 1>&6
     TMP_OCI8_LIB_DIR=lib32 
@@ -63133,7 +63419,7 @@
   fi
 
   echo $ac_n "checking OCI8 libraries dir""... $ac_c" 1>&6
-echo "configure:63137: checking OCI8 libraries dir" >&5
+echo "configure:63423: checking OCI8 libraries dir" >&5
   if test -d "$OCI8_DIR/lib" && test ! -d "$OCI8_DIR/lib32"; then
     OCI8_LIB_DIR=lib
   elif test ! -d "$OCI8_DIR/lib" && test -d "$OCI8_DIR/lib32"; then
@@ -63467,7 +63753,7 @@
 
   
   echo $ac_n "checking Oracle version""... $ac_c" 1>&6
-echo "configure:63471: checking Oracle version" >&5
+echo "configure:63757: checking Oracle version" >&5
   if test -s "$OCI8_DIR/orainst/unix.rgs"; then
     OCI8_VERSION=`grep '"ocommon"' $OCI8_DIR/orainst/unix.rgs | $PHP_OCI8_SED 's/  */:/g' | cut -d: -f 6 | cut -c 2-4`
     test -z "$OCI8_VERSION" && OCI8_VERSION=7.3
@@ -63982,7 +64268,7 @@
   done
 
   echo $ac_n "checking for OCIEnvCreate in -lclntsh""... $ac_c" 1>&6
-echo "configure:63986: checking for OCIEnvCreate in -lclntsh" >&5
+echo "configure:64272: checking for OCIEnvCreate in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIEnvCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -63990,7 +64276,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 63994 "configure"
+#line 64280 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -64001,7 +64287,7 @@
 OCIEnvCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:64005: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:64291: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -64135,7 +64421,7 @@
   done
 
   echo $ac_n "checking for OCIStmtPrepare2 in -lclntsh""... $ac_c" 1>&6
-echo "configure:64139: checking for OCIStmtPrepare2 in -lclntsh" >&5
+echo "configure:64425: checking for OCIStmtPrepare2 in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIStmtPrepare2 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -64143,7 +64429,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 64147 "configure"
+#line 64433 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -64154,7 +64440,7 @@
 OCIStmtPrepare2()
 ; return 0; }
 EOF
-if { (eval echo configure:64158: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:64444: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -64352,7 +64638,7 @@
   done
 
   echo $ac_n "checking for OCIEnvCreate in -lclntsh""... $ac_c" 1>&6
-echo "configure:64356: checking for OCIEnvCreate in -lclntsh" >&5
+echo "configure:64642: checking for OCIEnvCreate in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIEnvCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -64360,7 +64646,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 64364 "configure"
+#line 64650 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -64371,7 +64657,7 @@
 OCIEnvCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:64375: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:64661: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -64505,7 +64791,7 @@
   done
 
   echo $ac_n "checking for OCIStmtPrepare2 in -lclntsh""... $ac_c" 1>&6
-echo "configure:64509: checking for OCIStmtPrepare2 in -lclntsh" >&5
+echo "configure:64795: checking for OCIStmtPrepare2 in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIStmtPrepare2 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -64513,7 +64799,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 64517 "configure"
+#line 64803 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -64524,7 +64810,7 @@
 OCIStmtPrepare2()
 ; return 0; }
 EOF
-if { (eval echo configure:64528: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:64814: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -64564,7 +64850,7 @@
   old_CPPFLAGS=$CPPFLAGS
   CPPFLAGS=$OCI8_INCLUDES
   cat > conftest.$ac_ext <<EOF
-#line 64568 "configure"
+#line 64854 "configure"
 #include "confdefs.h"
 
 #include <oci.h>
@@ -64759,7 +65045,7 @@
   done
 
   echo $ac_n "checking for OCIEnvNlsCreate in -lclntsh""... $ac_c" 1>&6
-echo "configure:64763: checking for OCIEnvNlsCreate in -lclntsh" >&5
+echo "configure:65049: checking for OCIEnvNlsCreate in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIEnvNlsCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -64767,7 +65053,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 64771 "configure"
+#line 65057 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -64778,7 +65064,7 @@
 OCIEnvNlsCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:64782: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:65068: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -64895,7 +65181,7 @@
   done
 
   echo $ac_n "checking for OCINlsCharSetNameToId in -lclntsh""... $ac_c" 1>&6
-echo "configure:64899: checking for OCINlsCharSetNameToId in -lclntsh" >&5
+echo "configure:65185: checking for OCINlsCharSetNameToId in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCINlsCharSetNameToId | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -64903,7 +65189,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 64907 "configure"
+#line 65193 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -64914,7 +65200,7 @@
 OCINlsCharSetNameToId()
 ; return 0; }
 EOF
-if { (eval echo configure:64918: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:65204: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -65061,7 +65347,7 @@
   done
 
   echo $ac_n "checking for OCIEnvCreate in -lclntsh""... $ac_c" 1>&6
-echo "configure:65065: checking for OCIEnvCreate in -lclntsh" >&5
+echo "configure:65351: checking for OCIEnvCreate in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIEnvCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -65069,7 +65355,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 65073 "configure"
+#line 65359 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -65080,7 +65366,7 @@
 OCIEnvCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:65084: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:65370: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -65214,7 +65500,7 @@
   done
 
   echo $ac_n "checking for OCIStmtPrepare2 in -lclntsh""... $ac_c" 1>&6
-echo "configure:65218: checking for OCIStmtPrepare2 in -lclntsh" >&5
+echo "configure:65504: checking for OCIStmtPrepare2 in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIStmtPrepare2 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -65222,7 +65508,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 65226 "configure"
+#line 65512 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -65233,7 +65519,7 @@
 OCIStmtPrepare2()
 ; return 0; }
 EOF
-if { (eval echo configure:65237: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:65523: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -65367,7 +65653,7 @@
   done
 
   echo $ac_n "checking for OCILobRead2 in -lclntsh""... $ac_c" 1>&6
-echo "configure:65371: checking for OCILobRead2 in -lclntsh" >&5
+echo "configure:65657: checking for OCILobRead2 in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCILobRead2 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -65375,7 +65661,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 65379 "configure"
+#line 65665 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -65386,7 +65672,7 @@
 OCILobRead2()
 ; return 0; }
 EOF
-if { (eval echo configure:65390: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:65676: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -65618,7 +65904,7 @@
   done
 
   echo $ac_n "checking for OCILobIsTemporary in -lclntsh""... $ac_c" 1>&6
-echo "configure:65622: checking for OCILobIsTemporary in -lclntsh" >&5
+echo "configure:65908: checking for OCILobIsTemporary in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCILobIsTemporary | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -65626,7 +65912,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 65630 "configure"
+#line 65916 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -65637,7 +65923,7 @@
 OCILobIsTemporary()
 ; return 0; }
 EOF
-if { (eval echo configure:65641: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:65927: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -65767,7 +66053,7 @@
   done
 
   echo $ac_n "checking for OCILobIsTemporary in -locijdbc8""... $ac_c" 1>&6
-echo "configure:65771: checking for OCILobIsTemporary in -locijdbc8" >&5
+echo "configure:66057: checking for OCILobIsTemporary in -locijdbc8" >&5
 ac_lib_var=`echo ocijdbc8'_'OCILobIsTemporary | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -65775,7 +66061,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-locijdbc8  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 65779 "configure"
+#line 66065 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -65786,7 +66072,7 @@
 OCILobIsTemporary()
 ; return 0; }
 EOF
-if { (eval echo configure:65790: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:66076: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -65947,7 +66233,7 @@
   done
 
   echo $ac_n "checking for OCICollAssign in -lclntsh""... $ac_c" 1>&6
-echo "configure:65951: checking for OCICollAssign in -lclntsh" >&5
+echo "configure:66237: checking for OCICollAssign in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCICollAssign | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -65955,7 +66241,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 65959 "configure"
+#line 66245 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -65966,7 +66252,7 @@
 OCICollAssign()
 ; return 0; }
 EOF
-if { (eval echo configure:65970: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:66256: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -66614,7 +66900,7 @@
 elif test "$PHP_OCI8" != "no" && test "$PHP_OCI8_INSTANT_CLIENT" != "no"; then
 
   echo $ac_n "checking size of long int""... $ac_c" 1>&6
-echo "configure:66618: checking size of long int" >&5
+echo "configure:66904: checking size of long int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -66622,18 +66908,19 @@
   ac_cv_sizeof_long_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 66626 "configure"
+#line 66912 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:66637: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:66924: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_int=`cat conftestval`
 else
@@ -66658,7 +66945,7 @@
   fi
 
   echo $ac_n "checking Oracle Instant Client directory""... $ac_c" 1>&6
-echo "configure:66662: checking Oracle Instant Client directory" >&5
+echo "configure:66949: checking Oracle Instant Client directory" >&5
   if test "$PHP_OCI8_INSTANT_CLIENT" = "yes"; then
     PHP_OCI8_INSTANT_CLIENT=`ls -d /usr/lib/oracle/*/client${LIBDIR_SUFFIX}/lib 2> /dev/null | tail -1`
     if test -z "$PHP_OCI8_INSTANT_CLIENT"; then
@@ -66670,7 +66957,7 @@
   OCI8_DIR=$PHP_OCI8_INSTANT_CLIENT
 
   echo $ac_n "checking Oracle Instant Client SDK header directory""... $ac_c" 1>&6
-echo "configure:66674: checking Oracle Instant Client SDK header directory" >&5
+echo "configure:66961: checking Oracle Instant Client SDK header directory" >&5
 
   OCISDKRPMINC=`echo "$PHP_OCI8_INSTANT_CLIENT" | $PHP_OCI8_SED -e 's!^/usr/lib/oracle/\(.*\)/client\('${LIBDIR_SUFFIX}'\)*/lib/*$!/usr/include/oracle/\1/client\2!'`
 
@@ -66879,7 +67166,7 @@
 
   
   echo $ac_n "checking Oracle Instant Client version""... $ac_c" 1>&6
-echo "configure:66883: checking Oracle Instant Client version" >&5
+echo "configure:67170: checking Oracle Instant Client version" >&5
   if test -f $PHP_OCI8_INSTANT_CLIENT/libnnz11.$SHLIB_SUFFIX_NAME; then
     if test -f $PHP_OCI8_INSTANT_CLIENT/libclntsh.$SHLIB_SUFFIX_NAME.11.1; then
       if test ! -f $PHP_OCI8_INSTANT_CLIENT/libclntsh.$SHLIB_SUFFIX_NAME; then
@@ -67384,7 +67671,7 @@
 
   if test "$PHP_ADABAS" != "no"; then
     echo $ac_n "checking for Adabas support""... $ac_c" 1>&6
-echo "configure:67388: checking for Adabas support" >&5
+echo "configure:67675: checking for Adabas support" >&5
     if test "$PHP_ADABAS" = "yes"; then
       PHP_ADABAS=/usr/local
     fi
@@ -67590,7 +67877,7 @@
 
   if test "$PHP_SAPDB" != "no"; then
     echo $ac_n "checking for SAP DB support""... $ac_c" 1>&6
-echo "configure:67594: checking for SAP DB support" >&5
+echo "configure:67881: checking for SAP DB support" >&5
     if test "$PHP_SAPDB" = "yes"; then
       PHP_SAPDB=/usr/local
     fi
@@ -67726,7 +68013,7 @@
 
   if test "$PHP_SOLID" != "no"; then
     echo $ac_n "checking for Solid support""... $ac_c" 1>&6
-echo "configure:67730: checking for Solid support" >&5
+echo "configure:68017: checking for Solid support" >&5
     if test "$PHP_SOLID" = "yes"; then
       PHP_SOLID=/usr/local/solid
     fi
@@ -67753,7 +68040,7 @@
     echo "$ac_t""$ext_output" 1>&6
     
   echo $ac_n "checking Solid library file""... $ac_c" 1>&6
-echo "configure:67757: checking Solid library file" >&5  
+echo "configure:68044: checking Solid library file" >&5  
   ac_solid_uname_r=`uname -r 2>/dev/null`
   ac_solid_uname_s=`uname -s 2>/dev/null`
   case $ac_solid_uname_s in
@@ -67877,7 +68164,7 @@
 
   if test "$PHP_IBM_DB2" != "no"; then
     echo $ac_n "checking for IBM DB2 support""... $ac_c" 1>&6
-echo "configure:67881: checking for IBM DB2 support" >&5
+echo "configure:68168: checking for IBM DB2 support" >&5
     if test "$PHP_IBM_DB2" = "yes"; then
       ODBC_INCDIR=/home/db2inst1/sqllib/include
       ODBC_LIBDIR=/home/db2inst1/sqllib/lib
@@ -67908,7 +68195,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 67912 "configure"
+#line 68199 "configure"
 #include "confdefs.h"
 
     
@@ -67919,7 +68206,7 @@
     }
   
 EOF
-if { (eval echo configure:67923: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:68210: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -68003,7 +68290,7 @@
 
   if test "$PHP_ODBCROUTER" != "no"; then
     echo $ac_n "checking for ODBCRouter.com support""... $ac_c" 1>&6
-echo "configure:68007: checking for ODBCRouter.com support" >&5
+echo "configure:68294: checking for ODBCRouter.com support" >&5
     if test "$PHP_ODBCROUTER" = "yes"; then
       PHP_ODBCROUTER=/usr
     fi
@@ -68070,7 +68357,7 @@
 
   if test "$PHP_EMPRESS" != "no"; then
     echo $ac_n "checking for Empress support""... $ac_c" 1>&6
-echo "configure:68074: checking for Empress support" >&5
+echo "configure:68361: checking for Empress support" >&5
     if test "$PHP_EMPRESS" = "yes"; then
       ODBC_INCDIR=$EMPRESSPATH/include/odbc
       ODBC_LIBDIR=$EMPRESSPATH/shlib
@@ -68088,7 +68375,7 @@
     echo "$ac_t""$ext_output" 1>&6
     
   echo $ac_n "checking Empress library file""... $ac_c" 1>&6
-echo "configure:68092: checking Empress library file" >&5
+echo "configure:68379: checking Empress library file" >&5
   ODBC_LIBS=`echo $ODBC_LIBDIR/libempodbccl.so | cut -d' ' -f1`
   if test ! -f $ODBC_LIBS; then
     ODBC_LIBS=`echo $ODBC_LIBDIR/libempodbccl.so | cut -d' ' -f1`
@@ -68147,7 +68434,7 @@
 
   if test "$PHP_EMPRESS_BCS" != "no"; then
     echo $ac_n "checking for Empress local access support""... $ac_c" 1>&6
-echo "configure:68151: checking for Empress local access support" >&5
+echo "configure:68438: checking for Empress local access support" >&5
     if test "$PHP_EMPRESS_BCS" = "yes"; then
       ODBC_INCDIR=$EMPRESSPATH/include/odbc
       ODBC_LIBDIR=$EMPRESSPATH/shlib
@@ -68181,7 +68468,7 @@
     echo "$ac_t""$ext_output" 1>&6
     
   echo $ac_n "checking Empress local access library file""... $ac_c" 1>&6
-echo "configure:68185: checking Empress local access library file" >&5
+echo "configure:68472: checking Empress local access library file" >&5
   ODBCBCS_LIBS=`echo $ODBC_LIBDIR/libempodbcbcs.a | cut -d' ' -f1`
   if test ! -f $ODBCBCS_LIBS; then
     ODBCBCS_LIBS=`echo $ODBC_LIBDIR/libempodbcbcs.a | cut -d' ' -f1`
@@ -68240,7 +68527,7 @@
   
   if test "$PHP_BIRDSTEP" != "no"; then
     echo $ac_n "checking for Birdstep support""... $ac_c" 1>&6
-echo "configure:68244: checking for Birdstep support" >&5
+echo "configure:68531: checking for Birdstep support" >&5
     if test "$PHP_BIRDSTEP" = "yes"; then
         ODBC_INCDIR=/usr/local/birdstep/include
         ODBC_LIBDIR=/usr/local/birdstep/lib
@@ -68355,7 +68642,7 @@
 
   if test "$PHP_CUSTOM_ODBC" != "no"; then
     echo $ac_n "checking for a custom ODBC support""... $ac_c" 1>&6
-echo "configure:68359: checking for a custom ODBC support" >&5
+echo "configure:68646: checking for a custom ODBC support" >&5
     if test "$PHP_CUSTOM_ODBC" = "yes"; then
       PHP_CUSTOM_ODBC=/usr/local
     fi
@@ -68422,7 +68709,7 @@
 
   if test "$PHP_IODBC" != "no"; then
     echo $ac_n "checking for iODBC support""... $ac_c" 1>&6
-echo "configure:68426: checking for iODBC support" >&5
+echo "configure:68713: checking for iODBC support" >&5
     if test "$PHP_IODBC" = "yes"; then
       PHP_IODBC=/usr/local
     fi
@@ -68571,7 +68858,7 @@
 
   if test "$PHP_ESOOB" != "no"; then
     echo $ac_n "checking for Easysoft ODBC-ODBC Bridge support""... $ac_c" 1>&6
-echo "configure:68575: checking for Easysoft ODBC-ODBC Bridge support" >&5
+echo "configure:68862: checking for Easysoft ODBC-ODBC Bridge support" >&5
     if test "$PHP_ESOOB" = "yes"; then
       PHP_ESOOB=/usr/local/easysoft/oob/client
     fi
@@ -68638,7 +68925,7 @@
 
   if test "$PHP_UNIXODBC" != "no"; then
     echo $ac_n "checking for unixODBC support""... $ac_c" 1>&6
-echo "configure:68642: checking for unixODBC support" >&5
+echo "configure:68929: checking for unixODBC support" >&5
     if test "$PHP_UNIXODBC" = "yes"; then
       PHP_UNIXODBC=/usr/local
     fi
@@ -68710,7 +68997,7 @@
 
   if test "$PHP_DBMAKER" != "no"; then
     echo $ac_n "checking for DBMaker support""... $ac_c" 1>&6
-echo "configure:68714: checking for DBMaker support" >&5
+echo "configure:69001: checking for DBMaker support" >&5
     if test "$PHP_DBMAKER" = "yes"; then
       # find dbmaker's home directory
       DBMAKER_HOME=`grep "^dbmaker:" /etc/passwd | $AWK -F: '{print $6}'`
@@ -69272,7 +69559,7 @@
 php_enable_pcntl=no
 
 echo $ac_n "checking whether to enable pcntl support""... $ac_c" 1>&6
-echo "configure:69276: checking whether to enable pcntl support" >&5
+echo "configure:69563: checking whether to enable pcntl support" >&5
 # Check whether --enable-pcntl or --disable-pcntl was given.
 if test "${enable_pcntl+set}" = set; then
   enableval="$enable_pcntl"
@@ -69320,12 +69607,12 @@
   for ac_func in fork
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:69324: checking for $ac_func" >&5
+echo "configure:69611: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 69329 "configure"
+#line 69616 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -69348,7 +69635,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:69352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:69639: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -69379,12 +69666,12 @@
   for ac_func in waitpid
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:69383: checking for $ac_func" >&5
+echo "configure:69670: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 69388 "configure"
+#line 69675 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -69407,7 +69694,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:69411: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:69698: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -69438,12 +69725,12 @@
   for ac_func in sigaction
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:69442: checking for $ac_func" >&5
+echo "configure:69729: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 69447 "configure"
+#line 69734 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -69466,7 +69753,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:69470: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:69757: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -69497,12 +69784,12 @@
   for ac_func in getpriority setpriority wait3
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:69501: checking for $ac_func" >&5
+echo "configure:69788: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 69506 "configure"
+#line 69793 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -69525,7 +69812,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:69529: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:69816: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -69851,7 +70138,7 @@
 php_enable_pdo=yes
 
 echo $ac_n "checking whether to enable PDO support""... $ac_c" 1>&6
-echo "configure:69855: checking whether to enable PDO support" >&5
+echo "configure:70142: checking whether to enable PDO support" >&5
 # Check whether --enable-pdo or --disable-pdo was given.
 if test "${enable_pdo+set}" = set; then
   enableval="$enable_pdo"
@@ -70287,7 +70574,7 @@
 php_with_pdo_dblib=no
 
 echo $ac_n "checking for PDO_DBLIB support via FreeTDS""... $ac_c" 1>&6
-echo "configure:70291: checking for PDO_DBLIB support via FreeTDS" >&5
+echo "configure:70578: checking for PDO_DBLIB support via FreeTDS" >&5
 # Check whether --with-pdo-dblib or --without-pdo-dblib was given.
 if test "${with_pdo_dblib+set}" = set; then
   withval="$with_pdo_dblib"
@@ -70504,13 +70791,13 @@
   
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:70508: checking for PDO includes" >&5
+echo "configure:70795: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:70514: checking for PDO includes" >&5
+echo "configure:70801: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -70824,7 +71111,7 @@
   fi
 
   echo $ac_n "checking for dnet_addr in -ldnet_stub""... $ac_c" 1>&6
-echo "configure:70828: checking for dnet_addr in -ldnet_stub" >&5
+echo "configure:71115: checking for dnet_addr in -ldnet_stub" >&5
 ac_lib_var=`echo dnet_stub'_'dnet_addr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -70832,7 +71119,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldnet_stub  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 70836 "configure"
+#line 71123 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -70843,7 +71130,7 @@
 dnet_addr()
 ; return 0; }
 EOF
-if { (eval echo configure:70847: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:71134: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -71008,7 +71295,7 @@
 php_with_pdo_firebird=no
 
 echo $ac_n "checking for Firebird support for PDO""... $ac_c" 1>&6
-echo "configure:71012: checking for Firebird support for PDO" >&5
+echo "configure:71299: checking for Firebird support for PDO" >&5
 # Check whether --with-pdo-firebird or --without-pdo-firebird was given.
 if test "${with_pdo_firebird+set}" = set; then
   withval="$with_pdo_firebird"
@@ -71158,7 +71445,7 @@
   done
 
   echo $ac_n "checking for isc_detach_database in -lfbclient""... $ac_c" 1>&6
-echo "configure:71162: checking for isc_detach_database in -lfbclient" >&5
+echo "configure:71449: checking for isc_detach_database in -lfbclient" >&5
 ac_lib_var=`echo fbclient'_'isc_detach_database | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -71166,7 +71453,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lfbclient  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 71170 "configure"
+#line 71457 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -71177,7 +71464,7 @@
 isc_detach_database()
 ; return 0; }
 EOF
-if { (eval echo configure:71181: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:71468: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -71304,7 +71591,7 @@
   done
 
   echo $ac_n "checking for isc_detach_database in -lgds""... $ac_c" 1>&6
-echo "configure:71308: checking for isc_detach_database in -lgds" >&5
+echo "configure:71595: checking for isc_detach_database in -lgds" >&5
 ac_lib_var=`echo gds'_'isc_detach_database | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -71312,7 +71599,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lgds  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 71316 "configure"
+#line 71603 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -71323,7 +71610,7 @@
 isc_detach_database()
 ; return 0; }
 EOF
-if { (eval echo configure:71327: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:71614: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -71450,7 +71737,7 @@
   done
 
   echo $ac_n "checking for isc_detach_database in -lib_util""... $ac_c" 1>&6
-echo "configure:71454: checking for isc_detach_database in -lib_util" >&5
+echo "configure:71741: checking for isc_detach_database in -lib_util" >&5
 ac_lib_var=`echo ib_util'_'isc_detach_database | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -71458,7 +71745,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lib_util  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 71462 "configure"
+#line 71749 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -71469,7 +71756,7 @@
 isc_detach_database()
 ; return 0; }
 EOF
-if { (eval echo configure:71473: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:71760: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -71514,13 +71801,13 @@
  
   
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:71518: checking for PDO includes" >&5
+echo "configure:71805: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:71524: checking for PDO includes" >&5
+echo "configure:71811: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -71990,15 +72277,11 @@
 fi
 
 
-if test "$PHP_PDO" != "no"; then
 
-
-
-
 php_with_pdo_mysql=no
 
 echo $ac_n "checking for MySQL support for PDO""... $ac_c" 1>&6
-echo "configure:72002: checking for MySQL support for PDO" >&5
+echo "configure:72285: checking for MySQL support for PDO" >&5
 # Check whether --with-pdo-mysql or --without-pdo-mysql was given.
 if test "${with_pdo_mysql+set}" = set; then
   withval="$with_pdo_mysql"
@@ -72046,7 +72329,7 @@
 php_with_zlib_dir=no
 
 echo $ac_n "checking for the location of libz""... $ac_c" 1>&6
-echo "configure:72050: checking for the location of libz" >&5
+echo "configure:72333: checking for the location of libz" >&5
 # Check whether --with-zlib-dir or --without-zlib-dir was given.
 if test "${with_zlib_dir+set}" = set; then
   withval="$with_zlib_dir"
@@ -72070,13 +72353,12 @@
 fi
 
 if test "$PHP_PDO_MYSQL" != "no"; then
-  cat >> confdefs.h <<\EOF
-#define HAVE_MYSQL 1
-EOF
 
+  if test "$PHP_PDO" = "no" && test "$ext_shared" = "no"; then
+    { echo "configure: error: PDO is not enabled! Add --enable-pdo to your configure line." 1>&2; exit 1; }
+  fi
 
-  echo $ac_n "checking for mysql_config""... $ac_c" 1>&6
-echo "configure:72080: checking for mysql_config" >&5
+  
 
   if test -f $PHP_PDO_MYSQL && test -x $PHP_PDO_MYSQL ; then
     PDO_MYSQL_CONFIG=$PHP_PDO_MYSQL
@@ -72087,9 +72369,6 @@
       else
         PDO_MYSQL_DIR="$PHP_PDO_MYSQL"
       fi
-    else
-      echo "$ac_t""$PHP_PDO_MYSQL is not a directory" 1>&6
-      { echo "configure: error: can not find mysql under the "$PHP_PDO_MYSQL" that you specified" 1>&2; exit 1; }
     fi
   else
     for i in /usr/local /usr ; do
@@ -72104,13 +72383,27 @@
     done
   fi
 
-  if test -n "$PDO_MYSQL_CONFIG" && test -x "$PDO_MYSQL_CONFIG" ; then
-    echo "$ac_t""$PDO_MYSQL_CONFIG" 1>&6
-    if test "x$SED" = "x"; then
-      # Extract the first word of "sed", so it can be a program name with args.
+  if test "$PHP_PDO_MYSQL" = "mysqlnd"; then
+        PHP_MYSQLND_ENABLED=yes
+    cat >> confdefs.h <<\EOF
+#define PDO_USE_MYSQLND 1
+EOF
+
+  else
+    cat >> confdefs.h <<\EOF
+#define HAVE_MYSQL 1
+EOF
+
+
+    echo $ac_n "checking for mysql_config""... $ac_c" 1>&6
+echo "configure:72400: checking for mysql_config" >&5
+    if test -n "$PDO_MYSQL_CONFIG"; then
+      echo "$ac_t""$PDO_MYSQL_CONFIG" 1>&6
+      if test "x$SED" = "x"; then
+        # Extract the first word of "sed", so it can be a program name with args.
 set dummy sed; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:72114: checking for $ac_word" >&5
+echo "configure:72407: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SED'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -72142,139 +72435,38 @@
   echo "$ac_t""no" 1>&6
 fi
 
-    fi
-    if test "$enable_maintainer_zts" = "yes"; then
-      PDO_MYSQL_LIBNAME=mysqlclient_r
-      PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs_r | $SED -e "s/'//g"`
-    else
-      PDO_MYSQL_LIBNAME=mysqlclient
-      PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs | $SED -e "s/'//g"`
-    fi
-    PDO_MYSQL_INCLUDE=`$PDO_MYSQL_CONFIG --cflags | $SED -e "s/'//g"`
-    PDO_MYSQL_SOCKET=`$PDO_MYSQL_CONFIG --socket` 
-  elif test -z "$PDO_MYSQL_DIR"; then
-    echo "$ac_t""not found" 1>&6
-    { echo "configure: error: Cannot find MySQL header files under $PDO_MYSQL_DIR" 1>&2; exit 1; }
-  else
-    echo "$ac_t""not found" 1>&6
-    echo $ac_n "checking for mysql install under $PDO_MYSQL_DIR""... $ac_c" 1>&6
-echo "configure:72162: checking for mysql install under $PDO_MYSQL_DIR" >&5
-    if test -r $PDO_MYSQL_DIR/include/mysql; then
-      PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include/mysql
-    else
-      PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include
-    fi
-    if test -r $PDO_MYSQL_DIR/$PHP_LIBDIR/mysql; then
-      PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR/mysql
-    else
-      PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR
-    fi
-
-    if test -r "$PDO_MYSQL_LIB_DIR"; then
-      echo "$ac_t""libs under $PDO_MYSQL_LIB_DIR; seems promising" 1>&6
-    else
-      echo "$ac_t""can not find it" 1>&6
-      { echo "configure: error: Unable to find your mysql installation" 1>&2; exit 1; }
-    fi
-
-    
-
-  if test "$ext_shared" = "yes"; then
-    PDO_MYSQL_SHARED_LIBADD="-l$PDO_MYSQL_LIBNAME $PDO_MYSQL_SHARED_LIBADD"
-    if test -n "$PDO_MYSQL_LIB_DIR"; then
-      
-  if test "$PDO_MYSQL_LIB_DIR" != "/usr/$PHP_LIBDIR" && test "$PDO_MYSQL_LIB_DIR" != "/usr/lib"; then
-    
-  if test -z "$PDO_MYSQL_LIB_DIR" || echo "$PDO_MYSQL_LIB_DIR" | grep '^/' >/dev/null ; then
-    ai_p=$PDO_MYSQL_LIB_DIR
-  else
-    
-    ep_dir="`echo $PDO_MYSQL_LIB_DIR|$SED 's%/*[^/][^/]*/*$%%'`"
-    
-    ep_realdir="`(cd \"$ep_dir\" && pwd)`"
-    ai_p="$ep_realdir/`basename \"$PDO_MYSQL_LIB_DIR\"`"
-  fi
-
-    
-      if test "$ext_shared" = "yes"; then
-        PDO_MYSQL_SHARED_LIBADD="-L$ai_p $PDO_MYSQL_SHARED_LIBADD"
-        test -n "$ld_runpath_switch" && PDO_MYSQL_SHARED_LIBADD="$ld_runpath_switch$ai_p $PDO_MYSQL_SHARED_LIBADD"
+      fi
+      if test "$enable_maintainer_zts" = "yes"; then
+        PDO_MYSQL_LIBNAME=mysqlclient_r
+        PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs_r | $SED -e "s/'//g"`
       else
-        
-  
-  
-  unique=`echo $ai_p|$SED 's/[^a-zA-Z0-9]/_/g'`
-  
-  cmd="echo $ac_n \"\$LIBPATH$unique$ac_c\""
-  if test -n "$unique" && test "`eval $cmd`" = "" ; then
-    eval "LIBPATH$unique=set"
-    
-    test -n "$ld_runpath_switch" && LDFLAGS="$LDFLAGS $ld_runpath_switch$ai_p"
-    LDFLAGS="$LDFLAGS -L$ai_p"
-    PHP_RPATHS="$PHP_RPATHS $ai_p"
-  
-  fi
+        PDO_MYSQL_LIBNAME=mysqlclient
+        PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs | $SED -e "s/'//g"`
+      fi
+      PDO_MYSQL_INCLUDE=`$PDO_MYSQL_CONFIG --cflags | $SED -e "s/'//g"`
+    elif test -n "$PDO_MYSQL_DIR"; then
+      echo "$ac_t""not found" 1>&6
+      echo $ac_n "checking for mysql install under $PDO_MYSQL_DIR""... $ac_c" 1>&6
+echo "configure:72451: checking for mysql install under $PDO_MYSQL_DIR" >&5
+      if test -r $PDO_MYSQL_DIR/include/mysql; then
+        PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include/mysql
+      else
+        PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include
+      fi
+      if test -r $PDO_MYSQL_DIR/$PHP_LIBDIR/mysql; then
+        PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR/mysql
+      else
+        PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR
+      fi
 
-
+      if test -r "$PDO_MYSQL_LIB_DIR"; then
+        echo "$ac_t""libs under $PDO_MYSQL_LIB_DIR; seems promising" 1>&6
+      else
+        echo "$ac_t""can not find it" 1>&6
+        { echo "configure: error: Unable to find your mysql installation" 1>&2; exit 1; }
       fi
-    
-  fi
 
-    fi
-  else
-    
-
-  if test -n "$PDO_MYSQL_LIB_DIR"; then
-    
-  if test "$PDO_MYSQL_LIB_DIR" != "/usr/$PHP_LIBDIR" && test "$PDO_MYSQL_LIB_DIR" != "/usr/lib"; then
-    
-  if test -z "$PDO_MYSQL_LIB_DIR" || echo "$PDO_MYSQL_LIB_DIR" | grep '^/' >/dev/null ; then
-    ai_p=$PDO_MYSQL_LIB_DIR
-  else
-    
-    ep_dir="`echo $PDO_MYSQL_LIB_DIR|$SED 's%/*[^/][^/]*/*$%%'`"
-    
-    ep_realdir="`(cd \"$ep_dir\" && pwd)`"
-    ai_p="$ep_realdir/`basename \"$PDO_MYSQL_LIB_DIR\"`"
-  fi
-
-    
       
-  
-  
-  unique=`echo $ai_p|$SED 's/[^a-zA-Z0-9]/_/g'`
-  
-  cmd="echo $ac_n \"\$LIBPATH$unique$ac_c\""
-  if test -n "$unique" && test "`eval $cmd`" = "" ; then
-    eval "LIBPATH$unique=set"
-    
-    test -n "$ld_runpath_switch" && LDFLAGS="$LDFLAGS $ld_runpath_switch$ai_p"
-    LDFLAGS="$LDFLAGS -L$ai_p"
-    PHP_RPATHS="$PHP_RPATHS $ai_p"
-  
-  fi
-
-
-    
-  fi
-
-  fi
-  
-  
-  case $PDO_MYSQL_LIBNAME in
-  c|c_r|pthread*) ;;
-  *) 
-      LIBS="-l$PDO_MYSQL_LIBNAME $LIBS" 
-   ;;
-  esac
-
-
-
-
-  fi
-
-
-    
   if test "$PDO_MYSQL_INC_DIR" != "/usr/include"; then
     
   if test -z "$PDO_MYSQL_INC_DIR" || echo "$PDO_MYSQL_INC_DIR" | grep '^/' >/dev/null ; then
@@ -72305,20 +72497,17 @@
 
   fi
 
-    PDO_MYSQL_INCLUDE=-I$PDO_MYSQL_INC_DIR
-  fi
+      PDO_MYSQL_INCLUDE=-I$PDO_MYSQL_INC_DIR
+    else
+      echo "$ac_t""not found" 1>&6
+      { echo "configure: error: Unable to find your mysql installation" 1>&2; exit 1; }
+    fi
 
-  cat >> confdefs.h <<EOF
-#define PDO_MYSQL_UNIX_ADDR "$PDO_MYSQL_SOCKET"
-EOF
-
-
-
-  
+    
   save_old_LDFLAGS=$LDFLAGS
   ac_stuff="
-    $PDO_MYSQL_LIBS
-  "
+      $PDO_MYSQL_LIBS
+    "
   
   save_ext_shared=$ext_shared
   ext_shared=yes
@@ -72412,7 +72601,7 @@
   done
 
   echo $ac_n "checking for mysql_query in -l$PDO_MYSQL_LIBNAME""... $ac_c" 1>&6
-echo "configure:72416: checking for mysql_query in -l$PDO_MYSQL_LIBNAME" >&5
+echo "configure:72605: checking for mysql_query in -l$PDO_MYSQL_LIBNAME" >&5
 ac_lib_var=`echo $PDO_MYSQL_LIBNAME'_'mysql_query | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -72420,7 +72609,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$PDO_MYSQL_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 72424 "configure"
+#line 72613 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -72431,7 +72620,7 @@
 mysql_query()
 ; return 0; }
 EOF
-if { (eval echo configure:72435: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:72624: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -72450,7 +72639,7 @@
     LDFLAGS=$save_old_LDFLAGS
     ext_shared=$save_ext_shared
     
-    
+      
   for ac_i in $PDO_MYSQL_INCLUDE; do
     case $ac_i in
     -I*)
@@ -72490,7 +72679,7 @@
     esac
   done
 
-    
+      
   for ac_i in $PDO_MYSQL_LIBS; do
     case $ac_i in
     -pthread)
@@ -72579,8 +72768,8 @@
     esac
   done
 
+    
   
-  
 else
   echo "$ac_t""no" 1>&6
 
@@ -72588,8 +72777,8 @@
     ext_shared=$save_ext_shared
     unset ac_cv_lib_$PDO_MYSQL_LIBNAME_mysql_query
     
-    if test "$PHP_ZLIB_DIR" != "no"; then
-      
+      if test "$PHP_ZLIB_DIR" != "no"; then
+        
 
   if test "$ext_shared" = "yes"; then
     PDO_MYSQL_SHARED_LIBADD="-lz $PDO_MYSQL_SHARED_LIBADD"
@@ -72686,11 +72875,11 @@
   fi
 
 
-      
+        
   save_old_LDFLAGS=$LDFLAGS
   ac_stuff="
-        -L$PHP_ZLIB_DIR/$PHP_LIBDIR -L$PDO_MYSQL_LIB_DIR 
-      "
+          -L$PHP_ZLIB_DIR/$PHP_LIBDIR -L$PDO_MYSQL_LIB_DIR 
+        "
   
   save_ext_shared=$ext_shared
   ext_shared=yes
@@ -72784,7 +72973,7 @@
   done
 
   echo $ac_n "checking for mysql_query in -l$PDO_MYSQL_LIBNAME""... $ac_c" 1>&6
-echo "configure:72788: checking for mysql_query in -l$PDO_MYSQL_LIBNAME" >&5
+echo "configure:72977: checking for mysql_query in -l$PDO_MYSQL_LIBNAME" >&5
 ac_lib_var=`echo $PDO_MYSQL_LIBNAME'_'mysql_query | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -72792,7 +72981,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$PDO_MYSQL_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 72796 "configure"
+#line 72985 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -72803,7 +72992,7 @@
 mysql_query()
 ; return 0; }
 EOF
-if { (eval echo configure:72807: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:72996: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -72830,14 +73019,14 @@
     ext_shared=$save_ext_shared
     unset ac_cv_lib_$PDO_MYSQL_LIBNAME_mysql_query
     
-        { echo "configure: error: PDO_MYSQL configure failed. Please check config.log for more information." 1>&2; exit 1; }
-      
+          { echo "configure: error: PDO_MYSQL configure failed. Please check config.log for more information." 1>&2; exit 1; }
+        
   
 fi
   
-      PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -L$PHP_ZLIB_DIR/$PHP_LIBDIR -lz"
-    else
-      
+        PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -L$PHP_ZLIB_DIR/$PHP_LIBDIR -lz"
+      else
+        
   
   case z in
   c|c_r|pthread*) ;;
@@ -72860,11 +73049,11 @@
   esac
 
 
-      
+        
   save_old_LDFLAGS=$LDFLAGS
   ac_stuff="
-        -L$PDO_MYSQL_LIB_DIR
-      "
+          -L$PDO_MYSQL_LIB_DIR
+        "
   
   save_ext_shared=$ext_shared
   ext_shared=yes
@@ -72958,7 +73147,7 @@
   done
 
   echo $ac_n "checking for mysql_query in -l$PDO_MYSQL_LIBNAME""... $ac_c" 1>&6
-echo "configure:72962: checking for mysql_query in -l$PDO_MYSQL_LIBNAME" >&5
+echo "configure:73151: checking for mysql_query in -l$PDO_MYSQL_LIBNAME" >&5
 ac_lib_var=`echo $PDO_MYSQL_LIBNAME'_'mysql_query | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -72966,7 +73155,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$PDO_MYSQL_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 72970 "configure"
+#line 73159 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -72977,7 +73166,7 @@
 mysql_query()
 ; return 0; }
 EOF
-if { (eval echo configure:72981: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:73170: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -73004,15 +73193,15 @@
     ext_shared=$save_ext_shared
     unset ac_cv_lib_$PDO_MYSQL_LIBNAME_mysql_query
     
-        { echo "configure: error: Try adding --with-zlib-dir=<DIR>. Please check config.log for more information." 1>&2; exit 1; }
-      
+          { echo "configure: error: Try adding --with-zlib-dir=<DIR>. Please check config.log for more information." 1>&2; exit 1; }
+        
   
 fi
    
-      PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -lz"
-    fi
+        PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -lz"
+      fi
 
-    
+      
   for ac_i in $PDO_MYSQL_INCLUDE; do
     case $ac_i in
     -I*)
@@ -73052,7 +73241,7 @@
     esac
   done
 
-    
+      
   for ac_i in $PDO_MYSQL_LIBS; do
     case $ac_i in
     -pthread)
@@ -73141,21 +73330,22 @@
     esac
   done
 
+    
   
-  
 fi
 
-  _SAVE_LIBS=$LIBS
-  LIBS="$LIBS $PDO_MYSQL_LIBS"
-  for ac_func in mysql_commit mysql_stmt_prepare mysql_next_result mysql_sqlstate
+
+    _SAVE_LIBS=$LIBS
+    LIBS="$LIBS $PDO_MYSQL_LIBS"
+    for ac_func in mysql_commit mysql_stmt_prepare mysql_next_result mysql_sqlstate
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:73154: checking for $ac_func" >&5
+echo "configure:73344: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 73159 "configure"
+#line 73349 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -73178,7 +73368,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:73182: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:73372: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -73202,18 +73392,19 @@
 fi
 done
  
-  LIBS=$_SAVE_LIBS
+    LIBS=$_SAVE_LIBS
+  fi
 
   
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:73211: checking for PDO includes" >&5
+echo "configure:73402: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:73217: checking for PDO includes" >&5
+echo "configure:73408: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -73233,11 +73424,19 @@
 
   
 
-  
+  if test -n "$PDO_MYSQL_CONFIG"; then
+    PDO_MYSQL_SOCKET=`$PDO_MYSQL_CONFIG --socket`
+    cat >> confdefs.h <<EOF
+#define PDO_MYSQL_UNIX_ADDR "$PDO_MYSQL_SOCKET"
+EOF
+
+  fi
+
+    
   ext_builddir=ext/pdo_mysql
   ext_srcdir=$abs_srcdir/ext/pdo_mysql
 
-  ac_extra=`echo "-I$pdo_inc_path"|$SED s#@ext_srcdir@#$ext_srcdir#g|$SED s#@ext_builddir@#$ext_builddir#g`
+  ac_extra=`echo "-I$pdo_inc_path -I"|$SED s#@ext_srcdir@#$ext_srcdir#g|$SED s#@ext_builddir@#$ext_builddir#g`
 
   if test "$ext_shared" != "shared" && test "$ext_shared" != "yes" && test "" != "cli"; then
     PHP_PDO_MYSQL_SHARED=no
@@ -73545,7 +73744,28 @@
 " 1>&2; exit 1; }
   fi
   
+    if test "$PHP_MYSQL" = "mysqlnd"; then
+      
+  am_i_shared=$PHP_PDO_MYSQL_SHARED
+  is_it_shared=$PHP_MYSQLND_SHARED
+  is_it_enabled=$PHP_MYSQLND
+  if test "$am_i_shared" = "no" && test "$is_it_shared" = "yes" ; then
+    { echo "configure: error: 
+You've configured extension pdo_mysql to build statically, but it
+depends on extension mysqlnd, which you've configured to build shared.
+You either need to build pdo_mysql shared or build mysqlnd statically for the
+build to be successful.
+" 1>&2; exit 1; }
+  fi
+  if test "x$is_it_enabled" = "xno" && test "x" != "xtrue"; then
+    { echo "configure: error: 
+You've configured extension pdo_mysql, which depends on extension mysqlnd,
+but you've either not enabled mysqlnd, or have disabled it.
+" 1>&2; exit 1; }
+  fi
   
+    fi
+  
   PDO_MYSQL_MODULE_TYPE=external
 
   
@@ -73559,9 +73779,7 @@
 
 fi
 
-fi
 
-
 if test "$PHP_PDO" != "no"; then
 
                                                                                                                                                                 
@@ -73572,7 +73790,7 @@
 php_with_pdo_oci=no
 
 echo $ac_n "checking Oracle OCI support for PDO""... $ac_c" 1>&6
-echo "configure:73576: checking Oracle OCI support for PDO" >&5
+echo "configure:73794: checking Oracle OCI support for PDO" >&5
 # Check whether --with-pdo-oci or --without-pdo-oci was given.
 if test "${with_pdo_oci+set}" = set; then
   withval="$with_pdo_oci"
@@ -73617,7 +73835,7 @@
 
 if test "$PHP_PDO_OCI" != "no"; then
   echo $ac_n "checking Oracle Install-Dir""... $ac_c" 1>&6
-echo "configure:73621: checking Oracle Install-Dir" >&5
+echo "configure:73839: checking Oracle Install-Dir" >&5
   if test "$PHP_PDO_OCI" = "yes" || test -z "$PHP_PDO_OCI"; then
     PDO_OCI_DIR=$ORACLE_HOME
   else
@@ -73626,7 +73844,7 @@
   echo "$ac_t""$PHP_PDO_OCI" 1>&6
 
   echo $ac_n "checking if that is sane""... $ac_c" 1>&6
-echo "configure:73630: checking if that is sane" >&5
+echo "configure:73848: checking if that is sane" >&5
   if test -z "$PDO_OCI_DIR"; then
     { echo "configure: error: 
 You need to tell me where to find your Oracle Instant Client SDK, or set ORACLE_HOME.
@@ -73639,7 +73857,7 @@
     PDO_OCI_IC_PREFIX="`echo $PDO_OCI_DIR | cut -d, -f2`"
     PDO_OCI_IC_VERS="`echo $PDO_OCI_DIR | cut -d, -f3`"
     echo $ac_n "checking for oci.h""... $ac_c" 1>&6
-echo "configure:73643: checking for oci.h" >&5
+echo "configure:73861: checking for oci.h" >&5
     if test -f $PDO_OCI_IC_PREFIX/include/oracle/$PDO_OCI_IC_VERS/client/oci.h ; then
       
   if test "$PDO_OCI_IC_PREFIX/include/oracle/$PDO_OCI_IC_VERS/client" != "/usr/include"; then
@@ -73788,7 +74006,7 @@
   else
     
   echo $ac_n "checking size of long int""... $ac_c" 1>&6
-echo "configure:73792: checking size of long int" >&5
+echo "configure:74010: checking size of long int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -73796,18 +74014,19 @@
   ac_cv_sizeof_long_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 73800 "configure"
+#line 74018 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:73811: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:74030: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_int=`cat conftestval`
 else
@@ -73827,7 +74046,7 @@
 
 
   echo $ac_n "checking if we're on a 64-bit platform""... $ac_c" 1>&6
-echo "configure:73831: checking if we're on a 64-bit platform" >&5
+echo "configure:74050: checking if we're on a 64-bit platform" >&5
   if test "$ac_cv_sizeof_long_int" = "4" ; then
     echo "$ac_t""no" 1>&6
     TMP_PDO_OCI_LIB_DIR="$PDO_OCI_DIR/lib32"
@@ -73837,7 +74056,7 @@
   fi
 
   echo $ac_n "checking OCI8 libraries dir""... $ac_c" 1>&6
-echo "configure:73841: checking OCI8 libraries dir" >&5
+echo "configure:74060: checking OCI8 libraries dir" >&5
   if test -d "$PDO_OCI_DIR/lib" && test ! -d "$PDO_OCI_DIR/lib32"; then
     PDO_OCI_LIB_DIR="$PDO_OCI_DIR/lib"
   elif test ! -d "$PDO_OCI_DIR/lib" && test -d "$PDO_OCI_DIR/lib32"; then
@@ -74204,7 +74423,7 @@
     fi
     
   echo $ac_n "checking Oracle version""... $ac_c" 1>&6
-echo "configure:74208: checking Oracle version" >&5
+echo "configure:74427: checking Oracle version" >&5
   if test -s "$PDO_OCI_DIR/orainst/unix.rgs"; then
     PDO_OCI_VERSION=`grep '"ocommon"' $PDO_OCI_DIR/orainst/unix.rgs | sed 's/  */:/g' | cut -d: -f 6 | cut -c 2-4`
     test -z "$PDO_OCI_VERSION" && PDO_OCI_VERSION=7.3
@@ -74921,7 +75140,7 @@
   done
 
   echo $ac_n "checking for OCIEnvCreate in -lclntsh""... $ac_c" 1>&6
-echo "configure:74925: checking for OCIEnvCreate in -lclntsh" >&5
+echo "configure:75144: checking for OCIEnvCreate in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIEnvCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -74929,7 +75148,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 74933 "configure"
+#line 75152 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -74940,7 +75159,7 @@
 OCIEnvCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:74944: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:75163: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -75074,7 +75293,7 @@
   done
 
   echo $ac_n "checking for OCIEnvNlsCreate in -lclntsh""... $ac_c" 1>&6
-echo "configure:75078: checking for OCIEnvNlsCreate in -lclntsh" >&5
+echo "configure:75297: checking for OCIEnvNlsCreate in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIEnvNlsCreate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -75082,7 +75301,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 75086 "configure"
+#line 75305 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -75093,7 +75312,7 @@
 OCIEnvNlsCreate()
 ; return 0; }
 EOF
-if { (eval echo configure:75097: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:75316: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -75227,7 +75446,7 @@
   done
 
   echo $ac_n "checking for OCILobIsTemporary in -lclntsh""... $ac_c" 1>&6
-echo "configure:75231: checking for OCILobIsTemporary in -lclntsh" >&5
+echo "configure:75450: checking for OCILobIsTemporary in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCILobIsTemporary | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -75235,7 +75454,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 75239 "configure"
+#line 75458 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -75246,7 +75465,7 @@
 OCILobIsTemporary()
 ; return 0; }
 EOF
-if { (eval echo configure:75250: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:75469: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -75376,7 +75595,7 @@
   done
 
   echo $ac_n "checking for OCILobIsTemporary in -locijdbc8""... $ac_c" 1>&6
-echo "configure:75380: checking for OCILobIsTemporary in -locijdbc8" >&5
+echo "configure:75599: checking for OCILobIsTemporary in -locijdbc8" >&5
 ac_lib_var=`echo ocijdbc8'_'OCILobIsTemporary | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -75384,7 +75603,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-locijdbc8  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 75388 "configure"
+#line 75607 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -75395,7 +75614,7 @@
 OCILobIsTemporary()
 ; return 0; }
 EOF
-if { (eval echo configure:75399: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:75618: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -75556,7 +75775,7 @@
   done
 
   echo $ac_n "checking for OCICollAssign in -lclntsh""... $ac_c" 1>&6
-echo "configure:75560: checking for OCICollAssign in -lclntsh" >&5
+echo "configure:75779: checking for OCICollAssign in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCICollAssign | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -75564,7 +75783,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 75568 "configure"
+#line 75787 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -75575,7 +75794,7 @@
 OCICollAssign()
 ; return 0; }
 EOF
-if { (eval echo configure:75579: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:75798: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -75709,7 +75928,7 @@
   done
 
   echo $ac_n "checking for OCIStmtFetch2 in -lclntsh""... $ac_c" 1>&6
-echo "configure:75713: checking for OCIStmtFetch2 in -lclntsh" >&5
+echo "configure:75932: checking for OCIStmtFetch2 in -lclntsh" >&5
 ac_lib_var=`echo clntsh'_'OCIStmtFetch2 | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -75717,7 +75936,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lclntsh  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 75721 "configure"
+#line 75940 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -75728,7 +75947,7 @@
 OCIStmtFetch2()
 ; return 0; }
 EOF
-if { (eval echo configure:75732: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:75951: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -75767,13 +75986,13 @@
   
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:75771: checking for PDO includes" >&5
+echo "configure:75990: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:75777: checking for PDO includes" >&5
+echo "configure:75996: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -76144,7 +76363,7 @@
 php_with_pdo_odbc=no
 
 echo $ac_n "checking for ODBC v3 support for PDO""... $ac_c" 1>&6
-echo "configure:76148: checking for ODBC v3 support for PDO" >&5
+echo "configure:76367: checking for ODBC v3 support for PDO" >&5
 # Check whether --with-pdo-odbc or --without-pdo-odbc was given.
 if test "${with_pdo_odbc+set}" = set; then
   withval="$with_pdo_odbc"
@@ -76195,13 +76414,13 @@
   
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:76199: checking for PDO includes" >&5
+echo "configure:76418: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:76205: checking for PDO includes" >&5
+echo "configure:76424: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -76222,7 +76441,7 @@
   
 
   echo $ac_n "checking for selected PDO ODBC flavour""... $ac_c" 1>&6
-echo "configure:76226: checking for selected PDO ODBC flavour" >&5
+echo "configure:76445: checking for selected PDO ODBC flavour" >&5
 
   pdo_odbc_flavour="`echo $PHP_PDO_ODBC | cut -d, -f1`"
   pdo_odbc_dir="`echo $PHP_PDO_ODBC | cut -d, -f2`"
@@ -76295,7 +76514,7 @@
 
   
   echo $ac_n "checking for odbc.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76299: checking for odbc.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76518: checking for odbc.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/odbc.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76309,7 +76528,7 @@
 
   
   echo $ac_n "checking for odbcsdk.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76313: checking for odbcsdk.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76532: checking for odbcsdk.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/odbcsdk.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76323,7 +76542,7 @@
 
   
   echo $ac_n "checking for iodbc.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76327: checking for iodbc.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76546: checking for iodbc.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/iodbc.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76337,7 +76556,7 @@
 
   
   echo $ac_n "checking for sqlunix.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76341: checking for sqlunix.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76560: checking for sqlunix.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/sqlunix.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76351,7 +76570,7 @@
 
   
   echo $ac_n "checking for sqltypes.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76355: checking for sqltypes.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76574: checking for sqltypes.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/sqltypes.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76365,7 +76584,7 @@
 
   
   echo $ac_n "checking for sqlucode.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76369: checking for sqlucode.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76588: checking for sqlucode.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/sqlucode.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76379,7 +76598,7 @@
 
   
   echo $ac_n "checking for sql.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76383: checking for sql.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76602: checking for sql.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/sql.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76393,7 +76612,7 @@
 
   
   echo $ac_n "checking for isql.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76397: checking for isql.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76616: checking for isql.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/isql.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76407,7 +76626,7 @@
 
   
   echo $ac_n "checking for sqlext.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76411: checking for sqlext.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76630: checking for sqlext.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/sqlext.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76421,7 +76640,7 @@
 
   
   echo $ac_n "checking for isqlext.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76425: checking for isqlext.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76644: checking for isqlext.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/isqlext.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76435,7 +76654,7 @@
 
   
   echo $ac_n "checking for udbcext.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76439: checking for udbcext.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76658: checking for udbcext.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/udbcext.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76449,7 +76668,7 @@
 
   
   echo $ac_n "checking for sqlcli1.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76453: checking for sqlcli1.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76672: checking for sqlcli1.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/sqlcli1.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76463,7 +76682,7 @@
 
   
   echo $ac_n "checking for LibraryManager.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76467: checking for LibraryManager.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76686: checking for LibraryManager.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/LibraryManager.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76477,7 +76696,7 @@
 
   
   echo $ac_n "checking for cli0core.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76481: checking for cli0core.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76700: checking for cli0core.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/cli0core.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76491,7 +76710,7 @@
 
   
   echo $ac_n "checking for cli0ext.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76495: checking for cli0ext.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76714: checking for cli0ext.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/cli0ext.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76505,7 +76724,7 @@
 
   
   echo $ac_n "checking for cli0cli.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76509: checking for cli0cli.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76728: checking for cli0cli.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/cli0cli.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76519,7 +76738,7 @@
 
   
   echo $ac_n "checking for cli0defs.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76523: checking for cli0defs.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76742: checking for cli0defs.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/cli0defs.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76533,7 +76752,7 @@
 
   
   echo $ac_n "checking for cli0env.h in $PDO_ODBC_INCDIR""... $ac_c" 1>&6
-echo "configure:76537: checking for cli0env.h in $PDO_ODBC_INCDIR" >&5
+echo "configure:76756: checking for cli0env.h in $PDO_ODBC_INCDIR" >&5
   if test -f "$PDO_ODBC_INCDIR/cli0env.h"; then
     php_pdo_have_header=yes
     cat >> confdefs.h <<\EOF
@@ -76739,7 +76958,7 @@
   done
 
   echo $ac_n "checking for SQLBindCol in -l$pdo_odbc_def_lib""... $ac_c" 1>&6
-echo "configure:76743: checking for SQLBindCol in -l$pdo_odbc_def_lib" >&5
+echo "configure:76962: checking for SQLBindCol in -l$pdo_odbc_def_lib" >&5
 ac_lib_var=`echo $pdo_odbc_def_lib'_'SQLBindCol | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -76747,7 +76966,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$pdo_odbc_def_lib  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 76751 "configure"
+#line 76970 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -76758,7 +76977,7 @@
 SQLBindCol()
 ; return 0; }
 EOF
-if { (eval echo configure:76762: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:76981: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -76873,7 +77092,7 @@
   done
 
   echo $ac_n "checking for SQLAllocHandle in -l$pdo_odbc_def_lib""... $ac_c" 1>&6
-echo "configure:76877: checking for SQLAllocHandle in -l$pdo_odbc_def_lib" >&5
+echo "configure:77096: checking for SQLAllocHandle in -l$pdo_odbc_def_lib" >&5
 ac_lib_var=`echo $pdo_odbc_def_lib'_'SQLAllocHandle | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -76881,7 +77100,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$pdo_odbc_def_lib  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 76885 "configure"
+#line 77104 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -76892,7 +77111,7 @@
 SQLAllocHandle()
 ; return 0; }
 EOF
-if { (eval echo configure:76896: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77115: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77270,7 +77489,7 @@
 php_with_pdo_pgsql=no
 
 echo $ac_n "checking for PostgreSQL support for PDO""... $ac_c" 1>&6
-echo "configure:77274: checking for PostgreSQL support for PDO" >&5
+echo "configure:77493: checking for PostgreSQL support for PDO" >&5
 # Check whether --with-pdo-pgsql or --without-pdo-pgsql was given.
 if test "${with_pdo_pgsql+set}" = set; then
   withval="$with_pdo_pgsql"
@@ -77327,7 +77546,7 @@
 
 
   echo $ac_n "checking for pg_config""... $ac_c" 1>&6
-echo "configure:77331: checking for pg_config" >&5
+echo "configure:77550: checking for pg_config" >&5
   for i in $PHP_PDO_PGSQL $PHP_PDO_PGSQL/bin /usr/local/pgsql/bin /usr/local/bin /usr/bin ""; do
     if test -x $i/pg_config; then
       PG_CONFIG="$i/pg_config"
@@ -77391,13 +77610,13 @@
 
 
   echo $ac_n "checking for openssl dependencies""... $ac_c" 1>&6
-echo "configure:77395: checking for openssl dependencies" >&5
+echo "configure:77614: checking for openssl dependencies" >&5
   if grep -q openssl $PGSQL_INCLUDE/libpq-fe.h ; then
     echo "$ac_t""yes" 1>&6
         # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:77401: checking for $ac_word" >&5
+echo "configure:77620: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PKG_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -77441,7 +77660,7 @@
   old_LDFLAGS=$LDFLAGS
   LDFLAGS="$LDFLAGS -L$PGSQL_LIBDIR"
   echo $ac_n "checking for PQescapeString in -lpq""... $ac_c" 1>&6
-echo "configure:77445: checking for PQescapeString in -lpq" >&5
+echo "configure:77664: checking for PQescapeString in -lpq" >&5
 ac_lib_var=`echo pq'_'PQescapeString | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77449,7 +77668,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77453 "configure"
+#line 77672 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77460,7 +77679,7 @@
 PQescapeString()
 ; return 0; }
 EOF
-if { (eval echo configure:77464: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77683: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77484,7 +77703,7 @@
 fi
 
   echo $ac_n "checking for PQescapeStringConn in -lpq""... $ac_c" 1>&6
-echo "configure:77488: checking for PQescapeStringConn in -lpq" >&5
+echo "configure:77707: checking for PQescapeStringConn in -lpq" >&5
 ac_lib_var=`echo pq'_'PQescapeStringConn | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77492,7 +77711,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77496 "configure"
+#line 77715 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77503,7 +77722,7 @@
 PQescapeStringConn()
 ; return 0; }
 EOF
-if { (eval echo configure:77507: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77726: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77527,7 +77746,7 @@
 fi
 
   echo $ac_n "checking for PQescapeByteaConn in -lpq""... $ac_c" 1>&6
-echo "configure:77531: checking for PQescapeByteaConn in -lpq" >&5
+echo "configure:77750: checking for PQescapeByteaConn in -lpq" >&5
 ac_lib_var=`echo pq'_'PQescapeByteaConn | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77535,7 +77754,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77539 "configure"
+#line 77758 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77546,7 +77765,7 @@
 PQescapeByteaConn()
 ; return 0; }
 EOF
-if { (eval echo configure:77550: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77769: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77570,7 +77789,7 @@
 fi
 
   echo $ac_n "checking for PQsetnonblocking in -lpq""... $ac_c" 1>&6
-echo "configure:77574: checking for PQsetnonblocking in -lpq" >&5
+echo "configure:77793: checking for PQsetnonblocking in -lpq" >&5
 ac_lib_var=`echo pq'_'PQsetnonblocking | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77578,7 +77797,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77582 "configure"
+#line 77801 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77589,7 +77808,7 @@
 PQsetnonblocking()
 ; return 0; }
 EOF
-if { (eval echo configure:77593: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77812: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77613,7 +77832,7 @@
 fi
 
   echo $ac_n "checking for PQcmdTuples in -lpq""... $ac_c" 1>&6
-echo "configure:77617: checking for PQcmdTuples in -lpq" >&5
+echo "configure:77836: checking for PQcmdTuples in -lpq" >&5
 ac_lib_var=`echo pq'_'PQcmdTuples | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77621,7 +77840,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77625 "configure"
+#line 77844 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77632,7 +77851,7 @@
 PQcmdTuples()
 ; return 0; }
 EOF
-if { (eval echo configure:77636: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77855: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77656,7 +77875,7 @@
 fi
 
   echo $ac_n "checking for PQoidValue in -lpq""... $ac_c" 1>&6
-echo "configure:77660: checking for PQoidValue in -lpq" >&5
+echo "configure:77879: checking for PQoidValue in -lpq" >&5
 ac_lib_var=`echo pq'_'PQoidValue | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77664,7 +77883,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77668 "configure"
+#line 77887 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77675,7 +77894,7 @@
 PQoidValue()
 ; return 0; }
 EOF
-if { (eval echo configure:77679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77898: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77699,7 +77918,7 @@
 fi
 
   echo $ac_n "checking for PQclientEncoding in -lpq""... $ac_c" 1>&6
-echo "configure:77703: checking for PQclientEncoding in -lpq" >&5
+echo "configure:77922: checking for PQclientEncoding in -lpq" >&5
 ac_lib_var=`echo pq'_'PQclientEncoding | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77707,7 +77926,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77711 "configure"
+#line 77930 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77718,7 +77937,7 @@
 PQclientEncoding()
 ; return 0; }
 EOF
-if { (eval echo configure:77722: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77941: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77742,7 +77961,7 @@
 fi
 
   echo $ac_n "checking for PQparameterStatus in -lpq""... $ac_c" 1>&6
-echo "configure:77746: checking for PQparameterStatus in -lpq" >&5
+echo "configure:77965: checking for PQparameterStatus in -lpq" >&5
 ac_lib_var=`echo pq'_'PQparameterStatus | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77750,7 +77969,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77754 "configure"
+#line 77973 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77761,7 +77980,7 @@
 PQparameterStatus()
 ; return 0; }
 EOF
-if { (eval echo configure:77765: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:77984: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77785,7 +78004,7 @@
 fi
 
   echo $ac_n "checking for PQprotocolVersion in -lpq""... $ac_c" 1>&6
-echo "configure:77789: checking for PQprotocolVersion in -lpq" >&5
+echo "configure:78008: checking for PQprotocolVersion in -lpq" >&5
 ac_lib_var=`echo pq'_'PQprotocolVersion | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77793,7 +78012,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77797 "configure"
+#line 78016 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77804,7 +78023,7 @@
 PQprotocolVersion()
 ; return 0; }
 EOF
-if { (eval echo configure:77808: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78027: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77828,7 +78047,7 @@
 fi
 
   echo $ac_n "checking for PQtransactionStatus in -lpq""... $ac_c" 1>&6
-echo "configure:77832: checking for PQtransactionStatus in -lpq" >&5
+echo "configure:78051: checking for PQtransactionStatus in -lpq" >&5
 ac_lib_var=`echo pq'_'PQtransactionStatus | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77836,7 +78055,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77840 "configure"
+#line 78059 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77847,7 +78066,7 @@
 PQtransactionStatus()
 ; return 0; }
 EOF
-if { (eval echo configure:77851: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78070: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77871,7 +78090,7 @@
 fi
 
   echo $ac_n "checking for PQunescapeBytea in -lpq""... $ac_c" 1>&6
-echo "configure:77875: checking for PQunescapeBytea in -lpq" >&5
+echo "configure:78094: checking for PQunescapeBytea in -lpq" >&5
 ac_lib_var=`echo pq'_'PQunescapeBytea | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77879,7 +78098,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77883 "configure"
+#line 78102 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77890,7 +78109,7 @@
 PQunescapeBytea()
 ; return 0; }
 EOF
-if { (eval echo configure:77894: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78113: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77914,7 +78133,7 @@
 fi
 
   echo $ac_n "checking for PQExecParams in -lpq""... $ac_c" 1>&6
-echo "configure:77918: checking for PQExecParams in -lpq" >&5
+echo "configure:78137: checking for PQExecParams in -lpq" >&5
 ac_lib_var=`echo pq'_'PQExecParams | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77922,7 +78141,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77926 "configure"
+#line 78145 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77933,7 +78152,7 @@
 PQExecParams()
 ; return 0; }
 EOF
-if { (eval echo configure:77937: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78156: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -77957,7 +78176,7 @@
 fi
 
   echo $ac_n "checking for PQfreemem in -lpq""... $ac_c" 1>&6
-echo "configure:77961: checking for PQfreemem in -lpq" >&5
+echo "configure:78180: checking for PQfreemem in -lpq" >&5
 ac_lib_var=`echo pq'_'PQfreemem | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -77965,7 +78184,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 77969 "configure"
+#line 78188 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -77976,7 +78195,7 @@
 PQfreemem()
 ; return 0; }
 EOF
-if { (eval echo configure:77980: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78199: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -78000,7 +78219,7 @@
 fi
 
   echo $ac_n "checking for PQresultErrorField in -lpq""... $ac_c" 1>&6
-echo "configure:78004: checking for PQresultErrorField in -lpq" >&5
+echo "configure:78223: checking for PQresultErrorField in -lpq" >&5
 ac_lib_var=`echo pq'_'PQresultErrorField | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -78008,7 +78227,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 78012 "configure"
+#line 78231 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -78019,7 +78238,7 @@
 PQresultErrorField()
 ; return 0; }
 EOF
-if { (eval echo configure:78023: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -78043,7 +78262,7 @@
 fi
 
   echo $ac_n "checking for pg_encoding_to_char in -lpq""... $ac_c" 1>&6
-echo "configure:78047: checking for pg_encoding_to_char in -lpq" >&5
+echo "configure:78266: checking for pg_encoding_to_char in -lpq" >&5
 ac_lib_var=`echo pq'_'pg_encoding_to_char | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -78051,7 +78270,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 78055 "configure"
+#line 78274 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -78062,7 +78281,7 @@
 pg_encoding_to_char()
 ; return 0; }
 EOF
-if { (eval echo configure:78066: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78285: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -78087,7 +78306,7 @@
 
   
   echo $ac_n "checking for PQprepare in -lpq""... $ac_c" 1>&6
-echo "configure:78091: checking for PQprepare in -lpq" >&5
+echo "configure:78310: checking for PQprepare in -lpq" >&5
 ac_lib_var=`echo pq'_'PQprepare | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -78095,7 +78314,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 78099 "configure"
+#line 78318 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -78106,7 +78325,7 @@
 PQprepare()
 ; return 0; }
 EOF
-if { (eval echo configure:78110: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:78329: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -78269,13 +78488,13 @@
   
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:78273: checking for PDO includes" >&5
+echo "configure:78492: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:78279: checking for PDO includes" >&5
+echo "configure:78498: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -78619,7 +78838,7 @@
 php_with_pdo_sqlite=yes
 
 echo $ac_n "checking for sqlite 3 support for PDO""... $ac_c" 1>&6
-echo "configure:78623: checking for sqlite 3 support for PDO" >&5
+echo "configure:78842: checking for sqlite 3 support for PDO" >&5
 # Check whether --with-pdo-sqlite or --without-pdo-sqlite was given.
 if test "${with_pdo_sqlite+set}" = set; then
   withval="$with_pdo_sqlite"
@@ -78667,13 +78886,13 @@
   
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:78671: checking for PDO includes" >&5
+echo "configure:78890: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:78677: checking for PDO includes" >&5
+echo "configure:78896: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -78702,7 +78921,7 @@
       PDO_SQLITE_DIR=$PHP_PDO_SQLITE
     else # search default path list
       echo $ac_n "checking for sqlite3 files in default path""... $ac_c" 1>&6
-echo "configure:78706: checking for sqlite3 files in default path" >&5
+echo "configure:78925: checking for sqlite3 files in default path" >&5
       for i in $SEARCH_PATH ; do
         if test -r $i/$SEARCH_FOR; then
           PDO_SQLITE_DIR=$i
@@ -78848,7 +79067,7 @@
   done
 
   echo $ac_n "checking for $LIBSYMBOL in -l$LIBNAME""... $ac_c" 1>&6
-echo "configure:78852: checking for $LIBSYMBOL in -l$LIBNAME" >&5
+echo "configure:79071: checking for $LIBSYMBOL in -l$LIBNAME" >&5
 ac_lib_var=`echo $LIBNAME'_'$LIBSYMBOL | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -78856,7 +79075,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 78860 "configure"
+#line 79079 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -78867,7 +79086,7 @@
 $LIBSYMBOL()
 ; return 0; }
 EOF
-if { (eval echo configure:78871: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:79090: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -79097,7 +79316,7 @@
   done
 
   echo $ac_n "checking for sqlite3_key in -lsqlite3""... $ac_c" 1>&6
-echo "configure:79101: checking for sqlite3_key in -lsqlite3" >&5
+echo "configure:79320: checking for sqlite3_key in -lsqlite3" >&5
 ac_lib_var=`echo sqlite3'_'sqlite3_key | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -79105,7 +79324,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsqlite3  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 79109 "configure"
+#line 79328 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -79116,7 +79335,7 @@
 sqlite3_key()
 ; return 0; }
 EOF
-if { (eval echo configure:79120: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:79339: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -79769,7 +79988,7 @@
   
 
       echo $ac_n "checking size of char *""... $ac_c" 1>&6
-echo "configure:79773: checking size of char *" >&5
+echo "configure:79992: checking size of char *" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -79777,18 +79996,19 @@
   ac_cv_sizeof_char_p=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 79781 "configure"
+#line 80000 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(char *));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:79792: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:80012: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char_p=`cat conftestval`
 else
@@ -79835,12 +80055,12 @@
       for ac_func in usleep nanosleep
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:79839: checking for $ac_func" >&5
+echo "configure:80059: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 79844 "configure"
+#line 80064 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -79863,7 +80083,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:79867: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80087: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -79891,17 +80111,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:79895: checking for $ac_hdr" >&5
+echo "configure:80115: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 79900 "configure"
+#line 80120 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:79905: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:80125: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -80025,7 +80245,7 @@
   done
 
   echo $ac_n "checking for fdatasync in -lrt""... $ac_c" 1>&6
-echo "configure:80029: checking for fdatasync in -lrt" >&5
+echo "configure:80249: checking for fdatasync in -lrt" >&5
 ac_lib_var=`echo rt'_'fdatasync | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80033,7 +80253,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lrt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80037 "configure"
+#line 80257 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80044,7 +80264,7 @@
 fdatasync()
 ; return 0; }
 EOF
-if { (eval echo configure:80048: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80268: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80127,7 +80347,7 @@
 php_with_pgsql=no
 
 echo $ac_n "checking for PostgreSQL support""... $ac_c" 1>&6
-echo "configure:80131: checking for PostgreSQL support" >&5
+echo "configure:80351: checking for PostgreSQL support" >&5
 # Check whether --with-pgsql or --without-pgsql was given.
 if test "${with_pgsql+set}" = set; then
   withval="$with_pgsql"
@@ -80184,7 +80404,7 @@
 
 
   echo $ac_n "checking for pg_config""... $ac_c" 1>&6
-echo "configure:80188: checking for pg_config" >&5
+echo "configure:80408: checking for pg_config" >&5
   for i in $PHP_PGSQL $PHP_PGSQL/bin /usr/local/pgsql/bin /usr/local/bin /usr/bin ""; do
 	if test -x $i/pg_config; then
       PG_CONFIG="$i/pg_config"
@@ -80252,7 +80472,7 @@
   old_LDFLAGS=$LDFLAGS
   LDFLAGS="$LDFLAGS -L$PGSQL_LIBDIR"
   echo $ac_n "checking for PQescapeString in -lpq""... $ac_c" 1>&6
-echo "configure:80256: checking for PQescapeString in -lpq" >&5
+echo "configure:80476: checking for PQescapeString in -lpq" >&5
 ac_lib_var=`echo pq'_'PQescapeString | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80260,7 +80480,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80264 "configure"
+#line 80484 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80271,7 +80491,7 @@
 PQescapeString()
 ; return 0; }
 EOF
-if { (eval echo configure:80275: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80495: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80295,7 +80515,7 @@
 fi
 
   echo $ac_n "checking for PQunescapeBytea in -lpq""... $ac_c" 1>&6
-echo "configure:80299: checking for PQunescapeBytea in -lpq" >&5
+echo "configure:80519: checking for PQunescapeBytea in -lpq" >&5
 ac_lib_var=`echo pq'_'PQunescapeBytea | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80303,7 +80523,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80307 "configure"
+#line 80527 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80314,7 +80534,7 @@
 PQunescapeBytea()
 ; return 0; }
 EOF
-if { (eval echo configure:80318: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80538: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80338,7 +80558,7 @@
 fi
 
   echo $ac_n "checking for PQsetnonblocking in -lpq""... $ac_c" 1>&6
-echo "configure:80342: checking for PQsetnonblocking in -lpq" >&5
+echo "configure:80562: checking for PQsetnonblocking in -lpq" >&5
 ac_lib_var=`echo pq'_'PQsetnonblocking | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80346,7 +80566,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80350 "configure"
+#line 80570 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80357,7 +80577,7 @@
 PQsetnonblocking()
 ; return 0; }
 EOF
-if { (eval echo configure:80361: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80581: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80381,7 +80601,7 @@
 fi
 
   echo $ac_n "checking for PQcmdTuples in -lpq""... $ac_c" 1>&6
-echo "configure:80385: checking for PQcmdTuples in -lpq" >&5
+echo "configure:80605: checking for PQcmdTuples in -lpq" >&5
 ac_lib_var=`echo pq'_'PQcmdTuples | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80389,7 +80609,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80393 "configure"
+#line 80613 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80400,7 +80620,7 @@
 PQcmdTuples()
 ; return 0; }
 EOF
-if { (eval echo configure:80404: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80624: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80424,7 +80644,7 @@
 fi
 
   echo $ac_n "checking for PQoidValue in -lpq""... $ac_c" 1>&6
-echo "configure:80428: checking for PQoidValue in -lpq" >&5
+echo "configure:80648: checking for PQoidValue in -lpq" >&5
 ac_lib_var=`echo pq'_'PQoidValue | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80432,7 +80652,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80436 "configure"
+#line 80656 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80443,7 +80663,7 @@
 PQoidValue()
 ; return 0; }
 EOF
-if { (eval echo configure:80447: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80667: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80467,7 +80687,7 @@
 fi
 
   echo $ac_n "checking for PQclientEncoding in -lpq""... $ac_c" 1>&6
-echo "configure:80471: checking for PQclientEncoding in -lpq" >&5
+echo "configure:80691: checking for PQclientEncoding in -lpq" >&5
 ac_lib_var=`echo pq'_'PQclientEncoding | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80475,7 +80695,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80479 "configure"
+#line 80699 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80486,7 +80706,7 @@
 PQclientEncoding()
 ; return 0; }
 EOF
-if { (eval echo configure:80490: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80710: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80510,7 +80730,7 @@
 fi
 
   echo $ac_n "checking for PQparameterStatus in -lpq""... $ac_c" 1>&6
-echo "configure:80514: checking for PQparameterStatus in -lpq" >&5
+echo "configure:80734: checking for PQparameterStatus in -lpq" >&5
 ac_lib_var=`echo pq'_'PQparameterStatus | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80518,7 +80738,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80522 "configure"
+#line 80742 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80529,7 +80749,7 @@
 PQparameterStatus()
 ; return 0; }
 EOF
-if { (eval echo configure:80533: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80553,7 +80773,7 @@
 fi
 
   echo $ac_n "checking for PQprotocolVersion in -lpq""... $ac_c" 1>&6
-echo "configure:80557: checking for PQprotocolVersion in -lpq" >&5
+echo "configure:80777: checking for PQprotocolVersion in -lpq" >&5
 ac_lib_var=`echo pq'_'PQprotocolVersion | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80561,7 +80781,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80565 "configure"
+#line 80785 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80572,7 +80792,7 @@
 PQprotocolVersion()
 ; return 0; }
 EOF
-if { (eval echo configure:80576: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80796: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80596,7 +80816,7 @@
 fi
 
   echo $ac_n "checking for PQtransactionStatus in -lpq""... $ac_c" 1>&6
-echo "configure:80600: checking for PQtransactionStatus in -lpq" >&5
+echo "configure:80820: checking for PQtransactionStatus in -lpq" >&5
 ac_lib_var=`echo pq'_'PQtransactionStatus | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80604,7 +80824,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80608 "configure"
+#line 80828 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80615,7 +80835,7 @@
 PQtransactionStatus()
 ; return 0; }
 EOF
-if { (eval echo configure:80619: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80839: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80639,7 +80859,7 @@
 fi
 
   echo $ac_n "checking for PQexecParams in -lpq""... $ac_c" 1>&6
-echo "configure:80643: checking for PQexecParams in -lpq" >&5
+echo "configure:80863: checking for PQexecParams in -lpq" >&5
 ac_lib_var=`echo pq'_'PQexecParams | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80647,7 +80867,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80651 "configure"
+#line 80871 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80658,7 +80878,7 @@
 PQexecParams()
 ; return 0; }
 EOF
-if { (eval echo configure:80662: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80882: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80682,7 +80902,7 @@
 fi
 
   echo $ac_n "checking for PQprepare in -lpq""... $ac_c" 1>&6
-echo "configure:80686: checking for PQprepare in -lpq" >&5
+echo "configure:80906: checking for PQprepare in -lpq" >&5
 ac_lib_var=`echo pq'_'PQprepare | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80690,7 +80910,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80694 "configure"
+#line 80914 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80701,7 +80921,7 @@
 PQprepare()
 ; return 0; }
 EOF
-if { (eval echo configure:80705: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80925: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80725,7 +80945,7 @@
 fi
 
   echo $ac_n "checking for PQexecPrepared in -lpq""... $ac_c" 1>&6
-echo "configure:80729: checking for PQexecPrepared in -lpq" >&5
+echo "configure:80949: checking for PQexecPrepared in -lpq" >&5
 ac_lib_var=`echo pq'_'PQexecPrepared | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80733,7 +80953,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80737 "configure"
+#line 80957 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80744,7 +80964,7 @@
 PQexecPrepared()
 ; return 0; }
 EOF
-if { (eval echo configure:80748: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:80968: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80768,7 +80988,7 @@
 fi
 
   echo $ac_n "checking for PQresultErrorField in -lpq""... $ac_c" 1>&6
-echo "configure:80772: checking for PQresultErrorField in -lpq" >&5
+echo "configure:80992: checking for PQresultErrorField in -lpq" >&5
 ac_lib_var=`echo pq'_'PQresultErrorField | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80776,7 +80996,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80780 "configure"
+#line 81000 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80787,7 +81007,7 @@
 PQresultErrorField()
 ; return 0; }
 EOF
-if { (eval echo configure:80791: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81011: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80811,7 +81031,7 @@
 fi
 
   echo $ac_n "checking for PQsendQueryParams in -lpq""... $ac_c" 1>&6
-echo "configure:80815: checking for PQsendQueryParams in -lpq" >&5
+echo "configure:81035: checking for PQsendQueryParams in -lpq" >&5
 ac_lib_var=`echo pq'_'PQsendQueryParams | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80819,7 +81039,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80823 "configure"
+#line 81043 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80830,7 +81050,7 @@
 PQsendQueryParams()
 ; return 0; }
 EOF
-if { (eval echo configure:80834: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81054: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80854,7 +81074,7 @@
 fi
 
   echo $ac_n "checking for PQsendPrepare in -lpq""... $ac_c" 1>&6
-echo "configure:80858: checking for PQsendPrepare in -lpq" >&5
+echo "configure:81078: checking for PQsendPrepare in -lpq" >&5
 ac_lib_var=`echo pq'_'PQsendPrepare | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80862,7 +81082,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80866 "configure"
+#line 81086 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80873,7 +81093,7 @@
 PQsendPrepare()
 ; return 0; }
 EOF
-if { (eval echo configure:80877: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81097: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80897,7 +81117,7 @@
 fi
 
   echo $ac_n "checking for PQsendQueryPrepared in -lpq""... $ac_c" 1>&6
-echo "configure:80901: checking for PQsendQueryPrepared in -lpq" >&5
+echo "configure:81121: checking for PQsendQueryPrepared in -lpq" >&5
 ac_lib_var=`echo pq'_'PQsendQueryPrepared | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80905,7 +81125,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80909 "configure"
+#line 81129 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80916,7 +81136,7 @@
 PQsendQueryPrepared()
 ; return 0; }
 EOF
-if { (eval echo configure:80920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81140: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80940,7 +81160,7 @@
 fi
 
   echo $ac_n "checking for PQputCopyData in -lpq""... $ac_c" 1>&6
-echo "configure:80944: checking for PQputCopyData in -lpq" >&5
+echo "configure:81164: checking for PQputCopyData in -lpq" >&5
 ac_lib_var=`echo pq'_'PQputCopyData | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80948,7 +81168,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80952 "configure"
+#line 81172 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -80959,7 +81179,7 @@
 PQputCopyData()
 ; return 0; }
 EOF
-if { (eval echo configure:80963: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81183: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -80983,7 +81203,7 @@
 fi
 
   echo $ac_n "checking for PQputCopyEnd in -lpq""... $ac_c" 1>&6
-echo "configure:80987: checking for PQputCopyEnd in -lpq" >&5
+echo "configure:81207: checking for PQputCopyEnd in -lpq" >&5
 ac_lib_var=`echo pq'_'PQputCopyEnd | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -80991,7 +81211,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 80995 "configure"
+#line 81215 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81002,7 +81222,7 @@
 PQputCopyEnd()
 ; return 0; }
 EOF
-if { (eval echo configure:81006: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81226: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81026,7 +81246,7 @@
 fi
 
   echo $ac_n "checking for PQgetCopyData in -lpq""... $ac_c" 1>&6
-echo "configure:81030: checking for PQgetCopyData in -lpq" >&5
+echo "configure:81250: checking for PQgetCopyData in -lpq" >&5
 ac_lib_var=`echo pq'_'PQgetCopyData | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81034,7 +81254,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81038 "configure"
+#line 81258 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81045,7 +81265,7 @@
 PQgetCopyData()
 ; return 0; }
 EOF
-if { (eval echo configure:81049: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81269: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81069,7 +81289,7 @@
 fi
 
   echo $ac_n "checking for PQfreemem in -lpq""... $ac_c" 1>&6
-echo "configure:81073: checking for PQfreemem in -lpq" >&5
+echo "configure:81293: checking for PQfreemem in -lpq" >&5
 ac_lib_var=`echo pq'_'PQfreemem | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81077,7 +81297,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81081 "configure"
+#line 81301 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81088,7 +81308,7 @@
 PQfreemem()
 ; return 0; }
 EOF
-if { (eval echo configure:81092: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81312: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81112,7 +81332,7 @@
 fi
 
   echo $ac_n "checking for PQsetErrorVerbosity in -lpq""... $ac_c" 1>&6
-echo "configure:81116: checking for PQsetErrorVerbosity in -lpq" >&5
+echo "configure:81336: checking for PQsetErrorVerbosity in -lpq" >&5
 ac_lib_var=`echo pq'_'PQsetErrorVerbosity | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81120,7 +81340,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81124 "configure"
+#line 81344 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81131,7 +81351,7 @@
 PQsetErrorVerbosity()
 ; return 0; }
 EOF
-if { (eval echo configure:81135: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81355: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81155,7 +81375,7 @@
 fi
 
   echo $ac_n "checking for PQftable in -lpq""... $ac_c" 1>&6
-echo "configure:81159: checking for PQftable in -lpq" >&5
+echo "configure:81379: checking for PQftable in -lpq" >&5
 ac_lib_var=`echo pq'_'PQftable | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81163,7 +81383,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81167 "configure"
+#line 81387 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81174,7 +81394,7 @@
 PQftable()
 ; return 0; }
 EOF
-if { (eval echo configure:81178: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81398: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81198,7 +81418,7 @@
 fi
 
   echo $ac_n "checking for PQescapeStringConn in -lpq""... $ac_c" 1>&6
-echo "configure:81202: checking for PQescapeStringConn in -lpq" >&5
+echo "configure:81422: checking for PQescapeStringConn in -lpq" >&5
 ac_lib_var=`echo pq'_'PQescapeStringConn | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81206,7 +81426,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81210 "configure"
+#line 81430 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81217,7 +81437,7 @@
 PQescapeStringConn()
 ; return 0; }
 EOF
-if { (eval echo configure:81221: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81441: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81241,7 +81461,7 @@
 fi
 
   echo $ac_n "checking for PQescapeByteaConn in -lpq""... $ac_c" 1>&6
-echo "configure:81245: checking for PQescapeByteaConn in -lpq" >&5
+echo "configure:81465: checking for PQescapeByteaConn in -lpq" >&5
 ac_lib_var=`echo pq'_'PQescapeByteaConn | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81249,7 +81469,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81253 "configure"
+#line 81473 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81260,7 +81480,7 @@
 PQescapeByteaConn()
 ; return 0; }
 EOF
-if { (eval echo configure:81264: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81484: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81284,7 +81504,7 @@
 fi
 
   echo $ac_n "checking for pg_encoding_to_char in -lpq""... $ac_c" 1>&6
-echo "configure:81288: checking for pg_encoding_to_char in -lpq" >&5
+echo "configure:81508: checking for pg_encoding_to_char in -lpq" >&5
 ac_lib_var=`echo pq'_'pg_encoding_to_char | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -81292,7 +81512,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 81296 "configure"
+#line 81516 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -81303,7 +81523,7 @@
 pg_encoding_to_char()
 ; return 0; }
 EOF
-if { (eval echo configure:81307: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:81527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -81763,7 +81983,7 @@
 php_enable_posix=yes
 
 echo $ac_n "checking whether to enable POSIX-like functions""... $ac_c" 1>&6
-echo "configure:81767: checking whether to enable POSIX-like functions" >&5
+echo "configure:81987: checking whether to enable POSIX-like functions" >&5
 # Check whether --enable-posix or --disable-posix was given.
 if test "${enable_posix+set}" = set; then
   enableval="$enable_posix"
@@ -82108,17 +82328,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:82112: checking for $ac_hdr" >&5
+echo "configure:82332: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 82117 "configure"
+#line 82337 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:82122: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:82342: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -82148,12 +82368,12 @@
   for ac_func in seteuid setegid setsid getsid setpgid getpgid ctermid mkfifo mknod getrlimit getlogin getgroups makedev initgroups getpwuid_r getgrgid_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:82152: checking for $ac_func" >&5
+echo "configure:82372: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 82157 "configure"
+#line 82377 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -82176,7 +82396,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:82180: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:82400: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -82202,14 +82422,14 @@
 
 
   echo $ac_n "checking for working ttyname_r() implementation""... $ac_c" 1>&6
-echo "configure:82206: checking for working ttyname_r() implementation" >&5
+echo "configure:82426: checking for working ttyname_r() implementation" >&5
   if test "$cross_compiling" = yes; then
   
     echo "$ac_t""no, cannot detect working ttyname_r() when cross compiling. posix_ttyname() will be thread-unsafe" 1>&6
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 82213 "configure"
+#line 82433 "configure"
 #include "confdefs.h"
 
 #include <unistd.h>
@@ -82222,7 +82442,7 @@
 }
   
 EOF
-if { (eval echo configure:82226: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:82446: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     echo "$ac_t""yes" 1>&6
@@ -82244,13 +82464,13 @@
 
 
   echo $ac_n "checking for utsname.domainname""... $ac_c" 1>&6
-echo "configure:82248: checking for utsname.domainname" >&5
+echo "configure:82468: checking for utsname.domainname" >&5
 if eval "test \"`echo '$''{'ac_cv_have_utsname_domainname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     cat > conftest.$ac_ext <<EOF
-#line 82254 "configure"
+#line 82474 "configure"
 #include "confdefs.h"
 
       #define _GNU_SOURCE
@@ -82262,7 +82482,7 @@
     
 ; return 0; }
 EOF
-if { (eval echo configure:82266: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:82486: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
       ac_cv_have_utsname_domainname=yes
@@ -82293,7 +82513,7 @@
 php_with_pspell=no
 
 echo $ac_n "checking for PSPELL support""... $ac_c" 1>&6
-echo "configure:82297: checking for PSPELL support" >&5
+echo "configure:82517: checking for PSPELL support" >&5
 # Check whether --with-pspell or --without-pspell was given.
 if test "${with_pspell+set}" = set; then
   withval="$with_pspell"
@@ -82846,7 +83066,7 @@
   done
 
   echo $ac_n "checking for new_aspell_config in -laspell""... $ac_c" 1>&6
-echo "configure:82850: checking for new_aspell_config in -laspell" >&5
+echo "configure:83070: checking for new_aspell_config in -laspell" >&5
 ac_lib_var=`echo aspell'_'new_aspell_config | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -82854,7 +83074,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-laspell  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 82858 "configure"
+#line 83078 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -82865,7 +83085,7 @@
 new_aspell_config()
 ; return 0; }
 EOF
-if { (eval echo configure:82869: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:83089: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83039,7 +83259,7 @@
 php_with_libedit=no
 
 echo $ac_n "checking for libedit readline replacement""... $ac_c" 1>&6
-echo "configure:83043: checking for libedit readline replacement" >&5
+echo "configure:83263: checking for libedit readline replacement" >&5
 # Check whether --with-libedit or --without-libedit was given.
 if test "${with_libedit+set}" = set; then
   withval="$with_libedit"
@@ -83087,7 +83307,7 @@
 php_with_readline=no
 
 echo $ac_n "checking for readline support""... $ac_c" 1>&6
-echo "configure:83091: checking for readline support" >&5
+echo "configure:83311: checking for readline support" >&5
 # Check whether --with-readline or --without-readline was given.
 if test "${with_readline+set}" = set; then
   withval="$with_readline"
@@ -83176,7 +83396,7 @@
 
   PHP_READLINE_LIBS=""
   echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
-echo "configure:83180: checking for tgetent in -lncurses" >&5
+echo "configure:83400: checking for tgetent in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83184,7 +83404,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83188 "configure"
+#line 83408 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83195,7 +83415,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:83199: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:83419: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83240,7 +83460,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
-echo "configure:83244: checking for tgetent in -ltermcap" >&5
+echo "configure:83464: checking for tgetent in -ltermcap" >&5
 ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83248,7 +83468,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltermcap  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83252 "configure"
+#line 83472 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83259,7 +83479,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:83263: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:83483: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83406,7 +83626,7 @@
   done
 
   echo $ac_n "checking for readline in -lreadline""... $ac_c" 1>&6
-echo "configure:83410: checking for readline in -lreadline" >&5
+echo "configure:83630: checking for readline in -lreadline" >&5
 ac_lib_var=`echo readline'_'readline | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83414,7 +83634,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lreadline  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83418 "configure"
+#line 83638 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83425,7 +83645,7 @@
 readline()
 ; return 0; }
 EOF
-if { (eval echo configure:83429: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:83649: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83654,7 +83874,7 @@
   done
 
   echo $ac_n "checking for rl_pending_input in -lreadline""... $ac_c" 1>&6
-echo "configure:83658: checking for rl_pending_input in -lreadline" >&5
+echo "configure:83878: checking for rl_pending_input in -lreadline" >&5
 ac_lib_var=`echo readline'_'rl_pending_input | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83662,7 +83882,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lreadline  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83666 "configure"
+#line 83886 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83673,7 +83893,7 @@
 rl_pending_input()
 ; return 0; }
 EOF
-if { (eval echo configure:83677: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:83897: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83804,7 +84024,7 @@
   done
 
   echo $ac_n "checking for rl_callback_read_char in -lreadline""... $ac_c" 1>&6
-echo "configure:83808: checking for rl_callback_read_char in -lreadline" >&5
+echo "configure:84028: checking for rl_callback_read_char in -lreadline" >&5
 ac_lib_var=`echo readline'_'rl_callback_read_char | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83812,7 +84032,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lreadline  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83816 "configure"
+#line 84036 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83823,7 +84043,7 @@
 rl_callback_read_char()
 ; return 0; }
 EOF
-if { (eval echo configure:83827: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:84047: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83907,7 +84127,7 @@
 
 
   echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
-echo "configure:83911: checking for tgetent in -lncurses" >&5
+echo "configure:84131: checking for tgetent in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83915,7 +84135,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83919 "configure"
+#line 84139 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83926,7 +84146,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:83930: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:84150: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -83970,7 +84190,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
-echo "configure:83974: checking for tgetent in -ltermcap" >&5
+echo "configure:84194: checking for tgetent in -ltermcap" >&5
 ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -83978,7 +84198,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltermcap  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 83982 "configure"
+#line 84202 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -83989,7 +84209,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:83993: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:84213: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -84135,7 +84355,7 @@
   done
 
   echo $ac_n "checking for readline in -ledit""... $ac_c" 1>&6
-echo "configure:84139: checking for readline in -ledit" >&5
+echo "configure:84359: checking for readline in -ledit" >&5
 ac_lib_var=`echo edit'_'readline | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -84143,7 +84363,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ledit  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 84147 "configure"
+#line 84367 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -84154,7 +84374,7 @@
 readline()
 ; return 0; }
 EOF
-if { (eval echo configure:84158: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:84378: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -84295,12 +84515,12 @@
   for ac_func in rl_completion_matches
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:84299: checking for $ac_func" >&5
+echo "configure:84519: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 84304 "configure"
+#line 84524 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -84323,7 +84543,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:84327: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:84547: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -84649,7 +84869,7 @@
 php_with_recode=no
 
 echo $ac_n "checking for recode support""... $ac_c" 1>&6
-echo "configure:84653: checking for recode support" >&5
+echo "configure:84873: checking for recode support" >&5
 # Check whether --with-recode or --without-recode was given.
 if test "${with_recode+set}" = set; then
   withval="$with_recode"
@@ -84816,7 +85036,7 @@
   done
 
   echo $ac_n "checking for recode_format_table in -lrecode""... $ac_c" 1>&6
-echo "configure:84820: checking for recode_format_table in -lrecode" >&5
+echo "configure:85040: checking for recode_format_table in -lrecode" >&5
 ac_lib_var=`echo recode'_'recode_format_table | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -84824,7 +85044,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lrecode  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 84828 "configure"
+#line 85048 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -84835,7 +85055,7 @@
 recode_format_table()
 ; return 0; }
 EOF
-if { (eval echo configure:84839: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:85059: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -84965,7 +85185,7 @@
     LDFLAGS="$LDFLAGS -L$RECODE_DIR/$RECODE_LIB"
     LIBS="$LIBS -lrecode"
     cat > conftest.$ac_ext <<EOF
-#line 84969 "configure"
+#line 85189 "configure"
 #include "confdefs.h"
 
 char *program_name;
@@ -84976,7 +85196,7 @@
     
 ; return 0; }
 EOF
-if { (eval echo configure:84980: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:85200: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
       
@@ -85139,17 +85359,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:85143: checking for $ac_hdr" >&5
+echo "configure:85363: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 85148 "configure"
+#line 85368 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:85153: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:85373: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -85474,7 +85694,7 @@
 php_enable_reflection=yes
 
 echo $ac_n "checking whether to enable reflection support""... $ac_c" 1>&6
-echo "configure:85478: checking whether to enable reflection support" >&5
+echo "configure:85698: checking whether to enable reflection support" >&5
 # Check whether --enable-reflection or --disable-reflection was given.
 if test "${enable_reflection+set}" = set; then
   enableval="$enable_reflection"
@@ -85800,7 +86020,7 @@
 php_enable_session=yes
 
 echo $ac_n "checking whether to enable PHP sessions""... $ac_c" 1>&6
-echo "configure:85804: checking whether to enable PHP sessions" >&5
+echo "configure:86024: checking whether to enable PHP sessions" >&5
 # Check whether --enable-session or --disable-session was given.
 if test "${enable_session+set}" = set; then
   enableval="$enable_session"
@@ -85847,7 +86067,7 @@
 php_with_mm=no
 
 echo $ac_n "checking for mm support""... $ac_c" 1>&6
-echo "configure:85851: checking for mm support" >&5
+echo "configure:86071: checking for mm support" >&5
 # Check whether --with-mm or --without-mm was given.
 if test "${with_mm+set}" = set; then
   withval="$with_mm"
@@ -85872,7 +86092,7 @@
 if test "$PHP_SESSION" != "no"; then
   
   echo $ac_n "checking whether pwrite works""... $ac_c" 1>&6
-echo "configure:85876: checking whether pwrite works" >&5
+echo "configure:86096: checking whether pwrite works" >&5
 if eval "test \"`echo '$''{'ac_cv_pwrite'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -85884,7 +86104,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 85888 "configure"
+#line 86108 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -85905,7 +86125,7 @@
 
   
 EOF
-if { (eval echo configure:85909: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:86129: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     ac_cv_pwrite=yes
@@ -85930,7 +86150,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 85934 "configure"
+#line 86154 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -85951,7 +86171,7 @@
 
   
 EOF
-if { (eval echo configure:85955: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:86175: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     ac_cv_pwrite=yes
@@ -85992,7 +86212,7 @@
 
   
   echo $ac_n "checking whether pread works""... $ac_c" 1>&6
-echo "configure:85996: checking whether pread works" >&5
+echo "configure:86216: checking whether pread works" >&5
 if eval "test \"`echo '$''{'ac_cv_pread'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -86005,7 +86225,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 86009 "configure"
+#line 86229 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -86025,7 +86245,7 @@
     }
   
 EOF
-if { (eval echo configure:86029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:86249: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     ac_cv_pread=yes
@@ -86052,7 +86272,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 86056 "configure"
+#line 86276 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -86072,7 +86292,7 @@
     }
   
 EOF
-if { (eval echo configure:86076: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:86296: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     ac_cv_pread=yes
@@ -86617,7 +86837,7 @@
 php_enable_shmop=no
 
 echo $ac_n "checking whether to enable shmop support""... $ac_c" 1>&6
-echo "configure:86621: checking whether to enable shmop support" >&5
+echo "configure:86841: checking whether to enable shmop support" >&5
 # Check whether --enable-shmop or --disable-shmop was given.
 if test "${enable_shmop+set}" = set; then
   enableval="$enable_shmop"
@@ -86964,7 +87184,7 @@
 php_enable_simplexml=yes
 
 echo $ac_n "checking whether to enable SimpleXML support""... $ac_c" 1>&6
-echo "configure:86968: checking whether to enable SimpleXML support" >&5
+echo "configure:87188: checking whether to enable SimpleXML support" >&5
 # Check whether --enable-simplexml or --disable-simplexml was given.
 if test "${enable_simplexml+set}" = set; then
   enableval="$enable_simplexml"
@@ -87012,7 +87232,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:87016: checking libxml2 install dir" >&5
+echo "configure:87236: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -87043,7 +87263,7 @@
 
   
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:87047: checking for xml2-config path" >&5
+echo "configure:87267: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -87201,7 +87421,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:87205: checking whether libxml build works" >&5
+echo "configure:87425: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -87217,7 +87437,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 87221 "configure"
+#line 87441 "configure"
 #include "confdefs.h"
 
     
@@ -87228,7 +87448,7 @@
     }
   
 EOF
-if { (eval echo configure:87232: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:87452: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -87616,7 +87836,7 @@
 php_with_snmp=no
 
 echo $ac_n "checking for SNMP support""... $ac_c" 1>&6
-echo "configure:87620: checking for SNMP support" >&5
+echo "configure:87840: checking for SNMP support" >&5
 # Check whether --with-snmp or --without-snmp was given.
 if test "${with_snmp+set}" = set; then
   withval="$with_snmp"
@@ -87663,7 +87883,7 @@
 php_with_openssl_dir=no
 
 echo $ac_n "checking OpenSSL dir for SNMP""... $ac_c" 1>&6
-echo "configure:87667: checking OpenSSL dir for SNMP" >&5
+echo "configure:87887: checking OpenSSL dir for SNMP" >&5
 # Check whether --with-openssl-dir or --without-openssl-dir was given.
 if test "${with_openssl_dir+set}" = set; then
   withval="$with_openssl_dir"
@@ -87689,7 +87909,7 @@
 php_enable_ucd_snmp_hack=no
 
 echo $ac_n "checking whether to enable UCD SNMP hack""... $ac_c" 1>&6
-echo "configure:87693: checking whether to enable UCD SNMP hack" >&5
+echo "configure:87913: checking whether to enable UCD SNMP hack" >&5
 # Check whether --enable-ucd-snmp-hack or --disable-ucd-snmp-hack was given.
 if test "${enable_ucd_snmp_hack+set}" = set; then
   enableval="$enable_ucd_snmp_hack"
@@ -87717,7 +87937,7 @@
     # Extract the first word of "net-snmp-config", so it can be a program name with args.
 set dummy net-snmp-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:87721: checking for $ac_word" >&5
+echo "configure:87941: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SNMP_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -87918,17 +88138,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:87922: checking for $ac_hdr" >&5
+echo "configure:88142: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 87927 "configure"
+#line 88147 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:87932: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:88152: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -87956,9 +88176,9 @@
 
     if test "$ac_cv_header_default_store_h" = "yes"; then
       echo $ac_n "checking for OpenSSL support in SNMP libraries""... $ac_c" 1>&6
-echo "configure:87960: checking for OpenSSL support in SNMP libraries" >&5
+echo "configure:88180: checking for OpenSSL support in SNMP libraries" >&5
       cat > conftest.$ac_ext <<EOF
-#line 87962 "configure"
+#line 88182 "configure"
 #include "confdefs.h"
 
 #include <ucd-snmp-config.h>
@@ -88013,7 +88233,7 @@
     # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:88017: checking for $ac_word" >&5
+echo "configure:88237: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PKG_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -88218,9 +88438,9 @@
     old_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=-I$OPENSSL_INCDIR
     echo $ac_n "checking for OpenSSL version""... $ac_c" 1>&6
-echo "configure:88222: checking for OpenSSL version" >&5
+echo "configure:88442: checking for OpenSSL version" >&5
     cat > conftest.$ac_ext <<EOF
-#line 88224 "configure"
+#line 88444 "configure"
 #include "confdefs.h"
 
 #include <openssl/opensslv.h>
@@ -88375,7 +88595,7 @@
   done
 
   echo $ac_n "checking for CRYPTO_free in -lcrypto""... $ac_c" 1>&6
-echo "configure:88379: checking for CRYPTO_free in -lcrypto" >&5
+echo "configure:88599: checking for CRYPTO_free in -lcrypto" >&5
 ac_lib_var=`echo crypto'_'CRYPTO_free | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -88383,7 +88603,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 88387 "configure"
+#line 88607 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -88394,7 +88614,7 @@
 CRYPTO_free()
 ; return 0; }
 EOF
-if { (eval echo configure:88398: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:88618: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -88551,7 +88771,7 @@
   done
 
   echo $ac_n "checking for SSL_CTX_set_ssl_version in -lssl""... $ac_c" 1>&6
-echo "configure:88555: checking for SSL_CTX_set_ssl_version in -lssl" >&5
+echo "configure:88775: checking for SSL_CTX_set_ssl_version in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_CTX_set_ssl_version | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -88559,7 +88779,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 88563 "configure"
+#line 88783 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -88570,7 +88790,7 @@
 SSL_CTX_set_ssl_version()
 ; return 0; }
 EOF
-if { (eval echo configure:88574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:88794: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -88683,7 +88903,7 @@
     fi
 
     echo $ac_n "checking for kstat_read in -lkstat""... $ac_c" 1>&6
-echo "configure:88687: checking for kstat_read in -lkstat" >&5
+echo "configure:88907: checking for kstat_read in -lkstat" >&5
 ac_lib_var=`echo kstat'_'kstat_read | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -88691,7 +88911,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lkstat  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 88695 "configure"
+#line 88915 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -88702,7 +88922,7 @@
 kstat_read()
 ; return 0; }
 EOF
-if { (eval echo configure:88706: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:88926: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -88973,7 +89193,7 @@
   done
 
   echo $ac_n "checking for snmp_parse_oid in -l$SNMP_LIBNAME""... $ac_c" 1>&6
-echo "configure:88977: checking for snmp_parse_oid in -l$SNMP_LIBNAME" >&5
+echo "configure:89197: checking for snmp_parse_oid in -l$SNMP_LIBNAME" >&5
 ac_lib_var=`echo $SNMP_LIBNAME'_'snmp_parse_oid | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -88981,7 +89201,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$SNMP_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 88985 "configure"
+#line 89205 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -88992,7 +89212,7 @@
 snmp_parse_oid()
 ; return 0; }
 EOF
-if { (eval echo configure:88996: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:89216: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -89126,7 +89346,7 @@
   done
 
   echo $ac_n "checking for init_snmp in -l$SNMP_LIBNAME""... $ac_c" 1>&6
-echo "configure:89130: checking for init_snmp in -l$SNMP_LIBNAME" >&5
+echo "configure:89350: checking for init_snmp in -l$SNMP_LIBNAME" >&5
 ac_lib_var=`echo $SNMP_LIBNAME'_'init_snmp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -89134,7 +89354,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$SNMP_LIBNAME  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 89138 "configure"
+#line 89358 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -89145,7 +89365,7 @@
 init_snmp()
 ; return 0; }
 EOF
-if { (eval echo configure:89149: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:89369: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -89492,7 +89712,7 @@
 php_enable_soap=no
 
 echo $ac_n "checking whether to enable SOAP support""... $ac_c" 1>&6
-echo "configure:89496: checking whether to enable SOAP support" >&5
+echo "configure:89716: checking whether to enable SOAP support" >&5
 # Check whether --enable-soap or --disable-soap was given.
 if test "${enable_soap+set}" = set; then
   enableval="$enable_soap"
@@ -89540,7 +89760,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:89544: checking libxml2 install dir" >&5
+echo "configure:89764: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -89571,7 +89791,7 @@
 
   
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:89575: checking for xml2-config path" >&5
+echo "configure:89795: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -89729,7 +89949,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:89733: checking whether libxml build works" >&5
+echo "configure:89953: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -89745,7 +89965,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 89749 "configure"
+#line 89969 "configure"
 #include "confdefs.h"
 
     
@@ -89756,7 +89976,7 @@
     }
   
 EOF
-if { (eval echo configure:89760: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:89980: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -90106,7 +90326,7 @@
 php_enable_sockets=no
 
 echo $ac_n "checking whether to enable sockets support""... $ac_c" 1>&6
-echo "configure:90110: checking whether to enable sockets support" >&5
+echo "configure:90330: checking whether to enable sockets support" >&5
 # Check whether --enable-sockets or --disable-sockets was given.
 if test "${enable_sockets+set}" = set; then
   enableval="$enable_sockets"
@@ -90151,13 +90371,13 @@
 
 if test "$PHP_SOCKETS" != "no"; then
     echo $ac_n "checking for struct cmsghdr""... $ac_c" 1>&6
-echo "configure:90155: checking for struct cmsghdr" >&5
+echo "configure:90375: checking for struct cmsghdr" >&5
 if eval "test \"`echo '$''{'ac_cv_cmsghdr'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     cat > conftest.$ac_ext <<EOF
-#line 90161 "configure"
+#line 90381 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -90166,7 +90386,7 @@
 struct cmsghdr s; s
 ; return 0; }
 EOF
-if { (eval echo configure:90170: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:90390: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_cmsghdr=yes
 else
@@ -90191,12 +90411,12 @@
   for ac_func in hstrerror socketpair
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:90195: checking for $ac_func" >&5
+echo "configure:90415: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 90200 "configure"
+#line 90420 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -90219,7 +90439,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:90223: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:90443: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -90247,17 +90467,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:90251: checking for $ac_hdr" >&5
+echo "configure:90471: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 90256 "configure"
+#line 90476 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:90261: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:90481: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -90284,7 +90504,7 @@
 done
 
   cat > conftest.$ac_ext <<EOF
-#line 90288 "configure"
+#line 90508 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -90294,7 +90514,7 @@
 static struct msghdr tp; int n = (int) tp.msg_flags; return n
 ; return 0; }
 EOF
-if { (eval echo configure:90298: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:90518: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
@@ -90611,7 +90831,7 @@
 php_enable_spl=yes
 
 echo $ac_n "checking enable SPL suppport""... $ac_c" 1>&6
-echo "configure:90615: checking enable SPL suppport" >&5
+echo "configure:90835: checking enable SPL suppport" >&5
 # Check whether --enable-spl or --disable-spl was given.
 if test "${enable_spl+set}" = set; then
   enableval="$enable_spl"
@@ -90656,7 +90876,7 @@
 
 if test "$PHP_SPL" != "no"; then
   echo $ac_n "checking whether zend_object_value is packed""... $ac_c" 1>&6
-echo "configure:90660: checking whether zend_object_value is packed" >&5
+echo "configure:90880: checking whether zend_object_value is packed" >&5
   old_CPPFLAGS=$CPPFLAGS
   CPPFLAGS="$INCLUDES -I$abs_srcdir $CPPFLAGS"
   if test "$cross_compiling" = yes; then
@@ -90666,7 +90886,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 90670 "configure"
+#line 90890 "configure"
 #include "confdefs.h"
 
 #include "Zend/zend_types.h"
@@ -90675,7 +90895,7 @@
 }
   
 EOF
-if { (eval echo configure:90679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:90899: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     ac_result=1
@@ -91040,7 +91260,7 @@
 php_with_sqlite=yes
 
 echo $ac_n "checking for sqlite support""... $ac_c" 1>&6
-echo "configure:91044: checking for sqlite support" >&5
+echo "configure:91264: checking for sqlite support" >&5
 # Check whether --with-sqlite or --without-sqlite was given.
 if test "${with_sqlite+set}" = set; then
   withval="$with_sqlite"
@@ -91087,7 +91307,7 @@
 php_enable_sqlite_utf8=no
 
 echo $ac_n "checking whether to enable UTF-8 support in sqlite (default: ISO-8859-1)""... $ac_c" 1>&6
-echo "configure:91091: checking whether to enable UTF-8 support in sqlite (default: ISO-8859-1)" >&5
+echo "configure:91311: checking whether to enable UTF-8 support in sqlite (default: ISO-8859-1)" >&5
 # Check whether --enable-sqlite-utf8 or --disable-sqlite-utf8 was given.
 if test "${enable_sqlite_utf8+set}" = set; then
   enableval="$enable_sqlite_utf8"
@@ -91118,13 +91338,13 @@
   if test "$PHP_PDO" != "no"; then
     
   echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:91122: checking for PDO includes" >&5
+echo "configure:91342: checking for PDO includes" >&5
 if eval "test \"`echo '$''{'pdo_inc_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     echo $ac_n "checking for PDO includes""... $ac_c" 1>&6
-echo "configure:91128: checking for PDO includes" >&5
+echo "configure:91348: checking for PDO includes" >&5
     if test -f $abs_srcdir/include/php/ext/pdo/php_pdo_driver.h; then
       pdo_inc_path=$abs_srcdir/ext
     elif test -f $abs_srcdir/ext/pdo/php_pdo_driver.h; then
@@ -91158,7 +91378,7 @@
       SQLITE_DIR=$PHP_SQLITE
     else # search default path list
       echo $ac_n "checking for sqlite files in default path""... $ac_c" 1>&6
-echo "configure:91162: checking for sqlite files in default path" >&5
+echo "configure:91382: checking for sqlite files in default path" >&5
       for i in $SEARCH_PATH ; do
         if test -r $i/$SEARCH_FOR; then
           SQLITE_DIR=$i
@@ -91270,7 +91490,7 @@
   done
 
   echo $ac_n "checking for sqlite_open in -lsqlite""... $ac_c" 1>&6
-echo "configure:91274: checking for sqlite_open in -lsqlite" >&5
+echo "configure:91494: checking for sqlite_open in -lsqlite" >&5
 ac_lib_var=`echo sqlite'_'sqlite_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -91278,7 +91498,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsqlite  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 91282 "configure"
+#line 91502 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -91289,7 +91509,7 @@
 sqlite_open()
 ; return 0; }
 EOF
-if { (eval echo configure:91293: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:91513: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -91462,7 +91682,7 @@
   # Extract the first word of "lemon", so it can be a program name with args.
 set dummy lemon; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:91466: checking for $ac_word" >&5
+echo "configure:91686: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LEMON'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -91490,7 +91710,7 @@
 
   if test "$LEMON"; then
     echo $ac_n "checking for lemon version""... $ac_c" 1>&6
-echo "configure:91494: checking for lemon version" >&5
+echo "configure:91714: checking for lemon version" >&5
 if eval "test \"`echo '$''{'php_cv_lemon_version'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -91903,7 +92123,7 @@
   
 
     echo $ac_n "checking size of char *""... $ac_c" 1>&6
-echo "configure:91907: checking size of char *" >&5
+echo "configure:92127: checking size of char *" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -91911,18 +92131,19 @@
   ac_cv_sizeof_char_p=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 91915 "configure"
+#line 92135 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(char *));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:91926: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92147: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char_p=`cat conftestval`
 else
@@ -91984,12 +92205,12 @@
   for ac_func in usleep nanosleep
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:91988: checking for $ac_func" >&5
+echo "configure:92209: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 91993 "configure"
+#line 92214 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -92012,7 +92233,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:92016: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:92237: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -92040,17 +92261,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:92044: checking for $ac_hdr" >&5
+echo "configure:92265: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 92049 "configure"
+#line 92270 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:92054: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:92275: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -92081,7 +92302,7 @@
 
 
 echo $ac_n "checking whether flush should be called explicitly after a buffered io""... $ac_c" 1>&6
-echo "configure:92085: checking whether flush should be called explicitly after a buffered io" >&5
+echo "configure:92306: checking whether flush should be called explicitly after a buffered io" >&5
 if eval "test \"`echo '$''{'ac_cv_flush_io'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -92092,7 +92313,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 92096 "configure"
+#line 92317 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -92130,7 +92351,7 @@
 }
 
 EOF
-if { (eval echo configure:92134: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92355: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_flush_io=no
@@ -92158,7 +92379,7 @@
 
 if test "$ac_cv_func_crypt" = "no"; then
   echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
-echo "configure:92162: checking for crypt in -lcrypt" >&5
+echo "configure:92383: checking for crypt in -lcrypt" >&5
 ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -92166,7 +92387,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 92170 "configure"
+#line 92391 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -92177,7 +92398,7 @@
 crypt()
 ; return 0; }
 EOF
-if { (eval echo configure:92181: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:92402: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -92206,7 +92427,7 @@
 fi
   
 echo $ac_n "checking for standard DES crypt""... $ac_c" 1>&6
-echo "configure:92210: checking for standard DES crypt" >&5
+echo "configure:92431: checking for standard DES crypt" >&5
 if eval "test \"`echo '$''{'ac_cv_crypt_des'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -92217,7 +92438,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 92221 "configure"
+#line 92442 "configure"
 #include "confdefs.h"
 
 #if HAVE_UNISTD_H
@@ -92236,7 +92457,7 @@
 #endif
 }
 EOF
-if { (eval echo configure:92240: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92461: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_crypt_des=yes
@@ -92266,7 +92487,7 @@
 
 
 echo $ac_n "checking for extended DES crypt""... $ac_c" 1>&6
-echo "configure:92270: checking for extended DES crypt" >&5
+echo "configure:92491: checking for extended DES crypt" >&5
 if eval "test \"`echo '$''{'ac_cv_crypt_ext_des'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -92277,7 +92498,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 92281 "configure"
+#line 92502 "configure"
 #include "confdefs.h"
 
 #if HAVE_UNISTD_H
@@ -92296,7 +92517,7 @@
 #endif
 }
 EOF
-if { (eval echo configure:92300: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92521: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_crypt_ext_des=yes
@@ -92326,7 +92547,7 @@
 
 
 echo $ac_n "checking for MD5 crypt""... $ac_c" 1>&6
-echo "configure:92330: checking for MD5 crypt" >&5
+echo "configure:92551: checking for MD5 crypt" >&5
 if eval "test \"`echo '$''{'ac_cv_crypt_md5'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -92337,7 +92558,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 92341 "configure"
+#line 92562 "configure"
 #include "confdefs.h"
 
 #if HAVE_UNISTD_H
@@ -92365,7 +92586,7 @@
 #endif
 }
 EOF
-if { (eval echo configure:92369: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92590: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_crypt_md5=yes
@@ -92424,7 +92645,7 @@
 
 
 echo $ac_n "checking for Blowfish crypt""... $ac_c" 1>&6
-echo "configure:92428: checking for Blowfish crypt" >&5
+echo "configure:92649: checking for Blowfish crypt" >&5
 if eval "test \"`echo '$''{'ac_cv_crypt_blowfish'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -92435,7 +92656,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 92439 "configure"
+#line 92660 "configure"
 #include "confdefs.h"
 
 #if HAVE_UNISTD_H
@@ -92460,7 +92681,7 @@
 #endif
 }
 EOF
-if { (eval echo configure:92464: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92685: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_crypt_blowfish=yes
@@ -92492,12 +92713,12 @@
 for ac_func in getcwd getwd asinh acosh atanh log1p hypot glob strfmon nice fpclass isinf isnan
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:92496: checking for $ac_func" >&5
+echo "configure:92717: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 92501 "configure"
+#line 92722 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -92520,7 +92741,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:92524: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:92745: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -92545,7 +92766,7 @@
 done
 
 echo $ac_n "checking for working fnmatch""... $ac_c" 1>&6
-echo "configure:92549: checking for working fnmatch" >&5
+echo "configure:92770: checking for working fnmatch" >&5
 if eval "test \"`echo '$''{'ac_cv_func_fnmatch_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -92556,11 +92777,11 @@
   ac_cv_func_fnmatch_works=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 92560 "configure"
+#line 92781 "configure"
 #include "confdefs.h"
 main() { exit (fnmatch ("a*", "abc", 0) != 0); }
 EOF
-if { (eval echo configure:92564: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92785: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_fnmatch_works=yes
 else
@@ -92691,13 +92912,13 @@
 EOF
 
     echo $ac_n "checking whether field re_magic exists in struct regex_t""... $ac_c" 1>&6
-echo "configure:92695: checking whether field re_magic exists in struct regex_t" >&5
+echo "configure:92916: checking whether field re_magic exists in struct regex_t" >&5
 if eval "test \"`echo '$''{'ac_cv_regex_t_re_magic'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 92701 "configure"
+#line 92922 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <regex.h>
@@ -92705,7 +92926,7 @@
 regex_t rt; rt.re_magic;
 ; return 0; }
 EOF
-if { (eval echo configure:92709: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:92930: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_regex_t_re_magic=yes
 else
@@ -92726,11 +92947,11 @@
   fi 
 fi   
 echo $ac_n "checking which regex library to use""... $ac_c" 1>&6
-echo "configure:92730: checking which regex library to use" >&5
+echo "configure:92951: checking which regex library to use" >&5
 echo "$ac_t""$REGEX_TYPE" 1>&6
 
 echo $ac_n "checking whether rounding works as expected""... $ac_c" 1>&6
-echo "configure:92734: checking whether rounding works as expected" >&5
+echo "configure:92955: checking whether rounding works as expected" >&5
 if test "$cross_compiling" = yes; then
   
   PHP_ROUND_FUZZ=0.50000000001
@@ -92738,7 +92959,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 92742 "configure"
+#line 92963 "configure"
 #include "confdefs.h"
 
 #include <math.h>
@@ -92751,7 +92972,7 @@
   }
 
 EOF
-if { (eval echo configure:92755: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:92976: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   PHP_ROUND_FUZZ=0.5
@@ -92777,12 +92998,12 @@
 for ac_func in fork CreateProcess
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:92781: checking for $ac_func" >&5
+echo "configure:93002: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 92786 "configure"
+#line 93007 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -92805,7 +93026,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:92809: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93030: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -92836,7 +93057,7 @@
 
 
 echo $ac_n "checking if your OS can spawn processes with inherited handles""... $ac_c" 1>&6
-echo "configure:92840: checking if your OS can spawn processes with inherited handles" >&5
+echo "configure:93061: checking if your OS can spawn processes with inherited handles" >&5
 if test "$php_can_support_proc_open" = "yes"; then
   echo "$ac_t""yes" 1>&6
   cat >> confdefs.h <<\EOF
@@ -92861,12 +93082,12 @@
   unset found
   
   echo $ac_n "checking for res_nmkquery""... $ac_c" 1>&6
-echo "configure:92865: checking for res_nmkquery" >&5
+echo "configure:93086: checking for res_nmkquery" >&5
 if eval "test \"`echo '$''{'ac_cv_func_res_nmkquery'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 92870 "configure"
+#line 93091 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char res_nmkquery(); below.  */
@@ -92889,7 +93110,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:92893: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93114: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_res_nmkquery=yes"
 else
@@ -92907,12 +93128,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __res_nmkquery""... $ac_c" 1>&6
-echo "configure:92911: checking for __res_nmkquery" >&5
+echo "configure:93132: checking for __res_nmkquery" >&5
 if eval "test \"`echo '$''{'ac_cv_func___res_nmkquery'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 92916 "configure"
+#line 93137 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __res_nmkquery(); below.  */
@@ -92935,7 +93156,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:92939: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93160: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___res_nmkquery=yes"
 else
@@ -92973,7 +93194,7 @@
   unset ac_cv_lib_resolv___res_nmkquery
   unset found
   echo $ac_n "checking for res_nmkquery in -lresolv""... $ac_c" 1>&6
-echo "configure:92977: checking for res_nmkquery in -lresolv" >&5
+echo "configure:93198: checking for res_nmkquery in -lresolv" >&5
 ac_lib_var=`echo resolv'_'res_nmkquery | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -92981,7 +93202,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 92985 "configure"
+#line 93206 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -92992,7 +93213,7 @@
 res_nmkquery()
 ; return 0; }
 EOF
-if { (eval echo configure:92996: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93217: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93012,7 +93233,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_nmkquery in -lresolv""... $ac_c" 1>&6
-echo "configure:93016: checking for __res_nmkquery in -lresolv" >&5
+echo "configure:93237: checking for __res_nmkquery in -lresolv" >&5
 ac_lib_var=`echo resolv'_'__res_nmkquery | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93020,7 +93241,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93024 "configure"
+#line 93245 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93031,7 +93252,7 @@
 __res_nmkquery()
 ; return 0; }
 EOF
-if { (eval echo configure:93035: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93256: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93063,11 +93284,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 93067 "configure"
+#line 93288 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:93071: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:93292: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -93109,7 +93330,7 @@
   unset ac_cv_lib_bind___res_nmkquery
   unset found
   echo $ac_n "checking for res_nmkquery in -lbind""... $ac_c" 1>&6
-echo "configure:93113: checking for res_nmkquery in -lbind" >&5
+echo "configure:93334: checking for res_nmkquery in -lbind" >&5
 ac_lib_var=`echo bind'_'res_nmkquery | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93117,7 +93338,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93121 "configure"
+#line 93342 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93128,7 +93349,7 @@
 res_nmkquery()
 ; return 0; }
 EOF
-if { (eval echo configure:93132: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93353: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93148,7 +93369,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_nmkquery in -lbind""... $ac_c" 1>&6
-echo "configure:93152: checking for __res_nmkquery in -lbind" >&5
+echo "configure:93373: checking for __res_nmkquery in -lbind" >&5
 ac_lib_var=`echo bind'_'__res_nmkquery | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93156,7 +93377,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93160 "configure"
+#line 93381 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93167,7 +93388,7 @@
 __res_nmkquery()
 ; return 0; }
 EOF
-if { (eval echo configure:93171: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93392: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93199,11 +93420,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 93203 "configure"
+#line 93424 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:93207: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:93428: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -93245,7 +93466,7 @@
   unset ac_cv_lib_socket___res_nmkquery
   unset found
   echo $ac_n "checking for res_nmkquery in -lsocket""... $ac_c" 1>&6
-echo "configure:93249: checking for res_nmkquery in -lsocket" >&5
+echo "configure:93470: checking for res_nmkquery in -lsocket" >&5
 ac_lib_var=`echo socket'_'res_nmkquery | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93253,7 +93474,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93257 "configure"
+#line 93478 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93264,7 +93485,7 @@
 res_nmkquery()
 ; return 0; }
 EOF
-if { (eval echo configure:93268: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93489: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93284,7 +93505,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_nmkquery in -lsocket""... $ac_c" 1>&6
-echo "configure:93288: checking for __res_nmkquery in -lsocket" >&5
+echo "configure:93509: checking for __res_nmkquery in -lsocket" >&5
 ac_lib_var=`echo socket'_'__res_nmkquery | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93292,7 +93513,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93296 "configure"
+#line 93517 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93303,7 +93524,7 @@
 __res_nmkquery()
 ; return 0; }
 EOF
-if { (eval echo configure:93307: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93528: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93335,11 +93556,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 93339 "configure"
+#line 93560 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:93343: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:93564: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -93396,12 +93617,12 @@
   unset found
   
   echo $ac_n "checking for res_nsend""... $ac_c" 1>&6
-echo "configure:93400: checking for res_nsend" >&5
+echo "configure:93621: checking for res_nsend" >&5
 if eval "test \"`echo '$''{'ac_cv_func_res_nsend'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 93405 "configure"
+#line 93626 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char res_nsend(); below.  */
@@ -93424,7 +93645,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:93428: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93649: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_res_nsend=yes"
 else
@@ -93442,12 +93663,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __res_nsend""... $ac_c" 1>&6
-echo "configure:93446: checking for __res_nsend" >&5
+echo "configure:93667: checking for __res_nsend" >&5
 if eval "test \"`echo '$''{'ac_cv_func___res_nsend'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 93451 "configure"
+#line 93672 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __res_nsend(); below.  */
@@ -93470,7 +93691,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:93474: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93695: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___res_nsend=yes"
 else
@@ -93508,7 +93729,7 @@
   unset ac_cv_lib_resolv___res_nsend
   unset found
   echo $ac_n "checking for res_nsend in -lresolv""... $ac_c" 1>&6
-echo "configure:93512: checking for res_nsend in -lresolv" >&5
+echo "configure:93733: checking for res_nsend in -lresolv" >&5
 ac_lib_var=`echo resolv'_'res_nsend | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93516,7 +93737,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93520 "configure"
+#line 93741 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93527,7 +93748,7 @@
 res_nsend()
 ; return 0; }
 EOF
-if { (eval echo configure:93531: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93752: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93547,7 +93768,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_nsend in -lresolv""... $ac_c" 1>&6
-echo "configure:93551: checking for __res_nsend in -lresolv" >&5
+echo "configure:93772: checking for __res_nsend in -lresolv" >&5
 ac_lib_var=`echo resolv'_'__res_nsend | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93555,7 +93776,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93559 "configure"
+#line 93780 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93566,7 +93787,7 @@
 __res_nsend()
 ; return 0; }
 EOF
-if { (eval echo configure:93570: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93791: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93598,11 +93819,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 93602 "configure"
+#line 93823 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:93606: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:93827: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -93644,7 +93865,7 @@
   unset ac_cv_lib_bind___res_nsend
   unset found
   echo $ac_n "checking for res_nsend in -lbind""... $ac_c" 1>&6
-echo "configure:93648: checking for res_nsend in -lbind" >&5
+echo "configure:93869: checking for res_nsend in -lbind" >&5
 ac_lib_var=`echo bind'_'res_nsend | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93652,7 +93873,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93656 "configure"
+#line 93877 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93663,7 +93884,7 @@
 res_nsend()
 ; return 0; }
 EOF
-if { (eval echo configure:93667: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93888: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93683,7 +93904,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_nsend in -lbind""... $ac_c" 1>&6
-echo "configure:93687: checking for __res_nsend in -lbind" >&5
+echo "configure:93908: checking for __res_nsend in -lbind" >&5
 ac_lib_var=`echo bind'_'__res_nsend | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93691,7 +93912,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93695 "configure"
+#line 93916 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93702,7 +93923,7 @@
 __res_nsend()
 ; return 0; }
 EOF
-if { (eval echo configure:93706: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:93927: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93734,11 +93955,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 93738 "configure"
+#line 93959 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:93742: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:93963: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -93780,7 +94001,7 @@
   unset ac_cv_lib_socket___res_nsend
   unset found
   echo $ac_n "checking for res_nsend in -lsocket""... $ac_c" 1>&6
-echo "configure:93784: checking for res_nsend in -lsocket" >&5
+echo "configure:94005: checking for res_nsend in -lsocket" >&5
 ac_lib_var=`echo socket'_'res_nsend | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93788,7 +94009,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93792 "configure"
+#line 94013 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93799,7 +94020,7 @@
 res_nsend()
 ; return 0; }
 EOF
-if { (eval echo configure:93803: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94024: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93819,7 +94040,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __res_nsend in -lsocket""... $ac_c" 1>&6
-echo "configure:93823: checking for __res_nsend in -lsocket" >&5
+echo "configure:94044: checking for __res_nsend in -lsocket" >&5
 ac_lib_var=`echo socket'_'__res_nsend | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -93827,7 +94048,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 93831 "configure"
+#line 94052 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -93838,7 +94059,7 @@
 __res_nsend()
 ; return 0; }
 EOF
-if { (eval echo configure:93842: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94063: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -93870,11 +94091,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 93874 "configure"
+#line 94095 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:93878: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94099: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -93931,12 +94152,12 @@
   unset found
   
   echo $ac_n "checking for dn_expand""... $ac_c" 1>&6
-echo "configure:93935: checking for dn_expand" >&5
+echo "configure:94156: checking for dn_expand" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dn_expand'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 93940 "configure"
+#line 94161 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dn_expand(); below.  */
@@ -93959,7 +94180,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:93963: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94184: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dn_expand=yes"
 else
@@ -93977,12 +94198,12 @@
 else
   echo "$ac_t""no" 1>&6
  echo $ac_n "checking for __dn_expand""... $ac_c" 1>&6
-echo "configure:93981: checking for __dn_expand" >&5
+echo "configure:94202: checking for __dn_expand" >&5
 if eval "test \"`echo '$''{'ac_cv_func___dn_expand'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 93986 "configure"
+#line 94207 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char __dn_expand(); below.  */
@@ -94005,7 +94226,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:94009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94230: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func___dn_expand=yes"
 else
@@ -94043,7 +94264,7 @@
   unset ac_cv_lib_resolv___dn_expand
   unset found
   echo $ac_n "checking for dn_expand in -lresolv""... $ac_c" 1>&6
-echo "configure:94047: checking for dn_expand in -lresolv" >&5
+echo "configure:94268: checking for dn_expand in -lresolv" >&5
 ac_lib_var=`echo resolv'_'dn_expand | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -94051,7 +94272,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 94055 "configure"
+#line 94276 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -94062,7 +94283,7 @@
 dn_expand()
 ; return 0; }
 EOF
-if { (eval echo configure:94066: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94287: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -94082,7 +94303,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __dn_expand in -lresolv""... $ac_c" 1>&6
-echo "configure:94086: checking for __dn_expand in -lresolv" >&5
+echo "configure:94307: checking for __dn_expand in -lresolv" >&5
 ac_lib_var=`echo resolv'_'__dn_expand | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -94090,7 +94311,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 94094 "configure"
+#line 94315 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -94101,7 +94322,7 @@
 __dn_expand()
 ; return 0; }
 EOF
-if { (eval echo configure:94105: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -94133,11 +94354,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 94137 "configure"
+#line 94358 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:94141: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94362: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -94179,7 +94400,7 @@
   unset ac_cv_lib_bind___dn_expand
   unset found
   echo $ac_n "checking for dn_expand in -lbind""... $ac_c" 1>&6
-echo "configure:94183: checking for dn_expand in -lbind" >&5
+echo "configure:94404: checking for dn_expand in -lbind" >&5
 ac_lib_var=`echo bind'_'dn_expand | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -94187,7 +94408,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 94191 "configure"
+#line 94412 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -94198,7 +94419,7 @@
 dn_expand()
 ; return 0; }
 EOF
-if { (eval echo configure:94202: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94423: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -94218,7 +94439,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __dn_expand in -lbind""... $ac_c" 1>&6
-echo "configure:94222: checking for __dn_expand in -lbind" >&5
+echo "configure:94443: checking for __dn_expand in -lbind" >&5
 ac_lib_var=`echo bind'_'__dn_expand | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -94226,7 +94447,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 94230 "configure"
+#line 94451 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -94237,7 +94458,7 @@
 __dn_expand()
 ; return 0; }
 EOF
-if { (eval echo configure:94241: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94462: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -94269,11 +94490,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 94273 "configure"
+#line 94494 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:94277: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94498: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -94315,7 +94536,7 @@
   unset ac_cv_lib_socket___dn_expand
   unset found
   echo $ac_n "checking for dn_expand in -lsocket""... $ac_c" 1>&6
-echo "configure:94319: checking for dn_expand in -lsocket" >&5
+echo "configure:94540: checking for dn_expand in -lsocket" >&5
 ac_lib_var=`echo socket'_'dn_expand | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -94323,7 +94544,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 94327 "configure"
+#line 94548 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -94334,7 +94555,7 @@
 dn_expand()
 ; return 0; }
 EOF
-if { (eval echo configure:94338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -94354,7 +94575,7 @@
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for __dn_expand in -lsocket""... $ac_c" 1>&6
-echo "configure:94358: checking for __dn_expand in -lsocket" >&5
+echo "configure:94579: checking for __dn_expand in -lsocket" >&5
 ac_lib_var=`echo socket'_'__dn_expand | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -94362,7 +94583,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 94366 "configure"
+#line 94587 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -94373,7 +94594,7 @@
 __dn_expand()
 ; return 0; }
 EOF
-if { (eval echo configure:94377: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:94598: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -94405,11 +94626,11 @@
   found=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 94409 "configure"
+#line 94630 "configure"
 #include "confdefs.h"
 main() { return (0); }
 EOF
-if { (eval echo configure:94413: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94634: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   found=yes
 else
@@ -94473,7 +94694,7 @@
 esac
 
 echo $ac_n "checking whether atof() accepts NAN""... $ac_c" 1>&6
-echo "configure:94477: checking whether atof() accepts NAN" >&5
+echo "configure:94698: checking whether atof() accepts NAN" >&5
 if eval "test \"`echo '$''{'ac_cv_atof_accept_nan'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -94484,7 +94705,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 94488 "configure"
+#line 94709 "configure"
 #include "confdefs.h"
 
 #include <math.h>
@@ -94504,7 +94725,7 @@
 }
 
 EOF
-if { (eval echo configure:94508: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94729: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_atof_accept_nan=yes
@@ -94531,7 +94752,7 @@
 fi
 
 echo $ac_n "checking whether atof() accepts INF""... $ac_c" 1>&6
-echo "configure:94535: checking whether atof() accepts INF" >&5
+echo "configure:94756: checking whether atof() accepts INF" >&5
 if eval "test \"`echo '$''{'ac_cv_atof_accept_inf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -94542,7 +94763,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 94546 "configure"
+#line 94767 "configure"
 #include "confdefs.h"
 
 #include <math.h>
@@ -94565,7 +94786,7 @@
 }
 
 EOF
-if { (eval echo configure:94569: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94790: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_atof_accept_inf=yes
@@ -94592,7 +94813,7 @@
 fi
 
 echo $ac_n "checking whether HUGE_VAL == INF""... $ac_c" 1>&6
-echo "configure:94596: checking whether HUGE_VAL == INF" >&5
+echo "configure:94817: checking whether HUGE_VAL == INF" >&5
 if eval "test \"`echo '$''{'ac_cv_huge_val_inf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -94603,7 +94824,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 94607 "configure"
+#line 94828 "configure"
 #include "confdefs.h"
 
 #include <math.h>
@@ -94626,7 +94847,7 @@
 }
 
 EOF
-if { (eval echo configure:94630: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94851: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_huge_val_inf=yes
@@ -94653,7 +94874,7 @@
 fi
 
 echo $ac_n "checking whether HUGE_VAL + -HUGEVAL == NAN""... $ac_c" 1>&6
-echo "configure:94657: checking whether HUGE_VAL + -HUGEVAL == NAN" >&5
+echo "configure:94878: checking whether HUGE_VAL + -HUGEVAL == NAN" >&5
 if eval "test \"`echo '$''{'ac_cv_huge_val_nan'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -94664,7 +94885,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 94668 "configure"
+#line 94889 "configure"
 #include "confdefs.h"
 
 #include <math.h>
@@ -94689,7 +94910,7 @@
 }
 
 EOF
-if { (eval echo configure:94693: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:94914: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_huge_val_nan=yes
@@ -94716,13 +94937,13 @@
 fi
 
 echo $ac_n "checking whether strptime() declaration fails""... $ac_c" 1>&6
-echo "configure:94720: checking whether strptime() declaration fails" >&5
+echo "configure:94941: checking whether strptime() declaration fails" >&5
 if eval "test \"`echo '$''{'ac_cv_strptime_decl_fails'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 94726 "configure"
+#line 94947 "configure"
 #include "confdefs.h"
 
 #include <time.h>
@@ -94738,7 +94959,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:94742: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:94963: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
   ac_cv_strptime_decl_fails=no
@@ -94766,17 +94987,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:94770: checking for $ac_hdr" >&5
+echo "configure:94991: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 94775 "configure"
+#line 94996 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:94780: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:95001: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -94805,12 +95026,12 @@
 for ac_func in mblen
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:94809: checking for $ac_func" >&5
+echo "configure:95030: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 94814 "configure"
+#line 95035 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -94833,7 +95054,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:94837: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:95058: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -94860,12 +95081,12 @@
 for ac_func in mbrlen mbsinit
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:94864: checking for $ac_func" >&5
+echo "configure:95085: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 94869 "configure"
+#line 95090 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -94888,7 +95109,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:94892: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:95113: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -94913,13 +95134,13 @@
 done
 
 echo $ac_n "checking for mbstate_t""... $ac_c" 1>&6
-echo "configure:94917: checking for mbstate_t" >&5
+echo "configure:95138: checking for mbstate_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mbstate_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 94923 "configure"
+#line 95144 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_WCHAR_H
@@ -94932,7 +95153,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:94936: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:95157: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
   ac_cv_type_mbstate_t=yes
@@ -95319,7 +95540,7 @@
 php_with_sybase=no
 
 echo $ac_n "checking for Sybase support""... $ac_c" 1>&6
-echo "configure:95323: checking for Sybase support" >&5
+echo "configure:95544: checking for Sybase support" >&5
 # Check whether --with-sybase or --without-sybase was given.
 if test "${with_sybase+set}" = set; then
   withval="$with_sybase"
@@ -95791,7 +96012,7 @@
   fi
 
   echo $ac_n "checking for dnet_addr in -ldnet_stub""... $ac_c" 1>&6
-echo "configure:95795: checking for dnet_addr in -ldnet_stub" >&5
+echo "configure:96016: checking for dnet_addr in -ldnet_stub" >&5
 ac_lib_var=`echo dnet_stub'_'dnet_addr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -95799,7 +96020,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldnet_stub  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 95803 "configure"
+#line 96024 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -95810,7 +96031,7 @@
 dnet_addr()
 ; return 0; }
 EOF
-if { (eval echo configure:95814: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:96035: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -95936,7 +96157,7 @@
 EOF
 
   echo $ac_n "checking for tdsdbopen in -lsybdb""... $ac_c" 1>&6
-echo "configure:95940: checking for tdsdbopen in -lsybdb" >&5
+echo "configure:96161: checking for tdsdbopen in -lsybdb" >&5
 ac_lib_var=`echo sybdb'_'tdsdbopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -95944,7 +96165,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsybdb  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 95948 "configure"
+#line 96169 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -95955,7 +96176,7 @@
 tdsdbopen()
 ; return 0; }
 EOF
-if { (eval echo configure:95959: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:96180: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -95997,7 +96218,7 @@
 php_with_sybase_ct=no
 
 echo $ac_n "checking for Sybase-CT support""... $ac_c" 1>&6
-echo "configure:96001: checking for Sybase-CT support" >&5
+echo "configure:96222: checking for Sybase-CT support" >&5
 # Check whether --with-sybase-ct or --without-sybase-ct was given.
 if test "${with_sybase_ct+set}" = set; then
   withval="$with_sybase_ct"
@@ -96652,7 +96873,7 @@
   done
 
   echo $ac_n "checking for netg_errstr in -lsybtcl64""... $ac_c" 1>&6
-echo "configure:96656: checking for netg_errstr in -lsybtcl64" >&5
+echo "configure:96877: checking for netg_errstr in -lsybtcl64" >&5
 ac_lib_var=`echo sybtcl64'_'netg_errstr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -96660,7 +96881,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsybtcl64  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 96664 "configure"
+#line 96885 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -96671,7 +96892,7 @@
 netg_errstr()
 ; return 0; }
 EOF
-if { (eval echo configure:96675: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:96896: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -96846,7 +97067,7 @@
   done
 
   echo $ac_n "checking for insck__getVdate in -linsck64""... $ac_c" 1>&6
-echo "configure:96850: checking for insck__getVdate in -linsck64" >&5
+echo "configure:97071: checking for insck__getVdate in -linsck64" >&5
 ac_lib_var=`echo insck64'_'insck__getVdate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -96854,7 +97075,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-linsck64  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 96858 "configure"
+#line 97079 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -96865,7 +97086,7 @@
 insck__getVdate()
 ; return 0; }
 EOF
-if { (eval echo configure:96869: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:97090: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -97013,7 +97234,7 @@
   done
 
   echo $ac_n "checking for bsd_tcp in -linsck64""... $ac_c" 1>&6
-echo "configure:97017: checking for bsd_tcp in -linsck64" >&5
+echo "configure:97238: checking for bsd_tcp in -linsck64" >&5
 ac_lib_var=`echo insck64'_'bsd_tcp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -97021,7 +97242,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-linsck64  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 97025 "configure"
+#line 97246 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -97032,7 +97253,7 @@
 bsd_tcp()
 ; return 0; }
 EOF
-if { (eval echo configure:97036: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:97257: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -97278,7 +97499,7 @@
   done
 
   echo $ac_n "checking for netg_errstr in -lsybtcl""... $ac_c" 1>&6
-echo "configure:97282: checking for netg_errstr in -lsybtcl" >&5
+echo "configure:97503: checking for netg_errstr in -lsybtcl" >&5
 ac_lib_var=`echo sybtcl'_'netg_errstr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -97286,7 +97507,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsybtcl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 97290 "configure"
+#line 97511 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -97297,7 +97518,7 @@
 netg_errstr()
 ; return 0; }
 EOF
-if { (eval echo configure:97301: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:97522: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -97472,7 +97693,7 @@
   done
 
   echo $ac_n "checking for insck__getVdate in -linsck""... $ac_c" 1>&6
-echo "configure:97476: checking for insck__getVdate in -linsck" >&5
+echo "configure:97697: checking for insck__getVdate in -linsck" >&5
 ac_lib_var=`echo insck'_'insck__getVdate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -97480,7 +97701,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-linsck  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 97484 "configure"
+#line 97705 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -97491,7 +97712,7 @@
 insck__getVdate()
 ; return 0; }
 EOF
-if { (eval echo configure:97495: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:97716: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -97639,7 +97860,7 @@
   done
 
   echo $ac_n "checking for bsd_tcp in -linsck""... $ac_c" 1>&6
-echo "configure:97643: checking for bsd_tcp in -linsck" >&5
+echo "configure:97864: checking for bsd_tcp in -linsck" >&5
 ac_lib_var=`echo insck'_'bsd_tcp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -97647,7 +97868,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-linsck  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 97651 "configure"
+#line 97872 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -97658,7 +97879,7 @@
 bsd_tcp()
 ; return 0; }
 EOF
-if { (eval echo configure:97662: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:97883: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -97904,7 +98125,7 @@
   done
 
   echo $ac_n "checking for netg_errstr in -ltcl""... $ac_c" 1>&6
-echo "configure:97908: checking for netg_errstr in -ltcl" >&5
+echo "configure:98129: checking for netg_errstr in -ltcl" >&5
 ac_lib_var=`echo tcl'_'netg_errstr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -97912,7 +98133,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltcl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 97916 "configure"
+#line 98137 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -97923,7 +98144,7 @@
 netg_errstr()
 ; return 0; }
 EOF
-if { (eval echo configure:97927: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:98148: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -98098,7 +98319,7 @@
   done
 
   echo $ac_n "checking for insck__getVdate in -linsck""... $ac_c" 1>&6
-echo "configure:98102: checking for insck__getVdate in -linsck" >&5
+echo "configure:98323: checking for insck__getVdate in -linsck" >&5
 ac_lib_var=`echo insck'_'insck__getVdate | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -98106,7 +98327,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-linsck  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 98110 "configure"
+#line 98331 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -98117,7 +98338,7 @@
 insck__getVdate()
 ; return 0; }
 EOF
-if { (eval echo configure:98121: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:98342: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -98265,7 +98486,7 @@
   done
 
   echo $ac_n "checking for bsd_tcp in -linsck""... $ac_c" 1>&6
-echo "configure:98269: checking for bsd_tcp in -linsck" >&5
+echo "configure:98490: checking for bsd_tcp in -linsck" >&5
 ac_lib_var=`echo insck'_'bsd_tcp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -98273,7 +98494,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-linsck  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 98277 "configure"
+#line 98498 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -98284,7 +98505,7 @@
 bsd_tcp()
 ; return 0; }
 EOF
-if { (eval echo configure:98288: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:98509: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -98344,7 +98565,7 @@
 php_enable_sysvmsg=no
 
 echo $ac_n "checking whether to enable System V IPC support""... $ac_c" 1>&6
-echo "configure:98348: checking whether to enable System V IPC support" >&5
+echo "configure:98569: checking whether to enable System V IPC support" >&5
 # Check whether --enable-sysvmsg or --disable-sysvmsg was given.
 if test "${enable_sysvmsg+set}" = set; then
   enableval="$enable_sysvmsg"
@@ -98390,17 +98611,17 @@
 if test "$PHP_SYSVMSG" != "no"; then
   ac_safe=`echo "sys/msg.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for sys/msg.h""... $ac_c" 1>&6
-echo "configure:98394: checking for sys/msg.h" >&5
+echo "configure:98615: checking for sys/msg.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 98399 "configure"
+#line 98620 "configure"
 #include "confdefs.h"
 #include <sys/msg.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:98404: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:98625: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -98727,7 +98948,7 @@
 php_enable_sysvsem=no
 
 echo $ac_n "checking whether to enable System V semaphore support""... $ac_c" 1>&6
-echo "configure:98731: checking whether to enable System V semaphore support" >&5
+echo "configure:98952: checking whether to enable System V semaphore support" >&5
 # Check whether --enable-sysvsem or --disable-sysvsem was given.
 if test "${enable_sysvsem+set}" = set; then
   enableval="$enable_sysvsem"
@@ -99068,12 +99289,12 @@
 EOF
 
  echo $ac_n "checking for union semun""... $ac_c" 1>&6
-echo "configure:99072: checking for union semun" >&5
+echo "configure:99293: checking for union semun" >&5
 if eval "test \"`echo '$''{'php_cv_semun'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 99077 "configure"
+#line 99298 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -99084,7 +99305,7 @@
 union semun x;
 ; return 0; }
 EOF
-if { (eval echo configure:99088: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:99309: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
      php_cv_semun=yes
@@ -99120,7 +99341,7 @@
 php_enable_sysvshm=no
 
 echo $ac_n "checking whether to enable System V shared memory support""... $ac_c" 1>&6
-echo "configure:99124: checking whether to enable System V shared memory support" >&5
+echo "configure:99345: checking whether to enable System V shared memory support" >&5
 # Check whether --enable-sysvshm or --disable-sysvshm was given.
 if test "${enable_sysvshm+set}" = set; then
   enableval="$enable_sysvshm"
@@ -99467,7 +99688,7 @@
 php_with_tidy=no
 
 echo $ac_n "checking for TIDY support""... $ac_c" 1>&6
-echo "configure:99471: checking for TIDY support" >&5
+echo "configure:99692: checking for TIDY support" >&5
 # Check whether --with-tidy or --without-tidy was given.
 if test "${with_tidy+set}" = set; then
   withval="$with_tidy"
@@ -99759,7 +99980,7 @@
   done
 
   echo $ac_n "checking for tidyOptGetDoc in -ltidy""... $ac_c" 1>&6
-echo "configure:99763: checking for tidyOptGetDoc in -ltidy" >&5
+echo "configure:99984: checking for tidyOptGetDoc in -ltidy" >&5
 ac_lib_var=`echo tidy'_'tidyOptGetDoc | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -99767,7 +99988,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltidy  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 99771 "configure"
+#line 99992 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -99778,7 +99999,7 @@
 tidyOptGetDoc()
 ; return 0; }
 EOF
-if { (eval echo configure:99782: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:100003: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -100122,7 +100343,7 @@
 php_enable_tokenizer=yes
 
 echo $ac_n "checking whether to enable tokenizer support""... $ac_c" 1>&6
-echo "configure:100126: checking whether to enable tokenizer support" >&5
+echo "configure:100347: checking whether to enable tokenizer support" >&5
 # Check whether --enable-tokenizer or --disable-tokenizer was given.
 if test "${enable_tokenizer+set}" = set; then
   enableval="$enable_tokenizer"
@@ -100471,7 +100692,7 @@
 php_enable_wddx=no
 
 echo $ac_n "checking whether to enable WDDX support""... $ac_c" 1>&6
-echo "configure:100475: checking whether to enable WDDX support" >&5
+echo "configure:100696: checking whether to enable WDDX support" >&5
 # Check whether --enable-wddx or --disable-wddx was given.
 if test "${enable_wddx+set}" = set; then
   enableval="$enable_wddx"
@@ -100519,7 +100740,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:100523: checking libxml2 install dir" >&5
+echo "configure:100744: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -100546,7 +100767,7 @@
 php_with_libexpat_dir=no
 
 echo $ac_n "checking libexpat dir for WDDX""... $ac_c" 1>&6
-echo "configure:100550: checking libexpat dir for WDDX" >&5
+echo "configure:100771: checking libexpat dir for WDDX" >&5
 # Check whether --with-libexpat-dir or --without-libexpat-dir was given.
 if test "${with_libexpat_dir+set}" = set; then
   withval="$with_libexpat_dir"
@@ -100577,7 +100798,7 @@
 
     
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:100581: checking for xml2-config path" >&5
+echo "configure:100802: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -100735,7 +100956,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:100739: checking whether libxml build works" >&5
+echo "configure:100960: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -100751,7 +100972,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 100755 "configure"
+#line 100976 "configure"
 #include "confdefs.h"
 
     
@@ -100762,7 +100983,7 @@
     }
   
 EOF
-if { (eval echo configure:100766: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:100987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -101329,7 +101550,7 @@
 php_enable_xml=yes
 
 echo $ac_n "checking whether to enable XML support""... $ac_c" 1>&6
-echo "configure:101333: checking whether to enable XML support" >&5
+echo "configure:101554: checking whether to enable XML support" >&5
 # Check whether --enable-xml or --disable-xml was given.
 if test "${enable_xml+set}" = set; then
   enableval="$enable_xml"
@@ -101377,7 +101598,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:101381: checking libxml2 install dir" >&5
+echo "configure:101602: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -101404,7 +101625,7 @@
 php_with_libexpat_dir=no
 
 echo $ac_n "checking libexpat install dir""... $ac_c" 1>&6
-echo "configure:101408: checking libexpat install dir" >&5
+echo "configure:101629: checking libexpat install dir" >&5
 # Check whether --with-libexpat-dir or --without-libexpat-dir was given.
 if test "${with_libexpat_dir+set}" = set; then
   withval="$with_libexpat_dir"
@@ -101436,7 +101657,7 @@
 
     
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:101440: checking for xml2-config path" >&5
+echo "configure:101661: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -101594,7 +101815,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:101598: checking whether libxml build works" >&5
+echo "configure:101819: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -101610,7 +101831,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 101614 "configure"
+#line 101835 "configure"
 #include "confdefs.h"
 
     
@@ -101621,7 +101842,7 @@
     }
   
 EOF
-if { (eval echo configure:101625: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:101846: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -102157,7 +102378,7 @@
 php_enable_xmlreader=yes
 
 echo $ac_n "checking whether to enable XMLReader support""... $ac_c" 1>&6
-echo "configure:102161: checking whether to enable XMLReader support" >&5
+echo "configure:102382: checking whether to enable XMLReader support" >&5
 # Check whether --enable-xmlreader or --disable-xmlreader was given.
 if test "${enable_xmlreader+set}" = set; then
   enableval="$enable_xmlreader"
@@ -102205,7 +102426,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:102209: checking libxml2 install dir" >&5
+echo "configure:102430: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -102236,7 +102457,7 @@
 
   
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:102240: checking for xml2-config path" >&5
+echo "configure:102461: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -102394,7 +102615,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:102398: checking whether libxml build works" >&5
+echo "configure:102619: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -102410,7 +102631,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 102414 "configure"
+#line 102635 "configure"
 #include "confdefs.h"
 
     
@@ -102421,7 +102642,7 @@
     }
   
 EOF
-if { (eval echo configure:102425: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:102646: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -102803,7 +103024,7 @@
 php_with_xmlrpc=no
 
 echo $ac_n "checking for XMLRPC-EPI support""... $ac_c" 1>&6
-echo "configure:102807: checking for XMLRPC-EPI support" >&5
+echo "configure:103028: checking for XMLRPC-EPI support" >&5
 # Check whether --with-xmlrpc or --without-xmlrpc was given.
 if test "${with_xmlrpc+set}" = set; then
   withval="$with_xmlrpc"
@@ -102851,7 +103072,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:102855: checking libxml2 install dir" >&5
+echo "configure:103076: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -102878,7 +103099,7 @@
 php_with_libexpat_dir=no
 
 echo $ac_n "checking libexpat dir for XMLRPC-EPI""... $ac_c" 1>&6
-echo "configure:102882: checking libexpat dir for XMLRPC-EPI" >&5
+echo "configure:103103: checking libexpat dir for XMLRPC-EPI" >&5
 # Check whether --with-libexpat-dir or --without-libexpat-dir was given.
 if test "${with_libexpat_dir+set}" = set; then
   withval="$with_libexpat_dir"
@@ -102904,7 +103125,7 @@
 php_with_iconv_dir=no
 
 echo $ac_n "checking iconv dir for XMLRPC-EPI""... $ac_c" 1>&6
-echo "configure:102908: checking iconv dir for XMLRPC-EPI" >&5
+echo "configure:103129: checking iconv dir for XMLRPC-EPI" >&5
 # Check whether --with-iconv-dir or --without-iconv-dir was given.
 if test "${with_iconv_dir+set}" = set; then
   withval="$with_iconv_dir"
@@ -102963,7 +103184,7 @@
 
     
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:102967: checking for xml2-config path" >&5
+echo "configure:103188: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -103121,7 +103342,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:103125: checking whether libxml build works" >&5
+echo "configure:103346: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -103137,7 +103358,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 103141 "configure"
+#line 103362 "configure"
 #include "confdefs.h"
 
     
@@ -103148,7 +103369,7 @@
     }
   
 EOF
-if { (eval echo configure:103152: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:103373: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -103417,12 +103638,12 @@
 
         if test "$PHP_ICONV" = "yes"; then
     echo $ac_n "checking for iconv""... $ac_c" 1>&6
-echo "configure:103421: checking for iconv" >&5
+echo "configure:103642: checking for iconv" >&5
 if eval "test \"`echo '$''{'ac_cv_func_iconv'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 103426 "configure"
+#line 103647 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char iconv(); below.  */
@@ -103445,7 +103666,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:103449: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:103670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_iconv=yes"
 else
@@ -103466,12 +103687,12 @@
   echo "$ac_t""no" 1>&6
 
       echo $ac_n "checking for libiconv""... $ac_c" 1>&6
-echo "configure:103470: checking for libiconv" >&5
+echo "configure:103691: checking for libiconv" >&5
 if eval "test \"`echo '$''{'ac_cv_func_libiconv'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 103475 "configure"
+#line 103696 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char libiconv(); below.  */
@@ -103494,7 +103715,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:103498: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:103719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_libiconv=yes"
 else
@@ -103650,7 +103871,7 @@
   done
 
   echo $ac_n "checking for libiconv in -l$iconv_lib_name""... $ac_c" 1>&6
-echo "configure:103654: checking for libiconv in -l$iconv_lib_name" >&5
+echo "configure:103875: checking for libiconv in -l$iconv_lib_name" >&5
 ac_lib_var=`echo $iconv_lib_name'_'libiconv | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -103658,7 +103879,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$iconv_lib_name  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 103662 "configure"
+#line 103883 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -103669,7 +103890,7 @@
 libiconv()
 ; return 0; }
 EOF
-if { (eval echo configure:103673: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:103894: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -103810,7 +104031,7 @@
   done
 
   echo $ac_n "checking for iconv in -l$iconv_lib_name""... $ac_c" 1>&6
-echo "configure:103814: checking for iconv in -l$iconv_lib_name" >&5
+echo "configure:104035: checking for iconv in -l$iconv_lib_name" >&5
 ac_lib_var=`echo $iconv_lib_name'_'iconv | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -103818,7 +104039,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-l$iconv_lib_name  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 103822 "configure"
+#line 104043 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -103829,7 +104050,7 @@
 iconv()
 ; return 0; }
 EOF
-if { (eval echo configure:103833: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:104054: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -104019,7 +104240,7 @@
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:104023: checking for $ac_word" >&5
+echo "configure:104244: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -104047,21 +104268,21 @@
 fi
 
 echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:104051: checking for inline" >&5
+echo "configure:104272: checking for inline" >&5
 if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat > conftest.$ac_ext <<EOF
-#line 104058 "configure"
+#line 104279 "configure"
 #include "confdefs.h"
 
 int main() {
 } $ac_kw foo() {
 ; return 0; }
 EOF
-if { (eval echo configure:104065: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:104286: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_inline=$ac_kw; break
 else
@@ -104099,12 +104320,12 @@
 
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:104103: checking for ANSI C header files" >&5
+echo "configure:104324: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 104108 "configure"
+#line 104329 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -104112,7 +104333,7 @@
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:104116: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:104337: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -104129,7 +104350,7 @@
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 104133 "configure"
+#line 104354 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -104147,7 +104368,7 @@
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 104151 "configure"
+#line 104372 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -104168,7 +104389,7 @@
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 104172 "configure"
+#line 104393 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -104179,7 +104400,7 @@
 exit (0); }
 
 EOF
-if { (eval echo configure:104183: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:104404: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -104206,17 +104427,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:104210: checking for $ac_hdr" >&5
+echo "configure:104431: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 104215 "configure"
+#line 104436 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:104220: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:104441: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -104248,7 +104469,7 @@
 
 
 echo $ac_n "checking size of char""... $ac_c" 1>&6
-echo "configure:104252: checking size of char" >&5
+echo "configure:104473: checking size of char" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -104256,18 +104477,19 @@
   ac_cv_sizeof_char=1
 else
   cat > conftest.$ac_ext <<EOF
-#line 104260 "configure"
+#line 104481 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(char));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:104271: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:104493: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char=`cat conftestval`
 else
@@ -104288,7 +104510,7 @@
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:104292: checking size of int" >&5
+echo "configure:104514: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -104296,18 +104518,19 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 104300 "configure"
+#line 104522 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:104311: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:104534: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -104327,7 +104550,7 @@
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:104331: checking size of long" >&5
+echo "configure:104554: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -104335,18 +104558,19 @@
   ac_cv_sizeof_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 104339 "configure"
+#line 104562 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:104350: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:104574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -104366,7 +104590,7 @@
 
 
 echo $ac_n "checking size of long long""... $ac_c" 1>&6
-echo "configure:104370: checking size of long long" >&5
+echo "configure:104594: checking size of long long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -104374,18 +104598,19 @@
   ac_cv_sizeof_long_long=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 104378 "configure"
+#line 104602 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-int main()
+#include <sys/types.h>
+main()
 {
   FILE *f=fopen("conftestval", "w");
-  if (!f) return(1);
+  if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long long));
-  return(0);
+  exit(0);
 }
 EOF
-if { (eval echo configure:104389: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:104614: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long=`cat conftestval`
 else
@@ -104405,12 +104630,12 @@
 
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:104409: checking for size_t" >&5
+echo "configure:104634: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 104414 "configure"
+#line 104639 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -104438,12 +104663,12 @@
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:104442: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:104667: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 104447 "configure"
+#line 104672 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
@@ -104452,7 +104677,7 @@
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:104456: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:104681: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
@@ -104473,12 +104698,12 @@
 fi
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:104477: checking for uid_t in sys/types.h" >&5
+echo "configure:104702: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 104482 "configure"
+#line 104707 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
@@ -104518,12 +104743,12 @@
  memcpy memmove
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:104522: checking for $ac_func" >&5
+echo "configure:104747: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 104527 "configure"
+#line 104752 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -104546,7 +104771,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:104550: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:104775: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -104900,7 +105125,7 @@
     XMLRPC_DIR=$PHP_XMLRPC/include/xmlrpc-epi
   else
     echo $ac_n "checking for XMLRPC-EPI in default path""... $ac_c" 1>&6
-echo "configure:104904: checking for XMLRPC-EPI in default path" >&5
+echo "configure:105129: checking for XMLRPC-EPI in default path" >&5
     for i in /usr/local /usr; do
       if test -r $i/include/xmlrpc.h; then
         XMLRPC_DIR=$i/include
@@ -105343,7 +105568,7 @@
 php_enable_xmlwriter=yes
 
 echo $ac_n "checking whether to enable XMLWriter support""... $ac_c" 1>&6
-echo "configure:105347: checking whether to enable XMLWriter support" >&5
+echo "configure:105572: checking whether to enable XMLWriter support" >&5
 # Check whether --enable-xmlwriter or --disable-xmlwriter was given.
 if test "${enable_xmlwriter+set}" = set; then
   enableval="$enable_xmlwriter"
@@ -105391,7 +105616,7 @@
 php_with_libxml_dir=no
 
 echo $ac_n "checking libxml2 install dir""... $ac_c" 1>&6
-echo "configure:105395: checking libxml2 install dir" >&5
+echo "configure:105620: checking libxml2 install dir" >&5
 # Check whether --with-libxml-dir or --without-libxml-dir was given.
 if test "${with_libxml_dir+set}" = set; then
   withval="$with_libxml_dir"
@@ -105422,7 +105647,7 @@
 
   
 echo $ac_n "checking for xml2-config path""... $ac_c" 1>&6
-echo "configure:105426: checking for xml2-config path" >&5
+echo "configure:105651: checking for xml2-config path" >&5
 if eval "test \"`echo '$''{'ac_cv_php_xml2_config_path'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -105580,7 +105805,7 @@
 
 
             echo $ac_n "checking whether libxml build works""... $ac_c" 1>&6
-echo "configure:105584: checking whether libxml build works" >&5
+echo "configure:105809: checking whether libxml build works" >&5
 if eval "test \"`echo '$''{'php_cv_libxml_build_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -105596,7 +105821,7 @@
   
 else
   cat > conftest.$ac_ext <<EOF
-#line 105600 "configure"
+#line 105825 "configure"
 #include "confdefs.h"
 
     
@@ -105607,7 +105832,7 @@
     }
   
 EOF
-if { (eval echo configure:105611: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:105836: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
     LIBS=$old_LIBS
@@ -105957,7 +106182,7 @@
 php_with_xsl=no
 
 echo $ac_n "checking for XSL support""... $ac_c" 1>&6
-echo "configure:105961: checking for XSL support" >&5
+echo "configure:106186: checking for XSL support" >&5
 # Check whether --with-xsl or --without-xsl was given.
 if test "${with_xsl+set}" = set; then
   withval="$with_xsl"
@@ -106160,7 +106385,7 @@
 
       
       echo $ac_n "checking for EXSLT support""... $ac_c" 1>&6
-echo "configure:106164: checking for EXSLT support" >&5
+echo "configure:106389: checking for EXSLT support" >&5
       for i in $PHP_XSL /usr/local /usr; do
         if test -r "$i/include/libexslt/exslt.h"; then
           PHP_XSL_EXSL_DIR=$i
@@ -106636,7 +106861,7 @@
 php_enable_zip=no
 
 echo $ac_n "checking for zip archive read/writesupport""... $ac_c" 1>&6
-echo "configure:106640: checking for zip archive read/writesupport" >&5
+echo "configure:106865: checking for zip archive read/writesupport" >&5
 # Check whether --enable-zip or --disable-zip was given.
 if test "${enable_zip+set}" = set; then
   enableval="$enable_zip"
@@ -106684,7 +106909,7 @@
 php_with_zlib_dir=no
 
 echo $ac_n "checking for the location of libz""... $ac_c" 1>&6
-echo "configure:106688: checking for the location of libz" >&5
+echo "configure:106913: checking for the location of libz" >&5
 # Check whether --with-zlib-dir or --without-zlib-dir was given.
 if test "${with_zlib_dir+set}" = set; then
   withval="$with_zlib_dir"
@@ -106732,7 +106957,7 @@
 	fi
 
 		echo $ac_n "checking for the location of zlib""... $ac_c" 1>&6
-echo "configure:106736: checking for the location of zlib" >&5
+echo "configure:106961: checking for the location of zlib" >&5
 	if test "$PHP_ZLIB_DIR" = "no"; then
 		{ echo "configure: error: zip support requires ZLIB. Use --with-zlib-dir=<DIR> to specify prefix where ZLIB include and library are located" 1>&2; exit 1; }
 	else
@@ -107195,6 +107420,541 @@
 	fi
 
 
+
+php_enable_mysqlnd=no
+
+echo $ac_n "checking whether to enable mysqlnd""... $ac_c" 1>&6
+echo "configure:107428: checking whether to enable mysqlnd" >&5
+# Check whether --enable-mysqlnd or --disable-mysqlnd was given.
+if test "${enable_mysqlnd+set}" = set; then
+  enableval="$enable_mysqlnd"
+  PHP_MYSQLND=$enableval
+else
+  
+  PHP_MYSQLND=no
+
+  if test "$PHP_ENABLE_ALL" && test "yes" = "yes"; then
+    PHP_MYSQLND=$PHP_ENABLE_ALL
+  fi
+
+fi
+
+
+
+ext_output="yes, shared"
+ext_shared=yes
+case $PHP_MYSQLND in
+shared,*)
+  PHP_MYSQLND=`echo "$PHP_MYSQLND"|$SED 's/^shared,//'`
+  ;;
+shared)
+  PHP_MYSQLND=yes
+  ;;
+no)
+  ext_output=no
+  ext_shared=no
+  ;;
+*)
+  ext_output=yes
+  ext_shared=no
+  ;;
+esac
+
+
+
+echo "$ac_t""$ext_output" 1>&6
+
+
+
+
+
+php_enable_mysqlnd_compression_support=yes
+
+echo $ac_n "checking whether to disable compressed protocol support in mysqlnd""... $ac_c" 1>&6
+echo "configure:107475: checking whether to disable compressed protocol support in mysqlnd" >&5
+# Check whether --enable-mysqlnd_compression_support or --disable-mysqlnd_compression_support was given.
+if test "${enable_mysqlnd_compression_support+set}" = set; then
+  enableval="$enable_mysqlnd_compression_support"
+  PHP_MYSQLND_COMPRESSION_SUPPORT=$enableval
+else
+  
+  PHP_MYSQLND_COMPRESSION_SUPPORT=yes
+
+  if test "$PHP_ENABLE_ALL" && test "no" = "yes"; then
+    PHP_MYSQLND_COMPRESSION_SUPPORT=$PHP_ENABLE_ALL
+  fi
+
+fi
+
+
+ext_output=$PHP_MYSQLND_COMPRESSION_SUPPORT
+echo "$ac_t""$ext_output" 1>&6
+
+
+
+
+if test -z "$PHP_ZLIB_DIR"; then
+  
+php_with_zlib_dir=no
+
+echo $ac_n "checking for the location of libz""... $ac_c" 1>&6
+echo "configure:107502: checking for the location of libz" >&5
+# Check whether --with-zlib-dir or --without-zlib-dir was given.
+if test "${with_zlib_dir+set}" = set; then
+  withval="$with_zlib_dir"
+  PHP_ZLIB_DIR=$withval
+else
+  
+  PHP_ZLIB_DIR=no
+
+  if test "$PHP_ENABLE_ALL" && test "no" = "yes"; then
+    PHP_ZLIB_DIR=$PHP_ENABLE_ALL
+  fi
+
+fi
+
+
+ext_output=$PHP_ZLIB_DIR
+echo "$ac_t""$ext_output" 1>&6
+
+
+
+fi
+
+if test "$PHP_MYSQLND" != "no" || test "$PHP_MYSQLND_ENABLED" = "yes"; then
+  mysqlnd_ps_sources="mysqlnd_ps.c mysqlnd_ps_codec.c"
+  mysqlnd_base_sources="mysqlnd.c mysqlnd_charset.c mysqlnd_wireprotocol.c \
+                   mysqlnd_loaddata.c mysqlnd_net.c mysqlnd_statistics.c \
+				   mysqlnd_result.c mysqlnd_result_meta.c mysqlnd_debug.c\
+				   mysqlnd_block_alloc.c php_mysqlnd.c"
+
+
+  if test "$PHP_MYSQLND_COMPRESSION_SUPPORT" != "no"; then
+    cat >> confdefs.h <<\EOF
+#define MYSQLND_COMPRESSION_WANTED 1
+EOF
+
+  fi
+  cat >> confdefs.h <<\EOF
+#define MYSQLND_SSL_SUPPORTED 1
+EOF
+
+
+  mysqlnd_sources="$mysqlnd_base_sources $mysqlnd_ps_sources"
+  
+  ext_builddir=ext/mysqlnd
+  ext_srcdir=$abs_srcdir/ext/mysqlnd
+
+  ac_extra=
+
+  if test "$ext_shared" != "shared" && test "$ext_shared" != "yes" && test "" != "cli"; then
+    PHP_MYSQLND_SHARED=no
+    
+  
+  case ext/mysqlnd in
+  "") ac_srcdir="$abs_srcdir/"; unset ac_bdir; ac_inc="-I. -I$abs_srcdir" ;;
+  /*) ac_srcdir=`echo "ext/mysqlnd"|cut -c 2-`"/"; ac_bdir=$ac_srcdir; ac_inc="-I$ac_bdir -I$abs_srcdir/$ac_bdir" ;;
+  *) ac_srcdir="$abs_srcdir/ext/mysqlnd/"; ac_bdir="ext/mysqlnd/"; ac_inc="-I$ac_bdir -I$ac_srcdir" ;;
+  esac
+  
+  
+
+  b_c_pre=$php_c_pre
+  b_cxx_pre=$php_cxx_pre
+  b_c_meta=$php_c_meta
+  b_cxx_meta=$php_cxx_meta
+  b_c_post=$php_c_post
+  b_cxx_post=$php_cxx_post
+  b_lo=$php_lo
+
+
+  old_IFS=$IFS
+  for ac_src in $mysqlnd_sources; do
+  
+      IFS=.
+      set $ac_src
+      ac_obj=$1
+      IFS=$old_IFS
+      
+      PHP_GLOBAL_OBJS="$PHP_GLOBAL_OBJS $ac_bdir$ac_obj.lo"
+
+      case $ac_src in
+        *.c) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.s) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.S) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.cpp|*.cc|*.cxx) ac_comp="$b_cxx_pre $ac_extra $ac_inc $b_cxx_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_cxx_post" ;;
+      esac
+
+    cat >>Makefile.objects<<EOF
+$ac_bdir$ac_obj.lo: $ac_srcdir$ac_src
+	$ac_comp
+EOF
+  done
+
+
+    EXT_STATIC="$EXT_STATIC mysqlnd"
+    if test "$ext_shared" != "nocli"; then
+      EXT_CLI_STATIC="$EXT_CLI_STATIC mysqlnd"
+    fi
+  else
+    if test "$ext_shared" = "shared" || test "$ext_shared" = "yes"; then
+      PHP_MYSQLND_SHARED=yes
+      
+  case ext/mysqlnd in
+  "") ac_srcdir="$abs_srcdir/"; unset ac_bdir; ac_inc="-I. -I$abs_srcdir" ;;
+  /*) ac_srcdir=`echo "ext/mysqlnd"|cut -c 2-`"/"; ac_bdir=$ac_srcdir; ac_inc="-I$ac_bdir -I$abs_srcdir/$ac_bdir" ;;
+  *) ac_srcdir="$abs_srcdir/ext/mysqlnd/"; ac_bdir="ext/mysqlnd/"; ac_inc="-I$ac_bdir -I$ac_srcdir" ;;
+  esac
+  
+  
+
+  b_c_pre=$shared_c_pre
+  b_cxx_pre=$shared_cxx_pre
+  b_c_meta=$shared_c_meta
+  b_cxx_meta=$shared_cxx_meta
+  b_c_post=$shared_c_post
+  b_cxx_post=$shared_cxx_post
+  b_lo=$shared_lo
+
+
+  old_IFS=$IFS
+  for ac_src in $mysqlnd_sources; do
+  
+      IFS=.
+      set $ac_src
+      ac_obj=$1
+      IFS=$old_IFS
+      
+      shared_objects_mysqlnd="$shared_objects_mysqlnd $ac_bdir$ac_obj.lo"
+
+      case $ac_src in
+        *.c) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.s) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.S) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.cpp|*.cc|*.cxx) ac_comp="$b_cxx_pre $ac_extra $ac_inc $b_cxx_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_cxx_post" ;;
+      esac
+
+    cat >>Makefile.objects<<EOF
+$ac_bdir$ac_obj.lo: $ac_srcdir$ac_src
+	$ac_comp
+EOF
+  done
+
+      case $host_alias in
+        *netware*)
+          
+  install_modules="install-modules"
+
+  case $host_alias in
+    *aix*)
+      suffix=so
+      link_cmd='$(LIBTOOL) --mode=link $(CC) $(COMMON_FLAGS) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(LDFLAGS) -Wl,-G -o '$ext_builddir'/phpmysqlnd.la -export-dynamic -avoid-version -prefer-pic -module -rpath $(phplibdir) $(EXTRA_LDFLAGS) $(shared_objects_mysqlnd) $(PHPMYSQLND_SHARED_LIBADD) && mv -f '$ext_builddir'/.libs/phpmysqlnd.so '$ext_builddir'/phpmysqlnd.so'
+      ;;
+    *netware*)
+      suffix=nlm
+      link_cmd='$(LIBTOOL) --mode=link $(CC) $(COMMON_FLAGS) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(LDFLAGS) -o $@ -shared -export-dynamic -avoid-version -prefer-pic -module -rpath $(phplibdir) $(EXTRA_LDFLAGS) $(shared_objects_mysqlnd) -L$(top_builddir)/netware -lphp5lib $(M4_SUBSTR(PHPMYSQLND, 3)_SHARED_LIBADD)'
+      ;;
+    *)
+      suffix=la
+      link_cmd='$(LIBTOOL) --mode=link $(CC) $(COMMON_FLAGS) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(LDFLAGS) -o $@ -export-dynamic -avoid-version -prefer-pic -module -rpath $(phplibdir) $(EXTRA_LDFLAGS) $(shared_objects_mysqlnd) $(PHPMYSQLND_SHARED_LIBADD)'
+      ;;
+  esac
+
+  if test "x" = "xyes"; then
+    PHP_ZEND_EX="$PHP_ZEND_EX \$(phplibdir)/phpmysqlnd.$suffix"
+  else
+    PHP_MODULES="$PHP_MODULES \$(phplibdir)/phpmysqlnd.$suffix"
+  fi
+  
+  PHP_VAR_SUBST="$PHP_VAR_SUBST shared_objects_mysqlnd"
+
+  cat >>Makefile.objects<<EOF
+\$(phplibdir)/phpmysqlnd.$suffix: $ext_builddir/phpmysqlnd.$suffix
+	\$(LIBTOOL) --mode=install cp $ext_builddir/phpmysqlnd.$suffix \$(phplibdir)
+
+$ext_builddir/phpmysqlnd.$suffix: \$(shared_objects_mysqlnd) \$(PHPMYSQLND_SHARED_DEPENDENCIES)
+	$link_cmd
+
+EOF
+
+          ;;
+        *)
+          
+  install_modules="install-modules"
+
+  case $host_alias in
+    *aix*)
+      suffix=so
+      link_cmd='$(LIBTOOL) --mode=link $(CC) $(COMMON_FLAGS) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(LDFLAGS) -Wl,-G -o '$ext_builddir'/mysqlnd.la -export-dynamic -avoid-version -prefer-pic -module -rpath $(phplibdir) $(EXTRA_LDFLAGS) $(shared_objects_mysqlnd) $(MYSQLND_SHARED_LIBADD) && mv -f '$ext_builddir'/.libs/mysqlnd.so '$ext_builddir'/mysqlnd.so'
+      ;;
+    *netware*)
+      suffix=nlm
+      link_cmd='$(LIBTOOL) --mode=link $(CC) $(COMMON_FLAGS) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(LDFLAGS) -o $@ -shared -export-dynamic -avoid-version -prefer-pic -module -rpath $(phplibdir) $(EXTRA_LDFLAGS) $(shared_objects_mysqlnd) -L$(top_builddir)/netware -lphp5lib $(M4_SUBSTR(MYSQLND, 3)_SHARED_LIBADD)'
+      ;;
+    *)
+      suffix=la
+      link_cmd='$(LIBTOOL) --mode=link $(CC) $(COMMON_FLAGS) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(LDFLAGS) -o $@ -export-dynamic -avoid-version -prefer-pic -module -rpath $(phplibdir) $(EXTRA_LDFLAGS) $(shared_objects_mysqlnd) $(MYSQLND_SHARED_LIBADD)'
+      ;;
+  esac
+
+  if test "x" = "xyes"; then
+    PHP_ZEND_EX="$PHP_ZEND_EX \$(phplibdir)/mysqlnd.$suffix"
+  else
+    PHP_MODULES="$PHP_MODULES \$(phplibdir)/mysqlnd.$suffix"
+  fi
+  
+  PHP_VAR_SUBST="$PHP_VAR_SUBST shared_objects_mysqlnd"
+
+  cat >>Makefile.objects<<EOF
+\$(phplibdir)/mysqlnd.$suffix: $ext_builddir/mysqlnd.$suffix
+	\$(LIBTOOL) --mode=install cp $ext_builddir/mysqlnd.$suffix \$(phplibdir)
+
+$ext_builddir/mysqlnd.$suffix: \$(shared_objects_mysqlnd) \$(MYSQLND_SHARED_DEPENDENCIES)
+	$link_cmd
+
+EOF
+
+          ;;
+      esac
+      cat >> confdefs.h <<EOF
+#define COMPILE_DL_MYSQLND 1
+EOF
+
+    fi
+  fi
+
+  if test "$ext_shared" != "shared" && test "$ext_shared" != "yes" && test "" = "cli"; then
+    PHP_MYSQLND_SHARED=no
+    case "$PHP_SAPI" in
+      cgi|embed)
+        
+  
+  case ext/mysqlnd in
+  "") ac_srcdir="$abs_srcdir/"; unset ac_bdir; ac_inc="-I. -I$abs_srcdir" ;;
+  /*) ac_srcdir=`echo "ext/mysqlnd"|cut -c 2-`"/"; ac_bdir=$ac_srcdir; ac_inc="-I$ac_bdir -I$abs_srcdir/$ac_bdir" ;;
+  *) ac_srcdir="$abs_srcdir/ext/mysqlnd/"; ac_bdir="ext/mysqlnd/"; ac_inc="-I$ac_bdir -I$ac_srcdir" ;;
+  esac
+  
+  
+
+  b_c_pre=$php_c_pre
+  b_cxx_pre=$php_cxx_pre
+  b_c_meta=$php_c_meta
+  b_cxx_meta=$php_cxx_meta
+  b_c_post=$php_c_post
+  b_cxx_post=$php_cxx_post
+  b_lo=$php_lo
+
+
+  old_IFS=$IFS
+  for ac_src in $mysqlnd_sources; do
+  
+      IFS=.
+      set $ac_src
+      ac_obj=$1
+      IFS=$old_IFS
+      
+      PHP_GLOBAL_OBJS="$PHP_GLOBAL_OBJS $ac_bdir$ac_obj.lo"
+
+      case $ac_src in
+        *.c) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.s) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.S) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.cpp|*.cc|*.cxx) ac_comp="$b_cxx_pre $ac_extra $ac_inc $b_cxx_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_cxx_post" ;;
+      esac
+
+    cat >>Makefile.objects<<EOF
+$ac_bdir$ac_obj.lo: $ac_srcdir$ac_src
+	$ac_comp
+EOF
+  done
+
+
+        EXT_STATIC="$EXT_STATIC mysqlnd"
+        ;;
+      *)
+        
+  
+  case ext/mysqlnd in
+  "") ac_srcdir="$abs_srcdir/"; unset ac_bdir; ac_inc="-I. -I$abs_srcdir" ;;
+  /*) ac_srcdir=`echo "ext/mysqlnd"|cut -c 2-`"/"; ac_bdir=$ac_srcdir; ac_inc="-I$ac_bdir -I$abs_srcdir/$ac_bdir" ;;
+  *) ac_srcdir="$abs_srcdir/ext/mysqlnd/"; ac_bdir="ext/mysqlnd/"; ac_inc="-I$ac_bdir -I$ac_srcdir" ;;
+  esac
+  
+  
+
+  b_c_pre=$php_c_pre
+  b_cxx_pre=$php_cxx_pre
+  b_c_meta=$php_c_meta
+  b_cxx_meta=$php_cxx_meta
+  b_c_post=$php_c_post
+  b_cxx_post=$php_cxx_post
+  b_lo=$php_lo
+
+
+  old_IFS=$IFS
+  for ac_src in $mysqlnd_sources; do
+  
+      IFS=.
+      set $ac_src
+      ac_obj=$1
+      IFS=$old_IFS
+      
+      PHP_CLI_OBJS="$PHP_CLI_OBJS $ac_bdir$ac_obj.lo"
+
+      case $ac_src in
+        *.c) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.s) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.S) ac_comp="$b_c_pre $ac_extra $ac_inc $b_c_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_c_post" ;;
+        *.cpp|*.cc|*.cxx) ac_comp="$b_cxx_pre $ac_extra $ac_inc $b_cxx_meta -c $ac_srcdir$ac_src -o $ac_bdir$ac_obj.$b_lo $b_cxx_post" ;;
+      esac
+
+    cat >>Makefile.objects<<EOF
+$ac_bdir$ac_obj.lo: $ac_srcdir$ac_src
+	$ac_comp
+EOF
+  done
+
+
+        ;;
+    esac
+    EXT_CLI_STATIC="$EXT_CLI_STATIC mysqlnd"
+  fi
+  
+  
+    BUILD_DIR="$BUILD_DIR $ext_builddir"
+  
+
+
+  if test "$ext_builddir" = "."; then
+    PHP_PECL_EXTENSION=mysqlnd
+    
+  PHP_VAR_SUBST="$PHP_VAR_SUBST PHP_PECL_EXTENSION"
+
+  fi
+
+  
+  
+    $php_shtool mkdir -p ext/mysqlnd
+  
+
+  
+  
+    for header_file in ext/mysqlnd/; do
+      
+  
+  unique=`echo $header_file|$SED 's/[^a-zA-Z0-9]/_/g'`
+  
+  cmd="echo $ac_n \"\$INSTALLHEADERS$unique$ac_c\""
+  if test -n "$unique" && test "`eval $cmd`" = "" ; then
+    eval "INSTALLHEADERS$unique=set"
+    
+        INSTALL_HEADERS="$INSTALL_HEADERS $header_file"
+      
+  fi
+
+    done 
+  
+
+fi
+
+if test "$PHP_MYSQLND" != "no" || test "$PHP_MYSQLND_ENABLED" = "yes" || test "$PHP_MYSQLI" != "no"; then
+  
+  
+    $php_shtool mkdir -p ext/mysqlnd
+  
+
+
+    
+  for php_typename in int8 uint8 int16 uint16 int32 uint32 uchar ulong int8_t uint8_t int16_t uint16_t int32_t uint32_t int64_t uint64_t; do
+    echo $ac_n "checking whether $php_typename exists""... $ac_c" 1>&6
+echo "configure:107872: checking whether $php_typename exists" >&5
+    
+  php_cache_value=php_cv_sizeof_$php_typename
+  if eval "test \"`echo '$''{'php_cv_sizeof_$php_typename'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
+    old_LIBS=$LIBS
+    LIBS=
+    old_LDFLAGS=$LDFLAGS
+    LDFLAGS=
+    if test "$cross_compiling" = yes; then
+  
+    eval $php_cache_value=0
+
+else
+  cat > conftest.$ac_ext <<EOF
+#line 107889 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+  
+
+int main()
+{
+	FILE *fp = fopen("conftestval", "w");
+	if (!fp) return(1);
+	fprintf(fp, "%d\n", sizeof($php_typename));
+	return(0);
+}
+  
+EOF
+if { (eval echo configure:107919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  
+    eval $php_cache_value=`cat conftestval`
+  
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  
+    eval $php_cache_value=0
+  
+fi
+rm -fr conftest*
+fi
+
+  LDFLAGS=$old_LDFLAGS
+  LIBS=$old_LIBS
+
+fi
+
+  if eval test "\$$php_cache_value" != "0"; then
+
+      
+  php_def_have_what=HAVE_`echo $php_typename | tr 'abcdefghijklmnopqrstuvwxyz-' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_' `
+  echo "#define $php_def_have_what 1" >> ext/mysqlnd/php_mysqlnd_config.h
+  
+
+      echo "$ac_t""yes" 1>&6
+    
+else 
+      echo "$ac_t""no" 1>&6
+    
+  fi
+
+  done
+
+fi
+
+
 if test "$PHP_RECODE" != "no"; then
   test "$PHP_IMAP"  != "no" && recode_conflict="$recode_conflict imap"
   test "$PHP_MYSQL" != "no" && recode_conflict="$recode_conflict mysql"
@@ -107267,7 +108027,7 @@
 php_with_pear=DEFAULT
 
 echo $ac_n "checking whether to install PEAR""... $ac_c" 1>&6
-echo "configure:107271: checking whether to install PEAR" >&5
+echo "configure:108031: checking whether to install PEAR" >&5
 # Check whether --with-pear or --without-pear was given.
 if test "${with_pear+set}" = set; then
   withval="$with_pear"
@@ -107377,7 +108137,7 @@
   bison_version=none
   if test "$YACC"; then
     echo $ac_n "checking for bison version""... $ac_c" 1>&6
-echo "configure:107381: checking for bison version" >&5
+echo "configure:108141: checking for bison version" >&5
 if eval "test \"`echo '$''{'php_cv_bison_version'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -107434,17 +108194,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:107438: checking for $ac_hdr" >&5
+echo "configure:108198: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107443 "configure"
+#line 108203 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:107448: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:108208: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -107472,12 +108232,12 @@
 
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:107476: checking for size_t" >&5
+echo "configure:108236: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107481 "configure"
+#line 108241 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -107505,12 +108265,12 @@
 fi
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:107509: checking return type of signal handlers" >&5
+echo "configure:108269: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107514 "configure"
+#line 108274 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -107527,7 +108287,7 @@
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:107531: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:108291: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
@@ -107551,12 +108311,12 @@
 
 
 echo $ac_n "checking for uint""... $ac_c" 1>&6
-echo "configure:107555: checking for uint" >&5
+echo "configure:108315: checking for uint" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uint'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107560 "configure"
+#line 108320 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -107584,12 +108344,12 @@
 fi
 
 echo $ac_n "checking for ulong""... $ac_c" 1>&6
-echo "configure:107588: checking for ulong" >&5
+echo "configure:108348: checking for ulong" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ulong'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107593 "configure"
+#line 108353 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -107619,9 +108379,9 @@
 
 
 echo $ac_n "checking for int32_t""... $ac_c" 1>&6
-echo "configure:107623: checking for int32_t" >&5
+echo "configure:108383: checking for int32_t" >&5
 cat > conftest.$ac_ext <<EOF
-#line 107625 "configure"
+#line 108385 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H  
@@ -107640,7 +108400,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:107644: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:108404: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
   cat >> confdefs.h <<EOF
@@ -107659,9 +108419,9 @@
 rm -f conftest*
 
 echo $ac_n "checking for uint32_t""... $ac_c" 1>&6
-echo "configure:107663: checking for uint32_t" >&5
+echo "configure:108423: checking for uint32_t" >&5
 cat > conftest.$ac_ext <<EOF
-#line 107665 "configure"
+#line 108425 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H  
@@ -107680,7 +108440,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:107684: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:108444: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
   cat >> confdefs.h <<EOF
@@ -107699,12 +108459,12 @@
 rm -f conftest*
 
 echo $ac_n "checking for vprintf""... $ac_c" 1>&6
-echo "configure:107703: checking for vprintf" >&5
+echo "configure:108463: checking for vprintf" >&5
 if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107708 "configure"
+#line 108468 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char vprintf(); below.  */
@@ -107727,7 +108487,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:107731: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_vprintf=yes"
 else
@@ -107751,12 +108511,12 @@
 
 if test "$ac_cv_func_vprintf" != yes; then
 echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
-echo "configure:107755: checking for _doprnt" >&5
+echo "configure:108515: checking for _doprnt" >&5
 if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107760 "configure"
+#line 108520 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char _doprnt(); below.  */
@@ -107779,7 +108539,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:107783: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108543: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func__doprnt=yes"
 else
@@ -107804,7 +108564,7 @@
 fi
 
 echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
-echo "configure:107808: checking for 8-bit clean memcmp" >&5
+echo "configure:108568: checking for 8-bit clean memcmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -107812,7 +108572,7 @@
   ac_cv_func_memcmp_clean=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 107816 "configure"
+#line 108576 "configure"
 #include "confdefs.h"
 
 main()
@@ -107822,7 +108582,7 @@
 }
 
 EOF
-if { (eval echo configure:107826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:108586: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_memcmp_clean=yes
 else
@@ -107842,19 +108602,19 @@
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:107846: checking for working alloca.h" >&5
+echo "configure:108606: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107851 "configure"
+#line 108611 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:107858: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108618: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -107875,12 +108635,12 @@
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:107879: checking for alloca" >&5
+echo "configure:108639: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107884 "configure"
+#line 108644 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -107908,7 +108668,7 @@
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:107912: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108672: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -107940,12 +108700,12 @@
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:107944: checking whether alloca needs Cray hooks" >&5
+echo "configure:108704: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107949 "configure"
+#line 108709 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -107970,12 +108730,12 @@
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:107974: checking for $ac_func" >&5
+echo "configure:108734: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 107979 "configure"
+#line 108739 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -107998,7 +108758,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:108002: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108762: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -108025,7 +108785,7 @@
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:108029: checking stack direction for C alloca" >&5
+echo "configure:108789: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -108033,7 +108793,7 @@
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 108037 "configure"
+#line 108797 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -108052,7 +108812,7 @@
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:108056: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:108816: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -108076,12 +108836,12 @@
 for ac_func in memcpy strdup getpid kill strtod strtol finite fpclass
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:108080: checking for $ac_func" >&5
+echo "configure:108840: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 108085 "configure"
+#line 108845 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -108104,7 +108864,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:108108: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108868: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -108130,7 +108890,7 @@
 
 
   echo $ac_n "checking whether sprintf is broken""... $ac_c" 1>&6
-echo "configure:108134: checking whether sprintf is broken" >&5
+echo "configure:108894: checking whether sprintf is broken" >&5
 if eval "test \"`echo '$''{'ac_cv_broken_sprintf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -108141,11 +108901,11 @@
     
 else
   cat > conftest.$ac_ext <<EOF
-#line 108145 "configure"
+#line 108905 "configure"
 #include "confdefs.h"
 main() {char buf[20];exit(sprintf(buf,"testing 123")!=11); }
 EOF
-if { (eval echo configure:108149: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:108909: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       ac_cv_broken_sprintf=no
@@ -108179,12 +108939,12 @@
 for ac_func in finite isfinite isinf isnan
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:108183: checking for $ac_func" >&5
+echo "configure:108943: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 108188 "configure"
+#line 108948 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -108207,7 +108967,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:108211: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:108971: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -108234,13 +108994,13 @@
 
 
   echo $ac_n "checking whether fp_except is defined""... $ac_c" 1>&6
-echo "configure:108238: checking whether fp_except is defined" >&5
+echo "configure:108998: checking whether fp_except is defined" >&5
 if eval "test \"`echo '$''{'ac_cv_type_fp_except'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     cat > conftest.$ac_ext <<EOF
-#line 108244 "configure"
+#line 109004 "configure"
 #include "confdefs.h"
 
 #include <floatingpoint.h>
@@ -108251,7 +109011,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:108255: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:109015: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
      ac_cv_type_fp_except=yes
@@ -108281,17 +109041,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:108285: checking for $ac_hdr" >&5
+echo "configure:109045: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 108290 "configure"
+#line 109050 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:108295: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:109055: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -108319,14 +109079,14 @@
 
 
 echo $ac_n "checking whether dlsym() requires a leading underscore in symbol names""... $ac_c" 1>&6
-echo "configure:108323: checking whether dlsym() requires a leading underscore in symbol names" >&5
+echo "configure:109083: checking whether dlsym() requires a leading underscore in symbol names" >&5
 if test "$cross_compiling" = yes; then :
   
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 108330 "configure"
+#line 109090 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -108389,7 +109149,7 @@
     exit (status);
 }
 EOF
-  if { (eval echo configure:108393: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} 2>/dev/null; then
+  if { (eval echo configure:109153: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -108472,23 +109232,23 @@
 
 
 echo $ac_n "checking virtual machine dispatch method""... $ac_c" 1>&6
-echo "configure:108476: checking virtual machine dispatch method" >&5
+echo "configure:109236: checking virtual machine dispatch method" >&5
 echo "$ac_t""$PHP_ZEND_VM" 1>&6
 
 echo $ac_n "checking whether to enable thread-safety""... $ac_c" 1>&6
-echo "configure:108480: checking whether to enable thread-safety" >&5
+echo "configure:109240: checking whether to enable thread-safety" >&5
 echo "$ac_t""$ZEND_MAINTAINER_ZTS" 1>&6
 
 echo $ac_n "checking whether to enable inline optimization for GCC""... $ac_c" 1>&6
-echo "configure:108484: checking whether to enable inline optimization for GCC" >&5
+echo "configure:109244: checking whether to enable inline optimization for GCC" >&5
 echo "$ac_t""$ZEND_INLINE_OPTIMIZATION" 1>&6
 
 echo $ac_n "checking whether to enable Zend debugging""... $ac_c" 1>&6
-echo "configure:108488: checking whether to enable Zend debugging" >&5
+echo "configure:109248: checking whether to enable Zend debugging" >&5
 echo "$ac_t""$ZEND_DEBUG" 1>&6
 
 echo $ac_n "checking whether to enable Zend multibyte""... $ac_c" 1>&6
-echo "configure:108492: checking whether to enable Zend multibyte" >&5
+echo "configure:109252: checking whether to enable Zend multibyte" >&5
 echo "$ac_t""$ZEND_MULTIBYTE" 1>&6
 	
 case $PHP_ZEND_VM in
@@ -108561,21 +109321,21 @@
 
 
 echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:108565: checking for inline" >&5
+echo "configure:109325: checking for inline" >&5
 if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat > conftest.$ac_ext <<EOF
-#line 108572 "configure"
+#line 109332 "configure"
 #include "confdefs.h"
 
 int main() {
 } $ac_kw foo() {
 ; return 0; }
 EOF
-if { (eval echo configure:108579: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:109339: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_inline=$ac_kw; break
 else
@@ -108604,7 +109364,7 @@
 
 
 echo $ac_n "checking target system is Darwin""... $ac_c" 1>&6
-echo "configure:108608: checking target system is Darwin" >&5
+echo "configure:109368: checking target system is Darwin" >&5
 if echo "$target" | grep "darwin" > /dev/null; then
   cat >> confdefs.h <<\EOF
 #define DARWIN 1
@@ -108616,7 +109376,7 @@
 fi
 
 echo $ac_n "checking for MM alignment and log values""... $ac_c" 1>&6
-echo "configure:108620: checking for MM alignment and log values" >&5
+echo "configure:109380: checking for MM alignment and log values" >&5
 
 if test "$cross_compiling" = yes; then
   
@@ -108624,7 +109384,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 108628 "configure"
+#line 109388 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -108660,7 +109420,7 @@
 }
 
 EOF
-if { (eval echo configure:108664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:109424: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   LIBZEND_MM_ALIGN=`cat conftest.zend | cut -d ' ' -f 1`
@@ -108685,7 +109445,7 @@
 echo "$ac_t""done" 1>&6
 
 echo $ac_n "checking for memory allocation using mmap(MAP_ANON)""... $ac_c" 1>&6
-echo "configure:108689: checking for memory allocation using mmap(MAP_ANON)" >&5
+echo "configure:109449: checking for memory allocation using mmap(MAP_ANON)" >&5
 
 if test "$cross_compiling" = yes; then
   
@@ -108693,7 +109453,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 108697 "configure"
+#line 109457 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -108729,7 +109489,7 @@
 }
 
 EOF
-if { (eval echo configure:108733: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:109493: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   cat >> confdefs.h <<\EOF
@@ -108751,7 +109511,7 @@
 
 
 echo $ac_n "checking for memory allocation using mmap("/dev/zero")""... $ac_c" 1>&6
-echo "configure:108755: checking for memory allocation using mmap("/dev/zero")" >&5
+echo "configure:109515: checking for memory allocation using mmap("/dev/zero")" >&5
 
 if test "$cross_compiling" = yes; then
   
@@ -108759,7 +109519,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 108763 "configure"
+#line 109523 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -108805,7 +109565,7 @@
 }
 
 EOF
-if { (eval echo configure:108809: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:109569: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   cat >> confdefs.h <<\EOF
@@ -108829,12 +109589,12 @@
 for ac_func in mremap
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:108833: checking for $ac_func" >&5
+echo "configure:109593: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 108838 "configure"
+#line 109598 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -108857,7 +109617,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:108861: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:109621: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -108924,17 +109684,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:108928: checking for $ac_hdr" >&5
+echo "configure:109688: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 108933 "configure"
+#line 109693 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:108938: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:109698: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -109011,7 +109771,7 @@
   
 
 echo $ac_n "checking for GNU Pth""... $ac_c" 1>&6
-echo "configure:109015: checking for GNU Pth" >&5
+echo "configure:109775: checking for GNU Pth" >&5
 PTH_PREFIX="`$TSRM_PTH --prefix`"
 if test -z "$PTH_PREFIX"; then
   echo "$ac_t""Please check your Pth installation" 1>&6
@@ -109041,17 +109801,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:109045: checking for $ac_hdr" >&5
+echo "configure:109805: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 109050 "configure"
+#line 109810 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:109055: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:109815: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -109081,7 +109841,7 @@
 
   LIBS="$LIBS -lst"
   echo $ac_n "checking for SGI's State Threads""... $ac_c" 1>&6
-echo "configure:109085: checking for SGI's State Threads" >&5
+echo "configure:109845: checking for SGI's State Threads" >&5
   echo "$ac_t""yes" 1>&6
   cat >> confdefs.h <<\EOF
 #define TSRM_ST 1
@@ -109120,7 +109880,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 109124 "configure"
+#line 109884 "configure"
 #include "confdefs.h"
 
 #include <pthread.h>
@@ -109138,7 +109898,7 @@
     return pthread_create(&thd, NULL, thread_routine, &data);
 } 
 EOF
-if { (eval echo configure:109142: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:109902: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   pthreads_working=yes
@@ -109158,7 +109918,7 @@
   CFLAGS=$save_CFLAGS
 
   echo $ac_n "checking for pthreads_cflags""... $ac_c" 1>&6
-echo "configure:109162: checking for pthreads_cflags" >&5
+echo "configure:109922: checking for pthreads_cflags" >&5
 if eval "test \"`echo '$''{'ac_cv_pthreads_cflags'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -109180,7 +109940,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 109184 "configure"
+#line 109944 "configure"
 #include "confdefs.h"
 
 #include <pthread.h>
@@ -109198,7 +109958,7 @@
     return pthread_create(&thd, NULL, thread_routine, &data);
 } 
 EOF
-if { (eval echo configure:109202: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:109962: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   pthreads_working=yes
@@ -109228,7 +109988,7 @@
 echo "$ac_t""$ac_cv_pthreads_cflags" 1>&6
 
 echo $ac_n "checking for pthreads_lib""... $ac_c" 1>&6
-echo "configure:109232: checking for pthreads_lib" >&5
+echo "configure:109992: checking for pthreads_lib" >&5
 if eval "test \"`echo '$''{'ac_cv_pthreads_lib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -109250,7 +110010,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 109254 "configure"
+#line 110014 "configure"
 #include "confdefs.h"
 
 #include <pthread.h>
@@ -109268,7 +110028,7 @@
     return pthread_create(&thd, NULL, thread_routine, &data);
 } 
 EOF
-if { (eval echo configure:109272: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:110032: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   pthreads_working=yes
@@ -109319,7 +110079,7 @@
 
 
   echo $ac_n "checking for POSIX threads""... $ac_c" 1>&6
-echo "configure:109323: checking for POSIX threads" >&5
+echo "configure:110083: checking for POSIX threads" >&5
   echo "$ac_t""yes" 1>&6
 fi
 
@@ -109966,7 +110726,7 @@
 
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:109970: checking build system type" >&5
+echo "configure:110730: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
@@ -109995,7 +110755,7 @@
 if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   echo $ac_n "checking for ld used by $CC""... $ac_c" 1>&6
-echo "configure:109999: checking for ld used by $CC" >&5
+echo "configure:110759: checking for ld used by $CC" >&5
   case $host in
   *-*-mingw*)
     # gcc leaves a trailing carriage return which upsets mingw
@@ -110025,10 +110785,10 @@
   esac
 elif test "$with_gnu_ld" = yes; then
   echo $ac_n "checking for GNU ld""... $ac_c" 1>&6
-echo "configure:110029: checking for GNU ld" >&5
+echo "configure:110789: checking for GNU ld" >&5
 else
   echo $ac_n "checking for non-GNU ld""... $ac_c" 1>&6
-echo "configure:110032: checking for non-GNU ld" >&5
+echo "configure:110792: checking for non-GNU ld" >&5
 fi
 if eval "test \"`echo '$''{'lt_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -110067,7 +110827,7 @@
 fi
 test -z "$LD" && { echo "configure: error: no acceptable ld found in \$PATH" 1>&2; exit 1; }
 echo $ac_n "checking if the linker ($LD) is GNU ld""... $ac_c" 1>&6
-echo "configure:110071: checking if the linker ($LD) is GNU ld" >&5
+echo "configure:110831: checking if the linker ($LD) is GNU ld" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_gnu_ld'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110087,7 +110847,7 @@
 
 
 echo $ac_n "checking for $LD option to reload object files""... $ac_c" 1>&6
-echo "configure:110091: checking for $LD option to reload object files" >&5
+echo "configure:110851: checking for $LD option to reload object files" >&5
 if eval "test \"`echo '$''{'lt_cv_ld_reload_flag'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110112,7 +110872,7 @@
 esac
 
 echo $ac_n "checking for BSD-compatible nm""... $ac_c" 1>&6
-echo "configure:110116: checking for BSD-compatible nm" >&5
+echo "configure:110876: checking for BSD-compatible nm" >&5
 if eval "test \"`echo '$''{'lt_cv_path_NM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110165,7 +110925,7 @@
 NM="$lt_cv_path_NM"
 
 echo $ac_n "checking how to recognize dependent libraries""... $ac_c" 1>&6
-echo "configure:110169: checking how to recognize dependent libraries" >&5
+echo "configure:110929: checking how to recognize dependent libraries" >&5
 if eval "test \"`echo '$''{'lt_cv_deplibs_check_method'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110357,13 +111117,13 @@
 test -z "$deplibs_check_method" && deplibs_check_method=unknown
 
 echo $ac_n "checking for object suffix""... $ac_c" 1>&6
-echo "configure:110361: checking for object suffix" >&5
+echo "configure:111121: checking for object suffix" >&5
 if eval "test \"`echo '$''{'ac_cv_objext'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   rm -f conftest*
 echo 'int i = 1;' > conftest.$ac_ext
-if { (eval echo configure:110367: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:111127: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   for ac_file in conftest.*; do
     case $ac_file in
     *.c) ;;
@@ -110383,7 +111143,7 @@
 
 
 echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
-echo "configure:110387: checking for executable suffix" >&5
+echo "configure:111147: checking for executable suffix" >&5
 if eval "test \"`echo '$''{'ac_cv_exeext'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110393,10 +111153,10 @@
   rm -f conftest*
   echo 'int main () { return 0; }' > conftest.$ac_ext
   ac_cv_exeext=
-  if { (eval echo configure:110397: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; }; then
+  if { (eval echo configure:111157: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; }; then
     for file in conftest.*; do
       case $file in
-      *.c | *.o | *.obj) ;;
+      *.$ac_ext | *.c | *.o | *.obj) ;;
       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;
       esac
     done
@@ -110439,7 +111199,7 @@
 ia64-*-hpux*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
-  if { (eval echo configure:110443: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  if { (eval echo configure:111203: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
     case `/usr/bin/file conftest.$ac_objext` in
     *ELF-32*)
       HPUX_IA64_MODE="32"
@@ -110453,8 +111213,8 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 110457 "configure"' > conftest.$ac_ext
-  if { (eval echo configure:110458: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  echo '#line 111217 "configure"' > conftest.$ac_ext
+  if { (eval echo configure:111218: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    if test "$lt_cv_prog_gnu_ld" = yes; then
     case `/usr/bin/file conftest.$ac_objext` in
     *32-bit*)
@@ -110488,7 +111248,7 @@
 s390*-*linux*|sparc*-*linux*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
-  if { (eval echo configure:110492: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  if { (eval echo configure:111252: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
     case `/usr/bin/file conftest.o` in
     *32-bit*)
       case $host in
@@ -110538,7 +111298,7 @@
   SAVE_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -belf"
   echo $ac_n "checking whether the C compiler needs -belf""... $ac_c" 1>&6
-echo "configure:110542: checking whether the C compiler needs -belf" >&5
+echo "configure:111302: checking whether the C compiler needs -belf" >&5
 if eval "test \"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110551,14 +111311,14 @@
 cross_compiling=$ac_cv_prog_cc_cross
 
      cat > conftest.$ac_ext <<EOF
-#line 110555 "configure"
+#line 111315 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:110562: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:111322: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   lt_cv_cc_needs_belf=yes
 else
@@ -110586,7 +111346,7 @@
 sparc*-*solaris*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
-  if { (eval echo configure:110590: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  if { (eval echo configure:111350: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
     case `/usr/bin/file conftest.o` in
     *64-bit*)
       case $lt_cv_prog_gnu_ld in
@@ -110622,7 +111382,7 @@
 # Autoconf 2.13's AC_OBJEXT and AC_EXEEXT macros only works for C compilers!
 # find the maximum length of command line arguments
 echo $ac_n "checking the maximum length of command line arguments""... $ac_c" 1>&6
-echo "configure:110626: checking the maximum length of command line arguments" >&5
+echo "configure:111386: checking the maximum length of command line arguments" >&5
 if eval "test \"`echo '$''{'lt_cv_sys_max_cmd_len'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110744,7 +111504,7 @@
 
 # Check for command to grab the raw symbol name followed by C symbol from nm.
 echo $ac_n "checking command to parse $NM output from $compiler object""... $ac_c" 1>&6
-echo "configure:110748: checking command to parse $NM output from $compiler object" >&5
+echo "configure:111508: checking command to parse $NM output from $compiler object" >&5
 if eval "test \"`echo '$''{'lt_cv_sys_global_symbol_pipe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -110848,10 +111608,10 @@
 int main(){nm_test_var='a';nm_test_func();return(0);}
 EOF
 
-  if { (eval echo configure:110852: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  if { (eval echo configure:111612: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
     # Now try to grab the symbols.
     nlist=conftest.nm
-    if { (eval echo configure:110855: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\") 1>&5; (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5; } && test -s "$nlist"; then
+    if { (eval echo configure:111615: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\") 1>&5; (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5; } && test -s "$nlist"; then
       # Try sorting and uniquifying the output.
       if sort "$nlist" | uniq > "$nlist"T; then
 	mv -f "$nlist"T "$nlist"
@@ -110902,7 +111662,7 @@
 	  lt_save_CFLAGS="$CFLAGS"
 	  LIBS="conftstm.$ac_objext"
 	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
-	  if { (eval echo configure:110906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+	  if { (eval echo configure:111666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
 	    pipe_works=yes
 	  fi
 	  LIBS="$lt_save_LIBS"
@@ -110942,7 +111702,7 @@
 fi
 
 echo $ac_n "checking for objdir""... $ac_c" 1>&6
-echo "configure:110946: checking for objdir" >&5
+echo "configure:111706: checking for objdir" >&5
 if eval "test \"`echo '$''{'lt_cv_objdir'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111008,7 +111768,7 @@
 # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111012: checking for $ac_word" >&5
+echo "configure:111772: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111040,7 +111800,7 @@
   # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111044: checking for $ac_word" >&5
+echo "configure:111804: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111075,7 +111835,7 @@
 # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111079: checking for $ac_word" >&5
+echo "configure:111839: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111107,7 +111867,7 @@
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111111: checking for $ac_word" >&5
+echo "configure:111871: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111142,7 +111902,7 @@
 # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111146: checking for $ac_word" >&5
+echo "configure:111906: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111174,7 +111934,7 @@
   # Extract the first word of "strip", so it can be a program name with args.
 set dummy strip; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111178: checking for $ac_word" >&5
+echo "configure:111938: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111261,7 +112021,7 @@
 file_magic*)
   if test "$file_magic_cmd" = '$MAGIC_CMD'; then
     echo $ac_n "checking for ${ac_tool_prefix}file""... $ac_c" 1>&6
-echo "configure:111265: checking for ${ac_tool_prefix}file" >&5
+echo "configure:112025: checking for ${ac_tool_prefix}file" >&5
 if eval "test \"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111321,7 +112081,7 @@
 if test -z "$lt_cv_path_MAGIC_CMD"; then
   if test -n "$ac_tool_prefix"; then
     echo $ac_n "checking for file""... $ac_c" 1>&6
-echo "configure:111325: checking for file" >&5
+echo "configure:112085: checking for file" >&5
 if eval "test \"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111393,7 +112153,7 @@
     # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
 set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111397: checking for $ac_word" >&5
+echo "configure:112157: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_DSYMUTIL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111425,7 +112185,7 @@
   # Extract the first word of "dsymutil", so it can be a program name with args.
 set dummy dsymutil; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111429: checking for $ac_word" >&5
+echo "configure:112189: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_DSYMUTIL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111460,7 +112220,7 @@
     # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
 set dummy ${ac_tool_prefix}nmedit; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111464: checking for $ac_word" >&5
+echo "configure:112224: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_NMEDIT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111492,7 +112252,7 @@
   # Extract the first word of "nmedit", so it can be a program name with args.
 set dummy nmedit; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:111496: checking for $ac_word" >&5
+echo "configure:112256: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_NMEDIT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111526,7 +112286,7 @@
 
 
     echo $ac_n "checking for -single_module linker flag""... $ac_c" 1>&6
-echo "configure:111530: checking for -single_module linker flag" >&5
+echo "configure:112290: checking for -single_module linker flag" >&5
 if eval "test \"`echo '$''{'lt_cv_apple_cc_single_mod'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111549,7 +112309,7 @@
 
 echo "$ac_t""$lt_cv_apple_cc_single_mod" 1>&6
     echo $ac_n "checking for -exported_symbols_list linker flag""... $ac_c" 1>&6
-echo "configure:111553: checking for -exported_symbols_list linker flag" >&5
+echo "configure:112313: checking for -exported_symbols_list linker flag" >&5
 if eval "test \"`echo '$''{'lt_cv_ld_exported_symbols_list'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111559,12 +112319,12 @@
       LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
       
 cat > conftest.$ac_ext <<EOF
-#line 111563 "configure"
+#line 112323 "configure"
 #include "confdefs.h"
 int main() {
 ; return 0; }
 EOF
-if { (eval echo configure:111568: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:112328: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
  lt_cv_ld_exported_symbols_list=yes
   rm -rf conftest*
 else
@@ -111698,7 +112458,7 @@
 
   
 echo $ac_n "checking if $compiler supports -fno-rtti -fno-exceptions""... $ac_c" 1>&6
-echo "configure:111702: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+echo "configure:112462: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_rtti_exceptions'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -111715,11 +112475,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"configure:111719: $lt_compile\"" >&5)
+   (eval echo "\"configure:112479: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "configure:111723: \$? = $ac_status" >&5
+   echo "configure:112483: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -111748,7 +112508,7 @@
 lt_prog_compiler_static=
 
 echo $ac_n "checking for $compiler option to produce PIC""... $ac_c" 1>&6
-echo "configure:111752: checking for $compiler option to produce PIC" >&5
+echo "configure:112512: checking for $compiler option to produce PIC" >&5
  
   if test "$GCC" = yes; then
     lt_prog_compiler_wl='-Wl,'
@@ -111995,7 +112755,7 @@
 if test -n "$lt_prog_compiler_pic"; then
   
 echo $ac_n "checking if $compiler PIC flag $lt_prog_compiler_pic works""... $ac_c" 1>&6
-echo "configure:111999: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+echo "configure:112759: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_pic_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -112012,11 +112772,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"configure:112016: $lt_compile\"" >&5)
+   (eval echo "\"configure:112776: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "configure:112020: \$? = $ac_status" >&5
+   echo "configure:112780: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -112058,7 +112818,7 @@
 #
 wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
 echo $ac_n "checking if $compiler static flag $lt_tmp_static_flag works""... $ac_c" 1>&6
-echo "configure:112062: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+echo "configure:112822: checking if $compiler static flag $lt_tmp_static_flag works" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_static_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -112096,7 +112856,7 @@
 
 
 echo $ac_n "checking if $compiler supports -c -o file.$ac_objext""... $ac_c" 1>&6
-echo "configure:112100: checking if $compiler supports -c -o file.$ac_objext" >&5
+echo "configure:112860: checking if $compiler supports -c -o file.$ac_objext" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_c_o'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -112116,11 +112876,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"configure:112120: $lt_compile\"" >&5)
+   (eval echo "\"configure:112880: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "configure:112124: \$? = $ac_status" >&5
+   echo "configure:112884: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -112150,7 +112910,7 @@
 if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
   # do not overwrite the value of need_locks provided by the user
   echo $ac_n "checking if we can lock with hard links""... $ac_c" 1>&6
-echo "configure:112154: checking if we can lock with hard links" >&5
+echo "configure:112914: checking if we can lock with hard links" >&5
   hard_links=yes
   $rm conftest*
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
@@ -112167,7 +112927,7 @@
 fi
 
 echo $ac_n "checking whether the $compiler linker ($LD) supports shared libraries""... $ac_c" 1>&6
-echo "configure:112171: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+echo "configure:112931: checking whether the $compiler linker ($LD) supports shared libraries" >&5
 
   runpath_var=
   allow_undefined_flag=
@@ -112578,12 +113338,12 @@
        # Determine the default libpath from the value encoded in an empty executable.
        
 cat > conftest.$ac_ext <<EOF
-#line 112582 "configure"
+#line 113342 "configure"
 #include "confdefs.h"
 int main() {
 ; return 0; }
 EOF
-if { (eval echo configure:112587: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:113347: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
  
 lt_aix_libpath_sed='
     /Import File Strings/,/^$/ {
@@ -112616,12 +113376,12 @@
 	 # Determine the default libpath from the value encoded in an empty executable.
 	 
 cat > conftest.$ac_ext <<EOF
-#line 112620 "configure"
+#line 113380 "configure"
 #include "confdefs.h"
 int main() {
 ; return 0; }
 EOF
-if { (eval echo configure:112625: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:113385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
  
 lt_aix_libpath_sed='
     /Import File Strings/,/^$/ {
@@ -113111,11 +113871,11 @@
       # systems, -lgcc has to come before -lc. If gcc already passes -lc
       # to ld, don't add -lc before -lgcc.
       echo $ac_n "checking whether -lc should be explicitly linked in""... $ac_c" 1>&6
-echo "configure:113115: checking whether -lc should be explicitly linked in" >&5
+echo "configure:113875: checking whether -lc should be explicitly linked in" >&5
       $rm conftest*
       echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-      if { (eval echo configure:113119: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; } 2>conftest.err; then
+      if { (eval echo configure:113879: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; } 2>conftest.err; then
         soname=conftest
         lib=conftest
         libobjs=conftest.$ac_objext
@@ -113129,7 +113889,7 @@
         libname=conftest
         lt_save_allow_undefined_flag=$allow_undefined_flag
         allow_undefined_flag=
-        if { (eval echo configure:113133: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\") 1>&5; (eval $archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5; }
+        if { (eval echo configure:113893: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\") 1>&5; (eval $archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5; }
         then
 	  archive_cmds_need_lc=no
         else
@@ -113148,7 +113908,7 @@
 esac
 
 echo $ac_n "checking dynamic linker characteristics""... $ac_c" 1>&6
-echo "configure:113152: checking dynamic linker characteristics" >&5
+echo "configure:113912: checking dynamic linker characteristics" >&5
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
@@ -113773,7 +114533,7 @@
 fi
 
 echo $ac_n "checking how to hardcode library paths into programs""... $ac_c" 1>&6
-echo "configure:113777: checking how to hardcode library paths into programs" >&5
+echo "configure:114537: checking how to hardcode library paths into programs" >&5
 hardcode_action=
 if test -n "$hardcode_libdir_flag_spec" || \
    test -n "$runpath_var" || \
@@ -113811,7 +114571,7 @@
 striplib=
 old_striplib=
 echo $ac_n "checking whether stripping libraries is possible""... $ac_c" 1>&6
-echo "configure:113815: checking whether stripping libraries is possible" >&5
+echo "configure:114575: checking whether stripping libraries is possible" >&5
 if test -n "$STRIP" && $STRIP -V 2>&1 | grep "GNU strip" >/dev/null; then
   test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
   test -z "$striplib" && striplib="$STRIP --strip-unneeded"
@@ -113862,7 +114622,7 @@
   darwin*)
   # if libdl is installed we need to link against it
     echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:113866: checking for dlopen in -ldl" >&5
+echo "configure:114626: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -113870,7 +114630,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 113874 "configure"
+#line 114634 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -113881,7 +114641,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:113885: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114645: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -113910,12 +114670,12 @@
 
   *)
     echo $ac_n "checking for shl_load""... $ac_c" 1>&6
-echo "configure:113914: checking for shl_load" >&5
+echo "configure:114674: checking for shl_load" >&5
 if eval "test \"`echo '$''{'ac_cv_func_shl_load'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 113919 "configure"
+#line 114679 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char shl_load(); below.  */
@@ -113938,7 +114698,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:113942: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114702: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_shl_load=yes"
 else
@@ -113956,7 +114716,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for shl_load in -ldld""... $ac_c" 1>&6
-echo "configure:113960: checking for shl_load in -ldld" >&5
+echo "configure:114720: checking for shl_load in -ldld" >&5
 ac_lib_var=`echo dld'_'shl_load | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -113964,7 +114724,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldld  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 113968 "configure"
+#line 114728 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -113975,7 +114735,7 @@
 shl_load()
 ; return 0; }
 EOF
-if { (eval echo configure:113979: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114739: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -113994,12 +114754,12 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dlopen""... $ac_c" 1>&6
-echo "configure:113998: checking for dlopen" >&5
+echo "configure:114758: checking for dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 114003 "configure"
+#line 114763 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen(); below.  */
@@ -114022,7 +114782,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:114026: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114786: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dlopen=yes"
 else
@@ -114040,7 +114800,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:114044: checking for dlopen in -ldl" >&5
+echo "configure:114804: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -114048,7 +114808,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 114052 "configure"
+#line 114812 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -114059,7 +114819,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:114063: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114823: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -114078,7 +114838,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dlopen in -lsvld""... $ac_c" 1>&6
-echo "configure:114082: checking for dlopen in -lsvld" >&5
+echo "configure:114842: checking for dlopen in -lsvld" >&5
 ac_lib_var=`echo svld'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -114086,7 +114846,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsvld  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 114090 "configure"
+#line 114850 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -114097,7 +114857,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:114101: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114861: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -114116,7 +114876,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dld_link in -ldld""... $ac_c" 1>&6
-echo "configure:114120: checking for dld_link in -ldld" >&5
+echo "configure:114880: checking for dld_link in -ldld" >&5
 ac_lib_var=`echo dld'_'dld_link | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -114124,7 +114884,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldld  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 114128 "configure"
+#line 114888 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -114135,7 +114895,7 @@
 dld_link()
 ; return 0; }
 EOF
-if { (eval echo configure:114139: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:114899: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -114191,7 +114951,7 @@
     LIBS="$lt_cv_dlopen_libs $LIBS"
 
     echo $ac_n "checking whether a program can dlopen itself""... $ac_c" 1>&6
-echo "configure:114195: checking whether a program can dlopen itself" >&5
+echo "configure:114955: checking whether a program can dlopen itself" >&5
 if eval "test \"`echo '$''{'lt_cv_dlopen_self'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -114201,7 +114961,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 114205 "configure"
+#line 114965 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -114264,7 +115024,7 @@
     exit (status);
 }
 EOF
-  if { (eval echo configure:114268: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} 2>/dev/null; then
+  if { (eval echo configure:115028: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -114287,7 +115047,7 @@
     if test "x$lt_cv_dlopen_self" = xyes; then
       wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
       echo $ac_n "checking whether a statically linked program can dlopen itself""... $ac_c" 1>&6
-echo "configure:114291: checking whether a statically linked program can dlopen itself" >&5
+echo "configure:115051: checking whether a statically linked program can dlopen itself" >&5
 if eval "test \"`echo '$''{'lt_cv_dlopen_self_static'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -114297,7 +115057,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 114301 "configure"
+#line 115061 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -114360,7 +115120,7 @@
     exit (status);
 }
 EOF
-  if { (eval echo configure:114364: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} 2>/dev/null; then
+  if { (eval echo configure:115124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -114401,11 +115161,11 @@
 
 # Report which library types will actually be built
 echo $ac_n "checking if libtool supports shared libraries""... $ac_c" 1>&6
-echo "configure:114405: checking if libtool supports shared libraries" >&5
+echo "configure:115165: checking if libtool supports shared libraries" >&5
 echo "$ac_t""$can_build_shared" 1>&6
 
 echo $ac_n "checking whether to build shared libraries""... $ac_c" 1>&6
-echo "configure:114409: checking whether to build shared libraries" >&5
+echo "configure:115169: checking whether to build shared libraries" >&5
 test "$can_build_shared" = "no" && enable_shared=no
 
 # On AIX, shared libraries and static libraries use the same namespace, and
@@ -114428,7 +115188,7 @@
 echo "$ac_t""$enable_shared" 1>&6
 
 echo $ac_n "checking whether to build static libraries""... $ac_c" 1>&6
-echo "configure:114432: checking whether to build static libraries" >&5
+echo "configure:115192: checking whether to build static libraries" >&5
 # Make sure either enable_shared or enable_static is yes.
 test "$enable_shared" = yes || enable_static=yes
 echo "$ac_t""$enable_static" 1>&6
@@ -115114,7 +115874,7 @@
 if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   echo $ac_n "checking for ld used by $CC""... $ac_c" 1>&6
-echo "configure:115118: checking for ld used by $CC" >&5
+echo "configure:115878: checking for ld used by $CC" >&5
   case $host in
   *-*-mingw*)
     # gcc leaves a trailing carriage return which upsets mingw
@@ -115144,10 +115904,10 @@
   esac
 elif test "$with_gnu_ld" = yes; then
   echo $ac_n "checking for GNU ld""... $ac_c" 1>&6
-echo "configure:115148: checking for GNU ld" >&5
+echo "configure:115908: checking for GNU ld" >&5
 else
   echo $ac_n "checking for non-GNU ld""... $ac_c" 1>&6
-echo "configure:115151: checking for non-GNU ld" >&5
+echo "configure:115911: checking for non-GNU ld" >&5
 fi
 if eval "test \"`echo '$''{'lt_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -115186,7 +115946,7 @@
 fi
 test -z "$LD" && { echo "configure: error: no acceptable ld found in \$PATH" 1>&2; exit 1; }
 echo $ac_n "checking if the linker ($LD) is GNU ld""... $ac_c" 1>&6
-echo "configure:115190: checking if the linker ($LD) is GNU ld" >&5
+echo "configure:115950: checking if the linker ($LD) is GNU ld" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_gnu_ld'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -115252,7 +116012,7 @@
 
 # PORTME: fill in a description of your system's C++ link characteristics
 echo $ac_n "checking whether the $compiler linker ($LD) supports shared libraries""... $ac_c" 1>&6
-echo "configure:115256: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+echo "configure:116016: checking whether the $compiler linker ($LD) supports shared libraries" >&5
 ld_shlibs_CXX=yes
 case $host_os in
   aix3*)
@@ -115350,12 +116110,12 @@
       # Determine the default libpath from the value encoded in an empty executable.
       
 cat > conftest.$ac_ext <<EOF
-#line 115354 "configure"
+#line 116114 "configure"
 #include "confdefs.h"
 int main() {
 ; return 0; }
 EOF
-if { (eval echo configure:115359: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:116119: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
  
 lt_aix_libpath_sed='
     /Import File Strings/,/^$/ {
@@ -115389,12 +116149,12 @@
 	# Determine the default libpath from the value encoded in an empty executable.
 	
 cat > conftest.$ac_ext <<EOF
-#line 115393 "configure"
+#line 116153 "configure"
 #include "confdefs.h"
 int main() {
 ; return 0; }
 EOF
-if { (eval echo configure:115398: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:116158: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
  
 lt_aix_libpath_sed='
     /Import File Strings/,/^$/ {
@@ -116161,7 +116921,7 @@
 };
 EOF
 
-if { (eval echo configure:116165: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:116925: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   # Parse the compiler output and extract the necessary
   # objects, libraries and library flags.
 
@@ -116317,7 +117077,7 @@
 lt_prog_compiler_static_CXX=
 
 echo $ac_n "checking for $compiler option to produce PIC""... $ac_c" 1>&6
-echo "configure:116321: checking for $compiler option to produce PIC" >&5
+echo "configure:117081: checking for $compiler option to produce PIC" >&5
  
   # C++ specific cases for pic, static, wl, etc.
   if test "$GXX" = yes; then
@@ -116614,7 +117374,7 @@
 if test -n "$lt_prog_compiler_pic_CXX"; then
   
 echo $ac_n "checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works""... $ac_c" 1>&6
-echo "configure:116618: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
+echo "configure:117378: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_pic_works_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -116631,11 +117391,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"configure:116635: $lt_compile\"" >&5)
+   (eval echo "\"configure:117395: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "configure:116639: \$? = $ac_status" >&5
+   echo "configure:117399: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -116677,7 +117437,7 @@
 #
 wl=$lt_prog_compiler_wl_CXX eval lt_tmp_static_flag=\"$lt_prog_compiler_static_CXX\"
 echo $ac_n "checking if $compiler static flag $lt_tmp_static_flag works""... $ac_c" 1>&6
-echo "configure:116681: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+echo "configure:117441: checking if $compiler static flag $lt_tmp_static_flag works" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_static_works_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -116715,7 +117475,7 @@
 
 
 echo $ac_n "checking if $compiler supports -c -o file.$ac_objext""... $ac_c" 1>&6
-echo "configure:116719: checking if $compiler supports -c -o file.$ac_objext" >&5
+echo "configure:117479: checking if $compiler supports -c -o file.$ac_objext" >&5
 if eval "test \"`echo '$''{'lt_cv_prog_compiler_c_o_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -116735,11 +117495,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"configure:116739: $lt_compile\"" >&5)
+   (eval echo "\"configure:117499: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "configure:116743: \$? = $ac_status" >&5
+   echo "configure:117503: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -116769,7 +117529,7 @@
 if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
   # do not overwrite the value of need_locks provided by the user
   echo $ac_n "checking if we can lock with hard links""... $ac_c" 1>&6
-echo "configure:116773: checking if we can lock with hard links" >&5
+echo "configure:117533: checking if we can lock with hard links" >&5
   hard_links=yes
   $rm conftest*
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
@@ -116786,7 +117546,7 @@
 fi
 
 echo $ac_n "checking whether the $compiler linker ($LD) supports shared libraries""... $ac_c" 1>&6
-echo "configure:116790: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+echo "configure:117550: checking whether the $compiler linker ($LD) supports shared libraries" >&5
 
   export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
   case $host_os in
@@ -116832,11 +117592,11 @@
       # systems, -lgcc has to come before -lc. If gcc already passes -lc
       # to ld, don't add -lc before -lgcc.
       echo $ac_n "checking whether -lc should be explicitly linked in""... $ac_c" 1>&6
-echo "configure:116836: checking whether -lc should be explicitly linked in" >&5
+echo "configure:117596: checking whether -lc should be explicitly linked in" >&5
       $rm conftest*
       echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-      if { (eval echo configure:116840: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; } 2>conftest.err; then
+      if { (eval echo configure:117600: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; } 2>conftest.err; then
         soname=conftest
         lib=conftest
         libobjs=conftest.$ac_objext
@@ -116850,7 +117610,7 @@
         libname=conftest
         lt_save_allow_undefined_flag=$allow_undefined_flag_CXX
         allow_undefined_flag_CXX=
-        if { (eval echo configure:116854: \"$archive_cmds_CXX 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\") 1>&5; (eval $archive_cmds_CXX 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5; }
+        if { (eval echo configure:117614: \"$archive_cmds_CXX 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\") 1>&5; (eval $archive_cmds_CXX 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5; }
         then
 	  archive_cmds_need_lc_CXX=no
         else
@@ -116869,7 +117629,7 @@
 esac
 
 echo $ac_n "checking dynamic linker characteristics""... $ac_c" 1>&6
-echo "configure:116873: checking dynamic linker characteristics" >&5
+echo "configure:117633: checking dynamic linker characteristics" >&5
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
@@ -117442,7 +118202,7 @@
 fi
 
 echo $ac_n "checking how to hardcode library paths into programs""... $ac_c" 1>&6
-echo "configure:117446: checking how to hardcode library paths into programs" >&5
+echo "configure:118206: checking how to hardcode library paths into programs" >&5
 hardcode_action_CXX=
 if test -n "$hardcode_libdir_flag_spec_CXX" || \
    test -n "$runpath_var_CXX" || \
--- a/ext/mysql/config.m4
+++ b/ext/mysql/config.m4
@@ -1,5 +1,5 @@
 dnl
-dnl $Id: config.m4 214114 2006-06-01 19:14:48Z mike $
+dnl $Id$
 dnl
 
 AC_DEFUN([MYSQL_LIB_CHK], [
@@ -31,7 +31,7 @@
   done
 
   if test -n "$MYSQL_SOCK"; then
-    AC_DEFINE_UNQUOTED(MYSQL_UNIX_ADDR, "$MYSQL_SOCK", [ ])
+    AC_DEFINE_UNQUOTED(PHP_MYSQL_UNIX_SOCK_ADDR, "$MYSQL_SOCK", [ ])
     AC_MSG_RESULT([$MYSQL_SOCK])
   else
     AC_MSG_RESULT([no])
@@ -40,10 +40,12 @@
 
 
 PHP_ARG_WITH(mysql, for MySQL support,
-[  --with-mysql[=DIR]      Include MySQL support. DIR is the MySQL base directory])
+[  --with-mysql[=DIR]      Include MySQL support.  DIR is the MySQL base
+                          directory.  If mysqlnd is passed as DIR, 
+                          the MySQL native driver will be used [/usr/local]])
 
 PHP_ARG_WITH(mysql-sock, for specified location of the MySQL UNIX socket,
-[  --with-mysql-sock[=DIR]   MySQL: Location of the MySQL unix socket pointer.
+[  --with-mysql-sock[=DIR]   MySQL/MySQLi/PDO_MYSQL: Location of the MySQL unix socket pointer.
                             If unspecified, the default locations are searched], no, no)
 
 if test -z "$PHP_ZLIB_DIR"; then
@@ -51,21 +53,11 @@
   [  --with-zlib-dir[=DIR]     MySQL: Set the path to libz install prefix], no, no)
 fi
 
+if test "$PHP_MYSQL" = "mysqlnd"; then
+  dnl enables build of mysqnd library
+  PHP_MYSQLND_ENABLED=yes
 
-if test "$PHP_MYSQL" != "no"; then
-  AC_DEFINE(HAVE_MYSQL, 1, [Whether you have MySQL])
-
-  AC_MSG_CHECKING([for MySQL UNIX socket location])
-  if test "$PHP_MYSQL_SOCK" != "no" && test "$PHP_MYSQL_SOCK" != "yes"; then
-    MYSQL_SOCK=$PHP_MYSQL_SOCK
-    AC_DEFINE_UNQUOTED(MYSQL_UNIX_ADDR, "$MYSQL_SOCK", [ ])
-    AC_MSG_RESULT([$MYSQL_SOCK])
-  elif test "$PHP_MYSQL" = "yes" || test "$PHP_MYSQL_SOCK" = "yes"; then
-    PHP_MYSQL_SOCKET_SEARCH
-  else
-    AC_MSG_RESULT([no])
-  fi
-
+elif test "$PHP_MYSQL" != "no"; then
   MYSQL_DIR=
   MYSQL_INC_DIR=
 
@@ -107,6 +99,13 @@
   done
 
   if test -z "$MYSQL_LIB_DIR"; then
+    MYSQL_LIB_CHK(lib/x86_64-linux-gnu)
+  fi
+  if test -z "$MYSQL_LIB_DIR"; then
+    MYSQL_LIB_CHK(lib/i386-linux-gnu)
+  fi
+
+  if test -z "$MYSQL_LIB_DIR"; then
     AC_MSG_ERROR([Cannot find lib$MYSQL_LIBNAME under $MYSQL_DIR.
 Note that the MySQL client library is not bundled anymore!])
   fi
@@ -137,14 +136,34 @@
   PHP_ADD_LIBRARY_WITH_PATH($MYSQL_LIBNAME, $MYSQL_LIB_DIR, MYSQL_SHARED_LIBADD)
   PHP_ADD_INCLUDE($MYSQL_INC_DIR)
 
-  PHP_NEW_EXTENSION(mysql, php_mysql.c, $ext_shared)
-
   MYSQL_MODULE_TYPE=external
   MYSQL_LIBS="-L$MYSQL_LIB_DIR -l$MYSQL_LIBNAME $MYSQL_LIBS"
   MYSQL_INCLUDE=-I$MYSQL_INC_DIR
  
-  PHP_SUBST(MYSQL_SHARED_LIBADD)
   PHP_SUBST_OLD(MYSQL_MODULE_TYPE)
   PHP_SUBST_OLD(MYSQL_LIBS)
   PHP_SUBST_OLD(MYSQL_INCLUDE)
+fi
+
+dnl Enable extension
+if test "$PHP_MYSQL" != "no"; then
+  AC_MSG_CHECKING([for MySQL UNIX socket location])
+  if test "$PHP_MYSQL_SOCK" != "no" && test "$PHP_MYSQL_SOCK" != "yes"; then
+    MYSQL_SOCK=$PHP_MYSQL_SOCK
+    AC_DEFINE_UNQUOTED(PHP_MYSQL_UNIX_SOCK_ADDR, "$MYSQL_SOCK", [ ])
+    AC_MSG_RESULT([$MYSQL_SOCK])
+  elif test "$PHP_MYSQL" = "yes" || test "$PHP_MYSQL_SOCK" = "yes"; then
+    PHP_MYSQL_SOCKET_SEARCH
+  else
+    AC_MSG_RESULT([no])
+  fi
+
+  AC_DEFINE(HAVE_MYSQL, 1, [Whether you have MySQL])
+  PHP_NEW_EXTENSION(mysql, php_mysql.c, $ext_shared)
+  PHP_SUBST(MYSQL_SHARED_LIBADD)
+
+  if test "$PHP_MYSQL" = "mysqlnd"; then
+    PHP_ADD_EXTENSION_DEP(mysql, mysqlnd)
+    AC_DEFINE([MYSQL_USE_MYSQLND], 1, [Whether mysqlnd is enabled])
+  fi
 fi
--- a/ext/mysql/config.w32
+++ b/ext/mysql/config.w32
@@ -1,15 +1,28 @@
-// $Id: config.w32 187690 2005-06-05 19:25:01Z wez $
+// $Id$
 // vim:ft=javascript
 
 ARG_WITH("mysql", "MySQL support", "no");
 
 if (PHP_MYSQL != "no") {
-	if (CHECK_LIB("libmysql.lib", "mysql", PHP_MYSQL) &&
+	if ((PHP_MYSQL == "yes" || PHP_MYSQL == "mysqlnd")) {
+		AC_DEFINE('MYSQL_USE_MYSQLND', 1, 'Using MySQL native driver');
+		if (!ADD_EXTENSION_DEP('mysql', 'mysqlnd', true)) {
+			PHP_MYSQL = "no";
+			WARNING("mysql not enabled; mysqlnd is not enabled");
+		} else {
+			EXTENSION("mysql", "php_mysql.c");
+			AC_DEFINE('HAVE_MYSQL', 1, 'Have MySQL library');
+			MESSAGE("\tusing mysqlnd build");
+		}
+	} else if (PHP_MYSQL != "") {
+		if (CHECK_LIB("libmysql.lib", "mysql", PHP_MYSQL) &&
 			CHECK_HEADER_ADD_INCLUDE("mysql.h", "CFLAGS_MYSQL",
-				PHP_MYSQL + "\\include;" + PHP_PHP_BUILD + "\\include\\mysql;" + PHP_MYSQL)) {
-		EXTENSION("mysql", "php_mysql.c");
-		AC_DEFINE('HAVE_MYSQL', 1, 'Have MySQL library');
-	} else {
-		WARNING("mysql not enabled; libraries and headers not found");
+			PHP_MYSQL + "\\include;" + PHP_PHP_BUILD + "\\include\\mysql;" + PHP_MYSQL)) {
+			EXTENSION("mysql", "php_mysql.c");
+			AC_DEFINE('HAVE_MYSQL', 1, 'Have MySQL library');
+			MESSAGE("\tusing libmysql");
+		} else {
+			WARNING("mysql not enabled; libraries and headers not found");
+		}
 	}
 }
--- /dev/null
+++ b/ext/mysql/mysql_mysqlnd.h
@@ -0,0 +1,30 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2009 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+
+*/
+
+#ifndef MYSQL_MYSQLND_H
+#define MYSQL_MYSQLND_H
+
+#include "ext/mysqlnd/mysqlnd_libmysql_compat.h"
+
+/* Here comes non-libmysql API to have less ifdefs in mysqli */
+#define mysql_result_is_unbuffered(r)	((r)->unbuf)
+
+#endif
--- a/ext/mysql/php_mysql.c
+++ b/ext/mysql/php_mysql.c
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2010 The PHP Group                                |
+   | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -17,9 +17,9 @@
    |          Georg Richter <georg@php.net>                               |
    +----------------------------------------------------------------------+
 */
- 
-/* $Id: php_mysql.c 302613 2010-08-21 16:19:30Z kalle $ */
 
+/* $Id$ */
+
 /* TODO:
  *
  * ? Safe mode implementation
@@ -33,6 +33,7 @@
 #include "php_globals.h"
 #include "ext/standard/info.h"
 #include "ext/standard/php_string.h"
+#include "ext/standard/basic_functions.h"
 
 #ifdef ZEND_ENGINE_2
 # include "zend_exceptions.h"
@@ -64,7 +65,6 @@
 # endif
 #endif
 
-#include <mysql.h>
 #include "php_ini.h"
 #include "php_mysql_structs.h"
 
@@ -79,7 +79,7 @@
 
 #define SAFE_STRING(s) ((s)?(s):"")
 
-#if MYSQL_VERSION_ID > 32199
+#if MYSQL_VERSION_ID > 32199 || defined(MYSQL_USE_MYSQLND)
 # define mysql_row_length_type unsigned long
 # define HAVE_MYSQL_ERRNO
 #else
@@ -89,7 +89,7 @@
 # endif
 #endif
 
-#if MYSQL_VERSION_ID >= 32032
+#if MYSQL_VERSION_ID >= 32032 || defined(MYSQL_USE_MYSQLND)
 #define HAVE_GETINFO_FUNCS
 #endif
 
@@ -101,10 +101,6 @@
 #define MYSQL_HAS_YEAR
 #endif
 
-#if (MYSQL_VERSION_ID >= 40113 && MYSQL_VERSION_ID < 50000) || MYSQL_VERSION_ID >= 50007
-#define MYSQL_HAS_SET_CHARSET
-#endif
-
 #define MYSQL_ASSOC		1<<0
 #define MYSQL_NUM		1<<1
 #define MYSQL_BOTH		(MYSQL_ASSOC|MYSQL_NUM)
@@ -124,102 +120,227 @@
 static PHP_GINIT_FUNCTION(mysql);
 
 typedef struct _php_mysql_conn {
-	MYSQL conn;
+	MYSQL *conn;
 	int active_result_id;
+	int multi_query;
 } php_mysql_conn;
 
+
+#if MYSQL_VERSION_ID >= 40101
+#define MYSQL_DISABLE_MQ if (mysql->multi_query) { \
+	mysql_set_server_option(mysql->conn, MYSQL_OPTION_MULTI_STATEMENTS_OFF); \
+	mysql->multi_query = 0; \
+}
+#else
+#define MYSQL_DISABLE_MQ
+#endif
+
+/* {{{ arginfo */
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_connect, 0, 0, 0)
+	ZEND_ARG_INFO(0, hostname)
+	ZEND_ARG_INFO(0, username)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, new)
+	ZEND_ARG_INFO(0, flags)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_pconnect, 0, 0, 0)
+	ZEND_ARG_INFO(0, hostname)
+	ZEND_ARG_INFO(0, username)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, flags)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo__optional_mysql_link, 0, 0, 0)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_select_db, 0, 0, 1)
+	ZEND_ARG_INFO(0, database_name)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo__void_mysql_arg, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_set_charset, 0, 0, 1)
+	ZEND_ARG_INFO(0, charset_name)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_query, 0, 0, 1)
+	ZEND_ARG_INFO(0, query)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_db_query, 0, 0, 2)
+	ZEND_ARG_INFO(0, database_name)
+	ZEND_ARG_INFO(0, query)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_list_fields, 0, 0, 2)
+	ZEND_ARG_INFO(0, database_name)
+	ZEND_ARG_INFO(0, table_name)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_escape_string, 0, 0, 1)
+	ZEND_ARG_INFO(0, string)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_real_escape_string, 0, 0, 1)
+	ZEND_ARG_INFO(0, string)
+	ZEND_ARG_INFO(0, link_identifier)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_result, 0, 0, 2)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, row)
+	ZEND_ARG_INFO(0, field)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo__result_mysql_arg, 0, 0, 1)
+	ZEND_ARG_INFO(0, result)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_fetch_object, 0, 0, 1)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, class_name)
+	ZEND_ARG_INFO(0, ctor_params)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_fetch_array, 0, 0, 1)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, result_type)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_data_seek, 0, 0, 2)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, row_number)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_fetch_field, 0, 0, 1)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, field_offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_field_seek, 0, 0, 2)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, field_offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysql_field_name, 0, 0, 2)
+	ZEND_ARG_INFO(0, result)
+	ZEND_ARG_INFO(0, field_index)
+ZEND_END_ARG_INFO()
+/* }}} */
+
 /* {{{ mysql_functions[]
  */
-zend_function_entry mysql_functions[] = {
-	PHP_FE(mysql_connect,								NULL)
-	PHP_FE(mysql_pconnect,								NULL)
-	PHP_FE(mysql_close,									NULL)
-	PHP_FE(mysql_select_db,								NULL)
+static const zend_function_entry mysql_functions[] = {
+	PHP_FE(mysql_connect,								arginfo_mysql_connect)
+	PHP_FE(mysql_pconnect,								arginfo_mysql_pconnect)
+	PHP_FE(mysql_close,									arginfo__optional_mysql_link)
+	PHP_FE(mysql_select_db,								arginfo_mysql_select_db)
 #ifndef NETWARE		/* The below two functions not supported on NetWare */
 #if MYSQL_VERSION_ID < 40000
-	PHP_DEP_FE(mysql_create_db,							NULL)
-	PHP_DEP_FE(mysql_drop_db,							NULL)
+	PHP_DEP_FE(mysql_create_db,							arginfo_mysql_select_db)
+	PHP_DEP_FE(mysql_drop_db,							arginfo_mysql_select_db)
 #endif
 #endif	/* NETWARE */
-	PHP_FE(mysql_query,									NULL)
-	PHP_FE(mysql_unbuffered_query,						NULL)
-	PHP_FE(mysql_db_query,								NULL)
-	PHP_FE(mysql_list_dbs,								NULL)
-	PHP_DEP_FE(mysql_list_tables,						NULL)
-	PHP_FE(mysql_list_fields,							NULL)
-	PHP_FE(mysql_list_processes,						NULL)
-	PHP_FE(mysql_error,									NULL)
+	PHP_FE(mysql_query,									arginfo_mysql_query)
+	PHP_FE(mysql_unbuffered_query,						arginfo_mysql_query)
+	PHP_DEP_FE(mysql_db_query,							arginfo_mysql_db_query)
+	PHP_FE(mysql_list_dbs,								arginfo__optional_mysql_link)
+	PHP_DEP_FE(mysql_list_tables,						arginfo_mysql_select_db)
+	PHP_FE(mysql_list_fields,							arginfo_mysql_list_fields)
+	PHP_FE(mysql_list_processes,						arginfo__optional_mysql_link)
+	PHP_FE(mysql_error,									arginfo__optional_mysql_link)
 #ifdef HAVE_MYSQL_ERRNO
-	PHP_FE(mysql_errno,									NULL)
+	PHP_FE(mysql_errno,									arginfo__optional_mysql_link)
 #endif
-	PHP_FE(mysql_affected_rows,							NULL)
-	PHP_FE(mysql_insert_id,								NULL)
-	PHP_FE(mysql_result,								NULL)
-	PHP_FE(mysql_num_rows,								NULL)
-	PHP_FE(mysql_num_fields,							NULL)
-	PHP_FE(mysql_fetch_row,								NULL)
-	PHP_FE(mysql_fetch_array,							NULL)
-	PHP_FE(mysql_fetch_assoc,							NULL)
-	PHP_FE(mysql_fetch_object,							NULL)
-	PHP_FE(mysql_data_seek,								NULL)
-	PHP_FE(mysql_fetch_lengths,							NULL)
-	PHP_FE(mysql_fetch_field,							NULL)
-	PHP_FE(mysql_field_seek,							NULL)
-	PHP_FE(mysql_free_result,							NULL)
-	PHP_FE(mysql_field_name,							NULL)
-	PHP_FE(mysql_field_table,							NULL)
-	PHP_FE(mysql_field_len,								NULL)
-	PHP_FE(mysql_field_type,							NULL)
-	PHP_FE(mysql_field_flags,							NULL)
-	PHP_FE(mysql_escape_string,							NULL)
-	PHP_FE(mysql_real_escape_string,					NULL)
-	PHP_FE(mysql_stat,									NULL)
-	PHP_FE(mysql_thread_id,								NULL)
-	PHP_FE(mysql_client_encoding,					NULL)
-	PHP_FE(mysql_ping,									NULL)
+	PHP_FE(mysql_affected_rows,							arginfo__optional_mysql_link)
+	PHP_FE(mysql_insert_id,								arginfo__optional_mysql_link)
+	PHP_FE(mysql_result,								arginfo_mysql_result)
+	PHP_FE(mysql_num_rows,								arginfo__result_mysql_arg)
+	PHP_FE(mysql_num_fields,							arginfo__result_mysql_arg)
+	PHP_FE(mysql_fetch_row,								arginfo__result_mysql_arg)
+	PHP_FE(mysql_fetch_array,							arginfo_mysql_fetch_array)
+	PHP_FE(mysql_fetch_assoc,							arginfo__result_mysql_arg)
+	PHP_FE(mysql_fetch_object,							arginfo_mysql_fetch_object)
+	PHP_FE(mysql_data_seek,								arginfo_mysql_data_seek)
+	PHP_FE(mysql_fetch_lengths,							arginfo__result_mysql_arg)
+	PHP_FE(mysql_fetch_field,							arginfo_mysql_fetch_field)
+	PHP_FE(mysql_field_seek,							arginfo_mysql_field_seek)
+	PHP_FE(mysql_free_result,							arginfo__result_mysql_arg)
+	PHP_FE(mysql_field_name,							arginfo_mysql_field_name)
+	PHP_FE(mysql_field_table,							arginfo_mysql_field_seek)
+	PHP_FE(mysql_field_len,								arginfo_mysql_field_seek)
+	PHP_FE(mysql_field_type,							arginfo_mysql_field_seek)
+	PHP_FE(mysql_field_flags,							arginfo_mysql_field_seek)
+	PHP_FE(mysql_escape_string,							arginfo_mysql_escape_string)
+	PHP_FE(mysql_real_escape_string,					arginfo_mysql_real_escape_string)
+	PHP_FE(mysql_stat,									arginfo__optional_mysql_link)
+	PHP_FE(mysql_thread_id,								arginfo__optional_mysql_link)
+	PHP_FE(mysql_client_encoding,						arginfo__optional_mysql_link)
+	PHP_FE(mysql_ping,									arginfo__optional_mysql_link)
 #ifdef HAVE_GETINFO_FUNCS
-	PHP_FE(mysql_get_client_info,						NULL)
-	PHP_FE(mysql_get_host_info,							NULL)
-	PHP_FE(mysql_get_proto_info,						NULL)
-	PHP_FE(mysql_get_server_info,						NULL)
+	PHP_FE(mysql_get_client_info,						arginfo__void_mysql_arg)
+	PHP_FE(mysql_get_host_info,							arginfo__optional_mysql_link)
+	PHP_FE(mysql_get_proto_info,						arginfo__optional_mysql_link)
+	PHP_FE(mysql_get_server_info,						arginfo__optional_mysql_link)
 #endif
 
-	PHP_FE(mysql_info,		            				NULL)
+	PHP_FE(mysql_info,									arginfo__optional_mysql_link)
 #ifdef MYSQL_HAS_SET_CHARSET
-	PHP_FE(mysql_set_charset,							NULL)
+	PHP_FE(mysql_set_charset,							arginfo_mysql_set_charset)
 #endif
 	/* for downwards compatability */
-	PHP_FALIAS(mysql,				mysql_db_query,		NULL)
-	PHP_FALIAS(mysql_fieldname,		mysql_field_name,	NULL)
-	PHP_FALIAS(mysql_fieldtable,	mysql_field_table,	NULL)
-	PHP_FALIAS(mysql_fieldlen,		mysql_field_len,	NULL)
-	PHP_FALIAS(mysql_fieldtype,		mysql_field_type,	NULL)
-	PHP_FALIAS(mysql_fieldflags,	mysql_field_flags,	NULL)
-	PHP_FALIAS(mysql_selectdb,		mysql_select_db,	NULL)
+	PHP_FALIAS(mysql,				mysql_db_query,		arginfo_mysql_db_query)
+	PHP_FALIAS(mysql_fieldname,		mysql_field_name,	arginfo_mysql_field_name)
+	PHP_FALIAS(mysql_fieldtable,	mysql_field_table,	arginfo_mysql_field_seek)
+	PHP_FALIAS(mysql_fieldlen,		mysql_field_len,	arginfo_mysql_field_seek)
+	PHP_FALIAS(mysql_fieldtype,		mysql_field_type,	arginfo_mysql_field_seek)
+	PHP_FALIAS(mysql_fieldflags,	mysql_field_flags,	arginfo_mysql_field_seek)
+	PHP_FALIAS(mysql_selectdb,		mysql_select_db,	arginfo_mysql_select_db)
 #ifndef NETWARE		/* The below two functions not supported on NetWare */
 #if MYSQL_VERSION_ID < 40000
-	PHP_DEP_FALIAS(mysql_createdb,	mysql_create_db,	NULL)
-	PHP_DEP_FALIAS(mysql_dropdb,	mysql_drop_db,		NULL)
+	PHP_DEP_FALIAS(mysql_createdb,	mysql_create_db,	arginfo_mysql_select_db)
+	PHP_DEP_FALIAS(mysql_dropdb,	mysql_drop_db,		arginfo_mysql_select_db)
 #endif
 #endif	/* NETWARE */
-	PHP_FALIAS(mysql_freeresult,	mysql_free_result,	NULL)
-	PHP_FALIAS(mysql_numfields,		mysql_num_fields,	NULL)
-	PHP_FALIAS(mysql_numrows,		mysql_num_rows,		NULL)
-	PHP_FALIAS(mysql_listdbs,		mysql_list_dbs,		NULL)
-	PHP_DEP_FALIAS(mysql_listtables,mysql_list_tables,	NULL)
-	PHP_FALIAS(mysql_listfields,	mysql_list_fields,	NULL)
-	PHP_FALIAS(mysql_db_name,		mysql_result,		NULL)
-	PHP_FALIAS(mysql_dbname,		mysql_result,		NULL)
-	PHP_FALIAS(mysql_tablename,		mysql_result,		NULL)
-	PHP_FALIAS(mysql_table_name,	mysql_result,		NULL)
+	PHP_FALIAS(mysql_freeresult,	mysql_free_result,	arginfo__result_mysql_arg)
+	PHP_FALIAS(mysql_numfields,		mysql_num_fields,	arginfo__result_mysql_arg)
+	PHP_FALIAS(mysql_numrows,		mysql_num_rows,		arginfo__result_mysql_arg)
+	PHP_FALIAS(mysql_listdbs,		mysql_list_dbs,		arginfo__optional_mysql_link)
+	PHP_DEP_FALIAS(mysql_listtables,mysql_list_tables,	arginfo_mysql_select_db)
+	PHP_FALIAS(mysql_listfields,	mysql_list_fields,	arginfo_mysql_list_fields)
+	PHP_FALIAS(mysql_db_name,		mysql_result,		arginfo_mysql_result)
+	PHP_FALIAS(mysql_dbname,		mysql_result,		arginfo_mysql_result)
+	PHP_FALIAS(mysql_tablename,		mysql_result,		arginfo_mysql_result)
+	PHP_FALIAS(mysql_table_name,	mysql_result,		arginfo_mysql_result)
 	{NULL, NULL, NULL}
 };
 /* }}} */
 
+/* Dependancies */
+static const zend_module_dep mysql_deps[] = {
+#if defined(MYSQL_USE_MYSQLND)
+	ZEND_MOD_REQUIRED("mysqlnd")
+#endif
+	{NULL, NULL, NULL}
+};
+
 /* {{{ mysql_module_entry
  */
 zend_module_entry mysql_module_entry = {
-	STANDARD_MODULE_HEADER,
+#if ZEND_MODULE_API_NO >= 20050922
+	STANDARD_MODULE_HEADER_EX, NULL,
+	mysql_deps,
+#elif ZEND_MODULE_API_NO >= 20010901
+ 	STANDARD_MODULE_HEADER,
+#endif
 	"mysql",
 	mysql_functions,
 	ZEND_MODULE_STARTUP_N(mysql),
@@ -244,6 +365,26 @@
 
 #define CHECK_LINK(link) { if (link==-1) { php_error_docref(NULL TSRMLS_CC, E_WARNING, "A link to the server could not be established"); RETURN_FALSE; } }
 
+#if defined(MYSQL_USE_MYSQLND)
+#define PHPMY_UNBUFFERED_QUERY_CHECK() \
+{\
+	if (mysql->active_result_id) { \
+		do {					\
+			int type;			\
+			MYSQL_RES *_mysql_result;	\
+							\
+			_mysql_result = (MYSQL_RES *) zend_list_find(mysql->active_result_id, &type);	\
+			if (_mysql_result && type==le_result) {						\
+				if (mysql_result_is_unbuffered(_mysql_result) && !mysql_eof(_mysql_result)) { \
+					php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Function called without first fetching all rows from a previous unbuffered query");	\
+				}						\
+				zend_list_delete(mysql->active_result_id);	\
+				mysql->active_result_id = 0;			\
+			} \
+		} while(0); \
+	}\
+}
+#else
 #define PHPMY_UNBUFFERED_QUERY_CHECK()			\
 {							\
 	if (mysql->active_result_id) {			\
@@ -262,7 +403,8 @@
 			}							\
 		} while(0);							\
 	}									\
-}										\
+}
+#endif
 
 /* {{{ _free_mysql_result
  * This wrapper is required since mysql_free_result() returns an integer, and
@@ -295,7 +437,7 @@
 {
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	if (mysql_select_db(&mysql->conn, db) != 0) {
+	if (mysql_select_db(mysql->conn, db) != 0) {
 		return 0;
 	} else {
 		return 1;
@@ -308,10 +450,10 @@
 static void _close_mysql_link(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
 	php_mysql_conn *link = (php_mysql_conn *)rsrc->ptr;
-	void (*handler) (int); 
+	void (*handler) (int);
 
 	handler = signal(SIGPIPE, SIG_IGN);
-	mysql_close(&link->conn);
+	mysql_close(link->conn);
 	signal(SIGPIPE, handler);
 	efree(link);
 	MySG(num_links)--;
@@ -326,7 +468,7 @@
 	void (*handler) (int);
 
 	handler = signal(SIGPIPE, SIG_IGN);
-	mysql_close(&link->conn);
+	mysql_close(link->conn);
 	signal(SIGPIPE, handler);
 
 	free(link);
@@ -358,9 +500,14 @@
 	STD_PHP_INI_ENTRY("mysql.default_user",			NULL,	PHP_INI_ALL,		OnUpdateString,		default_user,		zend_mysql_globals,		mysql_globals)
 	STD_PHP_INI_ENTRY("mysql.default_password",		NULL,	PHP_INI_ALL,		OnUpdateString,		default_password,	zend_mysql_globals,		mysql_globals)
 	PHP_INI_ENTRY("mysql.default_port",				NULL,	PHP_INI_ALL,		OnMySQLPort)
+#ifdef MYSQL_UNIX_ADDR
+	STD_PHP_INI_ENTRY("mysql.default_socket",		MYSQL_UNIX_ADDR,PHP_INI_ALL,OnUpdateStringUnempty,	default_socket,	zend_mysql_globals,		mysql_globals)
+#else
 	STD_PHP_INI_ENTRY("mysql.default_socket",		NULL,	PHP_INI_ALL,		OnUpdateStringUnempty,	default_socket,	zend_mysql_globals,		mysql_globals)
+#endif
 	STD_PHP_INI_ENTRY("mysql.connect_timeout",		"60",	PHP_INI_ALL,		OnUpdateLong,		connect_timeout, 	zend_mysql_globals,		mysql_globals)
 	STD_PHP_INI_BOOLEAN("mysql.trace_mode",			"0",	PHP_INI_ALL,		OnUpdateLong,		trace_mode, 		zend_mysql_globals,		mysql_globals)
+	STD_PHP_INI_BOOLEAN("mysql.allow_local_infile",	"1",	PHP_INI_SYSTEM,		OnUpdateLong,		allow_local_infile, zend_mysql_globals,		mysql_globals)
 PHP_INI_END()
 /* }}} */
 
@@ -377,6 +524,7 @@
 	mysql_globals->connect_error = NULL;
 	mysql_globals->connect_timeout = 0;
 	mysql_globals->trace_mode = 0;
+	mysql_globals->allow_local_infile = 1;
 	mysql_globals->result_allocated = 0;
 }
 /* }}} */
@@ -395,17 +543,19 @@
 	REGISTER_LONG_CONSTANT("MYSQL_NUM", MYSQL_NUM, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQL_BOTH", MYSQL_BOTH, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQL_CLIENT_COMPRESS", CLIENT_COMPRESS, CONST_CS | CONST_PERSISTENT);
-#if MYSQL_VERSION_ID >= 40000	
+#if MYSQL_VERSION_ID >= 40000
 	REGISTER_LONG_CONSTANT("MYSQL_CLIENT_SSL", CLIENT_SSL, CONST_CS | CONST_PERSISTENT);
 #endif
 	REGISTER_LONG_CONSTANT("MYSQL_CLIENT_INTERACTIVE", CLIENT_INTERACTIVE, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("MYSQL_CLIENT_IGNORE_SPACE", CLIENT_IGNORE_SPACE, CONST_CS | CONST_PERSISTENT); 
+	REGISTER_LONG_CONSTANT("MYSQL_CLIENT_IGNORE_SPACE", CLIENT_IGNORE_SPACE, CONST_CS | CONST_PERSISTENT);
 
+#ifndef MYSQL_USE_MYSQLND
 #if MYSQL_VERSION_ID >= 40000
 	if (mysql_server_init(0, NULL, NULL)) {
 		return FAILURE;
 	}
 #endif
+#endif
 
 	return SUCCESS;
 }
@@ -415,10 +565,14 @@
  */
 PHP_MSHUTDOWN_FUNCTION(mysql)
 {
+#ifndef MYSQL_USE_MYSQLND
 #if MYSQL_VERSION_ID >= 40000
 #ifdef PHP_WIN32
 	unsigned long client_ver = mysql_get_client_version();
-	/* Can't call mysql_server_end() multiple times prior to 5.0.42 on Windows */
+	/*
+	  Can't call mysql_server_end() multiple times prior to 5.0.46 on Windows.
+	  PHP bug#41350 MySQL bug#25621
+	*/
 	if ((client_ver >= 50046 && client_ver < 50100) || client_ver > 50122) {
 		mysql_server_end();
 	}
@@ -426,6 +580,7 @@
 	mysql_server_end();
 #endif
 #endif
+#endif
 
 	UNREGISTER_INI_ENTRIES();
 	return SUCCESS;
@@ -436,7 +591,7 @@
  */
 PHP_RINIT_FUNCTION(mysql)
 {
-#if defined(ZTS) && MYSQL_VERSION_ID >= 40000
+#if !defined(MYSQL_USE_MYSQLND) && defined(ZTS) && MYSQL_VERSION_ID >= 40000
 	if (mysql_thread_init()) {
 		return FAILURE;
 	}
@@ -452,11 +607,23 @@
 }
 /* }}} */
 
+
+#if defined(A0) && defined(MYSQL_USE_MYSQLND)
+static int php_mysql_persistent_helper(zend_rsrc_list_entry *le TSRMLS_DC)
+{
+	if (le->type == le_plink) {
+		mysqlnd_end_psession(((php_mysql_conn *) le->ptr)->conn);
+	}
+	return ZEND_HASH_APPLY_KEEP;
+} /* }}} */
+#endif
+
+
 /* {{{ PHP_RSHUTDOWN_FUNCTION
  */
 PHP_RSHUTDOWN_FUNCTION(mysql)
 {
-#if defined(ZTS) && MYSQL_VERSION_ID >= 40000
+#if !defined(MYSQL_USE_MYSQLND) && defined(ZTS) && MYSQL_VERSION_ID >= 40000
 	mysql_thread_end();
 #endif
 
@@ -469,6 +636,11 @@
 	if (MySG(connect_error)!=NULL) {
 		efree(MySG(connect_error));
 	}
+
+#if defined(A0) && defined(MYSQL_USE_MYSQLND)
+	zend_hash_apply(&EG(persistent_list), (apply_func_t) php_mysql_persistent_helper TSRMLS_CC);
+#endif
+
 	return SUCCESS;
 }
 /* }}} */
@@ -486,7 +658,7 @@
 	snprintf(buf, sizeof(buf), "%ld", MySG(num_links));
 	php_info_print_table_row(2, "Active Links", buf);
 	php_info_print_table_row(2, "Client API version", mysql_get_client_info());
-#if !defined (PHP_WIN32) && !defined (NETWARE)
+#if !defined (PHP_WIN32) && !defined (NETWARE) && !defined(MYSQL_USE_MYSQLND)
 	php_info_print_table_row(2, "MYSQL_MODULE_TYPE", PHP_MYSQL_TYPE);
 	php_info_print_table_row(2, "MYSQL_SOCKET", MYSQL_UNIX_ADDR);
 	php_info_print_table_row(2, "MYSQL_INCLUDE", PHP_MYSQL_INCLUDE);
@@ -511,10 +683,14 @@
 	MYSQL_DO_CONNECT_CLEANUP();				\
 	RETURN_FALSE;
 
+#ifdef MYSQL_USE_MYSQLND
+#define MYSQL_PORT 0
+#endif
+
 static void php_mysql_do_connect(INTERNAL_FUNCTION_PARAMETERS, int persistent)
 {
 	char *user=NULL, *passwd=NULL, *host_and_port=NULL, *socket=NULL, *tmp=NULL, *host=NULL;
-	int  user_len, passwd_len, host_len;
+	int  user_len = 0, passwd_len = 0, host_len = 0;
 	char *hashed_details=NULL;
 	int hashed_details_length, port = MYSQL_PORT;
 	long client_flags = 0;
@@ -525,6 +701,13 @@
 	zend_bool free_host=0, new_link=0;
 	long connect_timeout;
 
+#if !defined(MYSQL_USE_MYSQLND)
+	if ((MYSQL_VERSION_ID / 100) != (mysql_get_client_version() / 100)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+						"Headers and client library minor version mismatch. Headers:%d Library:%ld",
+						MYSQL_VERSION_ID, mysql_get_client_version());
+	}
+#endif
 
 	connect_timeout = MySG(connect_timeout);
 
@@ -534,7 +717,7 @@
 #if !defined(PHP_WIN32) && !defined(NETWARE)
 		struct servent *serv_ptr;
 		char *env;
-		
+
 		MySG(default_port) = MYSQL_PORT;
 		if ((serv_ptr = getservbyname("mysql", "tcp"))) {
 			MySG(default_port) = (uint) ntohs((ushort) serv_ptr->s_port);
@@ -546,7 +729,7 @@
 		MySG(default_port) = MYSQL_PORT;
 #endif
 	}
-	
+
 	if (PG(sql_safe_mode)) {
 		if (ZEND_NUM_ARGS()>0) {
 			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "SQL safe mode in effect - ignoring host/user/password information");
@@ -565,7 +748,7 @@
         	}
 		} else {
 			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|s!s!s!bl", &host_and_port, &host_len,
-										&user, &user_len, &passwd, &passwd_len, 
+										&user, &user_len, &passwd, &passwd_len,
 										&new_link, &client_flags)==FAILURE) {
 				return;
 			}
@@ -579,13 +762,24 @@
 		}
 		if (!passwd) {
 			passwd = MySG(default_password);
+			passwd_len = passwd? strlen(passwd):0;
 		}
 
 		/* disable local infile option for open_basedir */
+#if PHP_API_VERSION < 20100412
 		if (((PG(open_basedir) && PG(open_basedir)[0] != '\0') || PG(safe_mode)) && (client_flags & CLIENT_LOCAL_FILES)) {
-                	client_flags ^= CLIENT_LOCAL_FILES;
+#else
+		if ((PG(open_basedir) && PG(open_basedir)[0] != '\0') && (client_flags & CLIENT_LOCAL_FILES)) {
+#endif
+			client_flags ^= CLIENT_LOCAL_FILES;
 		}
 
+#ifdef CLIENT_MULTI_RESULTS
+		client_flags |= CLIENT_MULTI_RESULTS; /* compatibility with 5.2, see bug#50416 */
+#endif
+#ifdef CLIENT_MULTI_STATEMENTS
+		client_flags &= ~CLIENT_MULTI_STATEMENTS;   /* don't allow multi_queries via connect parameter */
+#endif
 		hashed_details_length = spprintf(&hashed_details, 0, "mysql_%s_%s_%s_%ld", SAFE_STRING(host_and_port), SAFE_STRING(user), SAFE_STRING(passwd), client_flags);
 	}
 
@@ -624,41 +818,57 @@
 		if (zend_hash_find(&EG(persistent_list), hashed_details, hashed_details_length+1, (void **) &le)==FAILURE) {  /* we don't */
 			zend_rsrc_list_entry new_le;
 
-			if (MySG(max_links)!=-1 && MySG(num_links)>=MySG(max_links)) {
+			if (MySG(max_links) != -1 && MySG(num_links) >= MySG(max_links)) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Too many open links (%ld)", MySG(num_links));
 				efree(hashed_details);
 				MYSQL_DO_CONNECT_RETURN_FALSE();
 			}
-			if (MySG(max_persistent)!=-1 && MySG(num_persistent)>=MySG(max_persistent)) {
+			if (MySG(max_persistent) != -1 && MySG(num_persistent) >= MySG(max_persistent)) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Too many open persistent links (%ld)", MySG(num_persistent));
 				efree(hashed_details);
 				MYSQL_DO_CONNECT_RETURN_FALSE();
 			}
 			/* create the link */
 			mysql = (php_mysql_conn *) malloc(sizeof(php_mysql_conn));
+			if (!mysql) {
+				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Out of memory while allocating memory for a persistent link");
+			}
 			mysql->active_result_id = 0;
-#if MYSQL_VERSION_ID > 32199 /* this lets us set the port number */
-			mysql_init(&mysql->conn);
+#ifdef CLIENT_MULTI_STATEMENTS
+			mysql->multi_query = client_flags & CLIENT_MULTI_STATEMENTS? 1:0;
+#else
+			mysql->multi_query = 0;
+#endif
 
+#ifndef MYSQL_USE_MYSQLND
+			mysql->conn = mysql_init(NULL);
+#else
+			mysql->conn = mysql_init(persistent);
+#endif
+
 			if (connect_timeout != -1) {
-				mysql_options(&mysql->conn, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&connect_timeout);
+				mysql_options(mysql->conn, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&connect_timeout);
 			}
-
-			if (mysql_real_connect(&mysql->conn, host, user, passwd, NULL, port, socket, client_flags)==NULL) {
+#ifndef MYSQL_USE_MYSQLND
+			if (mysql_real_connect(mysql->conn, host, user, passwd, NULL, port, socket, client_flags)==NULL)
 #else
-			if (mysql_connect(&mysql->conn, host, user, passwd)==NULL) {
+			if (mysqlnd_connect(mysql->conn, host, user, passwd, passwd_len, NULL, 0, port, socket, client_flags TSRMLS_CC) == NULL)
 #endif
+			{
 				/* Populate connect error globals so that the error functions can read them */
-				if (MySG(connect_error)!=NULL) efree(MySG(connect_error));
-				MySG(connect_error)=estrdup(mysql_error(&mysql->conn));
+				if (MySG(connect_error) != NULL) {
+					efree(MySG(connect_error));
+				}
+				MySG(connect_error) = estrdup(mysql_error(mysql->conn));
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", MySG(connect_error));
 #if defined(HAVE_MYSQL_ERRNO)
-				MySG(connect_errno)=mysql_errno(&mysql->conn);
+				MySG(connect_errno) = mysql_errno(mysql->conn);
 #endif
 				free(mysql);
 				efree(hashed_details);
 				MYSQL_DO_CONNECT_RETURN_FALSE();
 			}
+			mysql_options(mysql->conn, MYSQL_OPT_LOCAL_INFILE, (char *)&MySG(allow_local_infile));
 
 			/* hash it up */
 			Z_TYPE(new_le) = le_plink;
@@ -674,41 +884,42 @@
 			if (Z_TYPE_P(le) != le_plink) {
 				MYSQL_DO_CONNECT_RETURN_FALSE();
 			}
-			/* ensure that the link did not die */
-#if MYSQL_VERSION_ID > 32230 /* Use mysql_ping to ensure link is alive (and to reconnect if needed) */
-			if (mysql_ping(le->ptr)) {
-#else	/* Use mysql_stat() to check if server is alive */
-			handler=signal(SIGPIPE, SIG_IGN);
-#if defined(HAVE_MYSQL_ERRNO) && defined(CR_SERVER_GONE_ERROR)
-			mysql_stat(le->ptr);
-			if (mysql_errno(&((php_mysql_conn *) le->ptr)->conn) == CR_SERVER_GONE_ERROR) {
+			mysql = (php_mysql_conn *) le->ptr;
+			mysql->active_result_id = 0;
+#ifdef CLIENT_MULTI_STATEMENTS
+			mysql->multi_query = client_flags & CLIENT_MULTI_STATEMENTS? 1:0;
 #else
-			if (!strcasecmp(mysql_stat(le->ptr), "mysql server has gone away")) { /* the link died */
+			mysql->multi_query = 0;
 #endif
-				signal(SIGPIPE, handler);
-#endif /* end mysql_ping */
-#if MYSQL_VERSION_ID > 32199 /* this lets us set the port number */
-				if (mysql_real_connect(le->ptr, host, user, passwd, NULL, port, socket, client_flags)==NULL) {
+			/* ensure that the link did not die */
+#if defined(A0) && MYSQL_USE_MYSQLND
+			mysqlnd_end_psession(mysql->conn);
+#endif
+			if (mysql_ping(mysql->conn)) {
+				if (mysql_errno(mysql->conn) == 2006) {
+#ifndef MYSQL_USE_MYSQLND
+					if (mysql_real_connect(mysql->conn, host, user, passwd, NULL, port, socket, client_flags)==NULL)
 #else
-				if (mysql_connect(le->ptr, host, user, passwd)==NULL) {
+					if (mysqlnd_connect(mysql->conn, host, user, passwd, passwd_len, NULL, 0, port, socket, client_flags TSRMLS_CC) == NULL)
 #endif
-					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Link to server lost, unable to reconnect");
-					zend_hash_del(&EG(persistent_list), hashed_details, hashed_details_length+1);
-					efree(hashed_details);
-					MYSQL_DO_CONNECT_RETURN_FALSE();
+					{
+						php_error_docref(NULL TSRMLS_CC, E_WARNING, "Link to server lost, unable to reconnect");
+						zend_hash_del(&EG(persistent_list), hashed_details, hashed_details_length+1);
+						efree(hashed_details);
+						MYSQL_DO_CONNECT_RETURN_FALSE();
+					}
+					mysql_options(mysql->conn, MYSQL_OPT_LOCAL_INFILE, (char *)&MySG(allow_local_infile));
 				}
-			}
-#if MYSQL_VERSION_ID < 32231
-			signal(SIGPIPE, handler);
+			} else {
+#ifdef MYSQL_USE_MYSQLND
+				mysqlnd_restart_psession(mysql->conn);
 #endif
-
-			mysql = (php_mysql_conn *) le->ptr;
-			mysql->active_result_id = 0;
+			}
 		}
 		ZEND_REGISTER_RESOURCE(return_value, mysql, le_plink);
 	} else { /* non persistent */
 		zend_rsrc_list_entry *index_ptr, new_index_ptr;
-		
+
 		/* first we check the hash for the hashed_details key.  if it exists,
 		 * it should point us to the right offset where the actual mysql link sits.
 		 * if it doesn't, open a new mysql link, add it to the resource list,
@@ -736,7 +947,7 @@
 				zend_hash_del(&EG(regular_list), hashed_details, hashed_details_length+1);
 			}
 		}
-		if (MySG(max_links)!=-1 && MySG(num_links)>=MySG(max_links)) {
+		if (MySG(max_links) != -1 && MySG(num_links) >= MySG(max_links)) {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Too many open links (%ld)", MySG(num_links));
 			efree(hashed_details);
 			MYSQL_DO_CONNECT_RETURN_FALSE();
@@ -744,28 +955,51 @@
 
 		mysql = (php_mysql_conn *) emalloc(sizeof(php_mysql_conn));
 		mysql->active_result_id = 0;
-#if MYSQL_VERSION_ID > 32199 /* this lets us set the port number */
-		mysql_init(&mysql->conn);
+#ifdef CLIENT_MULTI_STATEMENTS
+		mysql->multi_query = 1;
+#endif
 
+#ifndef MYSQL_USE_MYSQLND
+		mysql->conn = mysql_init(NULL);
+#else
+		mysql->conn = mysql_init(persistent);
+#endif
+		if (!mysql->conn) {
+			MySG(connect_error) = estrdup("OOM");
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "OOM");
+			efree(hashed_details);
+			efree(mysql);
+			MYSQL_DO_CONNECT_RETURN_FALSE();
+		}
+
 		if (connect_timeout != -1) {
-			mysql_options(&mysql->conn, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&connect_timeout);
+			mysql_options(mysql->conn, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&connect_timeout);
 		}
 
-		if (mysql_real_connect(&mysql->conn, host, user, passwd, NULL, port, socket, client_flags)==NULL) {
+#ifndef MYSQL_USE_MYSQLND
+		if (mysql_real_connect(mysql->conn, host, user, passwd, NULL, port, socket, client_flags)==NULL)
 #else
-		if (mysql_connect(&mysql->conn, host, user, passwd)==NULL) {
+		if (mysqlnd_connect(mysql->conn, host, user, passwd, passwd_len, NULL, 0, port, socket, client_flags TSRMLS_CC) == NULL)
 #endif
+		{
 			/* Populate connect error globals so that the error functions can read them */
-			if (MySG(connect_error)!=NULL) efree(MySG(connect_error));
-			MySG(connect_error)=estrdup(mysql_error(&mysql->conn));
+			if (MySG(connect_error) != NULL) {
+				efree(MySG(connect_error));
+			}
+			MySG(connect_error) = estrdup(mysql_error(mysql->conn));
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", MySG(connect_error));
 #if defined(HAVE_MYSQL_ERRNO)
-			MySG(connect_errno)=mysql_errno(&mysql->conn);
+			MySG(connect_errno) = mysql_errno(mysql->conn);
 #endif
+			/* free mysql structure */
+#ifdef MYSQL_USE_MYSQLND
+			mysqlnd_close(mysql->conn, MYSQLND_CLOSE_DISCONNECTED);
+#endif
 			efree(hashed_details);
 			efree(mysql);
 			MYSQL_DO_CONNECT_RETURN_FALSE();
 		}
+		mysql_options(mysql->conn, MYSQL_OPT_LOCAL_INFILE, (char *)&MySG(allow_local_infile));
 
 		/* add it to the list */
 		ZEND_REGISTER_RESOURCE(return_value, mysql, le_link);
@@ -818,37 +1052,39 @@
    Close a MySQL connection */
 PHP_FUNCTION(mysql_close)
 {
-	zval **mysql_link=NULL;
-	int id;
+	int resource_id;
+	zval *mysql_link=NULL;
 	php_mysql_conn *mysql;
 
-	switch (ZEND_NUM_ARGS()) {
-		case 0:
-			id = MySG(default_link);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
 
-	if (id==-1) { /* explicit resource number */
-		PHPMY_UNBUFFERED_QUERY_CHECK();
-		zend_list_delete(Z_RESVAL_PP(mysql_link));
+	if (mysql_link) {
+		ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, -1, "MySQL-Link", le_link, le_plink);
+	} else {
+		ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, NULL, MySG(default_link), "MySQL-Link", le_link, le_plink);
 	}
 
-	if (id!=-1 
-		|| (mysql_link && Z_RESVAL_PP(mysql_link)==MySG(default_link))) {
-		PHPMY_UNBUFFERED_QUERY_CHECK();
-		zend_list_delete(MySG(default_link));
+	resource_id = mysql_link ? Z_RESVAL_P(mysql_link) : MySG(default_link);
+	PHPMY_UNBUFFERED_QUERY_CHECK();
+#ifdef MYSQL_USE_MYSQLND
+	{
+		int tmp;
+		if ((mysql = zend_list_find(resource_id, &tmp)) && tmp == le_plink) {
+			mysqlnd_end_psession(mysql->conn);
+		}
+	}
+#endif
+	zend_list_delete(resource_id);
+
+	if (!mysql_link
+		|| (mysql_link && Z_RESVAL_P(mysql_link)==MySG(default_link))) {
 		MySG(default_link) = -1;
+		if (mysql_link) {
+			/* on an explicit close of the default connection it had a refcount of 2 so we need one more call */
+			zend_list_delete(resource_id);
+		}
 	}
 
 	RETURN_TRUE;
@@ -859,37 +1095,27 @@
    Selects a MySQL database */
 PHP_FUNCTION(mysql_select_db)
 {
-	zval **db, **mysql_link;
-	int id;
+	char *db;
+	int db_len;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 1:
-			if (zend_get_parameters_ex(1, &db)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 2:
-			if (zend_get_parameters_ex(2, &db, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &db, &db_len, &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
-	
-	convert_to_string_ex(db);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
-	if (php_mysql_select_db(mysql, Z_STRVAL_PP(db) TSRMLS_CC)) {
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	if (php_mysql_select_db(mysql, db TSRMLS_CC)) {
 		RETURN_TRUE;
 	} else {
-		RETURN_FALSE;	
+		RETURN_FALSE;
 	}
 }
 /* }}} */
@@ -901,10 +1127,10 @@
 PHP_FUNCTION(mysql_get_client_info)
 {
 	if (ZEND_NUM_ARGS() != 0) {
-		WRONG_PARAM_COUNT;
+		return;
 	}
 
-	RETURN_STRING((char *)mysql_get_client_info(),1);	
+	RETURN_STRING((char *)mysql_get_client_info(),1);
 }
 /* }}} */
 
@@ -912,29 +1138,22 @@
    Returns a string describing the type of connection in use, including the server host name */
 PHP_FUNCTION(mysql_get_host_info)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1,&mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
-	RETURN_STRING((char *)mysql_get_host_info(&mysql->conn),1);
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	RETURN_STRING((char *)mysql_get_host_info(mysql->conn),1);
 }
 /* }}} */
 
@@ -942,29 +1161,22 @@
    Returns the protocol version used by current connection */
 PHP_FUNCTION(mysql_get_proto_info)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1,&mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
-	RETURN_LONG(mysql_get_proto_info(&mysql->conn));
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	RETURN_LONG(mysql_get_proto_info(mysql->conn));
 }
 /* }}} */
 
@@ -972,29 +1184,22 @@
    Returns a string that represents the server version number */
 PHP_FUNCTION(mysql_get_server_info)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1,&mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
-	RETURN_STRING((char *)mysql_get_server_info(&mysql->conn),1);
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	RETURN_STRING((char *)mysql_get_server_info(mysql->conn),1);
 }
 /* }}} */
 
@@ -1002,7 +1207,7 @@
    Returns a string containing information about the most recent query */
 PHP_FUNCTION(mysql_info)
 {
-	zval *mysql_link;
+	zval *mysql_link = NULL;
 	int id = -1;
 	char *str;
 	php_mysql_conn *mysql;
@@ -1018,7 +1223,7 @@
 
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
 
-	if ((str = (char *)mysql_info(&mysql->conn))) {
+	if ((str = (char *)mysql_info(mysql->conn))) {
 		RETURN_STRING(str,1);
 	} else {
 		RETURN_FALSE;
@@ -1040,11 +1245,11 @@
 
 	if (ZEND_NUM_ARGS() == 0) {
 		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-		CHECK_LINK(id);		
+		CHECK_LINK(id);
 	}
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
 
-	RETURN_LONG(mysql_thread_id(&mysql->conn));
+	RETURN_LONG((long) mysql_thread_id(mysql->conn));
 }
 /* }}} */
 
@@ -1055,6 +1260,10 @@
 	zval *mysql_link = NULL;
 	int id = -1;
 	php_mysql_conn *mysql;
+	char *stat;
+#ifdef MYSQL_USE_MYSQLND
+	uint stat_len;
+#endif
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
 		return;
@@ -1062,13 +1271,21 @@
 
 	if (ZEND_NUM_ARGS() == 0) {
 		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-		CHECK_LINK(id);		
+		CHECK_LINK(id);
 	}
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
 
 	PHPMY_UNBUFFERED_QUERY_CHECK();
-
-	RETURN_STRING((char *)mysql_stat(&mysql->conn), 1);
+#ifndef MYSQL_USE_MYSQLND
+	if ((stat = (char *)mysql_stat(mysql->conn))) {
+		RETURN_STRING(stat, 1);
+#else
+	if (mysqlnd_stat(mysql->conn, &stat, &stat_len) == PASS) {
+		RETURN_STRINGL(stat, stat_len, 0);
+#endif
+	} else {
+		RETURN_FALSE;
+	}
 }
 /* }}} */
 
@@ -1090,8 +1307,7 @@
 	}
 
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
-
-	RETURN_STRING((char *)mysql_character_set_name(&mysql->conn), 1);
+	RETURN_STRING((char *)mysql_character_set_name(mysql->conn), 1);
 }
 /* }}} */
 #endif
@@ -1117,7 +1333,7 @@
 
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
 
-	if (!mysql_set_character_set(&mysql->conn, csname)) {
+	if (!mysql_set_character_set(mysql->conn, csname)) {
 		RETURN_TRUE;
 	} else {
 		RETURN_FALSE;
@@ -1132,36 +1348,26 @@
    Create a MySQL database */
 PHP_FUNCTION(mysql_create_db)
 {
-	zval **db, **mysql_link;
-	int id;
+	char *db;
+	int db_len;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 
-	switch(ZEND_NUM_ARGS()) {
-		case 1:
-			if (zend_get_parameters_ex(1, &db)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 2:
-			if (zend_get_parameters_ex(2, &db, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &db, &db_len, &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	convert_to_string_ex(db);
-
-	if (mysql_create_db(&mysql->conn, Z_STRVAL_PP(db))==0) {
+	if (mysql_create_db(mysql->conn, db)==0) {
 		RETURN_TRUE;
 	} else {
 		RETURN_FALSE;
@@ -1173,34 +1379,24 @@
    Drops (delete) a MySQL database */
 PHP_FUNCTION(mysql_drop_db)
 {
-	zval **db, **mysql_link;
-	int id;
+	char *db;
+	int db_len;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 1:
-			if (zend_get_parameters_ex(1, &db)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 2:
-			if (zend_get_parameters_ex(2, &db, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &db, &db_len, &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
-	
-	convert_to_string_ex(db);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
-	if (mysql_drop_db(&mysql->conn, Z_STRVAL_PP(db))==0) {
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	if (mysql_drop_db(mysql->conn, db)==0) {
 		RETURN_TRUE;
 	} else {
 		RETURN_FALSE;
@@ -1212,39 +1408,39 @@
 
 /* {{{ php_mysql_do_query_general
  */
-static void php_mysql_do_query_general(zval **query, zval **mysql_link, int link_id, zval **db, int use_store, zval *return_value TSRMLS_DC)
+static void php_mysql_do_query_general(char *query, int query_len, zval *mysql_link, int link_id, char *db, int use_store, zval *return_value TSRMLS_DC)
 {
 	php_mysql_conn *mysql;
 	MYSQL_RES *mysql_result;
-	
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, link_id, "MySQL-Link", le_link, le_plink);
-	
+
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, link_id, "MySQL-Link", le_link, le_plink);
+
 	if (db) {
-		convert_to_string_ex(db);
-		if (!php_mysql_select_db(mysql, Z_STRVAL_PP(db) TSRMLS_CC)) {
+		if (!php_mysql_select_db(mysql, db TSRMLS_CC)) {
 			RETURN_FALSE;
 		}
 	}
 
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	convert_to_string_ex(query);
+	MYSQL_DISABLE_MQ;
 
+#ifndef MYSQL_USE_MYSQLND
 	/* check explain */
 	if (MySG(trace_mode)) {
-		if (!strncasecmp("select", Z_STRVAL_PP(query), 6)){
+		if (!strncasecmp("select", query, 6)){
 			MYSQL_ROW 	row;
-			
+
 			char *newquery;
-			int newql = spprintf (&newquery, 0, "EXPLAIN %s", Z_STRVAL_PP(query));
-			mysql_real_query(&mysql->conn, newquery, newql);
+			int newql = spprintf (&newquery, 0, "EXPLAIN %s", query);
+			mysql_real_query(mysql->conn, newquery, newql);
 			efree (newquery);
-			if (mysql_errno(&mysql->conn)) {
-				php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "%s", mysql_error(&mysql->conn));
+			if (mysql_errno(mysql->conn)) {
+				php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "%s", mysql_error(mysql->conn));
 				RETURN_FALSE;
 			}
 			else {
-    			mysql_result = mysql_use_result(&mysql->conn);
+    			mysql_result = mysql_use_result(mysql->conn);
 				while ((row = mysql_fetch_row(mysql_result))) {
 					if (!strcmp("ALL", row[1])) {
 						php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "Your query requires a full tablescan (table %s, %s rows affected). Use EXPLAIN to optimize your query.", row[0], row[6]);
@@ -1254,38 +1450,39 @@
 				}
 				mysql_free_result(mysql_result);
 			}
-		}	
+		}
 	} /* end explain */
+#endif
 
 	/* mysql_query is binary unsafe, use mysql_real_query */
 #if MYSQL_VERSION_ID > 32199
-	if (mysql_real_query(&mysql->conn, Z_STRVAL_PP(query), Z_STRLEN_PP(query))!=0) {
+	if (mysql_real_query(mysql->conn, query, query_len)!=0) {
 		/* check possible error */
 		if (MySG(trace_mode)){
-			if (mysql_errno(&mysql->conn)){
-				php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "%s", mysql_error(&mysql->conn)); 
+			if (mysql_errno(mysql->conn)){
+				php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "%s", mysql_error(mysql->conn));
 			}
 		}
 		RETURN_FALSE;
 	}
 #else
-	if (mysql_query(&mysql->conn, Z_STRVAL_PP(query))!=0) {
+	if (mysql_query(mysql->conn, query)!=0) {
 		/* check possible error */
 		if (MySG(trace_mode)){
-			if (mysql_errno(&mysql->conn)){
-				php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "%s", mysql_error(&mysql->conn)); 
+			if (mysql_errno(mysql->conn)){
+				php_error_docref("http://www.mysql.com/doc" TSRMLS_CC, E_WARNING, "%s", mysql_error(mysql->conn));
 			}
 		}
 		RETURN_FALSE;
 	}
 #endif
 	if(use_store == MYSQL_USE_RESULT) {
-		mysql_result=mysql_use_result(&mysql->conn);
+		mysql_result=mysql_use_result(mysql->conn);
 	} else {
-		mysql_result=mysql_store_result(&mysql->conn);
+		mysql_result=mysql_store_result(mysql->conn);
 	}
 	if (!mysql_result) {
-		if (PHP_MYSQL_VALID_RESULT(&mysql->conn)) { /* query should have returned rows */
+		if (PHP_MYSQL_VALID_RESULT(mysql->conn)) { /* query should have returned rows */
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to save result set");
 			RETURN_FALSE;
 		} else {
@@ -1304,28 +1501,21 @@
  */
 static void php_mysql_do_query(INTERNAL_FUNCTION_PARAMETERS, int use_store)
 {
-	zval **query, **mysql_link;
-	int id;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 1:
-			if (zend_get_parameters_ex(1, &query)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 2:
-			if (zend_get_parameters_ex(2, &query, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	char *query;
+	int query_len;
+	zval *mysql_link = NULL;
+	int id = -1;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &query, &query_len, &mysql_link) == FAILURE) {
+		return;
 	}
-	php_mysql_do_query_general(query, mysql_link, id, NULL, use_store, return_value TSRMLS_CC);
+
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
+
+	php_mysql_do_query_general(query, query_len, mysql_link, id, NULL, use_store, return_value TSRMLS_CC);
 }
 /* }}} */
 
@@ -1351,33 +1541,23 @@
    Sends an SQL query to MySQL */
 PHP_FUNCTION(mysql_db_query)
 {
-	zval **db, **query, **mysql_link;
-	int id;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 2:
-			if (zend_get_parameters_ex(2, &db, &query)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 3:
-			if (zend_get_parameters_ex(3, &db, &query, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	char *db, *query;
+	int db_len, query_len;
+	zval *mysql_link = NULL;
+	int id = -1;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|r", &db, &db_len, &query, &query_len, &mysql_link) == FAILURE) {
+		return;
 	}
-	
-	if (MySG(trace_mode) || !strcasecmp(get_active_function_name(TSRMLS_C), "mysql")) {
-		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "This function is deprecated; use mysql_query() instead.");
+
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
 	}
-	
-	php_mysql_do_query_general(query, mysql_link, id, db, MYSQL_STORE_RESULT, return_value TSRMLS_CC);
+
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "This function is deprecated; use mysql_query() instead");
+
+	php_mysql_do_query_general(query, query_len, mysql_link, id, db, MYSQL_STORE_RESULT, return_value TSRMLS_CC);
 }
 /* }}} */
 
@@ -1386,35 +1566,29 @@
    List databases available on a MySQL server */
 PHP_FUNCTION(mysql_list_dbs)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 	MYSQL_RES *mysql_result;
 
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	if ((mysql_result=mysql_list_dbs(&mysql->conn, NULL))==NULL) {
+	if ((mysql_result=mysql_list_dbs(mysql->conn, NULL))==NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to save MySQL query result");
 		RETURN_FALSE;
 	}
+	MySG(result_allocated)++;
 	ZEND_REGISTER_RESOURCE(return_value, mysql_result, le_result);
 }
 /* }}} */
@@ -1424,42 +1598,35 @@
    List tables in a MySQL database */
 PHP_FUNCTION(mysql_list_tables)
 {
-	zval **db, **mysql_link;
-	int id;
+	char *db;
+	int db_len;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 	MYSQL_RES *mysql_result;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 1:
-			if (zend_get_parameters_ex(1, &db)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 2:
-			if (zend_get_parameters_ex(2, &db, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &db, &db_len, &mysql_link) == FAILURE) {
+		return;
 	}
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
 
-	convert_to_string_ex(db);
-	if (!php_mysql_select_db(mysql, Z_STRVAL_PP(db) TSRMLS_CC)) {
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
+
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	if (!php_mysql_select_db(mysql, db TSRMLS_CC)) {
 		RETURN_FALSE;
 	}
 
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	if ((mysql_result=mysql_list_tables(&mysql->conn, NULL))==NULL) {
+	if ((mysql_result=mysql_list_tables(mysql->conn, NULL))==NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to save MySQL query result");
 		RETURN_FALSE;
 	}
+	MySG(result_allocated)++;
 	ZEND_REGISTER_RESOURCE(return_value, mysql_result, le_result);
 }
 /* }}} */
@@ -1469,44 +1636,35 @@
    List MySQL result fields */
 PHP_FUNCTION(mysql_list_fields)
 {
-	zval **db, **table, **mysql_link;
-	int id;
+	char *db, *table;
+	int db_len, table_len;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
 	MYSQL_RES *mysql_result;
 
-	switch(ZEND_NUM_ARGS()) {
-		case 2:
-			if (zend_get_parameters_ex(2, &db, &table)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
-			CHECK_LINK(id);
-			break;
-		case 3:
-			if (zend_get_parameters_ex(3, &db, &table, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|r", &db, &db_len, &table, &table_len, &mysql_link) == FAILURE) {
+		return;
 	}
 
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
 
-	convert_to_string_ex(db);
-	if (!php_mysql_select_db(mysql, Z_STRVAL_PP(db) TSRMLS_CC)) {
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	if (!php_mysql_select_db(mysql, db TSRMLS_CC)) {
 		RETURN_FALSE;
 	}
 
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	convert_to_string_ex(table);
-	if ((mysql_result=mysql_list_fields(&mysql->conn, Z_STRVAL_PP(table), NULL))==NULL) {
+	if ((mysql_result=mysql_list_fields(mysql->conn, table, NULL))==NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to save MySQL query result");
 		RETURN_FALSE;
 	}
+	MySG(result_allocated)++;
 	ZEND_REGISTER_RESOURCE(return_value, mysql_result, le_result);
 }
 /* }}} */
@@ -1533,12 +1691,13 @@
 
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	mysql_result = mysql_list_processes(&mysql->conn);
+	mysql_result = mysql_list_processes(mysql->conn);
 	if (mysql_result == NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to save MySQL query result");
 		RETURN_FALSE;
 	}
 
+	MySG(result_allocated)++;
 	ZEND_REGISTER_RESOURCE(return_value, mysql_result, le_result);
 }
 /* }}} */
@@ -1548,35 +1707,28 @@
    Returns the text of the error message from previous MySQL operation */
 PHP_FUNCTION(mysql_error)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = MySG(default_link);
-			if (id==-1) {
-				if (MySG(connect_error)!=NULL){
-					RETURN_STRING(MySG(connect_error),1);
-				} else {
-					RETURN_FALSE;
-				}
-			}
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1, &mysql_link)==FAILURE) {
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
+	}
+
+	if (!mysql_link) {
+		id = MySG(default_link);
+		if (id==-1) {
+			if (MySG(connect_error)!=NULL){
+				RETURN_STRING(MySG(connect_error),1);
+			} else {
 				RETURN_FALSE;
 			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+		}
 	}
-	
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
-	
-	RETURN_STRING((char *)mysql_error(&mysql->conn), 1);
+
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	RETURN_STRING((char *)mysql_error(mysql->conn), 1);
 }
 /* }}} */
 
@@ -1586,35 +1738,28 @@
 #ifdef HAVE_MYSQL_ERRNO
 PHP_FUNCTION(mysql_errno)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = MySG(default_link);
-			if (id==-1) {
-			  	if (MySG(connect_errno)!=0){
-					RETURN_LONG(MySG(connect_errno));
-				} else {
-					RETURN_FALSE;
-				}
-			}
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1, &mysql_link)==FAILURE) {
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
+	}
+
+	if (!mysql_link) {
+		id = MySG(default_link);
+		if (id==-1) {
+		  	if (MySG(connect_errno)!=0){
+				RETURN_LONG(MySG(connect_errno));
+			} else {
 				RETURN_FALSE;
 			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+		}
 	}
-	
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
-	
-	RETURN_LONG(mysql_errno(&mysql->conn));
+
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
+	RETURN_LONG(mysql_errno(mysql->conn));
 }
 #endif
 /* }}} */
@@ -1624,30 +1769,23 @@
    Gets number of affected rows in previous MySQL operation */
 PHP_FUNCTION(mysql_affected_rows)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = MySG(default_link);
-			CHECK_LINK(id);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
-	
+
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
+
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
 	/* conversion from int64 to long happing here */
-	Z_LVAL_P(return_value) = (long) mysql_affected_rows(&mysql->conn);
+	Z_LVAL_P(return_value) = (long) mysql_affected_rows(mysql->conn);
 	Z_TYPE_P(return_value) = IS_LONG;
 }
 /* }}} */
@@ -1657,25 +1795,25 @@
    Escape string for mysql query */
 PHP_FUNCTION(mysql_escape_string)
 {
-	zval **str;
+	char *str;
+	int str_len;
 
-	if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &str) == FAILURE) {
-		ZEND_WRONG_PARAM_COUNT();
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &str, &str_len) == FAILURE) {
+		return;
 	}
-	convert_to_string_ex(str);
+
 	/* assume worst case situation, which is 2x of the original string.
 	 * we don't realloc() down to the real size since it'd most probably not
 	 * be worth it
 	 */
 
-	Z_STRVAL_P(return_value) = (char *) safe_emalloc(Z_STRLEN_PP(str), 2, 1);
-	Z_STRLEN_P(return_value) = mysql_escape_string(Z_STRVAL_P(return_value), Z_STRVAL_PP(str), Z_STRLEN_PP(str));
+	Z_STRVAL_P(return_value) = (char *) safe_emalloc(str_len, 2, 1);
+	Z_STRLEN_P(return_value) = mysql_escape_string(Z_STRVAL_P(return_value), str, str_len);
 	Z_TYPE_P(return_value) = IS_STRING;
 
 	if (MySG(trace_mode)){
 		php_error_docref("function.mysql-real-escape-string" TSRMLS_CC, E_WARNING, "This function is deprecated; use mysql_real_escape_string() instead.");
 	}
-
 }
 /* }}} */
 
@@ -1702,7 +1840,7 @@
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
 
 	new_str = safe_emalloc(str_len, 2, 1);
-	new_str_len = mysql_real_escape_string(&mysql->conn, new_str, str, str_len);
+	new_str_len = mysql_real_escape_string(mysql->conn, new_str, str, str_len);
 	new_str = erealloc(new_str, new_str_len + 1);
 
 	RETURN_STRINGL(new_str, new_str_len, 0);
@@ -1713,30 +1851,23 @@
    Gets the ID generated from the previous INSERT operation */
 PHP_FUNCTION(mysql_insert_id)
 {
-	zval **mysql_link;
-	int id;
+	zval *mysql_link = NULL;
+	int id = -1;
 	php_mysql_conn *mysql;
-	
-	switch(ZEND_NUM_ARGS()) {
-		case 0:
-			id = MySG(default_link);
-			CHECK_LINK(id);
-			break;
-		case 1:
-			if (zend_get_parameters_ex(1, &mysql_link)==FAILURE) {
-				RETURN_FALSE;
-			}
-			id = -1;
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql_link) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, mysql_link, id, "MySQL-Link", le_link, le_plink);
-	
+
+	if (!mysql_link) {
+		id = php_mysql_get_default_link(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+		CHECK_LINK(id);
+	}
+
+	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
+
 	/* conversion from int64 to long happing here */
-	Z_LVAL_P(return_value) = (long) mysql_insert_id(&mysql->conn);
+	Z_LVAL_P(return_value) = (long) mysql_insert_id(mysql->conn);
 	Z_TYPE_P(return_value) = IS_LONG;
 }
 /* }}} */
@@ -1746,54 +1877,45 @@
    Gets result data */
 PHP_FUNCTION(mysql_result)
 {
-	zval **result, **row, **field=NULL;
+	zval *result, *field=NULL;
+	long row;
 	MYSQL_RES *mysql_result;
+#ifndef MYSQL_USE_MYSQLND
 	MYSQL_ROW sql_row;
 	mysql_row_length_type *sql_row_lengths;
+#endif
 	int field_offset=0;
 
-	switch (ZEND_NUM_ARGS()) {
-		case 2:
-			if (zend_get_parameters_ex(2, &result, &row)==FAILURE) {
-				RETURN_FALSE;
-			}
-			break;
-		case 3:
-			if (zend_get_parameters_ex(3, &result, &row, &field)==FAILURE) {
-				RETURN_FALSE;
-			}
-			break;
-		default:
-			WRONG_PARAM_COUNT;
-			break;
+/*
+johannes TODO:
+Do 2 zend_parse_paramters calls instead of type "z" and switch below
+Q: String or long first?
+*/
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl|z", &result, &row, &field) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
-		
-	convert_to_long_ex(row);
-	if (Z_LVAL_PP(row)<0 || Z_LVAL_PP(row)>=(int)mysql_num_rows(mysql_result)) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to jump to row %ld on MySQL result index %ld", Z_LVAL_PP(row), Z_LVAL_PP(result));
+
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
+	if (row<0 || row>=(int)mysql_num_rows(mysql_result)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to jump to row %ld on MySQL result index %ld", row, Z_LVAL_P(result));
 		RETURN_FALSE;
 	}
-	mysql_data_seek(mysql_result, Z_LVAL_PP(row));
-	if ((sql_row=mysql_fetch_row(mysql_result))==NULL 
-		|| (sql_row_lengths=mysql_fetch_lengths(mysql_result))==NULL) { /* shouldn't happen? */
-		RETURN_FALSE;
-	}
-	
+	mysql_data_seek(mysql_result, row);
+
 	if (field) {
-		switch(Z_TYPE_PP(field)) {
+		switch(Z_TYPE_P(field)) {
 			case IS_STRING: {
 					int i=0;
-					MYSQL_FIELD *tmp_field;
+					const MYSQL_FIELD *tmp_field;
 					char *table_name, *field_name, *tmp;
 
-					if ((tmp=strchr(Z_STRVAL_PP(field), '.'))) {
-						table_name = estrndup(Z_STRVAL_PP(field), tmp-Z_STRVAL_PP(field));
+					if ((tmp=strchr(Z_STRVAL_P(field), '.'))) {
+						table_name = estrndup(Z_STRVAL_P(field), tmp-Z_STRVAL_P(field));
 						field_name = estrdup(tmp+1);
 					} else {
 						table_name = NULL;
-						field_name = estrndup(Z_STRVAL_PP(field),Z_STRLEN_PP(field));
+						field_name = estrndup(Z_STRVAL_P(field),Z_STRLEN_P(field));
 					}
 					mysql_field_seek(mysql_result, 0);
 					while ((tmp_field=mysql_fetch_field(mysql_result))) {
@@ -1805,7 +1927,7 @@
 					}
 					if (!tmp_field) { /* no match found */
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s%s%s not found in MySQL result index %ld",
-									(table_name?table_name:""), (table_name?".":""), field_name, Z_LVAL_PP(result));
+									(table_name?table_name:""), (table_name?".":""), field_name, Z_LVAL_P(result));
 						efree(field_name);
 						if (table_name) {
 							efree(table_name);
@@ -1819,8 +1941,8 @@
 				}
 				break;
 			default:
-				convert_to_long_ex(field);
-				field_offset = Z_LVAL_PP(field);
+				convert_to_long_ex(&field);
+				field_offset = Z_LVAL_P(field);
 				if (field_offset<0 || field_offset>=(int)mysql_num_fields(mysql_result)) {
 					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Bad column offset specified");
 					RETURN_FALSE;
@@ -1829,18 +1951,26 @@
 		}
 	}
 
+#ifndef MYSQL_USE_MYSQLND
+	if ((sql_row=mysql_fetch_row(mysql_result))==NULL
+		|| (sql_row_lengths=mysql_fetch_lengths(mysql_result))==NULL) { /* shouldn't happen? */
+		RETURN_FALSE;
+	}
 	if (sql_row[field_offset]) {
 		Z_TYPE_P(return_value) = IS_STRING;
 
 		if (PG(magic_quotes_runtime)) {
 			Z_STRVAL_P(return_value) = php_addslashes(sql_row[field_offset], sql_row_lengths[field_offset],&Z_STRLEN_P(return_value), 0 TSRMLS_CC);
-		} else {	
+		} else {
 			Z_STRLEN_P(return_value) = sql_row_lengths[field_offset];
 			Z_STRVAL_P(return_value) = (char *) safe_estrndup(sql_row[field_offset], Z_STRLEN_P(return_value));
 		}
 	} else {
 		Z_TYPE_P(return_value) = IS_NULL;
 	}
+#else
+	mysqlnd_result_fetch_field_data(mysql_result, field_offset, return_value);
+#endif
 }
 /* }}} */
 
@@ -1849,15 +1979,15 @@
    Gets number of rows in a result */
 PHP_FUNCTION(mysql_num_rows)
 {
-	zval **result;
+	zval *result;
 	MYSQL_RES *mysql_result;
-	
-	if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &result)==FAILURE) {
-		WRONG_PARAM_COUNT;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &result) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
-	
+
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
 	/* conversion from int64 to long happing here */
 	Z_LVAL_P(return_value) = (long) mysql_num_rows(mysql_result);
 	Z_TYPE_P(return_value) = IS_LONG;
@@ -1868,15 +1998,15 @@
    Gets number of fields in a result */
 PHP_FUNCTION(mysql_num_fields)
 {
-	zval **result;
+	zval *result;
 	MYSQL_RES *mysql_result;
-	
-	if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &result)==FAILURE) {
-		WRONG_PARAM_COUNT;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &result) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
-	
+
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
 	Z_LVAL_P(return_value) = mysql_num_fields(mysql_result);
 	Z_TYPE_P(return_value) = IS_LONG;
 }
@@ -1884,26 +2014,27 @@
 
 /* {{{ php_mysql_fetch_hash
  */
-static void php_mysql_fetch_hash(INTERNAL_FUNCTION_PARAMETERS, int result_type, int expected_args, int into_object)
+static void php_mysql_fetch_hash(INTERNAL_FUNCTION_PARAMETERS, long result_type, int expected_args, int into_object)
 {
-	zval **result, **arg2;
 	MYSQL_RES *mysql_result;
-	MYSQL_ROW mysql_row;
-	MYSQL_FIELD *mysql_field;
-	mysql_row_length_type *mysql_row_lengths;
-	int i;
 	zval            *res, *ctor_params = NULL;
 	zend_class_entry *ce = NULL;
+#ifndef MYSQL_USE_MYSQLND
+	int i;
+	MYSQL_FIELD *mysql_field;
+	MYSQL_ROW mysql_row;
+	mysql_row_length_type *mysql_row_lengths;
+#endif
 
 #ifdef ZEND_ENGINE_2
 	if (into_object) {
-		char *class_name;
-		int class_name_len;
+		char *class_name = NULL;
+		int class_name_len = 0;
 
 		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|sz", &res, &class_name, &class_name_len, &ctor_params) == FAILURE) {
 			return;
 		}
-		result = &res;
+
 		if (ZEND_NUM_ARGS() < 2) {
 			ce = zend_standard_class_def;
 		} else {
@@ -1917,47 +2048,35 @@
 	} else
 #endif
 	{
-		if (ZEND_NUM_ARGS() > expected_args) {
-			WRONG_PARAM_COUNT;
+		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r|l", &res, &result_type) == FAILURE) {
+			return;
 		}
-	
-		switch (ZEND_NUM_ARGS()) {
-			case 1:
-				if (zend_get_parameters_ex(1, &result)==FAILURE) {
-					RETURN_FALSE;
-				}
-				if (!result_type) {
-					result_type = MYSQL_BOTH;
-				}
-				break;
-			case 2:
-				if (zend_get_parameters_ex(2, &result, &arg2)==FAILURE) {
-					RETURN_FALSE;
-				}
-				convert_to_long_ex(arg2);
-				result_type = Z_LVAL_PP(arg2);
-				break;
-			default:
-				WRONG_PARAM_COUNT;
-				break;
+		if (!result_type) {
+			/* result_type might have been set outside, so only overwrite when not set */
+			result_type = MYSQL_BOTH;
 		}
 	}
 
-	if ((result_type & MYSQL_BOTH) == 0) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "The result type should be either MYSQL_NUM, MYSQL_ASSOC or MYSQL_BOTH.");
+	if (result_type & ~MYSQL_BOTH) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "The result type should be either MYSQL_NUM, MYSQL_ASSOC or MYSQL_BOTH");
+		result_type = MYSQL_BOTH;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
 
-	if ((mysql_row=mysql_fetch_row(mysql_result))==NULL 
-		|| (mysql_row_lengths=mysql_fetch_lengths(mysql_result))==NULL) {
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &res, -1, "MySQL result", le_result);
+
+#ifndef MYSQL_USE_MYSQLND
+	if ((mysql_row = mysql_fetch_row(mysql_result)) == NULL  ||
+		(mysql_row_lengths = mysql_fetch_lengths(mysql_result)) == NULL) {
 		RETURN_FALSE;
 	}
 
 	array_init(return_value);
-	
+
 	mysql_field_seek(mysql_result, 0);
-	for (mysql_field=mysql_fetch_field(mysql_result), i=0; mysql_field; mysql_field=mysql_fetch_field(mysql_result), i++) {
+	for (mysql_field = mysql_fetch_field(mysql_result), i = 0;
+		 mysql_field;
+		 mysql_field = mysql_fetch_field(mysql_result), i++)
+	{
 		if (mysql_row[i]) {
 			zval *data;
 
@@ -1975,7 +2094,7 @@
 			}
 			if (result_type & MYSQL_ASSOC) {
 				if (result_type & MYSQL_NUM) {
-					ZVAL_ADDREF(data);
+					Z_ADDREF_P(data);
 				}
 				add_assoc_zval(return_value, mysql_field->name, data);
 			}
@@ -1990,32 +2109,36 @@
 			}
 		}
 	}
+#else
+	mysqlnd_fetch_into(mysql_result, ((result_type & MYSQL_NUM)? MYSQLND_FETCH_NUM:0) | ((result_type & MYSQL_ASSOC)? MYSQLND_FETCH_ASSOC:0), return_value, MYSQLND_MYSQL);
+#endif
 
 #ifdef ZEND_ENGINE_2
-	if (into_object) {
+	/* mysqlnd might return FALSE if no more rows */
+	if (into_object && Z_TYPE_P(return_value) != IS_BOOL) {
 		zval dataset = *return_value;
 		zend_fcall_info fci;
 		zend_fcall_info_cache fcc;
-		zval *retval_ptr; 
-	
+		zval *retval_ptr;
+
 		object_and_properties_init(return_value, ce, NULL);
 		zend_merge_properties(return_value, Z_ARRVAL(dataset), 1 TSRMLS_CC);
-	
+
 		if (ce->constructor) {
 			fci.size = sizeof(fci);
 			fci.function_table = &ce->function_table;
 			fci.function_name = NULL;
 			fci.symbol_table = NULL;
-			fci.object_pp = &return_value;
+			fci.object_pp = return_value;
 			fci.retval_ptr_ptr = &retval_ptr;
 			if (ctor_params && Z_TYPE_P(ctor_params) != IS_NULL) {
 				if (Z_TYPE_P(ctor_params) == IS_ARRAY) {
-					HashTable *ht = Z_ARRVAL_P(ctor_params);
+					HashTable *htl = Z_ARRVAL_P(ctor_params);
 					Bucket *p;
-	
+
 					fci.param_count = 0;
-					fci.params = safe_emalloc(sizeof(zval*), ht->nNumOfElements, 0);
-					p = ht->pListHead;
+					fci.params = safe_emalloc(sizeof(zval*), htl->nNumOfElements, 0);
+					p = htl->pListHead;
 					while (p != NULL) {
 						fci.params[fci.param_count++] = (zval**)p->pData;
 						p = p->pListNext;
@@ -2023,7 +2146,7 @@
 				} else {
 					/* Two problems why we throw exceptions here: PHP is typeless
 					 * and hence passing one argument that's not an array could be
-					 * by mistake and the other way round is possible, too. The 
+					 * by mistake and the other way round is possible, too. The
 					 * single value is an array. Also we'd have to make that one
 					 * argument passed by reference.
 					 */
@@ -2039,8 +2162,8 @@
 			fcc.initialized = 1;
 			fcc.function_handler = ce->constructor;
 			fcc.calling_scope = EG(scope);
-			fcc.object_pp = &return_value;
-		
+			fcc.object_pp = return_value;
+
 			if (zend_call_function(&fci, &fcc TSRMLS_CC) == FAILURE) {
 				zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, "Could not execute %s::%s()", ce->name, ce->constructor->common.function_name);
 			} else {
@@ -2103,21 +2226,21 @@
    Move internal result pointer */
 PHP_FUNCTION(mysql_data_seek)
 {
-	zval **result, **offset;
+	zval *result;
+	long offset;
 	MYSQL_RES *mysql_result;
-	
-	if (ZEND_NUM_ARGS()!=2 || zend_get_parameters_ex(2, &result, &offset)==FAILURE) {
-		WRONG_PARAM_COUNT;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &result, &offset)) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
 
-	convert_to_long_ex(offset);
-	if (Z_LVAL_PP(offset)<0 || Z_LVAL_PP(offset)>=(int)mysql_num_rows(mysql_result)) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Offset %ld is invalid for MySQL result index %ld (or the query data is unbuffered)", Z_LVAL_PP(offset), Z_LVAL_PP(result));
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
+	if (offset<0 || offset>=(int)mysql_num_rows(mysql_result)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Offset %ld is invalid for MySQL result index %ld (or the query data is unbuffered)", offset, Z_LVAL_P(result));
 		RETURN_FALSE;
 	}
-	mysql_data_seek(mysql_result, Z_LVAL_PP(offset));
+	mysql_data_seek(mysql_result, offset);
 	RETURN_TRUE;
 }
 /* }}} */
@@ -2127,24 +2250,24 @@
    Gets max data size of each column in a result */
 PHP_FUNCTION(mysql_fetch_lengths)
 {
-	zval **result;
+	zval *result;
 	MYSQL_RES *mysql_result;
 	mysql_row_length_type *lengths;
 	int num_fields;
 	int i;
-	
-	if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &result)==FAILURE) {
-		WRONG_PARAM_COUNT;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &result) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
 
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
 	if ((lengths=mysql_fetch_lengths(mysql_result))==NULL) {
 		RETURN_FALSE;
 	}
 	array_init(return_value);
 	num_fields = mysql_num_fields(mysql_result);
-	
+
 	for (i=0; i<num_fields; i++) {
 		add_index_long(return_value, i, lengths[i]);
 	}
@@ -2160,6 +2283,9 @@
 		case FIELD_TYPE_VAR_STRING:
 			return "string";
 			break;
+#if MYSQL_VERSION_ID > 50002 || defined(MYSQL_USE_MYSQLND)
+		case MYSQL_TYPE_BIT:
+#endif
 #ifdef MYSQL_HAS_TINY
 		case FIELD_TYPE_TINY:
 #endif
@@ -2228,42 +2354,31 @@
    Gets column information from a result and return as an object */
 PHP_FUNCTION(mysql_fetch_field)
 {
-	zval **result, **field=NULL;
+	zval *result;
+	long field=0;
 	MYSQL_RES *mysql_result;
-	MYSQL_FIELD *mysql_field;
-	
-	switch (ZEND_NUM_ARGS()) {
-		case 1:
-			if (zend_get_parameters_ex(1, &result)==FAILURE) {
-				RETURN_FALSE;
-			}
-			break;
-		case 2:
-			if (zend_get_parameters_ex(2, &result, &field)==FAILURE) {
-				RETURN_FALSE;
-			}
-			convert_to_long_ex(field);
-			break;
-		default:
-			WRONG_PARAM_COUNT;
+	const MYSQL_FIELD *mysql_field;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r|l", &result, &field) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
 
-	if (field) {
-		if (Z_LVAL_PP(field)<0 || Z_LVAL_PP(field)>=(int)mysql_num_fields(mysql_result)) {
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
+	if (ZEND_NUM_ARGS() > 1) {
+		if (field<0 || field>=(int)mysql_num_fields(mysql_result)) {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Bad field offset");
 			RETURN_FALSE;
 		}
-		mysql_field_seek(mysql_result, Z_LVAL_PP(field));
+		mysql_field_seek(mysql_result, field);
 	}
 	if ((mysql_field=mysql_fetch_field(mysql_result))==NULL) {
 		RETURN_FALSE;
 	}
 	object_init(return_value);
 
-	add_property_string(return_value, "name",(mysql_field->name?mysql_field->name:""), 1);
-	add_property_string(return_value, "table",(mysql_field->table?mysql_field->table:""), 1);
+	add_property_string(return_value, "name", (char *) (mysql_field->name?mysql_field->name:""), 1);
+	add_property_string(return_value, "table",(char *) (mysql_field->table?mysql_field->table:""), 1);
 	add_property_string(return_value, "def",(mysql_field->def?mysql_field->def:""), 1);
 	add_property_long(return_value, "max_length", mysql_field->max_length);
 	add_property_long(return_value, "not_null", IS_NOT_NULL(mysql_field->flags)?1:0);
@@ -2283,21 +2398,20 @@
    Sets result pointer to a specific field offset */
 PHP_FUNCTION(mysql_field_seek)
 {
-	zval **result, **offset;
+	zval *result;
+	long offset;
 	MYSQL_RES *mysql_result;
-	
-	if (ZEND_NUM_ARGS()!=2 || zend_get_parameters_ex(2, &result, &offset)==FAILURE) {
-		WRONG_PARAM_COUNT;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &result, &offset) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
 
-	convert_to_long_ex(offset);
-	if (Z_LVAL_PP(offset)<0 || Z_LVAL_PP(offset)>=(int)mysql_num_fields(mysql_result)) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Field %ld is invalid for MySQL result index %ld", Z_LVAL_PP(offset), Z_LVAL_PP(result));
+	if (offset<0 || offset>=(int)mysql_num_fields(mysql_result)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Field %ld is invalid for MySQL result index %ld", offset, Z_LVAL_P(result));
 		RETURN_FALSE;
 	}
-	mysql_field_seek(mysql_result, Z_LVAL_PP(offset));
+	mysql_field_seek(mysql_result, offset);
 	RETURN_TRUE;
 }
 /* }}} */
@@ -2308,33 +2422,33 @@
 #define PHP_MYSQL_FIELD_LEN 3
 #define PHP_MYSQL_FIELD_TYPE 4
 #define PHP_MYSQL_FIELD_FLAGS 5
- 
+
 /* {{{ php_mysql_field_info
  */
 static void php_mysql_field_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
 {
-	zval **result, **field;
+	zval *result;
+	long field;
 	MYSQL_RES *mysql_result;
-	MYSQL_FIELD *mysql_field = {0};
+	const MYSQL_FIELD *mysql_field = {0};
 	char buf[512];
 	int  len;
 
-	if (ZEND_NUM_ARGS()!=2 || zend_get_parameters_ex(2, &result, &field)==FAILURE) {
-		WRONG_PARAM_COUNT;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &result, &field) == FAILURE) {
+		return;
 	}
-	
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
-	
-	convert_to_long_ex(field);
-	if (Z_LVAL_PP(field)<0 || Z_LVAL_PP(field)>=(int)mysql_num_fields(mysql_result)) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Field %ld is invalid for MySQL result index %ld", Z_LVAL_PP(field), Z_LVAL_PP(result));
+
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
+
+	if (field<0 || field>=(int)mysql_num_fields(mysql_result)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Field %ld is invalid for MySQL result index %ld", field, Z_LVAL_P(result));
 		RETURN_FALSE;
 	}
-	mysql_field_seek(mysql_result, Z_LVAL_PP(field));
+	mysql_field_seek(mysql_result, field);
 	if ((mysql_field=mysql_fetch_field(mysql_result))==NULL) {
 		RETURN_FALSE;
 	}
-	
+
 	switch (entry_type) {
 		case PHP_MYSQL_FIELD_NAME:
 			Z_STRLEN_P(return_value) = strlen(mysql_field->name);
@@ -2424,7 +2538,7 @@
 				buf[len-1] = 0;
 				len--;
 			}
-			
+
 	   		Z_STRLEN_P(return_value) = len;
    			Z_STRVAL_P(return_value) = estrndup(buf, len);
    			Z_TYPE_P(return_value) = IS_STRING;
@@ -2485,20 +2599,20 @@
    Free result memory */
 PHP_FUNCTION(mysql_free_result)
 {
-	zval **result;
+	zval *result;
 	MYSQL_RES *mysql_result;
 
-	if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &result)==FAILURE) {
-		WRONG_PARAM_COUNT;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &result) == FAILURE) {
+		return;
 	}
 
-	if (Z_TYPE_PP(result)==IS_RESOURCE && Z_LVAL_PP(result)==0) {
+	if (Z_LVAL_P(result)==0) {
 		RETURN_FALSE;
 	}
 
-	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, result, -1, "MySQL result", le_result);
+	ZEND_FETCH_RESOURCE(mysql_result, MYSQL_RES *, &result, -1, "MySQL result", le_result);
 
-	zend_list_delete(Z_LVAL_PP(result));
+	zend_list_delete(Z_LVAL_P(result));
 	RETURN_TRUE;
 }
 /* }}} */
@@ -2517,12 +2631,12 @@
 	} else if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &mysql_link)==FAILURE) {
 		return;
 	}
-	
+
 	ZEND_FETCH_RESOURCE2(mysql, php_mysql_conn *, &mysql_link, id, "MySQL-Link", le_link, le_plink);
 
 	PHPMY_UNBUFFERED_QUERY_CHECK();
 
-	RETURN_BOOL(! mysql_ping(&mysql->conn));
+	RETURN_BOOL(! mysql_ping(mysql->conn));
 }
 /* }}} */
 
--- a/ext/mysql/php_mysql.h
+++ b/ext/mysql/php_mysql.h
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2010 The PHP Group                                |
+   | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -17,7 +17,7 @@
 */
 
 
-/* $Id: php_mysql.h 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifndef PHP_MYSQL_H
 #define PHP_MYSQL_H
--- a/ext/mysql/php_mysql_structs.h
+++ b/ext/mysql/php_mysql_structs.h
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2010 The PHP Group                                |
+   | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -13,31 +13,46 @@
    | license@php.net so we can mail you a copy immediately.               |
    +----------------------------------------------------------------------+
    | Author: Zeev Suraski <zeev@zend.com>                                 |
+   |         Andrey Hristov <andrey@php.net>                              |
    +----------------------------------------------------------------------+
 */
 
 
-/* $Id: php_mysql_structs.h 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifndef PHP_MYSQL_STRUCTS_H
 #define PHP_MYSQL_STRUCTS_H
 
-#ifdef PHP_WIN32
-#define PHP_MYSQL_API __declspec(dllexport)
-#else
-#define PHP_MYSQL_API
+#ifdef ZTS
+#include "TSRM.h"
 #endif
 
-#if HAVE_MYSQL
+#ifndef TRUE
+#define TRUE 1
+#endif
 
-#ifdef ZTS
-#include "TSRM.h"
+#ifndef FALSE
+#define FALSE 0
 #endif
 
-extern zend_module_entry mysql_module_entry;
+#if defined(MYSQL_USE_MYSQLND)
+#include "ext/mysqlnd/mysqlnd.h"
+#include "mysql_mysqlnd.h"
+#else
+#include <mysql.h>
+#endif
 
-#define mysql_module_ptr &mysql_module_entry
+#ifdef PHP_MYSQL_UNIX_SOCK_ADDR
+#ifdef MYSQL_UNIX_ADDR
+#undef MYSQL_UNIX_ADDR
+#endif
+#define MYSQL_UNIX_ADDR PHP_MYSQL_UNIX_SOCK_ADDR
+#endif
 
+#if (MYSQL_VERSION_ID >= 40113 && MYSQL_VERSION_ID < 50000) || MYSQL_VERSION_ID >= 50007 || defined(MYSQL_USE_MYSQLND)
+#define MYSQL_HAS_SET_CHARSET
+#endif
+
 PHP_MINIT_FUNCTION(mysql);
 PHP_RINIT_FUNCTION(mysql);
 PHP_MSHUTDOWN_FUNCTION(mysql);
@@ -91,7 +106,7 @@
 PHP_FUNCTION(mysql_thread_id);
 PHP_FUNCTION(mysql_client_encoding);
 PHP_FUNCTION(mysql_ping);
-#if (MYSQL_VERSION_ID >= 40113 && MYSQL_VERSION_ID < 50000) || MYSQL_VERSION_ID >= 50007
+#ifdef MYSQL_HAS_SET_CHARSET
 PHP_FUNCTION(mysql_set_charset);
 #endif
 
@@ -108,6 +123,7 @@
 	long connect_timeout;
 	long result_allocated;
 	long trace_mode;
+	long allow_local_infile;
 ZEND_END_MODULE_GLOBALS(mysql)
 
 #ifdef ZTS
@@ -116,13 +132,5 @@
 # define MySG(v) (mysql_globals.v)
 #endif
 
-
-#else
-
-#define mysql_module_ptr NULL
-
-#endif
-
-#define phpext_mysql_ptr mysql_module_ptr
 
 #endif /* PHP_MYSQL_STRUCTS_H */
--- a/ext/mysql/tests/001.phpt
+++ b/ext/mysql/tests/001.phpt
@@ -1,25 +1,33 @@
 --TEST--
 mysql connect
 --SKIPIF--
-<?php include 'skipif.inc'; ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-
-include 'connect.inc';
+require_once('connect.inc');
 $test = '';
 
+if ($socket)
+	$host = sprintf("%s:%s", $host, $socket);
+else if ($port)
+	$host = sprintf("%s:%s", $host, $port);
+
 /*** test mysql_connect localhost ***/
 $db = mysql_connect($host, $user, $passwd);
 $test .= ($db) ? '1' : '0';
 mysql_close($db);
 
 /*** test mysql_connect localhost:port ***/
-$db = mysql_connect("{$host}:3306", $user, $passwd, true);
+$db = mysql_connect($host, $user, $passwd, true);
 $test .= ($db) ? '1' : '0';
 mysql_close($db);
 
 var_dump($test);
-
+print "done!";
 ?>
---EXPECT--
-string(2) "11"
+--EXPECTF--
+%unicode|string%(2) "11"
+done!
--- a/ext/mysql/tests/002.phpt
+++ b/ext/mysql/tests/002.phpt
@@ -1,18 +1,20 @@
 --TEST--
 mysql_fetch_array
 --SKIPIF--
-<?php include 'skipif.inc'; ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+require_once('connect.inc');
 
-include 'connect.inc';
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
 
-$db = mysql_connect($host, $user, $passwd);
+var_dump($link);
 
-var_dump($db);
-
-var_dump(mysql_select_db('test'));
-
 var_dump(mysql_query('DROP TABLE IF EXISTS test'));
 
 var_dump(mysql_query('CREATE TABLE test(col1 int PRIMARY KEY, col2 varchar(50), col3 char(5))'));
@@ -25,29 +27,35 @@
 	var_dump($data);
 }
 
-mysql_close($db);
+mysql_free_result($res);
+mysql_close($link);
 
+print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
 --EXPECTF--
 resource(%d) of type (mysql link)
 bool(true)
 bool(true)
 bool(true)
-bool(true)
 resource(%d) of type (mysql result)
 array(3) {
-  ["col1"]=>
-  string(1) "1"
-  ["col2"]=>
-  string(3) "foo"
-  ["col3"]=>
-  string(3) "bar"
+  [%u|b%"col1"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"col2"]=>
+  %unicode|string%(3) "foo"
+  [%u|b%"col3"]=>
+  %unicode|string%(3) "bar"
 }
 array(3) {
-  ["col1"]=>
-  string(1) "2"
-  ["col2"]=>
-  string(3) "foo"
-  ["col3"]=>
-  string(3) "bar"
+  [%u|b%"col1"]=>
+  %unicode|string%(1) "2"
+  [%u|b%"col2"]=>
+  %unicode|string%(3) "foo"
+  [%u|b%"col3"]=>
+  %unicode|string%(3) "bar"
 }
+done!
--- a/ext/mysql/tests/003.phpt
+++ b/ext/mysql/tests/003.phpt
@@ -1,84 +1,89 @@
 --TEST--
 mysql_fetch_object
 --SKIPIF--
-<?php include 'skipif.inc'; ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+include_once('connect.inc');
 
-include 'connect.inc';
-
 class class24 {
 	function __construct() {
 		echo __METHOD__ . "\n";
 	}
 }
 
-$data = array(
-	"one",
-	"two",
-	"three"
-	);
+$data = array("one", "two", "three");
 
-$db = mysql_connect($host, $user, $passwd);
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
 
-mysql_select_db("test");
+if (!mysql_query('DROP TABLE IF EXISTS test', $link))
+	printf("[002] [%d] %s\n", mysql_errno($link), mysql_error($link));
 
-mysql_query('DROP TABLE IF EXISTS test');
+if (!mysql_query("CREATE TABLE test(a varchar(10))", $link))
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
 
-mysql_query("CREATE TABLE test(a varchar(10))");
-
 foreach ($data as $str) {
-	mysql_query("INSERT INTO test VALUES('$str')");
-	var_dump($str);
+	if (!mysql_query(sprintf("INSERT INTO test VALUES('%s')", $str), $link))
+		printf("[004 - %s] [%d] %s\n", $str, mysql_errno($link), mysql_error($link));
 }
 
 echo "==stdClass==\n";
-$res = mysql_query("SELECT a FROM test");
+if (!$res = mysql_query("SELECT a FROM test", $link))
+	printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
 while ($obj = mysql_fetch_object($res)) {
 	var_dump($obj);
 }
+mysql_free_result($res);
 
 echo "==class24==\n";
-$res = mysql_query("SELECT a FROM test");
+if (!$res = mysql_query("SELECT a FROM test", $link))
+    printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
 while ($obj = mysql_fetch_object($res, 'class24')) {
 	var_dump($obj);
 }
-
-mysql_close($db);
-
+mysql_free_result($res);
+mysql_close($link);
+print "done!";
 ?>
-==DONE==
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
 --EXPECTF--
-string(3) "one"
-string(3) "two"
-string(5) "three"
 ==stdClass==
 object(stdClass)#%d (1) {
-  ["a"]=>
-  string(3) "one"
+  [%u|b%"a"]=>
+  %unicode|string%(3) "one"
 }
 object(stdClass)#%d (1) {
-  ["a"]=>
-  string(3) "two"
+  [%u|b%"a"]=>
+  %unicode|string%(3) "two"
 }
 object(stdClass)#%d (1) {
-  ["a"]=>
-  string(5) "three"
+  [%u|b%"a"]=>
+  %unicode|string%(5) "three"
 }
 ==class24==
 class24::__construct
 object(class24)#%d (1) {
-  ["a"]=>
-  string(3) "one"
+  [%u|b%"a"]=>
+  %unicode|string%(3) "one"
 }
 class24::__construct
 object(class24)#%d (1) {
-  ["a"]=>
-  string(3) "two"
+  [%u|b%"a"]=>
+  %unicode|string%(3) "two"
 }
 class24::__construct
 object(class24)#%d (1) {
-  ["a"]=>
-  string(5) "three"
+  [%u|b%"a"]=>
+  %unicode|string%(5) "three"
 }
-==DONE==
+done!
--- /dev/null
+++ b/ext/mysql/tests/bug47438.phpt
@@ -0,0 +1,52 @@
+--TEST--
+Bug #47438 (mysql_fetch_field ignores zero offset)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require_once('connect.inc');
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+        printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+                $host, $user, $db, $port, $socket);
+
+mysql_select_db($db, $link);
+mysql_query("DROP TABLE IF EXISTS test_47438", $link);
+mysql_query("CREATE TABLE test_47438 (a INT, b INT, c INT)", $link);
+mysql_query("INSERT INTO test_47438 VALUES (10, 11, 12), (20, 21, 22)", $link);
+$result = mysql_query("SELECT * FROM test_47438", $link);
+mysql_field_seek($result, 1);
+
+$i = 0;
+
+while($i<mysql_num_fields($result))
+{
+  $meta=mysql_fetch_field($result,$i);
+  echo $i . "." . $meta->name . "\n";
+  $i++;
+}
+
+mysql_query("DROP TABLE IF EXISTS test_47438", $link);
+
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+        printf("[c001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+                $host, $user, $db, $port, $socket);
+
+if (!mysql_select_db($db, $link) ||
+	!mysql_query("DROP TABLE IF EXISTS test_47438", $link))
+	printf("[c002] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+mysql_close($link);
+?>
+--EXPECT--
+0.a
+1.b
+2.c
--- /dev/null
+++ b/ext/mysql/tests/bug48754.phpt
@@ -0,0 +1,92 @@
+--TEST--
+Bug #48754 (mysql_close() crash php when no handle specified)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require_once('connect.inc');
+
+function my_mysql_pconnect($host, $user, $passwd, $db, $port, $socket) {
+	if ($socket)
+		$host = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$host = sprintf("%s:%s", $host, $port);
+
+	if (!$link = mysql_pconnect($host, $user, $passwd, true)) {
+		printf("[000-a] Cannot connect using host '%s', user '%s', password '****', [%d] %s\n",
+			$host, $user, $passwd,
+			mysql_errno(), mysql_error());
+		return false;
+	}
+	return $link;
+}
+
+echo "Explicit connection on close\n";
+$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket);
+$link1_thread_id = mysql_thread_id($link);
+$default1_thread_id = mysql_thread_id();
+echo 'Expect same thread id for $link and default conn: ';
+var_dump($link1_thread_id == $default1_thread_id);
+var_dump($link);
+mysql_close($link);
+var_dump($link);
+
+// we sohuld have no default link anymore
+mysql_close();
+
+echo "\nClosing default link\n";
+$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket);
+$link2_thread_id = mysql_thread_id($link);
+$default2_thread_id = mysql_thread_id();
+echo 'Expect same thread id for $link and default conn but not the previous: ';
+var_dump($link1_thread_id == $default1_thread_id && $link1_thread_id != $link2_thread_id);
+var_dump($link);
+mysql_close();
+var_dump($link);
+mysql_close($link);
+var_dump($link);
+
+echo "\nExplicit resource and pconnect\n";
+$link = my_mysql_pconnect($host, $user, $passwd, $db, $port, $socket);
+var_dump($link);
+mysql_close($link);
+var_dump($link);
+
+// we sohuld have no default link
+mysql_close();
+
+echo "\nDefault link and pconnect\n";
+$link = my_mysql_pconnect($host, $user, $passwd, $db, $port, $socket);
+var_dump($link);
+mysql_close();
+var_dump($link);
+mysql_close($link);
+var_dump($link);
+?>
+--EXPECTF--
+Explicit connection on close
+Expect same thread id for $link and default conn: bool(true)
+resource(%d) of type (mysql link)
+resource(%d) of type (Unknown)
+
+Warning: mysql_close(): no MySQL-Link resource supplied in %s on line %d
+
+Closing default link
+Expect same thread id for $link and default conn but not the previous: bool(true)
+resource(%d) of type (mysql link)
+resource(%d) of type (mysql link)
+resource(%d) of type (Unknown)
+
+Explicit resource and pconnect
+resource(%d) of type (mysql link persistent)
+resource(%d) of type (Unknown)
+
+Warning: mysql_close(): no MySQL-Link resource supplied in %s on line %d
+
+Default link and pconnect
+resource(%d) of type (mysql link persistent)
+resource(%d) of type (mysql link persistent)
+resource(%d) of type (Unknown)
--- /dev/null
+++ b/ext/mysql/tests/bug51242.phpt
@@ -0,0 +1,38 @@
+--TEST--
+Bug #51242 (Empty mysql.default_port does not default to 3306 anymore, but 0)
+--INI--
+mysql.default_port=
+mysql.default_socket=/this/does/not/really/need/to/exist
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifnotmysqlnd.inc');
+
+// Specific to this bug: we need to be able to connect via TCP. We'll use
+// 127.0.0.1:3306 as a (hopefully) moderately sensible default if the hostname
+// is actually specified as localhost.
+if ($host == 'localhost') {
+    $host = '127.0.0.1';
+}
+
+if (!@mysql_connect("$host:3306", $user, $passwd)) {
+    die("skip mysql not available at $host:3306");
+}
+?>
+--FILE--
+<?php
+require_once('connect.inc');
+
+if ($host == 'localhost') {
+    $host = '127.0.0.1';
+}
+
+if ($link = my_mysql_connect($host, $user, $passwd, $db, null, $socket)) {
+    var_dump($link);
+} else {
+    printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+            $host, $user, $db, null, $socket);
+}
+?>
+--EXPECTF--
+resource(%d) of type (mysql link)
--- /dev/null
+++ b/ext/mysql/tests/bug53649.phpt
@@ -0,0 +1,71 @@
+--TEST--
+Bug #53649 (mysql_query with "load data" unable to save result set)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Connect failed, [%d] %s\n", mysqlerrno(), mysqli_error()));
+}
+
+if (!mysql_query("DROP TABLE IF EXISTS test", $link) ||
+	!mysql_query("CREATE TABLE test (dump1 INT UNSIGNED NOT NULL PRIMARY KEY) ENGINE=" . $engine, $link))
+	die(sprintf("skip [%d] %s\n", mysql_errno($link), mysql_error($link)));
+
+if (false === file_put_contents('bug53649.data', "1\n2\n3\n"))
+	die(sprintf("skip Failed to create data file\n"));
+
+if (!mysql_query("LOAD DATA LOCAL INFILE 'bug53649.data' INTO TABLE test", $link) &&
+	1148 == mysql_errno($link))
+		die("skip LOAD DATA LOAD INFILE not allowed\n");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqlerrno(), mysqli_error());
+	}
+
+	if (!mysql_query("DROP TABLE IF EXISTS test", $link)) {
+		printf("[002] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+
+	if (!mysql_query("CREATE TABLE test (dump1 INT UNSIGNED NOT NULL PRIMARY KEY) ENGINE=" . $engine, $link)) {
+		printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+
+	if (false === file_put_contents('bug53649.data', "1\n2\n3\n"))
+		printf("[004] Failed to create data file\n");
+
+	if (!mysql_query("SELECT 1 FROM DUAL", $link))
+	  printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (!mysql_query("LOAD DATA LOCAL INFILE 'bug53649.data' INTO TABLE test", $link)) {
+		printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+		echo "bug";
+	} else {
+		echo "done";
+	}
+	mysql_close($link);
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+}
+
+if (!mysql_query($link, 'DROP TABLE IF EXISTS test', $link)) {
+	printf("[clean] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+}
+
+mysql_close($link);
+
+unlink('bug53649.data');
+?>
+--EXPECT--
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/bug55473.phpt
@@ -0,0 +1,79 @@
+--TEST--
+Bug #5547 (mysql_pconnect leaks file descriptors on reconnect)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+if (defined('PHP_WINDOWS_VERSION_MAJOR')) {
+	die("skip Test doesn't work on Windows");
+}
+
+if (!($output = @exec("lsof -np " . getmypid())))
+	die("skip Test can't find command line tool lsof");
+?>
+--INI--
+mysql.max_persistent=30
+mysql.allow_persistent=1
+--FILE--
+<?php
+	include "connect.inc";
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+ 	if ($socket)
+        $host = sprintf("%s:%s", $host, $socket);
+    else if ($port)
+        $host = sprintf("%s:%s", $host, $port);
+
+	function connect($host, $user, $passwd) {
+		$conn = mysql_pconnect($host, $user, $passwd);
+
+		if (!$conn)
+			die(sprintf("[001] %s\n", mysql_error()));
+
+		if (!mysql_query("set wait_timeout=1", $conn))
+			printf("[002] [%d] %s\n", mysql_errno($conn), mysql_error($conn));
+
+		return $conn;
+	}	
+
+	$conn = connect($host, $user, $passwd);
+	$opened_files = -1;
+
+	for ($i = 0; $i < 4; $i++) {
+		/* wait while mysql closes connection */
+		sleep(3);
+
+		if (!mysql_ping($conn)) {
+			printf("[003] reconnect %d\n", $i);
+			$conn = connect($host, $user, $passwd);  
+		}
+
+		$r = mysql_query('select 1', $conn);
+		if (!$r)
+			printf("[004] [%d] %s\n", mysql_errno($conn), mysql_error($conn));
+
+
+		if ($opened_files == -1) {
+			$opened_files = trim(exec("lsof -np " . getmypid() . " | wc -l"));
+			printf("[005] Setting openened files...\n");
+		} else if (($tmp = trim(exec("lsof -np " . getmypid() . " | wc -l"))) != $opened_files) {
+			printf("[006] [%d] different number of opened_files : expected %d, got %d", $i, $opened_files, $tmp);
+		} else {
+			printf("[007] Opened files as expected\n");
+		}
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+[003] reconnect 0
+[005] Setting openened files...
+[003] reconnect 1
+[007] Opened files as expected
+[003] reconnect 2
+[007] Opened files as expected
+[003] reconnect 3
+[007] Opened files as expected
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/clean_table.inc
@@ -0,0 +1,15 @@
+<?PHP
+require_once('connect.inc');
+
+// connect + select_db
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+ 	  $host, $myhost, $user, $db, $port, $socket);
+}
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link)) {
+	printf("[clean] Failed to drop test table: [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+mysql_close($link);
+?>
\ No newline at end of file
--- a/ext/mysql/tests/connect.inc
+++ b/ext/mysql/tests/connect.inc
@@ -1,10 +1,82 @@
 <?php
+if (!function_exists('sys_get_temp_dir')) {
+	function sys_get_temp_dir() {
 
-  /* default values are localhost, root and empty password 
-     Change the values if you use another configuration   */
+		if (!empty($_ENV['TMP']))
+			return realpath( $_ENV['TMP'] );
+		if (!empty($_ENV['TMPDIR']))
+			return realpath( $_ENV['TMPDIR'] );
+		if (!empty($_ENV['TEMP']))
+			return realpath( $_ENV['TEMP'] );
 
-	$host = "localhost";
-	$user = "root";
-	$passwd = "";
+		$temp_file = tempnam(md5(uniqid(rand(), TRUE)), '');
+		if ($temp_file) {
+                	$temp_dir = realpath(dirname($temp_file));
+			unlink($temp_file);
+			return $temp_dir;
+		}
+		return FALSE;
+	}
+}
 
+if (!function_exists('my_mysql_connect')) {
+	/* wrapper to simplify test porting */
+	function my_mysql_connect($host, $user, $passwd, $db, $port, $socket, $flags = NULL, $persistent = false) {
+		global $connect_flags;
+
+		$flags = ($flags === NULL) ? $connect_flags : $flags;
+
+		if ($socket)
+			$host = sprintf("%s:%s", $host, $socket);
+		else if ($port)
+			$host = sprintf("%s:%s", $host, $port);
+
+		if ($persistent) {
+			$link = mysql_pconnect($host, $user, $passwd, $flags);
+		} else {
+			 $link = mysql_connect($host, $user, $passwd, true, $flags);
+		}
+
+		if (!$link) {
+			printf("[000-a] Cannot connect using host '%s', user '%s', password '****', persistent = %d, [%d] %s\n",
+				$host, $user, ($persistent) ? 1 : 0,
+				mysql_errno(), mysql_error());
+			return false;
+		}
+
+		if (!mysql_select_db($db, $link)) {
+			printf("[000-b] [%d] %s\n", mysql_errno($link), mysql_error($link));
+			return false;
+		}
+
+		return $link;
+	}
+} else {
+	printf("skip Eeeek/BUG/FIXME - connect.inc included twice! skipif bug?\n");
+}
+
+/*
+Default values are "localhost", "root", database "test" and empty password.
+Change the MYSQL_TEST_* environment values if you want to use another configuration.
+*/
+
+$host		= getenv("MYSQL_TEST_HOST")	? getenv("MYSQL_TEST_HOST")	: "localhost";
+$port		= getenv("MYSQL_TEST_PORT")	? getenv("MYSQL_TEST_PORT")	: 3306;
+$user		= getenv("MYSQL_TEST_USER")	? getenv("MYSQL_TEST_USER")	: "root";
+$passwd	= getenv("MYSQL_TEST_PASSWD")	? getenv("MYSQL_TEST_PASSWD")	: "";
+
+$db			= getenv("MYSQL_TEST_DB")	? getenv("MYSQL_TEST_DB")	: "test";
+$engine	= getenv("MYSQL_TEST_ENGINE")	? getenv("MYSQL_TEST_ENGINE")	: "MyISAM";
+$socket	= getenv("MYSQL_TEST_SOCKET")	? getenv("MYSQL_TEST_SOCKET")	: null;
+$skip_on_connect_failure  = getenv("MYSQL_TEST_SKIP_CONNECT_FAILURE") ? getenv("MYSQL_TEST_SKIP_CONNECT_FAILURE") : true;
+$connect_flags = getenv("MYSQL_TEST_CONNECT_FLAGS") ? (int)getenv("MYSQL_TEST_CONNECT_FLAGS") : 0;
+if ($socket) {
+	ini_set('mysql.default_socket', $socket);
+}
+/* Development setting: test experimal features and/or feature requests that never worked before? */
+$TEST_EXPERIMENTAL = (in_array(getenv("MYSQL_TEST_EXPERIMENTAL"), array(0, 1))) ?
+	((1 == getenv("MYSQL_TEST_EXPERIMENTAL")) ? true : false) :
+	false;
+
+$IS_MYSQLND = stristr(mysql_get_client_info(), "mysqlnd");
 ?>
--- /dev/null
+++ b/ext/mysql/tests/mysql_affected_rows.phpt
@@ -0,0 +1,125 @@
+--TEST--
+mysql_affected_rows()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once("connect.inc");
+include_once('setupdefault.inc');
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (0 !== ($tmp = @mysql_affected_rows()))
+	printf("[001] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_affected_rows($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_null($tmp = @mysql_affected_rows($link, $link)))
+	printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[004] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+if (-1 !== ($tmp = mysql_affected_rows($link)))
+	printf("[005] Expecting int/-1, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link))
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!mysql_query('CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE = ' . $engine, $link))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!mysql_query("INSERT INTO test(id, label) VALUES (1, 'a')", $link))
+	printf("[008] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (1 !== ($tmp = mysql_affected_rows($link)))
+	printf("[010] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+// ignore INSERT error, NOTE: command line returns 0, affected_rows returns -1 as documented
+@mysql_query("INSERT INTO test(id, label) VALUES (1, 'a')", $link);
+if (-1 !== ($tmp = mysql_affected_rows($link)))
+	printf("[011] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("INSERT INTO test(id, label) VALUES (1, 'a') ON DUPLICATE KEY UPDATE id = 4", $link))
+	printf("[012] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (2 !== ($tmp = mysql_affected_rows($link)))
+	printf("[013] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("INSERT INTO test(id, label) VALUES (2, 'b'), (3, 'c')", $link))
+	printf("[014] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (2 !== ($tmp = mysql_affected_rows($link)))
+	printf("[015] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("INSERT IGNORE INTO test(id, label) VALUES (1, 'a')", $link)) {
+	printf("[016] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+}
+
+if (1 !== ($tmp = mysql_affected_rows($link)))
+	printf("[017] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("INSERT INTO test(id, label) SELECT id + 10, label FROM test", $link))
+	printf("[018] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (4 !== ($tmp = mysql_affected_rows($link)))
+	printf("[019] Expecting int/4, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("REPLACE INTO test(id, label) values (4, 'd')", $link))
+	printf("[020] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (2 !== ($tmp = mysql_affected_rows($link)))
+	printf("[021] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("REPLACE INTO test(id, label) values (5, 'e')", $link))
+	printf("[022] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (1 !== ($tmp = mysql_affected_rows($link)))
+	printf("[023] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("UPDATE test SET label = 'a' WHERE id = 2", $link))
+	printf("[024] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+if (1 !== ($tmp = mysql_affected_rows($link)))
+	printf("[025] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("UPDATE test SET label = 'a' WHERE id = 2", $link)) {
+	printf("[025] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+}
+
+if (0 !== ($tmp = mysql_affected_rows($link)))
+	printf("[026] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query("UPDATE test SET label = 'a' WHERE id = 100", $link)) {
+	printf("[025] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+}
+
+if (0 !== ($tmp = mysql_affected_rows($link)))
+	printf("[026] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (0 !== ($tmp = mysql_affected_rows()))
+	printf("[027] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link))
+	printf("[028] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+mysql_close($link);
+
+if (false !== ($tmp = @mysql_affected_rows($link)))
+	printf("[029] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_client_encoding.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysql_client_encoding()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+$default_link_enc = mysql_client_encoding();
+$link_enc = mysql_client_encoding($link);
+
+if ($default_link_enc !== $link_enc)
+	printf("[003] %s != %s, [%d] %s\n", $default_link_enc, $link_enc, mysql_errno($link), mysql_error($link));
+
+if (!$res = mysql_query('SELECT version() AS server_version', $link))
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+$tmp = mysql_fetch_assoc($res);
+mysql_free_result($res);
+$version = explode('.', $tmp['server_version']);
+if (empty($version))
+	printf("[005] Cannot determine server version, need MySQL Server 4.1+ for the test!\n");
+
+if ($version[0] <= 4 && $version[1] < 1)
+	printf("[006] Need MySQL Server 4.1+ for the test!\n");
+
+if (!$res = mysql_query('SELECT @@character_set_connection AS charset, @@collation_connection AS collation', $link))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+$tmp = mysql_fetch_assoc($res);
+mysql_free_result($res);
+if (!$tmp['charset'])
+	printf("[008] Cannot determine current character set and collation\n");
+
+if ($link_enc !== $tmp['charset']) {
+	if ($link_enc === $tmp['collation']) {
+		printf("[009] Known bug, collation instead of chatset returned, http://bugs.mysql.com/bug.php?id=7923\n");
+	} else {
+		printf("[009] Check manually, watch out for unicode and others\n");
+		var_dump($link_enc);
+		var_dump($tmp);
+	}
+}
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && function_exists('is_unicode')) {
+// unicode mode
+	if (!is_unicode($default_link_enc) || !is_unicode($link_enc)) {
+		printf("[010] No unicode returned!\n");
+		var_dump($default_link_enc);
+		var_dump($link_enc);
+	}
+}
+
+mysql_close($link);
+
+if (false !== ($tmp = @mysql_client_encoding($link)))
+	printf("[012] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_close.phpt
@@ -0,0 +1,39 @@
+--TEST--
+mysql_close()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (false !== ($tmp = @mysql_close()))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_close($link, $link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+$tmp = @mysql_close(NULL);
+if (null !== $tmp)
+	printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+$tmp = mysql_close($link);
+if (true !== $tmp)
+	printf("[005] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = @mysql_query("SELECT 1", $link)))
+	printf("[006] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!\n";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_connect.phpt
@@ -0,0 +1,108 @@
+--TEST--
+mysql_connect()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+// mysql_connect ( [string server [, string username [, string password [, bool new_link [, int client_flags]]]]] )
+if (NULL !== ($tmp = @mysql_connect($link, $link, $link, $link, $link, $link)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+$myhost = (is_null($socket)) ? ((is_null($port)) ? $host : $host . ':' . $port) : $host . ':' . $socket;
+if (!$link = mysql_connect($myhost, $user, $passwd, true))
+	printf("[002] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $myhost, $user, $db, $port, $socket);
+
+mysql_close($link);
+
+if (!$link = mysql_connect($myhost, $user, $passwd, true))
+	printf("[003] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $myhost, $user, $db, $port, $socket);
+
+mysql_close();
+
+if ($link = mysql_connect($myhost, $user . 'unknown_really', $passwd . 'non_empty', true))
+	printf("[004] Can connect to the server using host=%s/%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+		$host, $myhost, $user . 'unknown_really', $db, $port, $socket);
+
+if (false !== $link)
+printf("[005] Expecting boolean/false, got %s/%s\n", gettype($link), $link);
+
+// Run the following tests without an anoynmous MySQL user and use a password for the test user!
+ini_set('mysql.default_socket', $socket);
+if (!is_null($socket)) {	
+	if (!is_resource($link = mysql_connect($host, $user, $passwd, true))) {
+		printf("[006] Usage of mysql.default_socket failed\n");
+	} else {
+		mysql_close($link);
+	}
+}
+
+if (!ini_get('sql.safe_mode')) {
+
+	ini_set('mysql.default_port', $port);
+	if (!is_null($port)) {
+		if (!is_resource($link = mysql_connect($host, $user, $passwd, true))) {
+			printf("[007] Usage of mysql.default_port failed\n");
+		} else {
+			mysql_close($link);
+		}
+	}
+
+	ini_set('mysql.default_password', $passwd);
+	if (!is_resource($link = mysql_connect($myhost, $user))) {
+		printf("[008] Usage of mysql.default_password failed\n");
+	} else {
+		mysql_close($link);
+	}
+	ini_set('mysql.default_user', $user);
+	if (!is_resource($link = mysql_connect($myhost))) {
+		printf("[009] Usage of mysql.default_user failed\n");
+	} else {
+		mysql_close($link);
+	}
+
+	ini_set('mysql.default_host', $myhost);
+	if (!is_resource($link = mysql_connect())) {
+		printf("[010] Usage of mysql.default_host failed\n") ;
+	} else {
+		mysql_close($link);
+	}
+
+	if (!is_resource($link = mysql_connect()) || !is_resource($link2 = mysql_connect())) {
+		printf("[011] Usage of mysql.default_host failed\n") ;
+	} else {
+		mysql_close();
+		mysql_close($link2);
+	}
+
+	if (!stristr(PHP_OS, 'win') && !stristr(PHP_OS, 'netware')) {
+		ini_set('mysql.default_port', -1);
+		if (putenv(sprintf('MYSQL_TCP_PORT=%d', $port))) {
+			if (!is_resource($link = mysql_connect())) {
+				printf("[012] Usage of env MYSQL_TCP_PORT failed\n") ;
+			} else {
+			mysql_close($link);
+		}
+		} else if (putenv(sprintf('MYSQL_TCP_PORT=%d', $port + 1))) {
+			if (!is_resource($link = mysql_connect())) {
+				printf("[013] Usage of env MYSQL_TCP_PORT=%d should have failed\n", $port + 1) ;
+				mysql_close($link);
+		}
+		}
+	}
+}
+
+print "done!";
+?>
+--EXPECTF--
+Warning: mysql_connect(): Access denied for user '%s'@'%s' (using password: YES) in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_constants.phpt
@@ -0,0 +1,65 @@
+--TEST--
+Constants exported by ext/mysql
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require("connect.inc");
+require("table.inc");
+
+$constants = get_defined_constants(true);
+sort($constants);
+
+$expected_constants = array(
+	'MYSQL_ASSOC'                   => true,
+	'MYSQL_NUM'                     => true,
+	'MYSQL_BOTH'                    => true,
+	'MYSQL_CLIENT_COMPRESS'         => true,
+	'MYSQL_CLIENT_INTERACTIVE'      => true,
+	'MYSQL_CLIENT_IGNORE_SPACE'     => true,
+);
+
+$version = mysql_get_server_info($link);
+if (!preg_match('@(\d+)\.(\d+)\.(\d+)@ism', $version, $matches))
+	printf("[001] Cannot get server version\n");
+$version = ($matches[1] * 100) + ($matches[2] * 10) + $matches[3];
+
+if ($version > 400) {
+	$expected_constants = array_merge($expected_constants, array(
+					"MYSQL_CLIENT_SSL"                => true,
+					));
+}
+
+
+$unexpected_constants = array();
+
+foreach ($constants as $group => $consts) {
+	foreach ($consts as $name => $value) {
+		if (stristr($name, 'mysql') && !preg_match("/^mysql([^_]+)_/iu", $name)) {
+			$name = strtoupper($name);
+			if (isset($expected_constants[$name])) {
+				unset($expected_constants[$name]);
+			} else {
+				$unexpected_constants[$name] = $name;
+			}
+		}
+	}
+}
+
+if (!empty($unexpected_constants)) {
+	printf("Dumping list of unexpected constants\n");
+	var_dump($unexpected_constants);
+}
+
+if (!empty($expected_constants)) {
+	printf("Dumping list of missing constants\n");
+	var_dump($expected_constants);
+}
+
+print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_create_db.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysql_create_db()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+if (!function_exists('mysql_create_db'))
+	die("Skip mysql_create_db() exists only in old versions of the libmysql.");
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$link   = NULL;
+$tmp    = null;
+
+if (false !== ($tmp = mysql_create_db()))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_create_db($link, $link, $link)))
+	printf("[002] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if ($link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[003] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+		$host, $user . 'unknown_really', $db, $port, $socket);
+
+if (!mysql_query("CREATE DATABASE mysqlcreatedb", $link))
+	die(sprintf("[004] Cannot create database, aborting test, [%d] %s\n", mysql_errno($link), mysql_error($link)));
+
+if (!mysql_query("DROP DATABASE mysqlcreatedb", $link))
+	printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (true !== ($tmp = mysql_create_db("mysqlcreatedb", $link)))
+	printf("[006] Expecting boolean/true, got %s/%s, [%d] %s\n", gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+if (false !== ($tmp = mysql_create_db("mysqlcreatedb", $link)))
+	printf("[007] Expecting boolean/false, got %s/%s, [%d] %s\n", gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+if (!mysql_query("DROP DATABASE mysqlcreatedb", $link))
+	printf("[008] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[c001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+if (!mysql_query("DROP DATABASE IF EXISTS mysqlcreatedb", $link))
+	printf("[c002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysql_close($link);
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_data_seek.phpt
@@ -0,0 +1,77 @@
+--TEST--
+mysql_data_seek()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_data_seek()))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_data_seek($link)))
+	printf("[002] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_data_seek($link, $link)))
+	printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query('SELECT * FROM test ORDER BY id LIMIT 4', $link))
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (true !== ($tmp = mysql_data_seek($res, 3)))
+	printf("[005] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+$row = mysql_fetch_assoc($res);
+if (4 != $row['id'])
+	printf("[006] Expecting record 4/d, got record %s/%s\n", $row['id'], $row['label']);
+
+if (true !== ($tmp = mysql_data_seek($res, 0)))
+	printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+$row = mysql_fetch_assoc($res);
+if (1 != $row['id'])
+	printf("[008] Expecting record 1/a, got record %s/%s\n", $row['id'], $row['label']);
+
+if (false !== ($tmp = mysql_data_seek($res, 4)))
+	printf("[009] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_data_seek($res, -1)))
+	printf("[010] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+if (!$res = mysql_unbuffered_query('SELECT * FROM test ORDER BY id', $link))
+	printf("[011] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (false !== ($tmp = mysql_data_seek($res, 3)))
+	printf("[012] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+if (false !== ($tmp = mysql_data_seek($res, 1)))
+	printf("[013] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_close($link);
+
+print "done!\n";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_data_seek(): Offset 4 is invalid for MySQL result index %d (or the query data is unbuffered) in %s on line %d
+
+Warning: mysql_data_seek(): Offset -1 is invalid for MySQL result index %d (or the query data is unbuffered) in %s on line %d
+
+Warning: mysql_data_seek(): Offset 3 is invalid for MySQL result index %d (or the query data is unbuffered) in %s on line %d
+
+Warning: mysql_data_seek(): %d is not a valid MySQL result resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_db_name.phpt
@@ -0,0 +1,66 @@
+--TEST--
+mysql_db_name()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_db_name()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_db_name($link, $link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (!$res = @mysql_list_dbs($link))
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$num = mysql_num_rows($res))
+	printf("[004] Empty database list? [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (false !== ($tmp = mysql_db_name($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+if (false !== ($tmp = mysql_db_name($res, $num + 1)))
+	printf("[006] Expecting boolean/false, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+$unicode = (boolean)(version_compare(PHP_VERSION, '5.9.9', '>') == 1);
+for ($i = 0; $i < $num; $i++) {
+	if ('' === ($dbname = mysql_db_name($res, $i)))
+		printf("[%03d] Got empty database name! [%d] %s\n",
+			(($i * 2) + 1) + 6, mysql_errno($link), mysql_error($link));
+
+	if ($unicode && !is_unicode($dbname)) {
+		printf("[%03d] Expecting unicode string! [%d] %s\n",
+			(($i * 2) + 2) + 6, mysql_errno($link), mysql_error($link));
+		var_inspect($dbname);
+	}
+}
+
+mysql_free_result($res);
+
+if (false !== ($tmp = mysql_db_name($res, $num)))
+	printf("[999] Expecting boolean/false, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+mysql_close($link);
+
+print "done!\n";
+?>
+--EXPECTF--
+Warning: mysql_db_name(): Unable to jump to row -1 on MySQL result index %d in %s on line %d
+
+Warning: mysql_db_name(): Unable to jump to row %d on MySQL result index %d in %s on line %d
+
+Warning: mysql_db_name(): %d is not a valid MySQL result resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_db_query.phpt
@@ -0,0 +1,65 @@
+--TEST--
+mysql_db_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+// NOTE: this function is deprecated. We do only the most necessary
+// to test it. We don't test all aspects of the documented behaviour.
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_db_query()))
+	printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_db_query($link)))
+	printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_db_query($link)))
+	printf("[003] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = @mysql_db_query($db, 'SELECT id, label FROM test ORDER BY id LIMIT 1', $link))
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+$row = mysql_fetch_assoc($res);
+if (1 != $row['id'])
+	printf("[005] Expecting record 1/a, got record %s/%s\n", $row['id'], $row['label']);
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($row['label'])) {
+	printf("[006] No unicode returned! [%d] %s\n", mysql_errno($link), mysql_error($link));
+	var_inspect($row);
+}
+
+mysql_free_result($res);
+
+
+if (!$res = @mysql_db_query($db, 'SELECT id, label FROM test ORDER BY id LIMIT 1'))
+	printf("[007] [%d] %s\n", mysql_errno(), mysql_error());
+
+$row = mysql_fetch_assoc($res);
+if (1 != $row['id'])
+	printf("[008] Expecting record 1/a, got record %s/%s\n", $row['id'], $row['label']);
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($row['label'])) {
+	printf("[009] No unicode returned! [%d] %s\n", mysql_errno(), mysql_error());
+	var_inspect($row);
+}
+
+mysql_free_result($res);
+mysql_close($link);
+
+print "done!\n";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_deprecated_api.phpt
@@ -0,0 +1,78 @@
+--TEST--
+Check if deprecated API calls bail out
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.trace_mode=1
+error_reporting=E_ALL | E_NOTICE | E_STRICT
+--FILE--
+<?php
+/*
+  We use an extra test to cover deprecation warning.
+  Due to this extra test we can silence deprecation warnings
+  in have other test using @ operator without loosing the information
+  which function is deprecated and, without reducing test portability.
+*/
+include "table.inc";
+
+if (version_compare(PHP_VERSION, '5.3.0') >= 0) {
+	$error = NULL;
+	ob_start();
+	if (!$res = mysql_db_query($db, "SELECT * FROM test", $link))
+		$error .= sprintf("[001] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	else
+	  mysql_free_result($res);
+	$output = ob_get_contents();
+	ob_end_clean();
+
+	if (!stristr($output, 'deprecated')) {
+		printf("[002] mysql_db_query has been deprecated in 5.3.0\n");
+	}
+
+	/*
+		Deprecated since 2002 or the like but documented to be deprecated since 5.3.
+		In 5.3 and before the deprecation message was bound to mysql.trace_mode=1.
+		In 5.3.99 the warning will always be thrown, independent of the mysql.trace_mode
+		setting.
+	*/
+	$error = NULL;
+	ob_start();
+	if (!$query = mysql_escape_string("charsets will be ignored"))
+		$error .= sprintf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	$output = ob_get_contents();
+	ob_end_clean();
+
+	if (!stristr($output, 'deprecated')) {
+		printf("[006] mysql_escape_string has been deprecated in 5.3.0\n");
+	}
+
+}
+
+if (version_compare(PHP_VERSION, '5.3.99') >= 0) {
+	$error = NULL;
+	ob_start();
+	if (!$res = mysql_list_dbs($link))
+		$error .= sprintf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	else
+	  mysql_free_result($res);
+	$output = ob_get_contents();
+	ob_end_clean();
+
+  if (!stristr($output, 'deprecated')) {
+	printf("[004] mysql_db_query has been deprecated in 5.3.0\n");
+  }
+}
+
+
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_drop_db.phpt
@@ -0,0 +1,55 @@
+--TEST--
+mysql_drop_db()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+if (!function_exists('mysql_drop_db'))
+	die("Skip function is deprecated and not available");
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+// NOTE: again this test does not test all of the behaviour of the function
+
+if (NULL !== ($tmp = mysql_drop_db()))
+	printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!mysql_query('DROP DATABASE IF EXISTS mysqldropdb'))
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!mysql_query('CREATE DATABASE mysqldropdb'))
+	die(sprintf("[005] Skipping, can't create test database. [%d] %s\n", mysql_errno($link), mysql_error($link)));
+
+if (true !== ($tmp = mysql_drop_db('mysqldropdb', $link)))
+	printf("[006] Can't drop, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp,
+		mysql_errno($link), mysql_error($link));
+
+if (false !== ($tmp = mysql_drop_db('mysqldropdb', $link)))
+	printf("[007] Expecting boolean/false, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp,
+		mysql_errno($link), mysql_error($link));
+
+mysql_close($link);
+
+print "done!\n";
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[c001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+if (!mysql_query("DROP DATABASE IF EXISTS mysqldropdb", $link))
+	printf("[c002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysql_close($link);
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_errno.phpt
@@ -0,0 +1,63 @@
+--TEST--
+mysql_errno()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (false !== ($tmp = @mysql_errno()))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_errno($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_null($tmp = @mysql_errno($link, 'too many args')))
+	printf("[002b] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+}
+var_dump(mysql_errno($link));
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link)) {
+	printf("[004] Failed to drop old test table: [%d] %s\n", mysql_errno($link), mysql_errno($link));
+}
+
+mysql_query('SELECT * FROM test', $link);
+var_dump(mysql_errno($link));
+
+mysql_close($link);
+
+var_dump(mysql_errno($link));
+
+if ($link = @mysql_connect($host . '_unknown', $user . '_unknown', $passwd, true)) {
+	printf("[005] Can connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host . '_unknown', $user . '_unknown', $db, $port, $socket);
+} else {
+	$errno = mysql_errno();
+	if (!is_int($errno))
+		printf("[006] Expecting int/any (e.g 1046, 2005) got %s/%s\n", gettype($errno), $errno);
+
+}
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+int(0)
+int(%d)
+
+Warning: mysql_errno(): %d is not a valid MySQL-Link resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_error.phpt
@@ -0,0 +1,67 @@
+--TEST--
+mysql_error()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (false !== ($tmp = @mysql_error()))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_error($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_null($tmp = @mysql_error($link, 'too many args')))
+	printf("[002b] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+}
+
+$tmp = mysql_error($link);
+if (!is_string($tmp) || ('' !== $tmp))
+	printf("[004] Expecting string/empty, got %s/%s. [%d] %s\n", gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link)) {
+	printf("[005] Failed to drop old test table: [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+mysql_query('SELECT * FROM test', $link);
+$tmp = mysql_error($link);
+if (!is_string($tmp) || !preg_match("/Table '\w*\.test' doesn't exist/su", $tmp))
+	printf("[006] Expecting string/[Table... doesn't exit], got %s/%s. [%d] %s\n", gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp)) {
+	printf("[007] Expecting Unicode error message!\n");
+	var_inspect($tmp);
+}
+
+mysql_close($link);
+
+var_dump(mysql_error($link));
+
+if ($link = @mysql_connect($host . '_unknown', $user . '_unknown', $passwd, true)) {
+	printf("[008] Can connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host . '_unknown', $user . '_unknown', $db, $port, $socket);
+}
+if ('' == mysql_error())
+	printf("[009] Connect error should have been set\n");
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_error(): %d is not a valid MySQL-Link resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_escape_string.phpt
@@ -0,0 +1,33 @@
+--TEST--
+mysql_escape_string()
+--SKIPIF--
+<?php require_once('skipif.inc'); ?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_escape_string()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(@mysql_escape_string("Am I a unicode string in PHP 6?"));
+var_dump(@mysql_escape_string('\\'));
+var_dump(@mysql_escape_string('"'));
+var_dump(@mysql_escape_string("'"));
+var_dump(@mysql_escape_string("\n"));
+var_dump(@mysql_escape_string("\r"));
+var_dump(@mysql_escape_string("foo" . chr(0) . "bar"));
+
+print "done!";
+?>
+--EXPECTF--
+%unicode|string%(31) "Am I a unicode string in PHP 6?"
+%unicode|string%(2) "\\"
+%unicode|string%(2) "\""
+%unicode|string%(2) "\'"
+%unicode|string%(2) "\n"
+%unicode|string%(2) "\r"
+%unicode|string%(8) "foo\0bar"
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_fetch_array.phpt
@@ -0,0 +1,360 @@
+--TEST--
+mysql_fetch_array()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_fetch_array()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL != ($tmp = @mysql_fetch_array($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT * FROM test ORDER BY id LIMIT 5", $link)) {
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+print "[005]\n";
+var_dump(mysql_fetch_array($res));
+
+print "[006]\n";
+var_dump(mysql_fetch_array($res, MYSQL_NUM));
+
+print "[007]\n";
+var_dump(mysql_fetch_array($res, MYSQL_BOTH));
+
+print "[008]\n";
+var_dump(mysql_fetch_array($res, MYSQL_ASSOC));
+
+print "[009]\n";
+var_dump(mysql_fetch_array($res));
+
+mysql_free_result($res);
+
+if (!$res = mysql_query("SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e", $link)) {
+	printf("[010] Cannot run query, [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+print "[011]\n";
+var_dump(mysql_fetch_array($res, MYSQL_BOTH));
+
+mysql_free_result($res);
+if (!$res = mysql_query("SELECT 1 AS a, 2 AS b, 3 AS c, 4 AS C", $link)) {
+	printf("[012] Cannot run query, [%d] %s\n",
+		mysql_errno($link), $mysql_error($link));
+	exit(1);
+}
+
+do {
+	$illegal_mode = mt_rand(0, 10000);
+} while (in_array($illegal_mode, array(MYSQL_ASSOC, MYSQL_NUM, MYSQL_BOTH)));
+$tmp = mysql_fetch_array($res, $illegal_mode);
+if (!is_array($tmp))
+	printf("[013] Expecting array, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+$tmp = @mysql_fetch_array($res, $illegal_mode);
+if (false !== $tmp)
+	printf("[014] Expecting boolean/false, got %s/%s. [%d] %s\n",
+		gettype($tmp), $tmp, mysql_errno($link), mysql_error($link));
+
+mysql_free_result($res);
+
+function func_mysql_fetch_array($link, $engine, $sql_type, $sql_value, $php_value, $offset, $regexp_comparison = NULL, $binary_type = false) {
+
+	if (!mysql_query("DROP TABLE IF EXISTS test", $link)) {
+		printf("[%04d] [%d] %s\n", $offset, mysql_errno($link), mysql_error($link));
+		return false;
+	}
+
+	if (!mysql_query($sql = sprintf("CREATE TABLE test(id INT NOT NULL, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine), $link)) {
+		// don't bail, engine might not support the datatype
+		return false;
+	}
+
+	if (is_null($php_value) && !mysql_query($sql = sprintf("INSERT INTO test(id, label) VALUES (1, NULL)"), $link)) {
+		printf("[%04d] [%d] %s\n", $offset + 1, mysql_errno($link), mysql_error($link));
+		return false;
+	}
+
+	if (!is_null($php_value)) {
+		if (is_int($sql_value) && !mysql_query(sprintf("INSERT INTO test(id, label) VALUES (1, '%d')", $sql_value), $link)) {
+			printf("[%04d] [%d] %s\n", $offset + 1, mysql_errno($link), mysql_error($link));
+			return false;
+		} else if (!is_int($sql_value) && !mysql_query(sprintf("INSERT INTO test(id, label) VALUES (1, '%s')", $sql_value), $link)) {
+			printf("[%04d] [%d] %s\n", $offset + 1, mysql_errno($link), mysql_error($link));
+			return false;
+		}
+	}
+
+	if (!$res = mysql_query("SELECT id, label FROM test", $link)) {
+		printf("[%04d] [%d] %s\n", $offset + 2, mysql_errno($link), mysql_error($link));
+		return false;
+	}
+
+	if (!$row = mysql_fetch_array($res, MYSQL_BOTH)) {
+		printf("[%04d] [%d] %s\n", $offset + 3, mysql_errno($link), mysql_error($link));
+		return false;
+	}
+
+	if ($regexp_comparison) {
+		if (!preg_match($regexp_comparison, (string)$row['label']) || !preg_match($regexp_comparison, (string)$row[1])) {
+		printf("[%04d] Expecting %s/%s [reg exp = %s], got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+			gettype($php_value), $php_value, $regexp_comparison,
+			gettype($row[1]), $row[1],
+			gettype($row['label']), $row['label'], mysql_errno($link), mysql_error($link));
+		return false;
+		}
+	} else if ((gettype($php_value) == 'unicode') && $binary_type) {
+		// Unicode is on and we are told that the MySQL column type is a binary type.
+		// Don't expect a unicode value from the database, you'll get binary string
+		if (($row['label'] != $php_value) || ($row[1] != $php_value)) {
+			printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 5,
+				gettype($php_value), $php_value,
+				gettype($row[1]), $row[1],
+				gettype($row['label']), $row['label'], mysql_errno($link), mysql_error($link));
+			return false;
+		}
+		if (gettype($row['label']) == 'unicode') {
+			printf("[%04d] SQL Type: '%s', binary columns are supposed to return binary string and not unicode\n",
+				$offset + 6, $sql_type);
+			return false;
+		}
+	} else {
+		if (($row['label'] !== $php_value) || ($row[1] != $php_value)) {
+			printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 7,
+				gettype($php_value), $php_value,
+				gettype($row[1]), $row[1],
+				gettype($row['label']), $row['label'], mysql_errno($link), mysql_error($link));
+			return false;
+		}
+	}
+
+	return true;
+}
+
+function func_mysql_fetch_array_make_string($len) {
+
+	$ret = '';
+	for ($i = 0; $i < $len; $i++)
+		$ret .= chr(mt_rand(65, 90));
+
+	return $ret;
+}
+
+func_mysql_fetch_array($link, $engine, "TINYINT", -11, "-11", 20);
+func_mysql_fetch_array($link, $engine, "TINYINT", NULL, NULL, 30);
+func_mysql_fetch_array($link, $engine, "TINYINT UNSIGNED", 1, "1", 40);
+func_mysql_fetch_array($link, $engine, "TINYINT UNSIGNED", NULL, NULL, 50);
+
+func_mysql_fetch_array($link, $engine, "BOOL", 1, "1", 60);
+func_mysql_fetch_array($link, $engine, "BOOL", NULL, NULL, 70);
+func_mysql_fetch_array($link, $engine, "BOOLEAN", 0, "0", 80);
+func_mysql_fetch_array($link, $engine, "BOOLEAN", NULL, NULL, 90);
+
+func_mysql_fetch_array($link, $engine, "SMALLINT", -32768, "-32768", 100);
+func_mysql_fetch_array($link, $engine, "SMALLINT", 32767, "32767", 110);
+func_mysql_fetch_array($link, $engine, "SMALLINT", NULL, NULL, 120);
+func_mysql_fetch_array($link, $engine, "SMALLINT UNSIGNED", 65535, "65535", 130);
+func_mysql_fetch_array($link, $engine, "SMALLINT UNSIGNED", NULL, NULL, 140);
+
+func_mysql_fetch_array($link, $engine, "MEDIUMINT", -8388608, "-8388608", 150);
+func_mysql_fetch_array($link, $engine, "MEDIUMINT", 8388607, "8388607", 160);
+func_mysql_fetch_array($link, $engine, "MEDIUMINT", NULL, NULL, 170);
+func_mysql_fetch_array($link, $engine, "MEDIUMINT UNSIGNED", 16777215, "16777215", 180);
+func_mysql_fetch_array($link, $engine, "MEDIUMINT UNSIGNED", NULL, NULL, 190);
+
+func_mysql_fetch_array($link, $engine, "INTEGER", -2147483648, "-2147483648", 200);
+func_mysql_fetch_array($link, $engine, "INTEGER", 2147483647, "2147483647", 210);
+func_mysql_fetch_array($link, $engine, "INTEGER", NULL, NULL, 220);
+func_mysql_fetch_array($link, $engine, "INTEGER UNSIGNED", 4294967295, "4294967295", 230);
+func_mysql_fetch_array($link, $engine, "INTEGER UNSIGNED", NULL, NULL, 240);
+
+// func_mysql_fetch_array($link, $engine, "BIGINT", -9223372036854775808, "-9.22337e+018", 250, "/-9\.22337e\+[0]?18/iu");
+func_mysql_fetch_array($link, $engine, "BIGINT", NULL, NULL, 260);
+// func_mysql_fetch_array($link, $engine, "BIGINT UNSIGNED", 18446744073709551615, "1.84467e+019", 270, "/1\.84467e\+[0]?19/iu");
+func_mysql_fetch_array($link, $engine, "BIGINT UNSIGNED", NULL, NULL, 280);
+
+func_mysql_fetch_array($link, $engine, "FLOAT", -9223372036854775808 - 1.1, "-9.22337e+18", 290, "/-9\.22337e\+?[0]?18/iu");
+func_mysql_fetch_array($link, $engine, "FLOAT", NULL, NULL, 300);
+func_mysql_fetch_array($link, $engine, "FLOAT UNSIGNED", 18446744073709551615 + 1.1, "1.84467e+19", 310, "/1\.84467e\+?[0]?19/iu");
+func_mysql_fetch_array($link, $engine, "FLOAT UNSIGNED ", NULL, NULL, 320);
+
+func_mysql_fetch_array($link, $engine, "DOUBLE(10,2)", -99999999.99, "-99999999.99", 330);
+func_mysql_fetch_array($link, $engine, "DOUBLE(10,2)", NULL, NULL, 340);
+func_mysql_fetch_array($link, $engine, "DOUBLE(10,2) UNSIGNED", 99999999.99, "99999999.99", 350);
+func_mysql_fetch_array($link, $engine, "DOUBLE(10,2) UNSIGNED", NULL, NULL, 360);
+
+func_mysql_fetch_array($link, $engine, "DECIMAL(10,2)", -99999999.99, "-99999999.99", 370);
+func_mysql_fetch_array($link, $engine, "DECIMAL(10,2)", NULL, NULL, 380);
+func_mysql_fetch_array($link, $engine, "DECIMAL(10,2)", 99999999.99, "99999999.99", 390);
+func_mysql_fetch_array($link, $engine, "DECIMAL(10,2)", NULL, NULL, 400);
+
+// don't care about date() strict TZ warnings...
+func_mysql_fetch_array($link, $engine, "DATE", @date('Y-m-d'), @date('Y-m-d'), 410);
+func_mysql_fetch_array($link, $engine, "DATE NOT NULL", @date('Y-m-d'), @date('Y-m-d'), 420);
+func_mysql_fetch_array($link, $engine, "DATE", NULL, NULL, 430);
+
+func_mysql_fetch_array($link, $engine, "DATETIME", @date('Y-m-d H:i:s'), @date('Y-m-d H:i:s'), 440);
+func_mysql_fetch_array($link, $engine, "DATETIME NOT NULL", @date('Y-m-d H:i:s'), @date('Y-m-d H:i:s'), 450);
+func_mysql_fetch_array($link, $engine, "DATETIME", NULL, NULL, 460);
+
+func_mysql_fetch_array($link, $engine, "TIMESTAMP", @date('Y-m-d H:i:s'), @date('Y-m-d H:i:s'), 470);
+
+func_mysql_fetch_array($link, $engine, "TIME", @date('H:i:s'), @date('H:i:s'), 480);
+func_mysql_fetch_array($link, $engine, "TIME NOT NULL", @date('H:i:s'), @date('H:i:s'), 490);
+func_mysql_fetch_array($link, $engine, "TIME", NULL, NULL, 500);
+
+func_mysql_fetch_array($link, $engine, "YEAR", @date('Y'), @date('Y'), 510);
+func_mysql_fetch_array($link, $engine, "YEAR NOT NULL", @date('Y'), @date('Y'), 520);
+func_mysql_fetch_array($link, $engine, "YEAR", NULL, NULL, 530);
+
+$string255 = func_mysql_fetch_array_make_string(255);
+
+func_mysql_fetch_array($link, $engine, "CHAR(1)", "a", "a", 540);
+func_mysql_fetch_array($link, $engine, "CHAR(255)", $string255,  $string255, 550);
+func_mysql_fetch_array($link, $engine, "CHAR(1) NOT NULL", "a", "a", 560);
+func_mysql_fetch_array($link, $engine, "CHAR(1)", NULL, NULL, 570);
+
+$string65k = func_mysql_fetch_array_make_string(65400);
+
+func_mysql_fetch_array($link, $engine, "VARCHAR(1)", "a", "a", 580);
+func_mysql_fetch_array($link, $engine, "VARCHAR(255)", $string255, $string255, 590);
+func_mysql_fetch_array($link, $engine, "VARCHAR(65400)", $string65k, $string65k, 600);
+func_mysql_fetch_array($link, $engine, "VARCHAR(1) NOT NULL", "a", "a", 610);
+func_mysql_fetch_array($link, $engine, "VARCHAR(1)", NULL, NULL, 620);
+
+func_mysql_fetch_array($link, $engine, "BINARY(1)", "a", "a", 630, null , true);
+func_mysql_fetch_array($link, $engine, "BINARY(1) NOT NULL", "b", "b", 650, null , true);
+func_mysql_fetch_array($link, $engine, "BINARY(1)", NULL, NULL, 660, null , true);
+
+func_mysql_fetch_array($link, $engine, "VARBINARY(1)", "a", "a", 670, null , true);
+func_mysql_fetch_array($link, $engine, "VARBINARY(1) NOT NULL", "b", "b", 690, null , true);
+func_mysql_fetch_array($link, $engine, "VARBINARY(1)", NULL, NULL, 700, null , true);
+
+func_mysql_fetch_array($link, $engine, "TINYBLOB", "a", "a", 710, null , true);
+func_mysql_fetch_array($link, $engine, "TINYBLOB NOT NULL", "b", "b", 730, null , true);
+func_mysql_fetch_array($link, $engine, "TINYBLOB", NULL, NULL, 740, null , true);
+
+func_mysql_fetch_array($link, $engine, "TINYTEXT", "a", "a", 750);
+func_mysql_fetch_array($link, $engine, "TINYTEXT NOT NULL", "a", "a", 760);
+func_mysql_fetch_array($link, $engine, "TINYTEXT", NULL, NULL, 770);
+
+func_mysql_fetch_array($link, $engine, "BLOB", "a", "a", 780, null , true);
+func_mysql_fetch_array($link, $engine, "BLOB", NULL, NULL, 790, null , true);
+
+func_mysql_fetch_array($link, $engine, "TEXT", "a", "a", 800);
+func_mysql_fetch_array($link, $engine, "TEXT", NULL, NULL, 820);
+
+func_mysql_fetch_array($link, $engine, "MEDIUMBLOB", "a", "a", 830, null , true);
+func_mysql_fetch_array($link, $engine, "MEDIUMBLOB", NULL, NULL, 850, null , true);
+
+func_mysql_fetch_array($link, $engine, "MEDIUMTEXT", "a", "a", 860);
+func_mysql_fetch_array($link, $engine, "MEDIUMTEXT", NULL, NULL, 880);
+
+func_mysql_fetch_array($link, $engine, "LONGBLOB", "a", "a", 890, null , true);
+func_mysql_fetch_array($link, $engine, "LONGBLOB", NULL, NULL, 910, null , true);
+
+func_mysql_fetch_array($link, $engine, "ENUM('a', 'b')", "a", "a", 920);
+func_mysql_fetch_array($link, $engine, "ENUM('a', 'b')", NULL, NULL, 930);
+
+func_mysql_fetch_array($link, $engine, "SET('a', 'b')", "a", "a", 940);
+func_mysql_fetch_array($link, $engine, "SET('a', 'b')", NULL, NULL, 950);
+
+mysql_close($link);
+
+if (false !== ($tmp = mysql_fetch_array($res, MYSQL_ASSOC)))
+printf("[015] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "a"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[006]
+array(2) {
+  [0]=>
+  %unicode|string%(1) "2"
+  [1]=>
+  %unicode|string%(1) "b"
+}
+[007]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "3"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "3"
+  [1]=>
+  %unicode|string%(1) "c"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "c"
+}
+[008]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "d"
+}
+[009]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "5"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "5"
+  [1]=>
+  %unicode|string%(1) "e"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "e"
+}
+[011]
+array(11) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [%u|b%"a"]=>
+  %unicode|string%(1) "2"
+  [1]=>
+  %unicode|string%(1) "2"
+  [2]=>
+  %unicode|string%(1) "3"
+  [%u|b%"c"]=>
+  %unicode|string%(1) "3"
+  [3]=>
+  %unicode|string%(1) "4"
+  [%u|b%"C"]=>
+  %unicode|string%(1) "4"
+  [4]=>
+  NULL
+  [%u|b%"d"]=>
+  NULL
+  [5]=>
+  %unicode|string%(1) "1"
+  [%u|b%"e"]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysql_fetch_array(): The result type should be either MYSQL_NUM, MYSQL_ASSOC or MYSQL_BOTH in %s on line %d
+
+Warning: mysql_fetch_array(): %d is not a valid MySQL result resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_fetch_assoc.phpt
@@ -0,0 +1,103 @@
+--TEST--
+mysql_fetch_assoc()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+// Note: no SQL type tests, internally the same function gets used as for mysql_fetch_array() which does a lot of SQL type test
+
+if (!is_null($tmp = @mysql_fetch_assoc()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_fetch_assoc($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 1", $link)) {
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+print "[005]\n";
+var_dump(mysql_fetch_assoc($res));
+
+print "[006]\n";
+var_dump(mysql_fetch_assoc($res));
+
+mysql_free_result($res);
+
+if (!$res = mysql_query("SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e", $link)) {
+	printf("[007] Cannot run query, [%d] %s\n", mysql_errno($link), $mysql_error($link));
+}
+print "[008]\n";
+var_dump(mysql_fetch_assoc($res));
+
+mysql_free_result($res);
+
+if (false !== ($tmp = mysql_fetch_assoc($res)))
+	printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_close($link);
+
+include('table.inc');
+if (!$res = mysql_query("SELECT id, label, id AS _id, CONCAT(label, 'a') _label, NULL as _foo FROM test _test ORDER BY id ASC LIMIT 1", $link)) {
+	printf("[009] [%d] %s\n", mysql_errno($link), $mysql_error($link));
+}
+print "[010]\n";
+var_dump(mysql_fetch_assoc($res));
+mysql_free_result($res);
+
+mysql_close($link);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[006]
+bool(false)
+[008]
+array(5) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "2"
+  [%u|b%"c"]=>
+  %unicode|string%(1) "3"
+  [%u|b%"C"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"d"]=>
+  NULL
+  [%u|b%"e"]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysql_fetch_assoc(): %d is not a valid MySQL result resource in %s on line %d
+[010]
+array(5) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+  [%u|b%"_id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"_label"]=>
+  %unicode|string%(2) "aa"
+  [%u|b%"_foo"]=>
+  NULL
+}
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_fetch_field.phpt
@@ -0,0 +1,277 @@
+--TEST--
+mysql_fetch_field()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	include "connect.inc";
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// Note: no SQL type tests, internally the same function gets used as for mysql_fetch_array() which does a lot of SQL type test
+	if (!is_null($tmp = @mysql_fetch_field()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysql_fetch_field($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$version = mysql_get_server_info($link);
+	if (!preg_match('@(\d+)\.(\d+)\.(\d+)@ism', $version, $matches))
+		printf("[003] Cannot get server version\n");
+	$version = ($matches[1] * 100) + ($matches[2] * 10) + $matches[3];
+
+	if (!$res = mysql_query("SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1", $link)) {
+		printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+
+	while ($tmp = mysql_fetch_field($res))
+		var_dump($tmp);
+	var_dump($tmp);
+
+	mysql_free_result($res);
+
+	if (!$res = mysql_query("SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1", $link)) {
+		printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+	if (false !== ($tmp = mysql_fetch_field($res, PHP_INT_MAX - 1)))
+		printf("[006] Expecting boolean/false got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	mysql_free_result($res);
+
+	if (false !== ($tmp = mysql_fetch_field($res)))
+		printf("[007] Expecting boolean/false, got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	$types = array(
+		'BIT'               => array(1, 'int'),
+		'TINYINT'           => array(1, 'int'),
+		'BOOL'              => array('true', 'int'),
+		'BOOL'              => array(1, 'int'),
+		'SMALLINT'          => array(32767, 'int'),
+		'MEDIUMINT'         => array(8388607, 'int'),
+		'INT'               => array(100, 'int'),
+		'BIGINT'            => array(100, 'int'),
+		'FLOAT'             => array(100, 'real'),
+		'DOUBLE'            => array(100, 'real'),
+		'DECIMAL'           => array(100, 'real'),
+		'DATE'              => array(@date('Y-m-d'), 'date'),
+		'DATETIME'          => array(@date('Y-m-d H:i:s'), 'datetime'),
+		'TIMESTAMP'         => array(@date('Y-m-d H:i:s'), 'timestamp'),
+		'TIME'              => array(@date('H:i:s'), 'time'),
+		'YEAR'              => array(@date('Y'), 'year'),
+		'CHAR(1)'           => array('a', 'string'),
+		'VARCHAR(1)'        => array('a', 'string'),
+		'BINARY(1)'         => array('a', 'string'),
+		'VARBINARY(1)'      => array('a', 'string'),
+		'TINYBLOB'          => array('a', 'blob'),
+		'TINYTEXT'          => array('a', 'blob'),
+		'BLOB'              => array('a', 'blob'),
+		'TEXT'              => array('a', 'blob'),
+		'MEDIUMBLOB'        => array('a', 'blob'),
+		'MEDIUMTEXT'        => array('a', 'blob'),
+		'LONGBLOB'          => array('a', 'blob'),
+		'LONGTEXT'          => array('a', 'blob'),
+		'ENUM("a", "b")'    => array('a', 'string'), /* !!! */
+		'SET("a", "b")'     => array('a', 'string'), /* !!! */
+	);
+
+	foreach ($types as $type_name => $type_desc) {
+		if (!mysql_query("DROP TABLE IF EXISTS test", $link))
+			printf("[008/%s] [%d] %s\n", $type_name, mysql_errno($link), mysql_error($link));
+		if (!mysql_query(sprintf("CREATE TABLE test(id INT, label %s) ENGINE = %s", $type_name, $engine), $link)) {
+			// server and/or engine might not support the data type
+			continue;
+		}
+
+		if (is_string($type_desc[0]))
+			$insert = sprintf("INSERT INTO test(id, label) VALUES (1, '%s')", $type_desc[0]);
+		else
+			$insert = sprintf("INSERT INTO test(id, label) VALUES (1, %s)", $type_desc[0]);
+
+		if (!mysql_query($insert, $link)) {
+			if (1366 == mysql_errno($link)) {
+				/* Strict SQL mode - 1366, Incorrect integer value: 'true' for column 'label' at row 1 */
+				continue;
+			}
+			printf("[009/%s] [%d] %s\n", $type_name, mysql_errno($link), mysql_error($link));
+			continue;
+		}
+		if (!$res = mysql_query("SELECT id, label FROM test", $link)) {
+			printf("[010/%s] [%d] %s\n", $type_name, mysql_errno($link), mysql_error($link));
+			continue;
+		}
+		if (!$tmp = mysql_fetch_field($res, 1)) {
+			printf("[011/%s] [%d] %s\n", $type_name, mysql_errno($link), mysql_error($link));
+		}
+
+		if ($type_desc[1] != $tmp->type) {
+			printf("[012/%s] Expecting type '%s' got '%s'\n", $type_name, $type_desc[1], $tmp->type);
+		}
+		mysql_free_result($res);
+	}
+
+	if (!mysql_query("DROP TABLE IF EXISTS test", $link))
+		printf("[013] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (!mysql_query("CREATE TABLE test(id INT DEFAULT 1)"))
+		printf("[014] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (!mysql_query("INSERT INTO test(id) VALUES (2)"))
+		printf("[015] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (!$res = mysql_query("SELECT id FROM test", $link)) {
+		printf("[016] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+
+	var_dump(mysql_fetch_field($res));
+	mysql_free_result($res);
+
+	if (!$res = mysql_query("SELECT id FROM test", $link)) {
+		printf("[017] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+	$res = mysql_list_fields($db, 'test');
+	$found = false;
+	while ($tmp = mysql_fetch_field($res)) {
+		if ($tmp->name == 'id') {
+			printf("Fetch field from mysql_list_fields result set.\n");
+			$found = true;
+			var_dump($tmp);
+		}
+	}
+	if (!$found)
+		printf("[018] mysqli_list_fields result set processing has failed.\n");
+
+	mysql_free_result($res);
+
+	mysql_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "ID"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"not_null"]=>
+  int(1)
+  [%u|b%"primary_key"]=>
+  int(1)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(1)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(3) "int"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"not_null"]=>
+  int(0)
+  [%u|b%"primary_key"]=>
+  int(0)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(0)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(6) "string"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+bool(false)
+
+Warning: mysql_fetch_field(): Bad field offset in %s on line %d
+
+Warning: mysql_fetch_field(): %d is not a valid MySQL result resource in %s on line %d
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"not_null"]=>
+  int(0)
+  [%u|b%"primary_key"]=>
+  int(0)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(1)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(3) "int"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+Fetch field from mysql_list_fields result set.
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"not_null"]=>
+  int(0)
+  [%u|b%"primary_key"]=>
+  int(0)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(1)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(3) "int"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_fetch_lengths.phpt
@@ -0,0 +1,52 @@
+--TEST--
+mysql_fetch_lengths()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_fetch_lengths()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_fetch_lengths($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 1", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+while ($row = mysql_fetch_assoc($res))
+	var_dump(mysql_fetch_lengths($res));
+var_dump(mysql_fetch_lengths($res));
+
+mysql_free_result($res);
+
+var_dump(mysql_fetch_lengths($res));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+array(2) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(1)
+}
+bool(false)
+
+Warning: mysql_fetch_lengths(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_fetch_object.phpt
@@ -0,0 +1,152 @@
+--TEST--
+mysql_fetch_object()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_fetch_object()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = @mysql_fetch_object($link)))
+	printf("[002] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+var_dump(mysql_fetch_object($res));
+
+class mysql_fetch_object_test {
+
+	public $a = null;
+	public $b = null;
+
+	public function toString() {
+		var_dump($this);
+	}
+}
+
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_test'));
+
+class mysql_fetch_object_construct extends mysql_fetch_object_test {
+
+	public function __construct($a, $b) {
+		$this->a = $a;
+		$this->b = $b;
+	}
+
+}
+
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_construct', null));
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_construct', array('a')));
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_construct', array('a', 'b')));
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_construct', array('a', 'b', 'c')));
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_construct', "no array and not null"));
+var_dump(mysql_fetch_object($res));
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_construct', array('a', 'b')));
+
+class mysql_fetch_object_private_construct {
+	private function __construct($a, $b) {
+		var_dump($a);
+	}
+}
+var_dump(mysql_fetch_object($res, 'mysql_fetch_object_private_construct', array('a', 'b')));
+
+mysql_free_result($res);
+
+if (!$res = mysql_query("SELECT id AS ID, label FROM test AS TEST", $link)) {
+	printf("[009] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+mysql_free_result($res);
+
+var_dump(mysql_fetch_object($res));
+
+// Fatal error, script execution will end
+var_dump(mysql_fetch_object($res, 'this_class_does_not_exist'));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+object(stdClass)#%d (2) {
+  [%u|b%"ID"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+object(mysql_fetch_object_test)#%d (4) {
+  [%u|b%"a"]=>
+  NULL
+  [%u|b%"b"]=>
+  NULL
+  [%u|b%"ID"]=>
+  %unicode|string%(1) "2"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "b"
+}
+
+Warning: Missing argument 1 for mysql_fetch_object_construct::__construct() in %s on line %d
+
+Warning: Missing argument 2 for mysql_fetch_object_construct::__construct() in %s on line %d
+
+Notice: Undefined variable: a in %s on line %d
+
+Notice: Undefined variable: b in %s on line %d
+object(mysql_fetch_object_construct)#%d (4) {
+  [%u|b%"a"]=>
+  NULL
+  [%u|b%"b"]=>
+  NULL
+  [%u|b%"ID"]=>
+  %unicode|string%(1) "3"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "c"
+}
+
+Warning: Missing argument 2 for mysql_fetch_object_construct::__construct() in %s on line %d
+
+Notice: Undefined variable: b in %s on line %d
+object(mysql_fetch_object_construct)#%d (4) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "a"
+  [%u|b%"b"]=>
+  NULL
+  [%u|b%"ID"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "d"
+}
+object(mysql_fetch_object_construct)#%d (4) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "a"
+  [%u|b%"b"]=>
+  %unicode|string%(1) "b"
+  [%u|b%"ID"]=>
+  %unicode|string%(1) "5"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "e"
+}
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+
+Warning: mysql_fetch_object(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+
+Fatal error: Class 'this_class_does_not_exist' not found in %s on line %d
--- /dev/null
+++ b/ext/mysql/tests/mysql_fetch_row.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysql_fetch_row()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_fetch_row()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_fetch_row($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 1", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+print "[004]\n";
+var_dump(mysql_fetch_row($res));
+
+print "[005]\n";
+var_dump(mysql_fetch_row($res));
+
+mysql_free_result($res);
+
+var_dump(mysql_fetch_row($res));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+[004]
+array(2) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "a"
+}
+[005]
+bool(false)
+
+Warning: mysql_fetch_row(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_field_flags.phpt
@@ -0,0 +1,155 @@
+--TEST--
+mysql_field_flags()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_field_flags()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_field_flags($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 2", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (NULL !== ($tmp = mysql_field_flags($res)))
+	printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_field_flags($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_string($tmp = mysql_field_flags($res, 0)) || empty($tmp))
+	printf("[006] Expecting non empty string, got %s/%s\n", gettype($tmp), $tmp);
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp)) {
+	printf("[007] Check the unicode support!\n");
+	var_inspect($tmp);
+}
+
+if (false !== ($tmp = mysql_field_flags($res, 2)))
+	printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+$version = mysql_get_server_info($link);
+if (!preg_match('@(\d+)\.(\d+)\.(\d+)@ism', $version, $matches))
+	printf("[009] Cannot get server version\n");
+$version = ($matches[1] * 100) + ($matches[2] * 10) + $matches[3];
+
+$tables = array(
+	'label INT, UNIQUE KEY (label)'                         =>  array(
+								array('label', '1'),
+								'label' => array(($version < 500) ? 'multiple_key' : 'unique_key')
+								),
+	'labela INT, label2 CHAR(1), KEY keyname (labela, label2)'      =>  array(
+								array('labela, label2', "1, 'a'"),
+								'labela' => array('multiple_key'),
+								),
+	'label1 BLOB'                                           =>  array(
+								array('label1', "'blob'"),
+								'label1' => array('blob', 'binary'),
+								),
+	'label1 INT UNSIGNED'                                   =>  array(
+								array('label1', '100'),
+								'label1' => array('unsigned'),
+								),
+	'label1 INT UNSIGNED NOT NULL AUTO INCREMENT'           =>  array(
+								array('label1', '100'),
+								'label1' => array('auto_increment',
+										'unsigned'),
+								),
+	'label1 ENUM("a", "b")'                                 =>  array(
+								array('label1', "'a'"),
+								'label1' => array('enum'),
+								),
+	'label1 SET("a", "b")'                                  =>  array(
+								array('label1', "'a'"),
+								'label1' => array('set'),
+								),
+	'label1 TIMESTAMP'                                      =>  array(
+								array('label1', sprintf("'%s'", @date("Y-m-d H:i:s"))),
+								'label1' => array(
+										'timestamp',
+										'binary',
+										'not_null'),
+								),
+);
+
+if ($version < 560) {
+	$tables['label1 TIMESTAMP']['label1'][] = 'zerofill';
+	$tables['label1 TIMESTAMP']['label1'][] = 'unsigned';
+}
+
+
+foreach ($tables as $columns => $expected) {
+	if (!mysql_query("DROP TABLE IF EXISTS test", $link)) {
+		printf("[010/%s] [%d] %s\n", $columns, mysql_errno($link), mysql_error($link));
+		continue;
+	}
+	$sql = sprintf("CREATE TABLE test(id INT, %s) ENGINE = %s", $columns, $engine);
+		if (!@mysql_query($sql, $link)) {
+		// server or engine might not support this
+		continue;
+	}
+
+	reset($expected);
+	list($k, $values) = each($expected);
+	$sql = sprintf("INSERT INTO test(id, %s) VALUES (1, %s)", $values[0], $values[1]);
+	if (!mysql_query($sql, $link)) {
+		printf("[011/%s] '%s', [%d] %s\n", $columns, $sql, mysql_errno($link), mysql_error($link));
+		continue;
+	}
+
+	if (!$res = mysql_query(sprintf("SELECT id, %s FROM test", $values[0]), $link)) {
+		printf("[012/%s] [%d] %s\n", $columns, mysql_errno($link), mysql_error($link));
+		continue;
+	}
+
+	$i = 1;
+	while (list($field, $flags) = each($expected)) {
+		$tmp = mysql_field_flags($res, $i++);
+
+		foreach ($flags as $k => $flag) {
+		if (!preg_match(sprintf('@\s*%s\s*@ismU', $flag), $tmp)) {
+			printf("[013/%s] Field '%s', flag '%s' not found, [%d] %s\n", $columns, $field, $flag, mysql_errno($link), mysql_error($link));
+		}
+	}
+		foreach ($flags as $k => $flag) {
+			$tmp = preg_replace(sprintf('@\s*%s\s*@ismU', $flag), '', $tmp);
+		}
+		if ('' != $tmp)
+			printf("[014/%s] Field '%s', unexpected flags '%s' found, [%d] %s\n", $columns, $field, $tmp, mysql_errno($link), mysql_error($link));
+	}
+	mysql_free_result($res);
+}
+
+var_dump(mysql_field_flags($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_field_flags() expects exactly 2 parameters, 1 given in %s on line %d
+
+Warning: mysql_field_flags(): Field -1 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_flags(): Field 2 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_flags(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_field_len.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysql_field_len()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_field_len()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_field_len($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 2", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (NULL !== ($tmp = mysql_field_len($res)))
+printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_field_len($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_int($tmp = mysql_field_len($res, 0)) || empty($tmp))
+	printf("[006] Expecting non empty integer, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_field_len($res, 2)))
+	printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+var_dump(mysql_field_len($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_field_len() expects exactly 2 parameters, 1 given in %s on line %d
+
+Warning: mysql_field_len(): Field -1 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_len(): Field 2 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_len(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_field_name.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysql_field_name()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_field_name()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_field_name($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 2", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (NULL !== ($tmp = mysql_field_name($res)))
+	printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_field_name($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(mysql_field_name($res, 0));
+
+if (false !== ($tmp = mysql_field_name($res, 2)))
+	printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+var_dump(mysql_field_name($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_field_name() expects exactly 2 parameters, 1 given in %s on line %d
+
+Warning: mysql_field_name(): Field -1 is invalid for MySQL result index %d in %s on line %d
+%unicode|string%(2) "id"
+
+Warning: mysql_field_name(): Field 2 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_name(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_field_seek.phpt
@@ -0,0 +1,142 @@
+--TEST--
+mysql_field_seek()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_field_seek()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_null($tmp = @mysql_field_seek($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 1", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+var_dump(mysql_field_seek($res, -1));
+var_dump(mysql_fetch_field($res));
+var_dump(mysql_field_seek($res, 0));
+var_dump(mysql_fetch_field($res));
+var_dump(mysql_field_seek($res, 1));
+var_dump(mysql_fetch_field($res));
+var_dump(mysql_field_seek($res, 2));
+var_dump(mysql_fetch_field($res));
+
+mysql_free_result($res);
+
+var_dump(mysql_field_seek($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_field_seek(): Field -1 is invalid for MySQL result index %d in %s on line %d
+bool(false)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"not_null"]=>
+  int(1)
+  [%u|b%"primary_key"]=>
+  int(1)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(1)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(3) "int"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+bool(true)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"not_null"]=>
+  int(1)
+  [%u|b%"primary_key"]=>
+  int(1)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(1)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(3) "int"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+bool(true)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"not_null"]=>
+  int(0)
+  [%u|b%"primary_key"]=>
+  int(0)
+  [%u|b%"multiple_key"]=>
+  int(0)
+  [%u|b%"unique_key"]=>
+  int(0)
+  [%u|b%"numeric"]=>
+  int(0)
+  [%u|b%"blob"]=>
+  int(0)
+  [%u|b%"type"]=>
+  %unicode|string%(6) "string"
+  [%u|b%"unsigned"]=>
+  int(0)
+  [%u|b%"zerofill"]=>
+  int(0)
+}
+
+Warning: mysql_field_seek(): Field %d is invalid for MySQL result index %d in %s on line %d
+bool(false)
+bool(false)
+
+Warning: mysql_field_seek(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_field_table.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysql_field_table()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_field_table()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_field_table($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 2", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (NULL !== ($tmp = mysql_field_table($res)))
+	printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_field_table($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(mysql_field_table($res, 0));
+
+if (false !== ($tmp = mysql_field_table($res, 2)))
+	printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+var_dump(mysql_field_table($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_field_table() expects exactly 2 parameters, 1 given in %s on line %d
+
+Warning: mysql_field_table(): Field -1 is invalid for MySQL result index %d in %s on line %d
+%unicode|string%(4) "test"
+
+Warning: mysql_field_table(): Field 2 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_table(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_field_type.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysql_field_type()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_field_type()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_field_type($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 2", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (NULL !== ($tmp = mysql_field_type($res)))
+	printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_field_type($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(mysql_field_type($res, 0));
+
+if (false !== ($tmp = mysql_field_type($res, 2)))
+	printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+var_dump(mysql_field_type($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_field_type() expects exactly 2 parameters, 1 given in %s on line %d
+
+Warning: mysql_field_type(): Field -1 is invalid for MySQL result index %d in %s on line %d
+%unicode|string%(3) "int"
+
+Warning: mysql_field_type(): Field 2 is invalid for MySQL result index %d in %s on line %d
+
+Warning: mysql_field_type(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_free_result.phpt
@@ -0,0 +1,51 @@
+--TEST--
+mysql_free_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_free_result()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_free_result($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id FROM test ORDER BY id LIMIT 1", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+var_dump(mysql_free_result($res));
+var_dump(mysql_free_result($res));
+
+if ($tmp = sys_get_temp_dir()) {
+	$tmpname = tempnam($tmp, 'free_result');
+	if ($fp = fopen($tmpname, 'w')) {
+		if (false !== ($tmp = @mysql_free_result($fp)))
+			printf("[004] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+		fclose($fp);
+		@unlink($tmpname);
+	}
+}
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+
+Warning: mysql_free_result(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_get_client_info.phpt
@@ -0,0 +1,23 @@
+--TEST--
+mysql_get_client_info()
+--SKIPIF--
+<?php require_once('skipif.inc'); ?>
+--FILE--
+<?php
+include "connect.inc";
+if (!is_string($info = mysql_get_client_info()) || ('' === $info))
+	printf("[001] Expecting string/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($info)) {
+	printf("[002] Expecting Unicode!\n");
+	var_inspect($info);
+}
+
+if (!is_null($tmp = @mysql_get_client_info("too many arguments"))) {
+	printf("[003] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+}
+
+print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_get_host_info.phpt
@@ -0,0 +1,44 @@
+--TEST--
+mysql_get_host_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+if (NULL !== ($tmp = @mysql_get_host_info(NULL)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require "table.inc";
+if (!is_string($info = mysql_get_host_info($link)) || ('' === $info))
+	printf("[003] Expecting string/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+$def_info = mysql_get_host_info();
+if ($def_info !== $info) {
+	printf("[004] Host info for the default link and the specified link differ, [%d] %s\n",
+		mysql_errno(), mysql_error());
+
+	var_dump($def_info);
+	var_dump($info);
+}
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($info)) {
+	printf("[005] Expecting Unicode error message!\n");
+	var_inspect($info);
+}
+
+if (!is_null($tmp = @mysql_get_host_info($link, "too many arguments"))) {
+	printf("[006] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+}
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_get_proto_info.phpt
@@ -0,0 +1,34 @@
+--TEST--
+mysql_get_proto_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+if (NULL !== ($tmp = @mysql_get_proto_info(NULL)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require "table.inc";
+if (!is_int($info = mysql_get_proto_info($link)) || (0 === $info))
+	printf("[003] Expecting int/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+if (!is_int($info2 = mysql_get_proto_info()) || (0 === $info2))
+	printf("[004] Expecting int/any_non_empty, got %s/%s\n", gettype($info2), $info2);
+
+assert($info === $info2);
+
+if (NULL !== ($tmp = @mysql_get_proto_info('too many', 'arguments')))
+	printf("[005] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_get_server_info.phpt
@@ -0,0 +1,39 @@
+--TEST--
+mysql_get_server_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+if (null !== ($tmp = @mysql_get_server_info(NULL)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require "table.inc";
+if (!is_string($info = mysql_get_server_info($link)) || ('' === $info))
+	printf("[003] Expecting string/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+$def_info = mysql_get_server_info();
+if ($def_info !== $info) {
+	printf("[004] Server info for the default link and the specified link differ, [%d] %s\n",
+		mysql_errno(), mysql_error());
+
+	var_dump($def_info);
+	var_dump($info);
+}
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($info)) {
+	printf("[005] Expecting Unicode error message!\n");
+	var_inspect($info);
+}
+
+if (NULL !== ($tmp = @mysql_get_server_info('too many', 'just too many')))
+	printf("[006] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_info.phpt
@@ -0,0 +1,73 @@
+--TEST--
+mysql_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+if (false !== ($tmp = @mysql_info()))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_info(NULL)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require "table.inc";
+if (!$res = mysql_query("INSERT INTO test(id, label) VALUES (100, 'a')", $link))
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (false !== ($tmp = mysql_info($link)))
+	printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$res = mysql_query("INSERT INTO test(id, label) VALUES (101, 'a'), (102, 'b')", $link))
+	printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!is_string($tmp = mysql_info($link)) || ('' == $tmp))
+	printf("[006] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$res = mysql_query('INSERT INTO test(id, label) SELECT id + 200, label FROM test', $link))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!is_string($tmp = mysql_info($link)) || ('' == $tmp))
+	printf("[008] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$res = mysql_query('ALTER TABLE test MODIFY label CHAR(2)', $link))
+	printf("[009] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!is_string($tmp = mysql_info($link)) || ('' == $tmp))
+	printf("[010] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$res = mysql_query("UPDATE test SET label = 'b' WHERE id >= 100", $link))
+	printf("[011] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!is_string($tmp = mysql_info($link)) || ('' == $tmp))
+	printf("[012] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp)) {
+	printf("[013] Expecting Unicode!\n");
+	var_inspect($info);
+}
+
+if (!is_string($def_tmp = mysql_info()) || ('' == $def_tmp))
+	printf("[014] Expecting string/any_non_empty, got %s/%s\n", gettype($def_tmp), $def_tmp);
+
+if ($def_tmp !== $tmp) {
+	printf("[015] Results differ for default link and specified link, [%d] %s\n",
+		mysql_errno(), mysql_error());
+	var_inspect($tmp);
+	var_inspect($def_tmp);
+}
+
+// NOTE: no LOAD DATA INFILE test
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_insert_id.phpt
@@ -0,0 +1,71 @@
+--TEST--
+mysql_insert_id()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+include 'setupdefault.inc';
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (0 !== ($tmp = @mysql_insert_id()))
+	printf("[001] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_insert_id($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_null($tmp = @mysql_insert_id($link, 'too many args')))
+	printf("[002a] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (0 !== ($tmp = mysql_insert_id($link)))
+	printf("[003] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 1", $link)) {
+	printf("[004] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+if (0 !== ($tmp = mysql_insert_id($link)))
+	printf("[005] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+mysql_free_result($res);
+
+// no auto_increment column
+if (!$res = mysql_query("INSERT INTO test(id, label) VALUES (100, 'a')", $link)) {
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+if (0 !== ($tmp = mysql_insert_id($link)))
+	printf("[007] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$res = mysql_query("ALTER TABLE test MODIFY id INT NOT NULL AUTO_INCREMENT", $link)) {
+	printf("[008] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+if (!$res = mysql_query("INSERT INTO test(label) VALUES ('a')", $link)) {
+	printf("[009] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+if (0 === ($tmp = mysql_insert_id($link)))
+	printf("[010] Expecting int/not zero, got %s/%s\n", gettype($tmp), $tmp);
+
+if ($tmp !== ($tmp2 = mysql_insert_id()))
+	printf("[011] Expecting %s/%s, got %s/%s\n",
+		gettype($tmp), $tmp,
+		gettype($tmp2), $tmp2);
+
+mysql_close($link);
+
+var_dump(mysql_insert_id($link));
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_insert_id(): %d is not a valid MySQL-Link resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_list_dbs.phpt
@@ -0,0 +1,54 @@
+--TEST--
+mysql_list_dbs()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_list_dbs(NULL)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_list_dbs($link, $link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (!$res = @mysql_list_dbs($link))
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$num = mysql_num_rows($res))
+	printf("[004] Empty database list? [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+$row = mysql_fetch_array($res, MYSQL_NUM);
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($row[0])) {
+	printf("[005] Check for unicode support\n");
+	var_inspect($row);
+}
+
+mysql_free_result($res);
+
+if (!$res2 = @mysql_list_dbs())
+	printf("[006] [%d] %s\n", mysql_errno(), mysql_error());
+
+$row2 = mysql_fetch_array($res2, MYSQL_NUM);
+mysql_free_result($res2);
+
+assert($row === $row2);
+
+mysql_close($link);
+
+print "done!\n";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_list_fields.phpt
@@ -0,0 +1,79 @@
+--TEST--
+mysql_list_fields()
+--SKIPIF--
+<?php
+require_once 'skipif.inc';
+require_once 'skipifconnectfailure.inc';
+?>
+--FILE--
+<?php
+require_once 'connect.inc';
+
+$tmp    = NULL;
+$link   = NULL;
+
+require 'table.inc';
+
+if (!$res = mysql_list_fields($db, 'test', $link))
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (2 !== ($num = mysql_num_fields($res)))
+	printf("[004] Expecting two fields from 'test', got %d. [%d] %s\n", $num, mysql_errno($link), mysql_error($link));
+
+mysql_free_result($res);
+
+if (!mysql_query("DROP TABLE IF EXISTS test2", $link))
+	printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$res = @mysql_list_fields($db, 'test2', $link))
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$res = mysql_list_fields($db, 'test', $link))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (2 !== ($num = mysql_num_fields($res)))
+	printf("[008] Expecting 2 fields from 'test', got %d. [%d] %s\n", $num, mysql_errno($link), mysql_error($link));
+
+var_dump(mysql_fetch_assoc($res));
+for ($field_offset = 0; $field_offset < mysql_num_fields($res); $field_offset++) {
+	printf("Field Offset %d\n", $field_offset);
+	printf("mysql_field_flags(): %s\n", mysql_field_flags($res, $field_offset));
+	printf("mysql_field_len(): %s\n", mysql_field_len($res, $field_offset));
+	printf("mysql_field_name(): %s\n", mysql_field_name($res, $field_offset));
+	printf("mysql_field_type(): %s\n", mysql_field_type($res, $field_offset));
+}
+
+mysql_free_result($res);
+mysql_close($link);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once 'connect.inc';
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[c001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+if (!mysql_query("DROP TABLE IF EXISTS test", $link))
+	printf("[c002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysql_query("DROP TABLE IF EXISTS test2", $link))
+	printf("[c002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysql_close($link);
+?>
+--EXPECTF--
+[006] [%d] %s
+bool(false)
+Field Offset 0
+mysql_field_flags()%s
+mysql_field_len(): 11
+mysql_field_name(): id
+mysql_field_type(): int
+Field Offset 1
+mysql_field_flags()%s
+mysql_field_len(): 1
+mysql_field_name(): label
+mysql_field_type(): string
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_list_processes.phpt
@@ -0,0 +1,52 @@
+--TEST--
+mysql_list_processes()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_list_processes($link, $link)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (!$res = mysql_list_processes($link))
+	printf("[002] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$num = mysql_num_rows($res))
+	printf("[003] Empty process list? [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+$row = mysql_fetch_array($res, MYSQL_NUM);
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($row[0])) {
+	printf("[004] Check for unicode support\n");
+	var_inspect($row);
+}
+
+mysql_free_result($res);
+
+if (!$res = mysql_list_processes())
+	printf("[005] [%d] %s\n", mysql_errno(), mysql_error());
+
+if (!$num = mysql_num_rows($res))
+	printf("[006] Empty process list? [%d] %s\n", mysql_errno(), mysql_error());
+
+$row = mysql_fetch_array($res, MYSQL_NUM);
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($row[0])) {
+	printf("[007] Check for unicode support\n");
+	var_inspect($row);
+}
+
+mysql_free_result($res);
+mysql_close($link);
+
+print "done!\n";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_list_tables.phpt
@@ -0,0 +1,85 @@
+--TEST--
+mysql_list_tables()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_list_tables()))
+	printf("[001] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_list_tables('too', 'many', 'arguments')))
+	printf("[002] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = @mysql_list_tables(NULL)))
+	printf("[003] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_list_tables($db, NULL)))
+	printf("[004] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+require_once('table.inc');
+
+if (!$res_def = @mysql_list_tables($db))
+	printf("[005] [%d] %s\n", mysql_errno(), mysql_error());
+
+if (!$res = @mysql_list_tables($db, $link))
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$res_query = mysql_query("SHOW TABLES", $link))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+$tables_def = $tables = $tables_query = array();
+
+while ($row = mysql_fetch_assoc($res_def))
+	$tables_def[] = $row;
+mysql_free_result($res_def);
+
+while ($row = mysql_fetch_assoc($res))
+	$tables[] = $row;
+mysql_free_result($res);
+
+while ($row = mysql_fetch_assoc($res_query))
+	$tables_query[] = $row;
+mysql_free_result($res_query);
+
+if ($tables_def !== $tables) {
+	printf("[008] Got different table lists for default link and specified link\n");
+	var_dump($tables_def);
+	var_dump($tables);
+}
+
+$list1 = $list2 = array();
+foreach ($tables as $k => $tlist)
+	foreach ($tlist as $k => $table)
+		$list1[] = $table;
+
+foreach ($tables_query as $k => $tlist)
+	foreach ($tlist as $k => $table)
+		$list2[] = $table;
+
+if ($list1 !== $list2) {
+	printf("[009] Got different results for mysql_list_tables() and SHOW TABLES\n");
+	var_dump($list1);
+	var_dump($list2);
+}
+
+if (!in_array('test', $list1))
+	printf("[010] Table lists seem to be wrong. Check manually.\n");
+
+mysql_close($link);
+
+print "done!\n";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_max_links.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysql_[p]connect() - max_links/max_persistent
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.max_links=2
+--FILE--
+<?php
+require_once('connect.inc');
+
+function my_connect($offset, $host, $user, $passwd, $db, $port, $socket) {
+	if ($socket)
+		$host = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$host = sprintf("%s:%s", $host, $port);
+
+	$link = mysql_connect($host, $user, $passwd, true);
+
+	if (!$link) {
+		printf("[%03d] Cannot connect using host '%s', user '%s', password '****', [%d] %s\n",
+			$offset, $host, $user, $passwd,
+			mysql_errno(), mysql_error());
+		return false;
+	}
+
+	return $link;
+}
+
+$links = array();
+
+// try to open 3 links
+$links[0] = my_connect(10, $host, $user, $passwd, $db, $port, $socket);
+$links[1] = my_connect(20, $host, $user, $passwd, $db, $port, $socket);
+$links[2] = my_connect(30, $host, $user, $passwd, $db, $port, $socket);
+if (false !== $links[2])
+	printf("[040] Last connection should not have been allowed!\n");
+
+// free some links but let index 1 remain
+unset($links[2]);
+mysql_close($links[0]);
+unset($links[0]);
+
+// should be allowed -> second open connection
+$links[0] = my_connect(50, $host, $user, $passwd, $db, $port, $socket);
+$links[2] = my_connect(60, $host, $user, $passwd, $db, $port, $socket);
+ksort($links);
+var_dump($links);
+
+mysql_close($links[0]);
+mysql_close($links[1]);
+print "done!\n";
+?>
+--EXPECTF--
+Warning: mysql_connect(): Too many open links (2) in %s on line %s
+[030] Cannot connect using host '%s', user '%s', password '****', [0] 0
+
+Warning: mysql_connect(): Too many open links (2) in %s on line %s
+[060] Cannot connect using host '%s', user '%s', password '****', [0] 0
+array(3) {
+  [0]=>
+  resource(%d) of type (mysql link)
+  [1]=>
+  resource(%d) of type (mysql link)
+  [2]=>
+  bool(false)
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_max_persistent.phpt
@@ -0,0 +1,99 @@
+--TEST--
+mysql_[p]connect() - max_links/max_persistent
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('table.inc');
+
+mysql_query('DROP USER pcontest', $link);
+if (!mysql_query('CREATE USER pcontest IDENTIFIED BY "pcontest"', $link)) {
+	printf("skip Cannot create second DB user [%d] %s", mysql_errno($link), mysql_error($link));
+	mysql_close($link);
+	die();
+}
+
+// we might be able to specify the host using CURRENT_USER(), but...
+if (!mysql_query(sprintf("GRANT SELECT ON TABLE %s.test TO pcontest@'%%'", $db), $link)) {
+	printf("skip Cannot GRANT SELECT to second DB user [%d] %s", mysql_errno($link), mysql_error($link));
+	mysql_query('REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest', $link);
+	mysql_query('DROP USER pcontest', $link);
+	mysql_close($link);
+	die();
+}
+mysql_close($link);
+?>
+--INI--
+mysql.max_links=2
+mysql.allow_persistent=1
+mysql.max_persistent=1
+--FILE--
+<?php
+require_once('connect.inc');
+
+function my_connect($offset, $host, $user, $passwd, $db, $port, $socket) {
+	if ($socket)
+		$host = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$host = sprintf("%s:%s", $host, $port);
+
+
+	$link = mysql_pconnect($host, $user, $passwd);
+	if (!$link) {
+		printf("[%03d] Cannot connect using host '%s', user '%s', password '****', [%d] %s\n",
+			$offset, $host, $user, $passwd,
+			mysql_errno(), mysql_error());
+		return false;
+	}
+
+	if (!mysql_select_db($db, $link))
+		return false;
+
+	return $link;
+}
+
+$links = array();
+
+// try to open 2 links
+$links[0] = my_connect(10, $host, $user, $passwd, $db, $port, $socket);
+$links[1] = my_connect(20, $host, 'pcontest', 'pcontest', $db, $port, $socket);
+if (false !== $links[1])
+	printf("[030] Last connection should not have been allowed!\n");
+
+// free some links but let index 1 remain
+unset($links[1]);
+mysql_close($links[0]);
+unset($links[0]);
+
+// should be allowed -> only open connection
+$links[0] = my_connect(40, $host, $user, $passwd, $db, $port, $socket);
+var_dump($links);
+
+mysql_query('REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest', $links[0]);
+mysql_query('DROP USER pcontest', $links[0]);
+
+mysql_close($links[0]);
+print "done!\n";
+?>
+--CLEAN--
+<?php
+// connect + select_db
+require_once("connect.inc");
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[c001] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+ 	  $host, $myhost, $user, $db, $port, $socket);
+}
+
+@mysql_query('REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest', $link);
+@mysql_query('DROP USER pcontest', $link);
+
+mysql_close($link);
+?>
+--EXPECTF--
+Warning: mysql_pconnect(): Too many open persistent links (1) in %s on line %d
+[020] Cannot connect using host '%s', user '%s', password '****', [0] 0
+array(1) {
+  [0]=>
+  resource(%d) of type (mysql link persistent)
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_mysqlnd_read_timeout_long.phpt
@@ -0,0 +1,37 @@
+--TEST--
+mysqlnd.net_read_timeout > default_socket_timeout
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+?>
+--INI--
+default_socket_timeout=1
+mysqlnd.net_read_timeout=12
+max_execution_time=12
+--FILE--
+<?php
+	set_time_limit(12);
+	include ("connect.inc");
+
+	if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysql_errno(), mysqlerror());
+	}
+
+	if (!$res = mysql_query("SELECT SLEEP(6)", $link))
+		printf("[002] [%d] %s\n",  mysql_errno($link), mysql_error($link));
+
+	var_dump(mysql_fetch_assoc($res));
+
+	mysql_free_result($res);
+	mysql_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"SLEEP(6)"]=>
+  %unicode|string%(1) "0"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_num_fields.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysql_num_fields()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_num_fields()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_num_fields($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+function func_test_mysql_num_fields($link, $query, $expected, $offset, $test_free = false) {
+
+if (!($res = mysql_query($query, $link))) {
+	printf("[%03d] [%d] %s\n", $offset, mysql_errno($link), mysql_error($link));
+	return;
+}
+
+if ($expected !== ($tmp = mysql_num_fields($res)))
+	printf("[%03d] Expecting %s/%d, got %s/%d\n", $offset + 1,
+	gettype($expected), $expected,
+	gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+if ($test_free && (false !== ($tmp = mysql_num_fields($res))))
+	printf("[%03d] Expecting boolean/false, got %s/%s\n", $offset + 2, gettype($tmp), $tmp);
+}
+
+func_test_mysql_num_fields($link, "SELECT 1 AS a", 1, 5);
+func_test_mysql_num_fields($link, "SELECT id, label FROM test", 2, 10);
+func_test_mysql_num_fields($link, "SELECT 1 AS a, NULL AS b, 'foo' AS c", 3, 15);
+func_test_mysql_num_fields($link, "SELECT id FROM test", 1, 20, true);
+
+mysql_close($link);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_num_fields(): %d is not a valid MySQL result resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_num_rows.phpt
@@ -0,0 +1,87 @@
+--TEST--
+mysql_num_rows()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_num_rows()))
+printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (NULL !== ($tmp = @mysql_num_rows($link)))
+printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+function func_test_mysql_num_rows($link, $query, $expected, $offset, $test_free = false) {
+
+	if (!$res = mysql_query($query, $link)) {
+		printf("[%03d] [%d] %s\n", $offset, mysql_errno($link), mysql_error($link));
+		return;
+	}
+
+	if ($expected !== ($tmp = mysql_num_rows($res)))
+		printf("[%03d] Expecting %s/%d, got %s/%d\n", $offset + 1,
+			gettype($expected), $expected,
+			gettype($tmp), $tmp);
+
+	mysql_free_result($res);
+
+	if ($test_free && (false !== ($tmp = mysql_num_rows($res))))
+		printf("[%03d] Expecting boolean/false, got %s/%s\n", $offset + 2, gettype($tmp), $tmp);
+}
+
+func_test_mysql_num_rows($link, "SELECT 1 AS a", 1, 5);
+func_test_mysql_num_rows($link, "SHOW VARIABLES LIKE '%nixnutz%'", 0, 10);
+func_test_mysql_num_rows($link, "INSERT INTO test(id, label) VALUES (100, 'z')", NULL, 15);
+func_test_mysql_num_rows($link, "SELECT id FROM test LIMIT 2", 2, 20, true);
+
+if ($res = mysql_query('SELECT COUNT(id) AS num FROM test', $link)) {
+
+	$row = mysql_fetch_assoc($res);
+	mysql_free_result($res);
+
+	func_test_mysql_num_rows($link, "SELECT id, label FROM test", (int)$row['num'], 25);
+
+} else {
+	printf("[030] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if ($res = mysql_unbuffered_query('SELECT id, label FROM test')) {
+
+	if (0 != mysql_num_rows($res))
+		printf("[032] Expecting 0 rows got %d\n", mysql_num_rows($res));
+	
+	$rows = 0;
+	while ($row = mysql_fetch_assoc($res))
+		$rows++;
+
+	if ($rows != mysql_num_rows($res))
+		printf("[033] Expecting %d rows got %d\n", $rows, mysql_num_rows($res));
+
+	mysql_free_result($res);
+} else {
+	printf("[034] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_num_rows() expects parameter 1 to be resource, boolean given in %s on line %d
+
+Warning: mysql_free_result() expects parameter 1 to be resource, boolean given in %s on line %d
+
+Warning: mysql_num_rows(): %d is not a valid MySQL result resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_pconn_disable.phpt
@@ -0,0 +1,54 @@
+--TEST--
+mysql_pconnect() - disabling feature
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.allow_persistent=0
+mysql.max_persistent=1
+mysql.max_links=2
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	if (($plink = my_mysql_connect($host, $user, $passwd, $db, $port, $socket, NULL, true)))
+		printf("[001] Can connect to the server.\n");
+
+	if (($res = mysql_query('SELECT id FROM test ORDER BY id ASC', $plink)) &&
+			($row = mysql_fetch_assoc($res)) &&
+			(mysql_free_result($res))) {
+		printf("[002] Can fetch data using persistent connection! Data = '%s'\n",
+			$row['id']);
+	}
+
+	$thread_id = mysql_thread_id($plink);
+	mysql_close($plink);
+
+	if (!($plink = my_mysql_connect($host, $user, $passwd, $db, $port, $socket, NULL, true)))
+		printf("[003] Cannot connect, [%d] %s\n", mysql_errno(), mysql_error());
+
+	if (mysql_thread_id($plink) != $thread_id)
+		printf("[004] Looks like the second call to pconnect() did not give us the same connection.\n");
+
+	$thread_id = mysql_thread_id($plink);
+	mysql_close($plink);
+
+	if (!($plink = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[005] Cannot connect, [%d] %s\n", mysql_errno(), mysql_error());
+
+	if (mysql_thread_id($plink) == $thread_id)
+		printf("[006] Looks like connect() did not return a new connection.\n");
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+[001] Can connect to the server.
+[002] Can fetch data using persistent connection! Data = '1'
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_pconn_kill.phpt
@@ -0,0 +1,112 @@
+--TEST--
+mysql_pconnect() - killing persitent connection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.allow_persistent=1
+mysql.max_persistent=2
+--FILE--
+<?php
+	include "connect.inc";
+	include "table.inc";
+
+	if ($socket)
+		$myhost = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$myhost = sprintf("%s:%s", $host, $port);
+	else
+		$myhost = $host;
+
+	if (!($plink = mysql_pconnect($myhost, $user, $passwd)))
+		printf("[001] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $myhost, $user, $db, $port, $socket);
+	mysql_select_db($db, $plink);
+
+	$pthread_id = mysql_thread_id($plink);
+	$thread_id = mysql_thread_id($link);
+
+	if (!($res = mysql_query("SHOW FULL PROCESSLIST", $link)))
+		printf("[002] Cannot get processlist, [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	$processlist = array();
+	while ($row = mysql_fetch_assoc($res))
+		$processlist[$row['Id']] = $row;
+	mysql_free_result($res);
+
+	if (!isset($processlist[$thread_id]))
+		printf("[003] Cannot find regular connection thread in process list, [%d] %s\n", mysql_errno($link), mysql_error($link));
+	if (!isset($processlist[$pthread_id]))
+		printf("[004] Cannot find persistent connection thread in process list, [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (!mysql_query(sprintf("KILL %d", $pthread_id), $link))
+		printf("[005] Cannot kill persistent connection thread, [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	while (1) {
+		if (!($res = mysql_query("SHOW FULL PROCESSLIST", $link)))
+			printf("[006] Cannot get processlist, [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+		$processlist2 = array();
+		while ($row = mysql_fetch_assoc($res))
+			$processlist2[$row['Id']] = $row;
+		mysql_free_result($res);
+		if (isset($processlist2[$pthread_id])) {
+			sleep(1);
+		} else {
+			break;
+		}
+	}
+
+	if (!isset($processlist2[$thread_id]))
+		printf("[007] Cannot find regular connection thread in process list, [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	mysql_close($plink);
+
+	/* mysql_pconnect cound generate a warning when linked against mysqlnd 
+       PHP Warning:  mysql_pconnect(): MySQL server has gone away */  
+	if (!($plink = @mysql_pconnect($myhost, $user, $passwd)))
+		printf("[009] Cannot create new persistent connection, [%d] %s\n", mysql_errno(), mysql_error());
+	mysql_select_db($db, $plink);
+
+	if (!($res = mysql_query("SELECT 1", $plink)))
+		printf("[010] Cannot run query on new persistent connection, [%d] %s\n", @mysql_errno($plink), @mysql_error($plink));
+	mysql_free_result($res);
+
+	var_dump(mysql_ping($plink));
+
+	if (!($res = mysql_query("SELECT 1", $plink)))
+		printf("[011] Cannot run query on new persistent connection, [%d] %s\n", @mysql_errno($plink), @mysql_error($plink));
+	mysql_free_result($res);
+
+	if (!($link2 = mysql_connect($myhost, $user, $passwd, true)))
+		printf("[012] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $myhost, $user, $db, $port, $socket);
+	mysql_select_db($db, $link2);
+	if (!mysql_query(sprintf("KILL %d", $thread_id), $link2))
+		printf("[013] Cannot kill regular connection thread, [%d] %s\n", mysql_errno($link2), mysql_error($link2));
+
+	if (!($link = mysql_connect($myhost, $user, $passwd, true)))
+		printf("[014] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $myhost, $user, $db, $port, $socket);
+	mysql_select_db($db, $link);
+	if (!($res = mysql_query("SELECT * FROM test", $link)))
+		printf("[015] Cannot run query on new regular connection, [%d] %s\n", @mysql_errno($link), @mysql_error($link));
+
+	if (!($res = mysql_query("SELECT * FROM test", $link2)))
+		printf("[016] Cannot run query on other regular connection, [%d] %s\n", @mysql_errno($link2), @mysql_error($link2));
+
+	mysql_free_result($res);
+	mysql_close($plink);
+	mysql_close($link);
+	mysql_close($link2);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_pconn_max_links.phpt
@@ -0,0 +1,206 @@
+--TEST--
+Persistent connections and mysql.max_persistent
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifconnectfailure.inc');
+	require_once('table.inc');
+
+	if ($socket)
+		$host = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$host = sprintf("%s:%s", $host, $port);
+
+	// we need a second DB user to test for a possible flaw in the ext/mysql[i] code
+	if (!$link = mysql_connect($host, $user, $passwd, true))
+		die(sprintf("skip Cannot connect [%d] %s", mysql_errno(), mysql_error()));
+
+	if (!mysql_select_db($db, $link))
+		die(sprintf("skip [%d] %s", mysql_errno($link), mysql_error($link)));
+
+	if (!$res = mysql_query('SHOW VARIABLES LIKE "old_passwords"', $link)) {
+		die(sprintf("skip [%d] %s", mysql_errno($link), mysql_error($link)));
+	}
+
+	if (mysql_num_rows($res) != 1) {
+		die(sprintf("skip Can't check if old_passwords = ON"));
+	}
+
+	$row = mysql_fetch_assoc($res);
+	mysql_free_result($res);
+	if ($row['Value'] == "ON")
+		die(sprintf("skip Test will fail because old_passwords = ON. Hint: old passwords are insecure!"));
+
+	if (!$res = mysql_query("SELECT CURRENT_USER() AS _user", $link))
+		die(sprintf("skip [%d] %s", mysql_errno($link), mysql_error($link)));
+
+	$row = mysql_fetch_assoc($res);
+	mysql_free_result($res);
+	$host = substr($row['_user'], strrpos($row['_user'], "@") + 1, strlen($row['_user']));
+
+	mysql_query('DROP USER pcontest', $link);
+	mysql_query(sprintf('DROP USER pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+	if (!mysql_query(sprintf('CREATE USER pcontest@"%s" IDENTIFIED BY "pcontest"', mysql_real_escape_string($host, $link)), $link)) {
+		printf("skip Cannot create second DB user [%d] %s", mysql_errno($link), mysql_error($link));
+		mysql_close($link);
+		die();
+	}
+
+	// we might be able to specify the host using CURRENT_USER(), but...
+	if (!mysql_query(sprintf('GRANT SELECT ON TABLE %s.test TO pcontest@"%s"', $db, mysql_real_escape_string($host, $link)), $link)) {
+		printf("skip Cannot GRANT SELECT to second DB user [%d] %s", mysql_errno($link), mysql_error($link));
+		mysql_query(sprintf('REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+		mysql_query(sprintf('DROP USER pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+		mysql_close($link);
+		die();
+	}
+
+	mysql_close($link);
+?>
+--INI--
+mysql.max_links=3
+mysql.max_persistent=2
+mysql.allow_persistent=1
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once('table.inc');
+
+	if ($socket)
+		$host = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$host = sprintf("%s:%s", $host, $port);
+
+	if (!$plink = mysql_pconnect($host, $user, $passwd))
+		printf("[001] Cannot connect using the second DB user created during SKIPIF, [%d] %s\n",
+			mysql_errno(), mysql_error());
+
+	if (!mysql_select_db($db, $plink))
+		printf("[002] [%d] %s\n", mysql_errno($plink), mysql_error($plink));
+
+	ob_start();
+	phpinfo();
+	$phpinfo = strip_tags(ob_get_contents());
+	ob_end_clean();
+	$phpinfo = substr($phpinfo, strpos($phpinfo, 'MySQL Support => enabled'), 500);
+	if (!preg_match('@Active Persistent Links\s+=>\s+(\d+)@ismU', $phpinfo, $matches))
+		printf("[003] Cannot get # active persistent links from phpinfo()");
+	$num_plinks = $matches[1];
+
+	if (!$res = mysql_query('SELECT id, label FROM test WHERE id = 1', $plink))
+		printf("[004] Cannot run query on persistent connection of second DB user, [%d] %s\n",
+			mysql_errno($plink), mysql_error($plink));
+
+	if (!$row = mysql_fetch_assoc($res))
+		printf("[005] Cannot run fetch result, [%d] %s\n",
+			mysql_errno($plink), mysql_error($plink));
+	mysql_free_result($res);
+	var_dump($row);
+
+	// change the password for the second DB user and kill the persistent connection
+	if (!$res = mysql_query("SELECT CURRENT_USER() AS _user", $link))
+		printf("[006] [%d] %s", mysql_errno($link), mysql_error($link));
+
+	$row = mysql_fetch_assoc($res);
+	mysql_free_result($res);
+	$host = substr($row['_user'], strrpos($row['_user'], "@") + 1, strlen($row['_user']));
+
+	$sql = sprintf('SET PASSWORD FOR pcontest@"%s" = PASSWORD("newpass")', mysql_real_escape_string($host, $link));
+	if (!mysql_query($sql, $link))
+		printf("[007] Cannot change PW of second DB user, [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	// persistent connections cannot be closed but only be killed
+	$pthread_id = mysql_thread_id($plink);
+	if (!mysql_query(sprintf('KILL %d', $pthread_id), $link))
+		printf("[008] Cannot KILL persistent connection of second DB user, [%d] %s\n", mysql_errno($link), mysql_error($link));
+	// give the server a second to really kill the thread
+	sleep(1);
+
+	if (!$res = mysql_query("SHOW FULL PROCESSLIST", $link))
+		printf("[009] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	$running_threads = array();
+	while ($row = mysql_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysql_free_result($res);
+
+	if (isset($running_threads[$pthread_id]))
+		printf("[010] Persistent connection has not been killed\n");
+
+	// we might get the old handle
+	if ($plink = @mysql_pconnect($host, 'pcontest', 'pcontest'))
+		printf("[011] Can connect using the old password, [%d] %s\n",
+			mysql_errno(), mysql_error());
+
+	ob_start();
+	phpinfo();
+	$phpinfo = strip_tags(ob_get_contents());
+	ob_end_clean();
+	$phpinfo = substr($phpinfo, strpos($phpinfo, 'MySQL Support => enabled'), 500);
+	if (!preg_match('@Active Persistent Links\s+=>\s+(\d+)@ismU', $phpinfo, $matches))
+		printf("[012] Cannot get # active persistent links from phpinfo()\n");
+
+	$num_plinks_kill = $matches[1];
+	if ($num_plinks_kill > $num_plinks)
+		printf("[013] Statistics seems to be wrong, got %d active persistent links, expecting < %d links\n",
+			$num_plinks_kill, $num_plinks);
+
+	// The first connection has been closed, the last pconnect() was unable to connect -> no connection open
+	// We must be able to connect because max_persistent limit has not been reached
+	if (!$plink = mysql_pconnect($host, 'pcontest', 'newpass'))
+		die(sprintf("[014] Cannot connect using the second DB, [%d] %s\n",
+			mysql_errno(), mysql_error()));
+
+	if (!mysql_select_db($db, $plink))
+		printf("[015] [%d] %s\n", mysql_errno($plink), mysql_error($plink));
+
+	if (!$res = mysql_query('SELECT id, label FROM test WHERE id = 1', $plink))
+		printf("[016] Cannot run query on persistent connection of second DB user, [%d] %s\n",
+			mysql_errno($plink), mysql_error($plink));
+
+	if (!$row = mysql_fetch_assoc($res))
+		printf("[017] Cannot run fetch result, [%d] %s\n",
+			mysql_errno($plink), mysql_error($plink));
+	mysql_free_result($res);
+	var_dump($row);
+
+	mysql_query(sprintf('REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+	mysql_query(sprintf('DROP USER pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+	mysql_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+// connect + select_db
+require_once("connect.inc");
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[c001] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+ 	  $host, $myhost, $user, $db, $port, $socket);
+}
+
+if (!$res = mysql_query("SELECT CURRENT_USER() AS _user", $link))
+	printf("[c002] [%d] %s", mysql_errno($link), mysql_error($link));
+
+$row = mysql_fetch_assoc($res);
+mysql_free_result($res);
+$host = substr($row['_user'], strrpos($row['_user'], "@") + 1, strlen($row['_user']));
+
+@mysql_query(sprintf('REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+@mysql_query(sprintf('DROP USER pcontest@"%s"', mysql_real_escape_string($host, $link)), $link);
+
+mysql_close($link);
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_pconn_reuse.phpt
@@ -0,0 +1,66 @@
+--TEST--
+mysql_pconnect() - disabling feature
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.allow_persistent=1
+mysql.max_persistent=1
+mysql.max_links=2
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+	mysql_close($link);
+
+	if ($socket)
+		$myhost = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$myhost = sprintf("%s:%s", $host, $port);
+	else
+	$myhost = $host;
+
+	if (($plink = mysql_pconnect($myhost, $user, $passwd)))
+		printf("[001] Can connect to the server.\n");
+
+	if ((mysql_select_db($db, $plink)) &&
+			($res = mysql_query('SELECT id FROM test', $plink)) &&
+			($row = mysql_fetch_assoc($res)) &&
+			(mysql_free_result($res))) {
+		printf("[002] Can fetch data using persistent connection! Data = '%s'\n",
+			$row['id']);
+	} else {
+		printf("[002] [%d] %s\n", mysql_errno($plink), mysql_error($plink));
+	}
+
+	$thread_id = mysql_thread_id($plink);
+	mysql_close($plink);
+
+	if (!($plink = mysql_pconnect($myhost, $user, $passwd)))
+		printf("[003] Cannot connect, [%d] %s\n", mysql_errno(), mysql_error());
+
+	if (mysql_thread_id($plink) != $thread_id)
+		printf("[004] Looks like the second call to pconnect() did not give us the same connection.\n");
+
+	$thread_id = mysql_thread_id($plink);
+	mysql_close($plink);
+
+	if (!($plink = mysql_connect($myhost, $user, $passwd, true)))
+		printf("[005] Cannot connect, [%d] %s\n", mysql_errno(), mysql_error());
+
+	if (mysql_thread_id($plink) == $thread_id)
+		printf("[006] Looks like connect() did not return a new connection.\n");
+
+	if (($link = mysql_connect($myhost, $user, $passwd, true)))
+		printf("[007] Can connect although limit has been reached, [%d] %s\n", mysql_errno(), mysql_error());
+
+	print "done!";
+?>
+--EXPECTF--
+[001] Can connect to the server.
+[002] Can fetch data using persistent connection! Data = '1'
+
+Warning: mysql_connect(): Too many open links (2) in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_pconnect.phpt
@@ -0,0 +1,85 @@
+--TEST--
+mysql_pconnect()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.max_persistent=10
+mysql.allow_persistent=1
+--FILE--
+<?php
+	include "connect.inc";
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// mysql_pconnect ( [string server [, string username [, string password [, bool new_link [, int client_flags]]]]] )
+	if (NULL !== ($tmp = @mysql_pconnect($link, $link, $link, $link, $link, $link)))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$myhost = (is_null($socket)) ? ((is_null($port)) ? $host : $host . ':' . $port) : $host . ':' . $socket;
+	if (!$link = mysql_pconnect($myhost, $user, $passwd, true))
+		printf("[002] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $myhost, $user, $db, $port, $socket);
+
+	mysql_close($link);
+
+	if ($link = mysql_pconnect($myhost, $user . 'unknown_really', $passwd . 'non_empty', true))
+		printf("[003] Can connect to the server using host=%s/%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+			$host, $myhost, $user . 'unknown_really', $db, $port, $socket);
+
+	if (false !== $link)
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($link), $link);
+
+	// Run the following tests without an anoynmous MySQL user and use a password for the test user!
+
+
+	if (!ini_get('sql.safe_mode')) {
+
+		if ($socket) {
+			ini_set('mysql.default_socket', $socket);
+			if (!is_resource($link = mysql_pconnect($host, $user, $passwd, true))) {
+				printf("[005] Usage of mysql.default_socket failed\n") ;
+			} else {
+				mysql_close($link);
+			}
+		} else {
+			ini_set('mysql.default_socket', null);
+		}
+
+		ini_set('mysql.default_port', $port);
+		if (!is_resource($link = mysql_pconnect($host, $user, $passwd, true))) {
+			printf("[006] Usage of mysql.default_port failed\n") ;
+		} else {
+			mysql_close($link);
+		}
+
+		ini_set('mysql.default_password', $passwd);
+		if (!is_resource($link = mysql_pconnect($myhost, $user))) {
+			printf("[007] Usage of mysql.default_password failed\n") ;
+		} else {
+			mysql_close($link);
+		}
+
+		ini_set('mysql.default_user', $user);
+		if (!is_resource($link = mysql_pconnect($myhost))) {
+			printf("[008] Usage of mysql.default_user failed\n");
+		} else {
+			mysql_close($link);
+		}
+
+		ini_set('mysql.default_host', $myhost);
+		if (!is_resource($link = mysql_pconnect())) {
+			printf("[009] Usage of mysql.default_host failed\n") ;
+		} else {
+			mysql_close($link);
+		}
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysql_pconnect(): Access denied for user '%s'@'%s' (using password: YES) in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_phpinfo.phpt
@@ -0,0 +1,75 @@
+--TEST--
+phpinfo() mysql section
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once("connect.inc");
+
+@ob_clean();
+ob_start();
+phpinfo();
+$phpinfo = ob_get_contents();
+ob_end_clean();
+
+/* all versions should at least dump this minimum information */
+if (!stristr($phpinfo, "mysql support"))
+	printf("[001] ext/mysql should have exposed itself.\n");
+
+if (!stristr($phpinfo, "client api version"))
+	printf("[002] ext/mysql should have exposed the library version.\n");
+
+if (!stristr($phpinfo, "mysql.default_host"))
+	printf("[003] php.ini setting mysql.default_host not shown.\n");
+
+if (!stristr($phpinfo, "mysql.default_port"))
+	printf("[004] php.ini setting mysql.default_port not shown.\n");
+
+if (!stristr($phpinfo, "mysql.default_password"))
+	printf("[005] php.ini setting mysql.default_password not shown.\n");
+
+if (!stristr($phpinfo, "mysql.default_socket"))
+	printf("[006] php.ini setting mysql.default_socket not shown.\n");
+
+if (!stristr($phpinfo, "mysql.default_user"))
+	printf("[007] php.ini setting mysql.default_user not shown.\n");
+
+if (!stristr($phpinfo, "mysql.max_links"))
+	printf("[008] php.ini setting mysql.max_links not shown.\n");
+
+if (!stristr($phpinfo, "mysql.max_persistent"))
+	printf("[009] php.ini setting mysql.max_persistent not shown.\n");
+
+if (!stristr($phpinfo, "mysql.connect_timeout"))
+	printf("[010] php.ini setting mysql.connect_timeout not shown.\n");
+
+if (!stristr($phpinfo, "mysql.allow_persistent"))
+	printf("[011] php.ini setting mysql.allow_persistent not shown.\n");
+
+if ($IS_MYSQLND) {
+	$expected = array(
+		'client statistics',
+		'bytes_sent', 'bytes_received', 'packets_sent', 'packets_received',
+		'protocol_overhead_in', 'protocol_overhead_out', 'result_set_queries',
+		'non_result_set_queries', 'no_index_used', 'bad_index_used',
+		'buffered_sets', 'unbuffered_sets', 'ps_buffered_sets', 'ps_unbuffered_sets',
+		'flushed_normal_sets', 'flushed_ps_sets', 'rows_fetched_from_server',
+		'rows_fetched_from_client', 'rows_skipped', 'copy_on_write_saved',
+		'copy_on_write_performed', 'command_buffer_too_small', 'connect_success',
+		'connect_failure', 'connection_reused', 'explicit_close', 'implicit_close',
+		'disconnect_close', 'in_middle_of_command_close', 'explicit_free_result',
+		'implicit_free_result', 'explicit_stmt_close', 'implicit_stmt_close',
+		'size',
+	);
+	foreach ($expected as $k => $entry)
+		if (!stristr($phpinfo, $entry))
+			printf("[012] Could not find entry for '%s'\n", $entry);
+}
+
+print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_ping.phpt
@@ -0,0 +1,50 @@
+--TEST--
+mysql_ping()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+require('table.inc');
+
+if (!is_null($tmp = @mysql_ping($link, $link)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(mysql_ping($link));
+
+// provoke an error to check if mysql_ping resets it
+$res = mysql_query('SELECT * FROM unknown_table', $link);
+if (!($errno = mysql_errno($link)))
+	printf("[002] Statement should have caused an error\n");
+
+var_dump(mysql_ping($link));
+
+if ($errno === mysql_errno($link))
+	printf("[003] Error codes should have been reset\n");
+
+var_dump(mysql_ping());
+mysql_close($link);
+
+if (false !== ($tmp = mysql_ping($link)))
+	printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+bool(true)
+
+Warning: mysql_ping(): %d is not a valid MySQL-Link resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_query.phpt
@@ -0,0 +1,127 @@
+--TEST--
+mysql_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once("connect.inc");
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_query()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = @mysql_query($link)))
+	printf("[002] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (NULL !== ($tmp = @mysql_query("SELECT 1 AS a", $link, "foo")))
+	printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_query('THIS IS NOT SQL', $link)))
+	printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_query("SELECT 'this is sql but with backslash g'\g", $link)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if ((0 === mysql_errno($link)) || ('' == mysql_error($link)))
+	printf("[006] mysql_errno()/mysql_error should return some error\n");
+
+if (!$res = mysql_query("SELECT 'this is sql but with semicolon' AS valid ; ", $link))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+var_dump(mysql_fetch_assoc($res));
+mysql_free_result($res);
+
+if (!$res = mysql_query("SELECT 'a' AS ''", $link))
+	printf("[007a] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+var_dump($tmp = mysql_fetch_assoc($res));
+var_dump($tmp[""]);
+mysql_free_result($res);
+
+if (false !== ($res = mysql_query("SELECT 'this is sql but with semicolon' AS valid ; SHOW VARIABLES", $link)))
+	printf("[008] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (mysql_query('DROP PROCEDURE IF EXISTS p', $link)) {
+	// let's try to play with stored procedures
+	if (mysql_query('CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;', $link)) {
+		$res = mysql_query('CALL p(@version)', $link);
+		$res = mysql_query('SELECT @version AS p_version', $link);
+		$tmp = mysql_fetch_assoc($res);
+		if (!isset($tmp['p_version']) || ('' == $tmp['p_version'])) {
+			printf("[009] Result seems wrong, dumping\n");
+			var_dump($tmp);
+		}
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp['p_version'])) {
+			printf("[010] Expecting unicode string, dumping\n");
+			var_dump($tmp);
+		}
+		mysql_free_result($res);
+	} else {
+		printf("[011] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+
+	mysql_query('DROP FUNCTION IF EXISTS f', $link);
+	if (mysql_query('CREATE FUNCTION f( ver_param VARCHAR(25)) RETURNS VARCHAR(25) DETERMINISTIC RETURN ver_param;', $link)) {
+		$res = mysql_query('SELECT f(VERSION()) AS f_version', $link);
+		$tmp = mysql_fetch_assoc($res);
+		if (!isset($tmp['f_version']) || ('' == $tmp['f_version'])) {
+			printf("[012] Result seems wrong, dumping\n");
+			var_dump($tmp);
+		}
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp['f_version'])) {
+			printf("[013] Expecting unicode string, dumping\n");
+			var_dump($tmp);
+		}
+		mysql_free_result($res);
+	} else {
+		printf("[014] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+}
+
+mysql_close($link);
+
+if (false !== ($tmp = mysql_query("SELECT id FROM test", $link)))
+	printf("[011] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+
+// connect + select_db
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+ 	  $host, $myhost, $user, $db, $port, $socket);
+}
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link)) {
+	printf("[clean] Failed to drop test table: [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+/* MySQL server may not support this - ignore errors */
+@mysql_query('DROP PROCEDURE IF EXISTS p', $link);
+@mysql_query('DROP FUNCTION IF EXISTS f', $link);
+
+mysql_close($link);
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"valid"]=>
+  %unicode|string%(30) "this is sql but with semicolon"
+}
+array(1) {
+  [%u|b%""]=>
+  %unicode|string%(1) "a"
+}
+%unicode|string%(1) "a"
+
+Warning: mysql_query(): %d is not a valid MySQL-Link resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_query_load_data_openbasedir.phpt
@@ -0,0 +1,124 @@
+--TEST--
+LOAD DATA INFILE - open_basedir
+--SKIPIF--
+<?php
+include_once('skipif.inc');
+
+if (!isset($db)) {
+  die("skip open_basedir setting prevents inclusing of required files");
+}
+
+include_once('skipifconnectfailure.inc');
+
+
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only, libmysql does not know about open_basedir restrictions");
+
+if (file_exists('./simple.csv') && !unlink('./simple.csv'))
+	die("skip Cannot remove previous CSV file");
+
+if (!$fp = fopen('./simple.csv', 'w'))
+	die("skip Cannot create test CSV file");
+
+fclose($fp);
+@unlink('./simple.csv');
+
+if ($socket == "" && $host != NULL && $host != 'localhost' && $host != '.') {
+	/* could be a remote TCP/IP connection. LOCAL INFILE may not work */
+	if (gethostbyaddr($host) != gethostname()) {
+		die("skip LOAD DATA LOCAL INFILE will fail if connecting to remote MySQL");
+	}
+}
+?>
+--INI--
+open_basedir="."
+--FILE--
+<?php
+@include_once("connect.inc");
+
+if (!isset($db)) {
+	// run-tests, I love you for not allowing me to set ini settings dynamically
+	print "[006] [1148] The used command is not allowed with this MySQL version
+[007] [0]
+[008] LOAD DATA not run?
+[010] [1148] The used command is not allowed with this MySQL version
+done!";
+	die();
+}
+require('table.inc');
+mysql_close($link);
+if ($socket)
+	$host = sprintf("%s:%s", $host, $socket);
+else if ($port)
+	$host = sprintf("%s:%s", $host, $port);
+
+if (!$link = mysql_connect($host, $user, $passwd, true, 128)) {
+	printf("[001] Cannot connect using host '%s', user '%s', password '****', [%d] %s\n",
+		$host, $user, $passwd,
+		mysql_errno(), mysql_error());
+}
+
+if (!mysql_select_db($db, $link)) {
+	printf("[002] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (file_exists('./simple.csv'))
+	unlink('./simple.csv');
+
+if (!$fp = fopen('./simple.csv', 'w'))
+	printf("[003] Cannot open CSV file\n");
+
+if (version_compare(PHP_VERSION, '5.9.9', '>') >= 0) {
+	if (!fwrite($fp, (binary)"'97';'x';\n") ||
+		!fwrite($fp, (binary)"'98';'y';\n") ||
+		!fwrite($fp, (binary)"99;'z';\n")) {
+		printf("[004] Cannot write CVS file '%s'\n", $file);
+	}
+} else {
+	if (!fwrite($fp, "97;'x';\n") ||
+		!fwrite($fp, "98;'y';\n") ||
+		!fwrite($fp, "99;'z';\n")) {
+		printf("[005] Cannot write CVS file '%s'\n", $file);
+	}
+}
+fclose($fp);
+
+$sql = sprintf("LOAD DATA LOCAL INFILE '%s'
+			INTO TABLE test
+			FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\''
+			LINES TERMINATED BY '\n'",
+			mysql_real_escape_string(realpath('./simple.csv'), $link));
+
+if (!mysql_query($sql, $link))
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!($res = mysql_query('SELECT label FROM test WHERE id = 97', $link)) ||
+		!($row = mysql_fetch_assoc($res)) ||
+		!mysql_free_result($res))
+	printf("[007] [%d] '%s'\n", mysql_errno($link), mysql_error($link));
+
+if ($row['label'] != "x")
+	printf("[008] LOAD DATA not run?\n");
+
+if (!mysql_query('DELETE FROM test', $link))
+	printf("[009] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+$sql = "LOAD DATA LOCAL INFILE '/tmp/idonotexist'
+			INTO TABLE test
+			FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\''
+			LINES TERMINATED BY '\n'";
+
+if (!mysql_query($sql, $link))
+	printf("[010] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+mysql_close($link);
+unlink("./simple.csv");
+
+print "done!";
+?>
+--EXPECTF--
+[006] [1148] %s
+[007] [0] ''
+[008] LOAD DATA not run?
+[010] [1148] %s
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_real_escape_string.phpt
@@ -0,0 +1,43 @@
+--TEST--
+mysql_real_escape_string()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (NULL !== ($tmp = @mysql_real_escape_string()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (NULL !== ($tmp = @mysql_real_escape_string('foo', $link, $link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(mysql_real_escape_string("Am I a unicode string in PHP 6?", $link));
+var_dump(mysql_real_escape_string('\\', $link));
+var_dump(mysql_real_escape_string('"', $link));
+var_dump(mysql_real_escape_string("'", $link));
+var_dump(mysql_real_escape_string("\n", $link));
+var_dump(mysql_real_escape_string("\r", $link));
+var_dump($tmp = mysql_real_escape_string("foo" . chr(0) . "bar", $link));
+
+assert($tmp === mysql_real_escape_string("foo" . chr(0) . "bar"));
+
+print "done!";
+?>
+--EXPECTF--
+%unicode|string%(31) "Am I a unicode string in PHP 6?"
+%unicode|string%(2) "\\"
+%unicode|string%(2) "\""
+%unicode|string%(2) "\'"
+%unicode|string%(2) "\n"
+%unicode|string%(2) "\r"
+%unicode|string%(8) "foo\0bar"
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_result.phpt
@@ -0,0 +1,114 @@
+--TEST--
+mysql_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require_once("connect.inc");
+
+$tmp    = NULL;
+$link   = NULL;
+
+// string mysql_result ( resource result, int row [, mixed field] )
+
+if (!is_null($tmp = @mysql_result()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!is_null($tmp = @mysql_result($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require_once('table.inc');
+if (!$res = mysql_query("SELECT id, label, id AS _id, CONCAT(label, 'a') _label, NULL as _foo FROM test _test ORDER BY id ASC LIMIT 1", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+var_dump(mysql_result($res, -1));
+var_dump(mysql_result($res, 2));
+
+var_dump(mysql_result($res, 0, -1));
+var_dump(mysql_result($res, 0, 500));
+
+print "valid fields\n";
+var_dump(mysql_result($res, 0));
+var_dump(mysql_result($res, 0, 1));
+
+var_dump(mysql_result($res, 0, 'id'));
+var_dump(mysql_result($res, 0, '_test.id'));
+var_dump(mysql_result($res, 0, 'label'));
+var_dump(mysql_result($res, 0, '_test.label'));
+print "some invalid fields\n";
+var_dump(mysql_result($res, 0, 'unknown'));
+var_dump(mysql_result($res, 0, '_test.'));
+var_dump(mysql_result($res, 0, chr(0)));
+var_dump(mysql_result($res, 0, '_test.' . chr(0)));
+print "_id\n";
+var_dump(mysql_result($res, 0, '_id'));
+print "_label\n";
+var_dump(mysql_result($res, 0, '_label'));
+print "_foo\n";
+var_dump(mysql_result($res, 0, '_foo'));
+var_dump(mysql_result($res, 0, 'test.id'));
+var_dump(mysql_result($res, 0, 'test.label'));
+
+mysql_free_result($res);
+
+var_dump(mysql_result($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysql_result(): Unable to jump to row -1 on MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result(): Unable to jump to row 2 on MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result(): Bad column offset specified in %s on line %d
+bool(false)
+
+Warning: mysql_result(): Bad column offset specified in %s on line %d
+bool(false)
+valid fields
+%unicode|string%(1) "1"
+%unicode|string%(1) "a"
+%unicode|string%(1) "1"
+%unicode|string%(1) "1"
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+some invalid fields
+
+Warning: mysql_result(): unknown not found in MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result(): _test. not found in MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result():  not found in MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result(): _test. not found in MySQL result index %d in %s on line %d
+bool(false)
+_id
+%unicode|string%(1) "1"
+_label
+string(2) "aa"
+_foo
+NULL
+
+Warning: mysql_result(): test.id not found in MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result(): test.label not found in MySQL result index %d in %s on line %d
+bool(false)
+
+Warning: mysql_result(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_select_db.phpt
@@ -0,0 +1,73 @@
+--TEST--
+mysql_select_db()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (false !== ($tmp = @mysql_select_db($link)))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+if (!is_null($tmp = @mysql_select_db($db, $link, "foo")))
+	printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+/* does not make too much sense, unless we have access to at least one more database than $db */
+if (!mysql_select_db($db, $link))
+	printf("[004] Cannot select DB %s, [%d] %s\n", $db, mysql_errno($link), mysql_error($link));
+
+if (!$res = mysql_query("SELECT DATABASE() AS dbname", $link))
+	printf("[005] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (!$row = mysql_fetch_assoc($res))
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if ($row['dbname'] !== (string)$db)
+	printf("[007] Expecting database '%s', found '%s'\n", $db, $row['dbname']);
+
+var_dump($row['dbname']);
+
+mysql_free_result($res);
+
+if (mysql_select_db('mysql', $link)) {
+	// Yippie, a second database to play with - that's great because mysql_select_db
+	// ($db) was done by mysql__connect() already and the previous test
+	// was quite useless
+	if (!$res = mysql_query("SELECT DATABASE() AS dbname", $link))
+		printf("[008] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (!$row = mysql_fetch_assoc($res))
+		printf("[009] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+	if (strtolower($row['dbname']) !== 'mysql')
+		printf("[010] Expecting database 'mysql', found '%s'\n", $row['dbname']);
+
+	mysql_free_result($res);
+}
+
+
+var_dump(mysql_select_db('I can not imagine that this database exists', $link));
+
+mysql_close($link);
+
+if (false !== ($tmp = mysql_select_db($db, $link)))
+	printf("[012] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!\n";
+?>
+--EXPECTF--
+%unicode|string%(%d) "%s"
+bool(false)
+
+Warning: mysql_select_db(): %d is not a valid MySQL-Link resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_set_charset.phpt
@@ -0,0 +1,61 @@
+--TEST--
+mysql_set_charset() - STUB, function usage not recommended
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip set character set not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
+}
+
+if (!function_exists('mysql_set_charset'))
+	die("skip Function not available");
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_set_charset()))
+	printf("[001] Expecting NULL got %s/%s\n", $tmp, gettype($tmp));
+
+if (false !== ($tmp = @mysql_set_charset($link)))
+	printf("[002] Expecting boolean/false got %s/%s\n", $tmp, gettype($tmp));
+
+if (false !== ($tmp = @mysql_set_charset(-1)))
+	printf("[003] Expecting boolean/false got %s/%s\n", $tmp, gettype($tmp));
+
+if (!is_null($tmp = @mysql_set_charset('somecharset', $link)))
+	printf("[004] Expecting NULL got %s/%s\n", $tmp, gettype($tmp));
+
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket))
+	printf("[005] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+/* unicode mode should throw a warning */
+$tmp = mysql_set_charset('uFt8', $link);
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1))
+	$expect = false;
+else
+	$expect = true;
+
+$charsets = array('latin1', 'latin2');
+foreach ($charsets as $k => $charset) {
+	if (!($res = mysql_query(sprintf('SHOW CHARACTER SET LIKE "%s"', $charset), $link)))
+		continue;
+	mysql_free_result($res);
+	if ($expect !== ($tmp = @mysql_set_charset($charset, $link)))
+		printf("[006] Expecting %s/%s got %s/%s\n",
+			gettype($expect), $expect,
+			gettype($tmp), $tmp);
+}
+
+mysql_close($link);
+print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_sql_safe_mode.phpt
@@ -0,0 +1,40 @@
+--TEST--
+mysql_[p]connect() - safe_mode
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+$link = @mysql_connect("", "", "", true);
+if ($link)
+	die("skip Test cannot be run if annonymous connections are allowed");
+?>
+--INI--
+sql.safe_mode=1
+--FILE--
+<?php
+require_once('connect.inc');
+if ($socket)
+	$host = sprintf("%s:%s", $host, $socket);
+else if ($port)
+	$host = sprintf("%s:%s", $host, $port);
+
+if ($link = mysql_connect($host, $user, $passwd, true)) {
+	printf("[001] Safe mode not working properly?\n");
+	mysql_close($link);
+}
+
+if ($link = mysql_pconnect($host, $user, $passwd)) {
+	printf("[002] Safe mode not working properly?\n");
+	mysql_close($link);
+}
+print "done!\n";
+?>
+--EXPECTF--
+Notice: mysql_connect(): SQL safe mode in effect - ignoring host/user/password information in %s on line %d
+
+Warning: mysql_connect(): Access denied for user '%s'@'%s' (using password: NO) in %s on line %d
+
+Notice: mysql_pconnect(): SQL safe mode in effect - ignoring host/user/password information in %s on line %d
+
+Warning: mysql_pconnect(): Access denied for user '%s'@'%s' (using password: NO) in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_stat.phpt
@@ -0,0 +1,48 @@
+--TEST--
+mysql_stat()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$dbname = 'test';
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_stat($link)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (!is_null($tmp = @mysql_stat($link, "foo")))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if ((!is_string($stat = mysql_stat($link))) || ('' === $stat))
+	printf("[003] Expecting non empty string, got %s/'%s', [%d] %s\n",
+		gettype($stat), $stat, mysql_errno($link), mysql_error($link));
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($stat)) {
+	printf("[004] Expecting Unicode error message!\n");
+	var_inspect($stat);
+}
+
+if ((!is_string($stat_def = mysql_stat())) || ('' === $stat_def))
+	printf("[003] Expecting non empty string, got %s/'%s', [%d] %s\n",
+		gettype($stat_def), $stat_def, mysql_errno(), mysql_error());
+
+assert(soundex($stat) === soundex($stat_def));
+
+mysql_close($link);
+
+if (false !== ($tmp = mysql_stat($link)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--EXPECTF--
+Warning: mysql_stat(): %d is not a valid MySQL-Link resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_tablename.phpt
@@ -0,0 +1,54 @@
+--TEST--
+mysql_tablename()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_tablename()))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (null !== ($tmp = @mysql_tablename($link)))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+if (!$res = mysql_query("SELECT id, label FROM test ORDER BY id LIMIT 2", $link)) {
+	printf("[003] [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+if (NULL !== ($tmp = mysql_tablename($res)))
+	printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_tablename($res, -1)))
+	printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+var_dump(mysql_tablename($res, 0));
+
+if (false !== ($tmp = mysql_tablename($res, 2)))
+	printf("[00%d] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+mysql_free_result($res);
+
+var_dump(mysql_tablename($res, 0));
+
+mysql_close($link);
+print "done!";
+?>
+--EXPECTF--
+Warning: mysql_tablename() expects at least 2 parameters, 1 given in %s on line %d
+
+Warning: mysql_tablename(): Unable to jump to row -1 on MySQL result index %d in %s on line %d
+%unicode|string%(1) "1"
+
+Warning: mysql_tablename(): Unable to jump to row 2 on MySQL result index %d in %s on line %d
+
+Warning: mysql_tablename(): %d is not a valid MySQL result resource in %s on line %d
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysql/tests/mysql_thread_id.phpt
@@ -0,0 +1,39 @@
+--TEST--
+mysql_thread_id()
+--SKIPIF--
+<?php 
+require_once('skipif.inc'); 
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once "connect.inc";
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (!is_null($tmp = @mysql_thread_id($link)))
+	printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (!is_int($id = mysql_thread_id($link)) || (0 === $id))
+	printf("[002] Expecting int/any but zero, got %s/%s. [%d] %s\n",
+		gettype($id), $id, mysql_errno($link), mysql_error($link));
+
+if (!is_int($id_def = mysql_thread_id()) || (0 === $id_def))
+	printf("[003] Expecting int/any but zero, got %s/%s. [%d] %s\n",
+		gettype($id_def), $id_def, mysql_errno(), mysql_error());
+
+assert($id === $id_def);
+
+mysql_close($link);
+
+if (false !== ($tmp = mysql_thread_id($link)))
+	printf("[003] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--EXPECTF--
+Warning: mysql_thread_id(): %d is not a valid MySQL-Link resource in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/mysql_trace_mode.phpt
@@ -0,0 +1,36 @@
+--TEST--
+mysql.trace_mode=1
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysql.trace_mode=1
+error_reporting=E_ALL | E_NOTICE | E_STRICT
+--FILE--
+<?php
+require_once('table.inc');
+
+$res1 = mysql_query('SELECT id FROM test', $link);
+
+if (!$res2 = @mysql_db_query($db, 'SELECT id FROM test', $link))
+	printf("[001] [%d] %s\n", mysql_errno($link), mysql_error($link));
+mysql_free_result($res2);
+print @mysql_escape_string("I don't mind character sets, do I?\n");
+
+$res3 = mysql_query('BOGUS_SQL', $link);
+mysql_close($link);
+
+print "done!\n";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+I don\'t mind character sets, do I?\n
+Warning: mysql_query(): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'BOGUS_SQL' at line 1 in %s on line %d
+done!
+
+Warning: Unknown: 1 result set(s) not freed. Use mysql_free_result to free result sets which were requested using mysql_query() in %s on line %d
--- /dev/null
+++ b/ext/mysql/tests/mysql_unbuffered_query.phpt
@@ -0,0 +1,121 @@
+--TEST--
+mysql_unbuffered_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+include_once("connect.inc");
+
+$tmp    = NULL;
+$link   = NULL;
+
+if (false !== ($tmp = @mysql_unbuffered_query($link)))
+	printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+require('table.inc');
+
+if (NULL !== ($tmp = @mysql_unbuffered_query("SELECT 1 AS a", $link, "foo")))
+	printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_unbuffered_query('THIS IS NOT SQL', $link)))
+	printf("[003] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if (false !== ($tmp = mysql_unbuffered_query("SELECT 'this is sql but with backslash g'\g", $link)))
+	printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+if ((0 === mysql_errno($link)) || ('' == mysql_error($link)))
+	printf("[005] mysql_errno()/mysql_error should return some error\n");
+
+if (!$res = mysql_unbuffered_query("SELECT 'this is sql but with semicolon' AS valid ; ", $link))
+	printf("[006] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+var_dump(mysql_fetch_assoc($res));
+mysql_free_result($res);
+
+if (false !== ($res = mysql_unbuffered_query("SELECT 'this is sql but with semicolon' AS valid ; SHOW VARIABLES", $link)))
+	printf("[007] [%d] %s\n", mysql_errno($link), mysql_error($link));
+
+if (mysql_unbuffered_query('DROP PROCEDURE IF EXISTS p', $link)) {
+	// let's try to play with stored procedures
+	if (mysql_unbuffered_query('CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;', $link)) {
+		$res = mysql_unbuffered_query('CALL p(@version)', $link);
+		$res = mysql_unbuffered_query('SELECT @version AS p_version', $link);
+		$tmp = mysql_fetch_assoc($res);
+		if (!isset($tmp['p_version']) || ('' == $tmp['p_version'])) {
+			printf("[008] Result seems wrong, dumping\n");
+			var_dump($tmp);
+		}
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp['p_version'])) {
+			printf("[009] Expecting unicode string, dumping\n");
+			var_dump($tmp);
+		}
+		mysql_free_result($res);
+	} else {
+		printf("[010] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+
+	mysql_unbuffered_query('DROP FUNCTION IF EXISTS f', $link);
+	if (mysql_unbuffered_query('CREATE FUNCTION f( ver_param VARCHAR(25)) RETURNS VARCHAR(25) DETERMINISTIC RETURN ver_param;', $link)) {
+		$res = mysql_unbuffered_query('SELECT f(VERSION()) AS f_version', $link);
+		$tmp = mysql_fetch_assoc($res);
+		if (!isset($tmp['f_version']) || ('' == $tmp['f_version'])) {
+			printf("[011] Result seems wrong, dumping\n");
+			var_dump($tmp);
+		}
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp['f_version'])) {
+			printf("[012] Expecting unicode string, dumping\n");
+			var_dump($tmp);
+		}
+		mysql_free_result($res);
+	} else {
+		printf("[012] [%d] %s\n", mysql_errno($link), mysql_error($link));
+	}
+}
+
+var_dump(mysql_unbuffered_query('INSERT INTO test(id) VALUES (100)', $link));
+var_dump($res = mysql_unbuffered_query('SELECT id FROM test', $link));
+var_dump(mysql_num_rows($res));
+
+mysql_close($link);
+
+if (false !== ($tmp = mysql_unbuffered_query("SELECT id FROM test", $link)))
+	printf("[010] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+
+// connect + select_db
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+ 	  $host, $myhost, $user, $db, $port, $socket);
+}
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link)) {
+	printf("[clean] Failed to drop test table: [%d] %s\n", mysql_errno($link), mysql_error($link));
+}
+
+/* MySQL server may not support this - ignore errors */
+@mysql_query('DROP PROCEDURE IF EXISTS p', $link);
+@mysql_query('DROP FUNCTION IF EXISTS f', $link);
+
+mysql_close($link);
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"valid"]=>
+  %unicode|string%(30) "this is sql but with semicolon"
+}
+bool(true)
+resource(%d) of type (mysql result)
+int(0)
+
+Notice: mysql_close(): Function called without first fetching all rows from a previous unbuffered query in %s on line %d
+
+Warning: mysql_unbuffered_query(): %d is not a valid MySQL-Link resource in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysql/tests/setupdefault.inc
@@ -0,0 +1,10 @@
+<?php
+
+// copy variables from connect.inc into mysql default connection ini settings, so that implicit mysql_connect() behaviour can be tested where needed
+// must be loaded AFTER connect.inc
+
+ini_set('mysql.default_host',		$host);
+ini_set('mysql.default_user',		$user);
+ini_set('mysql.default_password',	$passwd);
+
+?>
--- a/ext/mysql/tests/skipif.inc
+++ b/ext/mysql/tests/skipif.inc
@@ -1,11 +1,6 @@
 <?php
-
-include 'connect.inc';
 if (!extension_loaded("mysql")) {
-    die('skip mysql extension not available');
+	die('skip mysql extension not available');
 }
-$link = @mysql_connect($host, $user, $passwd);
-if (!$link) die('skip cannot connect');
-mysql_close($link);
-
+require_once('connect.inc');
 ?>
--- /dev/null
+++ b/ext/mysql/tests/skipifconnectfailure.inc
@@ -0,0 +1,17 @@
+<?php
+require_once('connect.inc');
+if ($skip_on_connect_failure) {
+	if ($socket)
+		$myhost = sprintf("%s:%s", $host, $socket);
+	else if ($port)
+		$myhost = sprintf("%s:%s", $host, $port);
+
+	if (!$link = @mysql_connect($myhost, $user, $passwd, true, $connect_flags))
+		die(sprintf("skip Can't connect to MySQL Server - [%d] %s", mysql_errno(), mysql_error()));
+
+	if (!@mysql_select_db($db, $link))
+		die(sprintf("skip Can't connect to MySQL Server - [%d] %s", mysql_errno(), mysql_error()));
+
+	mysql_close($link);
+}
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/mysql/tests/skipifnotmysqlnd.inc
@@ -0,0 +1,5 @@
+<?php
+if (strpos(mysql_get_client_info(), 'mysqlnd') === false) {
+	die('skip mysqlnd extension not available');
+}
+?>
--- /dev/null
+++ b/ext/mysql/tests/table.inc
@@ -0,0 +1,24 @@
+<?PHP
+require_once 'connect.inc';
+
+// connect + select_db
+if (!$link = my_mysql_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("Cannot connect to the server using host=%s/%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+ 	  $host, $myhost, $user, $db, $port, $socket);
+	exit(1);
+}
+
+if (!mysql_query('DROP TABLE IF EXISTS test', $link)) {
+	printf("Failed to drop old test table: [%d] %s\n", mysql_errno($link), mysql_error($link));
+	exit(1);
+}
+
+if (!mysql_query('CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=' . $engine, $link)) {
+	printf("Failed to create test table: [%d] %s\n", mysql_errno($link), mysql_error($link));
+	exit(1);
+}
+
+if (!mysql_query("INSERT INTO test(id, label) VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')", $link)) {
+	printf("[%d] %s\n",  mysql_errno($link), mysql_error($link));
+}
+?>
--- a/ext/mysqli/config.m4
+++ b/ext/mysqli/config.m4
@@ -1,20 +1,21 @@
 dnl
-dnl $Id: config.m4 239118 2007-07-03 17:25:43Z sniper $
+dnl $Id$
 dnl config.m4 for extension mysqli
 
 PHP_ARG_WITH(mysqli, for MySQLi support,
-[  --with-mysqli[=FILE]    Include MySQLi support.  FILE is the optional pathname 
-                          to mysql_config [mysql_config]])
+[  --with-mysqli[=FILE]    Include MySQLi support.  FILE is the path
+                          to mysql_config.  If mysqlnd is passed as FILE,
+                          the MySQL native driver will be used [mysql_config]])
 
 PHP_ARG_ENABLE(embedded_mysqli, whether to enable embedded MySQLi support,
-[  --enable-embedded-mysqli  MYSQLi: Enable embedded support], no, no)
+[  --enable-embedded-mysqli  MYSQLi: Enable embedded support
+                            Note: Does not work with MySQL native driver!], no, no)
 
-if test "$PHP_MYSQLI" != "no"; then
+if test "$PHP_MYSQLI" = "mysqlnd"; then
+  dnl This needs to be set in any extension which wishes to use mysqlnd
+  PHP_MYSQLND_ENABLED=yes
 
-dnl there are no mysql libs currently bundled with PHP.. --Jani
-dnl  if test "$PHP_MYSQL" = "yes"; then
-dnl    AC_MSG_ERROR([--with-mysql (using bundled libs) can not be used together with --with-mysqli.])
-dnl  fi
+elif test "$PHP_MYSQLI" != "no"; then
 
   if test "$PHP_MYSQLI" = "yes"; then
     MYSQL_CONFIG=`$php_shtool path mysql_config`
@@ -26,6 +27,8 @@
   if test "$PHP_EMBEDDED_MYSQLI" = "yes"; then
     AC_DEFINE(HAVE_EMBEDDED_MYSQLI, 1, [embedded MySQL support enabled])
     MYSQL_LIB_CFG='--libmysqld-libs'
+    dnl mysqlnd doesn't support embedded, so we have to add some extra stuff
+    mysqli_extra_sources="mysqli_embedded.c"
   elif test "$enable_maintainer_zts" = "yes"; then
     MYSQL_LIB_CFG='--libs_r'
     MYSQL_LIB_NAME='mysqlclient_r'
@@ -48,17 +51,39 @@
   [
     PHP_EVAL_INCLINE($MYSQLI_INCLINE)
     PHP_EVAL_LIBLINE($MYSQLI_LIBLINE, MYSQLI_SHARED_LIBADD)
-    AC_DEFINE(HAVE_MYSQLILIB,1,[ ])
-    PHP_CHECK_LIBRARY($MYSQL_LIB_NAME, mysql_stmt_field_count,
+    AC_DEFINE(HAVE_MYSQLILIB, 1, [ ])
+    PHP_CHECK_LIBRARY($MYSQL_LIB_NAME, mysql_set_character_set,
     [ ],[
-		AC_MSG_ERROR([MySQLI doesn't support versions < 4.1.3 (for MySQL 4.1.x) and < 5.0.1 for (MySQL 5.0.x) anymore. Please update your libraries.])
-	],[$MYSQLI_LIBLINE])
+      AC_MSG_ERROR([MySQLI doesn't support versions < 4.1.13 (for MySQL 4.1.x) and < 5.0.7 for (MySQL 5.0.x) anymore. Please update your libraries.])
+    ],[$MYSQLI_LIBLINE])
   ],[
     AC_MSG_ERROR([wrong mysql library version or lib not found. Check config.log for more information.])
   ],[
     $MYSQLI_LIBLINE
   ])
+  dnl
+  dnl Check the library for mysql_stmt_next_result
+  dnl
+  PHP_CHECK_LIBRARY($MYSQL_LIB_NAME, mysql_stmt_next_result,
+  [
+    AC_DEFINE(HAVE_STMT_NEXT_RESULT,             1, [ ])
+  ],[
+  ],[
+    $MYSQLI_LIBLINE
+  ])
+fi
 
-  PHP_NEW_EXTENSION(mysqli, mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c mysqli_fe.c mysqli_report.c mysqli_repl.c mysqli_driver.c mysqli_warning.c mysqli_exception.c mysqli_embedded.c, $ext_shared)
+dnl Build extension
+if test "$PHP_MYSQLI" != "no"; then
+  mysqli_sources="mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c \
+                  mysqli_fe.c mysqli_report.c mysqli_driver.c mysqli_warning.c \
+                  mysqli_exception.c $mysqli_extra_sources"
+  PHP_NEW_EXTENSION(mysqli, $mysqli_sources, $ext_shared)
   PHP_SUBST(MYSQLI_SHARED_LIBADD)
+  PHP_INSTALL_HEADERS([ext/mysqli/php_mysqli_structs.h])
+
+  if test "$PHP_MYSQLI" = "mysqlnd"; then
+    PHP_ADD_EXTENSION_DEP(mysqli, mysqlnd)
+    AC_DEFINE([MYSQLI_USE_MYSQLND], 1, [Whether mysqlnd is enabled])
+  fi
 fi
--- a/ext/mysqli/config.w32
+++ b/ext/mysqli/config.w32
@@ -1,14 +1,45 @@
-// $Id: config.w32 187690 2005-06-05 19:25:01Z wez $
+// $Id$
 // vim:ft=javascript
 
+// Note: The extension name is "mysqli", you enable it with "--with-mysqli".
+// Passing value "mysqlnd" to it enables the bundled
+// client library to connect to the MySQL server, i.e. no external MySQL
+// client library is needed to perform the build.
+
 ARG_WITH("mysqli", "MySQLi support", "no");
 
 if (PHP_MYSQLI != "no") {
-	if (CHECK_LIB("libmysql.lib", "mysqli", PHP_MYSQLI) &&
-			CHECK_HEADER_ADD_INCLUDE("mysql.h", "CFLAGS_MYSQLI", PHP_MYSQLI + "\\include;" + PHP_PHP_BUILD + "\\include\\mysql;" + PHP_MYSQLI)) {
-		EXTENSION("mysqli", "mysqli.c mysqli_api.c mysqli_prop.c mysqli_nonapi.c mysqli_fe.c mysqli_report.c mysqli_repl.c mysqli_driver.c mysqli_warning.c mysqli_exception.c mysqli_embedded.c");
+	mysqli_source =
+		"mysqli.c " +
+		"mysqli_api.c " +
+		"mysqli_driver.c " +
+		"mysqli_embedded.c " +
+		"mysqli_exception.c " +
+		"mysqli_fe.c " +
+		"mysqli_nonapi.c " +
+		"mysqli_prop.c " +
+		"mysqli_report.c " +
+		"mysqli_warning.c";
+
+	if (PHP_MYSQLI == "yes" || PHP_MYSQLI == "mysqlnd") {
+		EXTENSION("mysqli", mysqli_source);
+		AC_DEFINE('MYSQLI_USE_MYSQLND', 1, 'Using MySQL native driver');
 		AC_DEFINE('HAVE_MYSQLILIB', 1, 'Have MySQLi library');
+		ADD_EXTENSION_DEP('mysqli', 'mysqlnd', true);
+		MESSAGE("\tmysqlnd build");
+		PHP_INSTALL_HEADERS("ext/mysqli", "php_mysqli_structs.h");
 	} else {
-		WARNING("mysqli not enabled; libraries and headers not found");
+		if (CHECK_LIB("libmysql.lib", "mysqli", PHP_MYSQLI) &&
+			CHECK_HEADER_ADD_INCLUDE("mysql.h", "CFLAGS_MYSQLI", PHP_MYSQLI + 
+										"\\include;" + PHP_PHP_BUILD +
+										"\\include\\mysql;" + PHP_MYSQLI)) {
+			EXTENSION("mysqli", mysqli_source);
+			AC_DEFINE('HAVE_MYSQLILIB', 1, 'Have MySQLi library');
+			MESSAGE("\tlibmysql build");
+			PHP_INSTALL_HEADERS("ext/mysqli", "php_mysqli_structs.h");
+		} else {
+			WARNING("mysqli not enabled; libraries and headers not found");
+			PHP_MYSQLI = "no"
+		}
 	}
 }
--- a/ext/mysqli/mysqli.c
+++ b/ext/mysqli/mysqli.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -12,10 +12,12 @@
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
-  | Author: Georg Richter <georg@php.net>                                |
+  | Authors: Georg Richter <georg@php.net>                               |
+  |          Andrey Hristov <andrey@php.net>                             |
+  |          Ulf Wendel <uw@php.net>                                     |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli.c 302181 2010-08-13 10:43:15Z kalle $ 
+  $Id$
 */
 
 #ifdef HAVE_CONFIG_H
@@ -28,15 +30,34 @@
 #include "php_ini.h"
 #include "ext/standard/info.h"
 #include "ext/standard/php_string.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_priv.h"
 #include "zend_exceptions.h"
 
-#define MYSQLI_STORE_RESULT 0
-#define MYSQLI_USE_RESULT 1
-
 ZEND_DECLARE_MODULE_GLOBALS(mysqli)
 static PHP_GINIT_FUNCTION(mysqli);
 
+#define MYSQLI_ADD_PROPERTIES(a,b) \
+{ \
+	int i = 0; \
+	while (b[i].pname != NULL) { \
+		mysqli_add_property((a), (b)[i].pname, (b)[i].pname_length, \
+							(mysqli_read_t)(b)[i].r_func, (mysqli_write_t)(b)[i].w_func TSRMLS_CC); \
+		i++; \
+	}\
+}
+
+#define MYSQLI_ADD_PROPERTIES_INFO(a,b) \
+{ \
+	int i = 0; \
+	while (b[i].name != NULL) { \
+		zend_declare_property_null((a), (b)[i].name, (b)[i].name_length, ZEND_ACC_PUBLIC TSRMLS_CC); \
+		i++; \
+	}\
+}
+
+
+
 static zend_object_handlers mysqli_object_handlers;
 static HashTable classes;
 static HashTable mysqli_driver_properties;
@@ -52,16 +73,46 @@
 zend_class_entry *mysqli_warning_class_entry;
 zend_class_entry *mysqli_exception_class_entry;
 
-extern void php_mysqli_connect(INTERNAL_FUNCTION_PARAMETERS);
 
 typedef int (*mysqli_read_t)(mysqli_object *obj, zval **retval TSRMLS_DC);
 typedef int (*mysqli_write_t)(mysqli_object *obj, zval *newval TSRMLS_DC);
 
 typedef struct _mysqli_prop_handler {
+	char *name;
+	size_t name_len;
 	mysqli_read_t read_func;
 	mysqli_write_t write_func;
 } mysqli_prop_handler;
 
+static int le_pmysqli;
+
+
+/* Destructor for mysqli entries in free_links/used_links */
+void php_mysqli_dtor_p_elements(void *data)
+{
+	MYSQL *mysql = (MYSQL *) data;
+	TSRMLS_FETCH();
+	mysqli_close(mysql, MYSQLI_CLOSE_IMPLICIT);
+}
+
+
+ZEND_RSRC_DTOR_FUNC(php_mysqli_dtor)
+{
+	if (rsrc->ptr) {
+		mysqli_plist_entry *plist = (mysqli_plist_entry *) rsrc->ptr;
+		zend_ptr_stack_clean(&plist->free_links, php_mysqli_dtor_p_elements, 0);
+		zend_ptr_stack_destroy(&plist->free_links);
+		free(plist);
+	}
+}
+
+
+int php_le_pmysqli(void)
+{
+	return le_pmysqli;
+}
+
+#ifndef MYSQLI_USE_MYSQLND
 /* {{{ php_free_stmt_bind_buffer */
 void php_free_stmt_bind_buffer(BIND_BUFFER bbuf, int type)
 {
@@ -80,7 +131,7 @@
 
 		if (bbuf.vars[i]) {
 			zval_ptr_dtor(&bbuf.vars[i]);
-		}	
+		}
 	}
 
 	if (bbuf.vars) {
@@ -100,30 +151,44 @@
 	}
 
 	bbuf.var_cnt = 0;
-	return;
 }
 /* }}} */
+#endif
 
 /* {{{ php_clear_stmt_bind */
-void php_clear_stmt_bind(MY_STMT *stmt)
+void php_clear_stmt_bind(MY_STMT *stmt TSRMLS_DC)
 {
 	if (stmt->stmt) {
-		mysql_stmt_close(stmt->stmt);
+		if (mysqli_stmt_close(stmt->stmt, TRUE)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error occured while closing statement");
+			return;
+		}
 	}
 
+	/*
+	  mysqlnd keeps track of the binding and has freed its
+	  structures in stmt_close() above
+	*/
+#ifndef MYSQLI_USE_MYSQLND
+	/* Clean param bind */
 	php_free_stmt_bind_buffer(stmt->param, FETCH_SIMPLE);
+	/* Clean output bind */
 	php_free_stmt_bind_buffer(stmt->result, FETCH_RESULT);
+#endif
 
 	if (stmt->query) {
 		efree(stmt->query);
 	}
 	efree(stmt);
-	return;
 }
 /* }}} */
 
 /* {{{ php_clear_mysql */
 void php_clear_mysql(MY_MYSQL *mysql) {
+	if (mysql->hash_key) {
+		efree(mysql->hash_key);
+		mysql->hash_key = NULL;
+	}
 	if (mysql->li_read) {
 		zval_ptr_dtor(&(mysql->li_read));
 		mysql->li_read = NULL;
@@ -139,12 +204,14 @@
 	mysqli_object 	*intern = (mysqli_object *)zo;
 	MYSQLI_RESOURCE	*my_res = (MYSQLI_RESOURCE *)intern->ptr;
 
-	my_efree(my_res);	
+	my_efree(my_res);
 	zend_object_std_dtor(&intern->zo TSRMLS_CC);
 	efree(intern);
 }
 /* }}} */
 
+/* mysqli_link_free_storage partly doubles the work of PHP_FUNCTION(mysqli_close) */
+
 /* {{{ mysqli_link_free_storage
  */
 static void mysqli_link_free_storage(void *object TSRMLS_DC)
@@ -156,15 +223,23 @@
 	if (my_res && my_res->ptr) {
 		MY_MYSQL *mysql = (MY_MYSQL *)my_res->ptr;
 		if (mysql->mysql) {
-			mysql_close(mysql->mysql);
+			php_mysqli_close(mysql, MYSQLI_CLOSE_EXPLICIT, my_res->status TSRMLS_CC);
 		}
 		php_clear_mysql(mysql);
 		efree(mysql);
+		my_res->status = MYSQLI_STATUS_UNKNOWN;
 	}
 	mysqli_objects_free_storage(object TSRMLS_CC);
 }
 /* }}} */
 
+/* {{{ mysql_driver_free_storage */
+static void mysqli_driver_free_storage(void *object TSRMLS_DC)
+{
+	mysqli_objects_free_storage(object TSRMLS_CC);
+}
+/* }}} */
+
 /* {{{ mysqli_stmt_free_storage
  */
 static void mysqli_stmt_free_storage(void *object TSRMLS_DC)
@@ -175,7 +250,7 @@
 
 	if (my_res && my_res->ptr) {
 		MY_STMT *stmt = (MY_STMT *)my_res->ptr;
-		php_clear_stmt_bind(stmt);
+		php_clear_stmt_bind(stmt TSRMLS_CC);
 	}
 	mysqli_objects_free_storage(object TSRMLS_CC);
 }
@@ -229,6 +304,14 @@
 }
 /* }}} */
 
+#ifndef Z_ADDREF_P
+/* PHP 5.2, old GC */
+#define Z_ADDREF_P(pz)				(++(pz)->refcount)
+#define Z_REFCOUNT_P(pz)			((pz)->refcount)
+#define Z_SET_REFCOUNT_P(pz, rc)	((pz)->refcount = rc)
+#endif
+
+
 /* {{{ mysqli_read_property */
 zval *mysqli_read_property(zval *object, zval *member, int type TSRMLS_DC)
 {
@@ -236,13 +319,12 @@
 	zval *retval;
 	mysqli_object *obj;
 	mysqli_prop_handler *hnd;
-	zend_object_handlers *std_hnd;
 	int ret;
 
 	ret = FAILURE;
 	obj = (mysqli_object *)zend_objects_get_address(object TSRMLS_CC);
 
- 	if (member->type != IS_STRING) {
+	if (member->type != IS_STRING) {
 		tmp_member = *member;
 		zval_copy_ctor(&tmp_member);
 		convert_to_string(&tmp_member);
@@ -257,12 +339,12 @@
 		ret = hnd->read_func(obj, &retval TSRMLS_CC);
 		if (ret == SUCCESS) {
 			/* ensure we're creating a temporary variable */
-			retval->refcount = 0;
+			Z_SET_REFCOUNT_P(retval, 0);
 		} else {
 			retval = EG(uninitialized_zval_ptr);
 		}
 	} else {
-		std_hnd = zend_get_std_object_handlers();
+		zend_object_handlers * std_hnd = zend_get_std_object_handlers();
 		retval = std_hnd->read_property(object, member, type TSRMLS_CC);
 	}
 
@@ -279,10 +361,9 @@
 	zval tmp_member;
 	mysqli_object *obj;
 	mysqli_prop_handler *hnd;
-	zend_object_handlers *std_hnd;
 	int ret;
 
- 	if (member->type != IS_STRING) {
+	if (member->type != IS_STRING) {
 		tmp_member = *member;
 		zval_copy_ctor(&tmp_member);
 		convert_to_string(&tmp_member);
@@ -297,12 +378,12 @@
 	}
 	if (ret == SUCCESS) {
 		hnd->write_func(obj, value TSRMLS_CC);
-		if (! PZVAL_IS_REF(value) && value->refcount == 0) {
-			value->refcount++;
+		if (! PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) == 0) {
+			Z_ADDREF_P(value);
 			zval_ptr_dtor(&value);
 		}
 	} else {
-		std_hnd = zend_get_std_object_handlers();
+		zend_object_handlers * std_hnd = zend_get_std_object_handlers();
 		std_hnd->write_property(object, member, value TSRMLS_CC);
 	}
 
@@ -313,50 +394,89 @@
 /* }}} */
 
 /* {{{ void mysqli_add_property(HashTable *h, char *pname, mysqli_read_t r_func, mysqli_write_t w_func TSRMLS_DC) */
-void mysqli_add_property(HashTable *h, char *pname, mysqli_read_t r_func, mysqli_write_t w_func TSRMLS_DC) {
+void mysqli_add_property(HashTable *h, const char *pname, size_t pname_len, mysqli_read_t r_func, mysqli_write_t w_func TSRMLS_DC) {
 	mysqli_prop_handler		p;
 
-	p.read_func = (r_func) ? r_func : mysqli_read_na; 
+	p.name = (char*) pname;
+	p.name_len = pname_len;
+	p.read_func = (r_func) ? r_func : mysqli_read_na;
 	p.write_func = (w_func) ? w_func : mysqli_write_na;
-
-	zend_hash_add(h, pname, strlen(pname) + 1, &p, sizeof(mysqli_prop_handler), NULL);
+	zend_hash_add(h, pname, pname_len + 1, &p, sizeof(mysqli_prop_handler), NULL);
 }
 /* }}} */
 
-static union _zend_function *php_mysqli_constructor_get(zval *object TSRMLS_DC)
+static int mysqli_object_has_property(zval *object, zval *member, int has_set_exists TSRMLS_DC) /* {{{ */
 {
 	mysqli_object *obj = (mysqli_object *)zend_objects_get_address(object TSRMLS_CC);
-	zend_class_entry * ce = Z_OBJCE_P(object);
+	mysqli_prop_handler	p;
+	int ret = 0;
 
-	if (ce != mysqli_link_class_entry && ce != mysqli_stmt_class_entry &&
-		ce != mysqli_result_class_entry && ce != mysqli_driver_class_entry && 
-		ce != mysqli_warning_class_entry) {
-		return zend_std_get_constructor(object TSRMLS_CC);
+	if (zend_hash_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member) + 1, (void **)&p) == SUCCESS) {
+		switch (has_set_exists) {
+			case 2:
+				ret = 1;
+				break;
+			case 1: {
+				zval *value = mysqli_read_property(object, member, BP_VAR_IS TSRMLS_CC);
+				if (value != EG(uninitialized_zval_ptr)) {
+					convert_to_boolean(value);
+					ret = Z_BVAL_P(value)? 1:0;
+					/* refcount is 0 */
+					Z_ADDREF_P(value);
+					zval_ptr_dtor(&value);
+				}
+				break;
+			}
+			case 0:{
+				zval *value = mysqli_read_property(object, member, BP_VAR_IS TSRMLS_CC);
+				if (value != EG(uninitialized_zval_ptr)) {
+					ret = Z_TYPE_P(value) != IS_NULL? 1:0;
+					/* refcount is 0 */
+					Z_ADDREF_P(value);
+					zval_ptr_dtor(&value);
+				}
+				break;
+			}
+			default:
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid value for has_set_exists");
+		}
 	} else {
-		static zend_internal_function f;
+		zend_object_handlers * std_hnd = zend_get_std_object_handlers();
+		ret = std_hnd->has_property(object, member, has_set_exists TSRMLS_CC);
+	}
+	return ret;
+} /* }}} */
 
-		f.function_name = obj->zo.ce->name;
-		f.scope = obj->zo.ce;
-		f.arg_info = NULL;
-		f.num_args = 0;
-		f.fn_flags = 0;
 
-		f.type = ZEND_INTERNAL_FUNCTION;
-		if (obj->zo.ce == mysqli_link_class_entry) {
-			f.handler = ZEND_FN(mysqli_connect);
-		} else if (obj->zo.ce == mysqli_stmt_class_entry) {
-			f.handler = ZEND_FN(mysqli_stmt_construct);
-		} else if (obj->zo.ce == mysqli_result_class_entry) {
-			f.handler = ZEND_FN(mysqli_result_construct);
-		} else if (obj->zo.ce == mysqli_driver_class_entry) {
-			f.handler = ZEND_FN(mysqli_driver_construct);
-		} else if (obj->zo.ce == mysqli_warning_class_entry) {
-			f.handler = ZEND_MN(mysqli_warning___construct);
+#if PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 3
+HashTable * mysqli_object_get_debug_info(zval *object, int *is_temp TSRMLS_DC)
+{
+	mysqli_object *obj = (mysqli_object *)zend_objects_get_address(object TSRMLS_CC);
+	HashTable *retval, *props = obj->prop_handler;
+	HashPosition pos;
+	mysqli_prop_handler *entry;
+
+	ALLOC_HASHTABLE(retval);
+	ZEND_INIT_SYMTABLE_EX(retval, zend_hash_num_elements(props) + 1, 0);
+
+	zend_hash_internal_pointer_reset_ex(props, &pos);
+	while (zend_hash_get_current_data_ex(props, (void **)&entry, &pos) == SUCCESS) {
+		zval member;
+		zval *value;
+		INIT_ZVAL(member);
+		ZVAL_STRINGL(&member, entry->name, entry->name_len, 0);
+		value = mysqli_read_property(object, &member, BP_VAR_IS TSRMLS_CC);
+		if (value != EG(uninitialized_zval_ptr)) {
+			Z_ADDREF_P(value);
+			zend_hash_add(retval, entry->name, entry->name_len + 1, &value, sizeof(zval *), NULL);
 		}
-	
-		return (union _zend_function*)&f;
+		zend_hash_move_forward_ex(props, &pos);
 	}
+
+	*is_temp = 1;
+	return retval;
 }
+#endif
 
 /* {{{ mysqli_objects_new
  */
@@ -374,20 +494,22 @@
 	intern->prop_handler = NULL;
 
 	mysqli_base_class = class_type;
-	while (mysqli_base_class->type != ZEND_INTERNAL_CLASS && mysqli_base_class->parent != NULL)
-	{
+	while (mysqli_base_class->type != ZEND_INTERNAL_CLASS &&
+		   mysqli_base_class->parent != NULL) {
 		mysqli_base_class = mysqli_base_class->parent;
 	}
-	zend_hash_find(&classes, mysqli_base_class->name, mysqli_base_class->name_length + 1, 
+	zend_hash_find(&classes, mysqli_base_class->name, mysqli_base_class->name_length + 1,
 					(void **) &intern->prop_handler);
 
 	zend_object_std_init(&intern->zo, class_type TSRMLS_CC);
-	zend_hash_copy(intern->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,
+	zend_hash_copy(intern->zo.properties, &class_type->default_properties, (copy_ctor_func_t)  zval_property_ctor,
 					(void *) &tmp, sizeof(zval *));
 
 	/* link object */
 	if (instanceof_function(class_type, mysqli_link_class_entry TSRMLS_CC)) {
 		free_storage = mysqli_link_free_storage;
+	} else if (instanceof_function(class_type, mysqli_driver_class_entry TSRMLS_CC)) { /* driver object */
+		free_storage = mysqli_driver_free_storage;
 	} else if (instanceof_function(class_type, mysqli_stmt_class_entry TSRMLS_CC)) { /* stmt object */
 		free_storage = mysqli_stmt_free_storage;
 	} else if (instanceof_function(class_type, mysqli_result_class_entry TSRMLS_CC)) { /* result object */
@@ -404,64 +526,39 @@
 	return retval;
 }
 /* }}} */
-	
-/* {{{ mysqli_module_entry
- */
-/* Dependancies */
-static zend_module_dep mysqli_deps[] = {
-#if defined(HAVE_SPL) && ((PHP_MAJOR_VERSION > 5) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 1))
-	ZEND_MOD_REQUIRED("spl")
-#endif
-	{NULL, NULL, NULL}
-};
 
-zend_module_entry mysqli_module_entry = {
-#if ZEND_MODULE_API_NO >= 20050922
-	STANDARD_MODULE_HEADER_EX, NULL,
-	mysqli_deps,
-#elif ZEND_MODULE_API_NO >= 20010901
-	STANDARD_MODULE_HEADER,
-#endif
-	"mysqli",
-	mysqli_functions,
-	PHP_MINIT(mysqli),
-	PHP_MSHUTDOWN(mysqli),
-	PHP_RINIT(mysqli),
-	PHP_RSHUTDOWN(mysqli),
-	PHP_MINFO(mysqli),
-	"0.1", /* Replace with version number for your extension */
-	PHP_MODULE_GLOBALS(mysqli),
-	PHP_GINIT(mysqli),
-	NULL,
-	NULL,
-	STANDARD_MODULE_PROPERTIES_EX
-};
-/* }}} */
 
-#ifdef COMPILE_DL_MYSQLI
-ZEND_GET_MODULE(mysqli)
-#endif
-
 /* {{{ PHP_INI_BEGIN
 */
 PHP_INI_BEGIN()
 	STD_PHP_INI_ENTRY_EX("mysqli.max_links",			"-1",	PHP_INI_SYSTEM,		OnUpdateLong,		max_links,			zend_mysqli_globals,		mysqli_globals, display_link_numbers)
+	STD_PHP_INI_ENTRY_EX("mysqli.max_persistent",		"-1",	PHP_INI_SYSTEM,		OnUpdateLong,		max_persistent,		zend_mysqli_globals,		mysqli_globals,	display_link_numbers)
+	STD_PHP_INI_BOOLEAN("mysqli.allow_persistent",		"1",	PHP_INI_SYSTEM,		OnUpdateLong,		allow_persistent,	zend_mysqli_globals,		mysqli_globals)
 	STD_PHP_INI_ENTRY("mysqli.default_host",			NULL,	PHP_INI_ALL,		OnUpdateString,		default_host,		zend_mysqli_globals,		mysqli_globals)
 	STD_PHP_INI_ENTRY("mysqli.default_user",			NULL,	PHP_INI_ALL,		OnUpdateString,		default_user,		zend_mysqli_globals,		mysqli_globals)
 	STD_PHP_INI_ENTRY("mysqli.default_pw",				NULL,	PHP_INI_ALL,		OnUpdateString,		default_pw,			zend_mysqli_globals,		mysqli_globals)
 	STD_PHP_INI_ENTRY("mysqli.default_port",			"3306",	PHP_INI_ALL,		OnUpdateLong,		default_port,		zend_mysqli_globals,		mysqli_globals)
+#ifdef PHP_MYSQL_UNIX_SOCK_ADDR
+	STD_PHP_INI_ENTRY("mysqli.default_socket",			MYSQL_UNIX_ADDR,PHP_INI_ALL,OnUpdateStringUnempty,	default_socket,	zend_mysqli_globals,		mysqli_globals)
+#else
 	STD_PHP_INI_ENTRY("mysqli.default_socket",			NULL,	PHP_INI_ALL,		OnUpdateStringUnempty,	default_socket,	zend_mysqli_globals,		mysqli_globals)
+#endif
 	STD_PHP_INI_BOOLEAN("mysqli.reconnect",				"0",	PHP_INI_SYSTEM,		OnUpdateLong,		reconnect,			zend_mysqli_globals,		mysqli_globals)
+	STD_PHP_INI_BOOLEAN("mysqli.allow_local_infile",	"1",	PHP_INI_SYSTEM,		OnUpdateLong,		allow_local_infile,	zend_mysqli_globals,		mysqli_globals)
 PHP_INI_END()
-
 /* }}} */
 
+
 /* {{{ PHP_GINIT_FUNCTION
  */
 static PHP_GINIT_FUNCTION(mysqli)
 {
 	mysqli_globals->num_links = 0;
-	mysqli_globals->max_links = 0;
+	mysqli_globals->num_active_persistent = 0;
+	mysqli_globals->num_inactive_persistent = 0;
+	mysqli_globals->max_links = -1;
+	mysqli_globals->max_persistent = -1;
+	mysqli_globals->allow_persistent = 1;
 	mysqli_globals->default_port = 0;
 	mysqli_globals->default_host = NULL;
 	mysqli_globals->default_user = NULL;
@@ -470,6 +567,7 @@
 	mysqli_globals->reconnect = 0;
 	mysqli_globals->report_mode = 0;
 	mysqli_globals->report_ht = 0;
+	mysqli_globals->allow_local_infile = 1;
 #ifdef HAVE_EMBEDDED_MYSQLI
 	mysqli_globals->embedded = 1;
 #else
@@ -484,24 +582,32 @@
 {
 	zend_class_entry *ce,cex;
 	zend_object_handlers *std_hnd = zend_get_std_object_handlers();
-	
-	REGISTER_INI_ENTRIES();
 
+	REGISTER_INI_ENTRIES();
+#ifndef MYSQLI_USE_MYSQLND
 #if MYSQL_VERSION_ID >= 40000
 	if (mysql_server_init(0, NULL, NULL)) {
 		return FAILURE;
 	}
 #endif
+#endif
 
 	memcpy(&mysqli_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));
 	mysqli_object_handlers.clone_obj = NULL;
 	mysqli_object_handlers.read_property = mysqli_read_property;
 	mysqli_object_handlers.write_property = mysqli_write_property;
 	mysqli_object_handlers.get_property_ptr_ptr = std_hnd->get_property_ptr_ptr;
-	mysqli_object_handlers.get_constructor = php_mysqli_constructor_get;
+	mysqli_object_handlers.has_property = mysqli_object_has_property;
+#if PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 3
+	mysqli_object_handlers.get_debug_info = mysqli_object_get_debug_info;
+#endif
 
 	zend_hash_init(&classes, 0, NULL, NULL, 1);
 
+	/* persistent connections */
+	le_pmysqli = zend_register_list_destructors_ex(NULL, php_mysqli_dtor,
+		"MySqli persistent connection", module_number);
+
 	INIT_CLASS_ENTRY(cex, "mysqli_sql_exception", mysqli_exception_methods);
 #ifdef HAVE_SPL
 	mysqli_exception_class_entry = zend_register_internal_class_ex(&cex, spl_ce_RuntimeException, NULL TSRMLS_CC);
@@ -510,12 +616,13 @@
 #endif
 	mysqli_exception_class_entry->ce_flags |= ZEND_ACC_FINAL;
 	zend_declare_property_long(mysqli_exception_class_entry, "code", sizeof("code")-1, 0, ZEND_ACC_PROTECTED TSRMLS_CC);
-	zend_declare_property_string(mysqli_exception_class_entry, "sqlstate", sizeof("sqlstate")-1, "00000", ZEND_ACC_PROTECTED TSRMLS_CC);	
+	zend_declare_property_string(mysqli_exception_class_entry, "sqlstate", sizeof("sqlstate")-1, "00000", ZEND_ACC_PROTECTED TSRMLS_CC);
 
 	REGISTER_MYSQLI_CLASS_ENTRY("mysqli_driver", mysqli_driver_class_entry, mysqli_driver_methods);
 	ce = mysqli_driver_class_entry;
 	zend_hash_init(&mysqli_driver_properties, 0, NULL, NULL, 1);
 	MYSQLI_ADD_PROPERTIES(&mysqli_driver_properties, mysqli_driver_property_entries);
+	MYSQLI_ADD_PROPERTIES_INFO(ce, mysqli_driver_property_info_entries);
 	zend_hash_add(&classes, ce->name, ce->name_length+1, &mysqli_driver_properties, sizeof(mysqli_driver_properties), NULL);
 	ce->ce_flags |= ZEND_ACC_FINAL_CLASS;
 
@@ -523,6 +630,7 @@
 	ce = mysqli_link_class_entry;
 	zend_hash_init(&mysqli_link_properties, 0, NULL, NULL, 1);
 	MYSQLI_ADD_PROPERTIES(&mysqli_link_properties, mysqli_link_property_entries);
+	MYSQLI_ADD_PROPERTIES_INFO(ce, mysqli_link_property_info_entries);
 	zend_hash_add(&classes, ce->name, ce->name_length+1, &mysqli_link_properties, sizeof(mysqli_link_properties), NULL);
 
 	REGISTER_MYSQLI_CLASS_ENTRY("mysqli_warning", mysqli_warning_class_entry, mysqli_warning_methods);
@@ -530,28 +638,41 @@
 	ce->ce_flags |= ZEND_ACC_FINAL_CLASS | ZEND_ACC_PROTECTED;
 	zend_hash_init(&mysqli_warning_properties, 0, NULL, NULL, 1);
 	MYSQLI_ADD_PROPERTIES(&mysqli_warning_properties, mysqli_warning_property_entries);
+	MYSQLI_ADD_PROPERTIES_INFO(ce, mysqli_warning_property_info_entries);
 	zend_hash_add(&classes, ce->name, ce->name_length+1, &mysqli_warning_properties, sizeof(mysqli_warning_properties), NULL);
 
 	REGISTER_MYSQLI_CLASS_ENTRY("mysqli_result", mysqli_result_class_entry, mysqli_result_methods);
 	ce = mysqli_result_class_entry;
 	zend_hash_init(&mysqli_result_properties, 0, NULL, NULL, 1);
 	MYSQLI_ADD_PROPERTIES(&mysqli_result_properties, mysqli_result_property_entries);
+	MYSQLI_ADD_PROPERTIES_INFO(ce, mysqli_result_property_info_entries);
 	zend_hash_add(&classes, ce->name, ce->name_length+1, &mysqli_result_properties, sizeof(mysqli_result_properties), NULL);
 
 	REGISTER_MYSQLI_CLASS_ENTRY("mysqli_stmt", mysqli_stmt_class_entry, mysqli_stmt_methods);
 	ce = mysqli_stmt_class_entry;
 	zend_hash_init(&mysqli_stmt_properties, 0, NULL, NULL, 1);
 	MYSQLI_ADD_PROPERTIES(&mysqli_stmt_properties, mysqli_stmt_property_entries);
+	MYSQLI_ADD_PROPERTIES_INFO(ce, mysqli_stmt_property_info_entries);
 	zend_hash_add(&classes, ce->name, ce->name_length+1, &mysqli_stmt_properties, sizeof(mysqli_stmt_properties), NULL);
-	
+
 	/* mysqli_options */
 	REGISTER_LONG_CONSTANT("MYSQLI_READ_DEFAULT_GROUP", MYSQL_READ_DEFAULT_GROUP, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_READ_DEFAULT_FILE", MYSQL_READ_DEFAULT_FILE, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_OPT_CONNECT_TIMEOUT", MYSQL_OPT_CONNECT_TIMEOUT, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_OPT_LOCAL_INFILE", MYSQL_OPT_LOCAL_INFILE, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_INIT_COMMAND", MYSQL_INIT_COMMAND, CONST_CS | CONST_PERSISTENT);
+#if defined(MYSQLI_USE_MYSQLND)
+	REGISTER_LONG_CONSTANT("MYSQLI_OPT_NET_CMD_BUFFER_SIZE", MYSQLND_OPT_NET_CMD_BUFFER_SIZE, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_OPT_NET_READ_BUFFER_SIZE", MYSQLND_OPT_NET_READ_BUFFER_SIZE, CONST_CS | CONST_PERSISTENT);
+#endif
+#ifdef MYSQLND_STRING_TO_INT_CONVERSION
+	REGISTER_LONG_CONSTANT("MYSQLI_OPT_INT_AND_FLOAT_NATIVE", MYSQLND_OPT_INT_AND_FLOAT_NATIVE, CONST_CS | CONST_PERSISTENT);
+#endif
+#if MYSQL_VERSION_ID > 50110 || defined(MYSQLI_USE_MYSQLND)
+	REGISTER_LONG_CONSTANT("MYSQLI_OPT_SSL_VERIFY_SERVER_CERT", MYSQL_OPT_SSL_VERIFY_SERVER_CERT, CONST_CS | CONST_PERSISTENT);
+#endif
 
-	/* mysqli_real_connect flags */	
+	/* mysqli_real_connect flags */
 	REGISTER_LONG_CONSTANT("MYSQLI_CLIENT_SSL", CLIENT_SSL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_CLIENT_COMPRESS",CLIENT_COMPRESS, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_CLIENT_INTERACTIVE", CLIENT_INTERACTIVE, CONST_CS | CONST_PERSISTENT);
@@ -560,18 +681,21 @@
 	REGISTER_LONG_CONSTANT("MYSQLI_CLIENT_FOUND_ROWS", CLIENT_FOUND_ROWS, CONST_CS | CONST_PERSISTENT);
 
 	/* for mysqli_query */
-	REGISTER_LONG_CONSTANT("MYSQLI_STORE_RESULT", 0, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("MYSQLI_USE_RESULT", 1, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_STORE_RESULT", MYSQLI_STORE_RESULT, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_USE_RESULT", MYSQLI_USE_RESULT, CONST_CS | CONST_PERSISTENT);
+#if defined (MYSQLI_USE_MYSQLND)
+	REGISTER_LONG_CONSTANT("MYSQLI_ASYNC", MYSQLI_ASYNC, CONST_CS | CONST_PERSISTENT);
+#endif
 
 	/* for mysqli_fetch_assoc */
 	REGISTER_LONG_CONSTANT("MYSQLI_ASSOC", MYSQLI_ASSOC, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_NUM", MYSQLI_NUM, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_BOTH", MYSQLI_BOTH, CONST_CS | CONST_PERSISTENT);
-	
+
 	/* for mysqli_stmt_set_attr */
 	REGISTER_LONG_CONSTANT("MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH", STMT_ATTR_UPDATE_MAX_LENGTH, CONST_CS | CONST_PERSISTENT);
 
-#if MYSQL_VERSION_ID > 50003
+#if MYSQL_VERSION_ID > 50003 || defined(MYSQLI_USE_MYSQLND)
 	REGISTER_LONG_CONSTANT("MYSQLI_STMT_ATTR_CURSOR_TYPE", STMT_ATTR_CURSOR_TYPE, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_CURSOR_TYPE_NO_CURSOR", CURSOR_TYPE_NO_CURSOR, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_CURSOR_TYPE_READ_ONLY", CURSOR_TYPE_READ_ONLY, CONST_CS | CONST_PERSISTENT);
@@ -579,10 +703,10 @@
 	REGISTER_LONG_CONSTANT("MYSQLI_CURSOR_TYPE_SCROLLABLE", CURSOR_TYPE_SCROLLABLE, CONST_CS | CONST_PERSISTENT);
 #endif
 
-#if MYSQL_VERSION_ID > 50007
+#if MYSQL_VERSION_ID > 50007 || defined(MYSQLI_USE_MYSQLND)
 	REGISTER_LONG_CONSTANT("MYSQLI_STMT_ATTR_PREFETCH_ROWS", STMT_ATTR_PREFETCH_ROWS, CONST_CS | CONST_PERSISTENT);
 #endif
-	
+
 	/* column information */
 	REGISTER_LONG_CONSTANT("MYSQLI_NOT_NULL_FLAG", NOT_NULL_FLAG, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_PRI_KEY_FLAG", PRI_KEY_FLAG, CONST_CS | CONST_PERSISTENT);
@@ -597,7 +721,16 @@
 	REGISTER_LONG_CONSTANT("MYSQLI_NUM_FLAG", NUM_FLAG, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_PART_KEY_FLAG", PART_KEY_FLAG, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_GROUP_FLAG", GROUP_FLAG, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_ENUM_FLAG", ENUM_FLAG, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_BINARY_FLAG", BINARY_FLAG, CONST_CS | CONST_PERSISTENT);
+#if MYSQL_VERSION_ID > 50001 || defined(MYSQLI_USE_MYSQLND)
+	REGISTER_LONG_CONSTANT("MYSQLI_NO_DEFAULT_VALUE_FLAG", NO_DEFAULT_VALUE_FLAG, CONST_CS | CONST_PERSISTENT);
+#endif
 
+#if (MYSQL_VERSION_ID > 51122 && MYSQL_VERSION_ID < 60000) || (MYSQL_VERSION_ID > 60003) || defined(MYSQLI_USE_MYSQLND)
+	REGISTER_LONG_CONSTANT("MYSQLI_ON_UPDATE_NOW_FLAG", ON_UPDATE_NOW_FLAG, CONST_CS | CONST_PERSISTENT);
+#endif
+
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_DECIMAL", FIELD_TYPE_DECIMAL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_TINY", FIELD_TYPE_TINY, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_SHORT", FIELD_TYPE_SHORT, CONST_CS | CONST_PERSISTENT);
@@ -625,20 +758,14 @@
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_INTERVAL", FIELD_TYPE_INTERVAL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_GEOMETRY", FIELD_TYPE_GEOMETRY, CONST_CS | CONST_PERSISTENT);
 
-#if MYSQL_VERSION_ID > 50002
+#if MYSQL_VERSION_ID > 50002 || defined(MYSQLI_USE_MYSQLND)
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_NEWDECIMAL", FIELD_TYPE_NEWDECIMAL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_TYPE_BIT", FIELD_TYPE_BIT, CONST_CS | CONST_PERSISTENT);
 #endif
 
 	REGISTER_LONG_CONSTANT("MYSQLI_SET_CHARSET_NAME", MYSQL_SET_CHARSET_NAME, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_SET_CHARSET_DIR", MYSQL_SET_CHARSET_DIR, CONST_CS | CONST_PERSISTENT);
 
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	/* replication */
-	REGISTER_LONG_CONSTANT("MYSQLI_RPL_MASTER", MYSQL_RPL_MASTER, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("MYSQLI_RPL_SLAVE", MYSQL_RPL_SLAVE, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("MYSQLI_RPL_ADMIN", MYSQL_RPL_ADMIN, CONST_CS | CONST_PERSISTENT);
-#endif
-
 	/* bind support */
 	REGISTER_LONG_CONSTANT("MYSQLI_NO_DATA", MYSQL_NO_DATA, CONST_CS | CONST_PERSISTENT);
 #ifdef MYSQL_DATA_TRUNCATED
@@ -652,6 +779,38 @@
 	REGISTER_LONG_CONSTANT("MYSQLI_REPORT_ALL", MYSQLI_REPORT_ALL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("MYSQLI_REPORT_OFF", 0, CONST_CS | CONST_PERSISTENT);
 
+	/* We use non-nested macros with expansion, as VC has problems */
+#ifdef MYSQLI_USE_MYSQLND
+	REGISTER_LONG_CONSTANT("MYSQLI_DEBUG_TRACE_ENABLED", MYSQLND_DBG_ENABLED, CONST_CS | CONST_PERSISTENT);
+#else
+#ifndef DBUG_OFF
+	REGISTER_LONG_CONSTANT("MYSQLI_DEBUG_TRACE_ENABLED", 0, CONST_CS | CONST_PERSISTENT);
+#else
+	REGISTER_LONG_CONSTANT("MYSQLI_DEBUG_TRACE_ENABLED", 1, CONST_CS | CONST_PERSISTENT);
+#endif
+#endif
+
+	REGISTER_LONG_CONSTANT("MYSQLI_SERVER_QUERY_NO_GOOD_INDEX_USED", SERVER_QUERY_NO_GOOD_INDEX_USED, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_SERVER_QUERY_NO_INDEX_USED", SERVER_QUERY_NO_INDEX_USED, CONST_CS | CONST_PERSISTENT);
+#ifdef SERVER_QUERY_WAS_SLOW
+	REGISTER_LONG_CONSTANT("MYSQLI_SERVER_QUERY_WAS_SLOW", SERVER_QUERY_WAS_SLOW, CONST_CS | CONST_PERSISTENT);
+#endif
+#ifdef SERVER_PS_OUT_PARAMS
+	REGISTER_LONG_CONSTANT("MYSQLI_SERVER_PS_OUT_PARAMS", SERVER_PS_OUT_PARAMS, CONST_CS | CONST_PERSISTENT);
+#endif
+
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_GRANT",      REFRESH_GRANT, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_LOG",        REFRESH_LOG, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_TABLES",     REFRESH_TABLES, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_HOSTS",      REFRESH_HOSTS, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_STATUS",     REFRESH_STATUS, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_THREADS",    REFRESH_THREADS, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_SLAVE",      REFRESH_SLAVE, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_MASTER",     REFRESH_MASTER, CONST_CS | CONST_PERSISTENT);
+#ifdef REFRESH_BACKUP_LOG
+	REGISTER_LONG_CONSTANT("MYSQLI_REFRESH_BACKUP_LOG", REFRESH_BACKUP_LOG, CONST_CS | CONST_PERSISTENT);
+#endif
+
 	return SUCCESS;
 }
 /* }}} */
@@ -660,10 +819,14 @@
  */
 PHP_MSHUTDOWN_FUNCTION(mysqli)
 {
+#ifndef MYSQLI_USE_MYSQLND
 #if MYSQL_VERSION_ID >= 40000
 #ifdef PHP_WIN32
 	unsigned long client_ver = mysql_get_client_version();
-	/* Can't call mysql_server_end() multiple times prior to 5.0.42 on Windows */
+	/*
+	  Can't call mysql_server_end() multiple times prior to 5.0.46 on Windows.
+	  PHP bug#41350 MySQL bug#25621
+	*/
 	if ((client_ver >= 50046 && client_ver < 50100) || client_ver > 50122) {
 		mysql_server_end();
 	}
@@ -671,6 +834,7 @@
 	mysql_server_end();
 #endif
 #endif
+#endif
 
 	zend_hash_destroy(&mysqli_driver_properties);
 	zend_hash_destroy(&mysqli_result_properties);
@@ -688,7 +852,7 @@
  */
 PHP_RINIT_FUNCTION(mysqli)
 {
-#if defined(ZTS) && MYSQL_VERSION_ID >= 40000
+#if !defined(MYSQLI_USE_MYSQLND) && defined(ZTS) && MYSQL_VERSION_ID >= 40000
 	if (mysql_thread_init()) {
 		return FAILURE;
 	}
@@ -701,74 +865,150 @@
 }
 /* }}} */
 
+#if defined(A0) && defined(MYSQLI_USE_MYSQLND)
+static void php_mysqli_persistent_helper_for_every(void *p)
+{
+	TSRMLS_FETCH();
+	mysqlnd_end_psession((MYSQLND *) p);
+} /* }}} */
+
+
+static int php_mysqli_persistent_helper_once(zend_rsrc_list_entry *le TSRMLS_DC)
+{
+	if (le->type == php_le_pmysqli()) {
+		mysqli_plist_entry *plist = (mysqli_plist_entry *) le->ptr;
+		zend_ptr_stack_apply(&plist->free_links, php_mysqli_persistent_helper_for_every);
+	}
+	return ZEND_HASH_APPLY_KEEP;
+} /* }}} */
+#endif
+
+
 /* {{{ PHP_RSHUTDOWN_FUNCTION
  */
 PHP_RSHUTDOWN_FUNCTION(mysqli)
 {
-#if defined(ZTS) && MYSQL_VERSION_ID >= 40000
+	/* check persistent connections, move used to free */
+
+#if !defined(MYSQLI_USE_MYSQLND) && defined(ZTS) && MYSQL_VERSION_ID >= 40000
 	mysql_thread_end();
 #endif
 	if (MyG(error_msg)) {
 		efree(MyG(error_msg));
 	}
+#if defined(A0) && defined(MYSQLI_USE_MYSQLND)
+	/* psession is being called when the connection is freed - explicitly or implicitly */
+	zend_hash_apply(&EG(persistent_list), (apply_func_t) php_mysqli_persistent_helper_once TSRMLS_CC);
+#endif
 	return SUCCESS;
 }
 /* }}} */
 
+
 /* {{{ PHP_MINFO_FUNCTION
  */
 PHP_MINFO_FUNCTION(mysqli)
 {
+	char buf[32];
+
 	php_info_print_table_start();
 	php_info_print_table_header(2, "MysqlI Support", "enabled");
 	php_info_print_table_row(2, "Client API library version", mysql_get_client_info());
+	snprintf(buf, sizeof(buf), "%ld", MyG(num_active_persistent));
+	php_info_print_table_row(2, "Active Persistent Links", buf);
+	snprintf(buf, sizeof(buf), "%ld", MyG(num_inactive_persistent));
+	php_info_print_table_row(2, "Inactive Persistent Links", buf);
+	snprintf(buf, sizeof(buf), "%ld", MyG(num_links));
+	php_info_print_table_row(2, "Active Links", buf);
+#if !defined(MYSQLI_USE_MYSQLND)
 	php_info_print_table_row(2, "Client API header version", MYSQL_SERVER_VERSION);
 	php_info_print_table_row(2, "MYSQLI_SOCKET", MYSQL_UNIX_ADDR);
-	
-	
+#endif
 	php_info_print_table_end();
 
 	DISPLAY_INI_ENTRIES();
 }
 /* }}} */
 
-/* {{{ mixed mysqli_stmt_construct() 
+
+/* Dependancies */
+static const  zend_module_dep mysqli_deps[] = {
+#if defined(HAVE_SPL) && ((PHP_MAJOR_VERSION > 5) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 1))
+	ZEND_MOD_REQUIRED("spl")
+#endif
+#if defined(MYSQLI_USE_MYSQLND)
+	ZEND_MOD_REQUIRED("mysqlnd")
+#endif
+	{NULL, NULL, NULL}
+};
+
+/* {{{ mysqli_module_entry
+ */
+zend_module_entry mysqli_module_entry = {
+#if ZEND_MODULE_API_NO >= 20050922
+	STANDARD_MODULE_HEADER_EX, NULL,
+	mysqli_deps,
+#elif ZEND_MODULE_API_NO >= 20010901
+	STANDARD_MODULE_HEADER,
+#endif
+	"mysqli",
+	mysqli_functions,
+	PHP_MINIT(mysqli),
+	PHP_MSHUTDOWN(mysqli),
+	PHP_RINIT(mysqli),
+	PHP_RSHUTDOWN(mysqli),
+	PHP_MINFO(mysqli),
+	"0.1", /* Replace with version number for your extension */
+	PHP_MODULE_GLOBALS(mysqli),
+	PHP_GINIT(mysqli),
+	NULL,
+	NULL,
+	STANDARD_MODULE_PROPERTIES_EX
+};
+/* }}} */
+
+#ifdef COMPILE_DL_MYSQLI
+ZEND_GET_MODULE(mysqli)
+#endif
+
+
+/* {{{ mixed mysqli_stmt_construct()
 constructor for statement object.
-Parameters: 
+Parameters:
   object -> mysqli_stmt_init
   object, query -> mysqli_prepare
 */
-ZEND_FUNCTION(mysqli_stmt_construct)
+PHP_FUNCTION(mysqli_stmt_construct)
 {
 	MY_MYSQL			*mysql;
-	zval  				*mysql_link;
+	zval				*mysql_link;
 	MY_STMT				*stmt;
-	MYSQLI_RESOURCE 	*mysqli_resource;
+	MYSQLI_RESOURCE		*mysqli_resource;
 	char				*statement;
-	int					stmt_len;
+	int					statement_len;
 
 	switch (ZEND_NUM_ARGS())
 	{
 		case 1:  /* mysql_stmt_init */
-	        if (zend_parse_parameters(1 TSRMLS_CC, "O", &mysql_link, mysqli_link_class_entry)==FAILURE) {
+			if (zend_parse_parameters(1 TSRMLS_CC, "O", &mysql_link, mysqli_link_class_entry)==FAILURE) {
 				return;
 			}
-			MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+			MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 			stmt = (MY_STMT *)ecalloc(1,sizeof(MY_STMT));
 
 			stmt->stmt = mysql_stmt_init(mysql->mysql);
 		break;
 		case 2:
-	        if (zend_parse_parameters(2 TSRMLS_CC, "Os", &mysql_link, mysqli_link_class_entry, &statement, &stmt_len)==FAILURE) {
+			if (zend_parse_parameters(2 TSRMLS_CC, "Os", &mysql_link, mysqli_link_class_entry, &statement, &statement_len)==FAILURE) {
 				return;
 			}
-			MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+			MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 			stmt = (MY_STMT *)ecalloc(1,sizeof(MY_STMT));
-	
+
 			if ((stmt->stmt = mysql_stmt_init(mysql->mysql))) {
-				mysql_stmt_prepare(stmt->stmt, statement, stmt_len);
+				mysql_stmt_prepare(stmt->stmt, (char *)statement, statement_len);
 			}
 		break;
 		default:
@@ -789,38 +1029,46 @@
 }
 /* }}} */
 
-/* {{{ mixed mysqli_result_construct() 
+/* {{{ mixed mysqli_result_construct()
 constructor for result object.
-Parameters: 
+Parameters:
   object [, mode] -> mysqli_store/use_result
 */
-ZEND_FUNCTION(mysqli_result_construct)
+PHP_FUNCTION(mysqli_result_construct)
 {
 	MY_MYSQL			*mysql;
-	MYSQL_RES			*result;
+	MYSQL_RES			*result = NULL;
 	zval				*mysql_link;
-	MYSQLI_RESOURCE 	*mysqli_resource;
+	MYSQLI_RESOURCE		*mysqli_resource;
 	long				resmode = MYSQLI_STORE_RESULT;
 
 	switch (ZEND_NUM_ARGS()) {
 		case 1:
-	        if (zend_parse_parameters(1 TSRMLS_CC, "O", &mysql_link, mysqli_link_class_entry)==FAILURE) {
+			if (zend_parse_parameters(1 TSRMLS_CC, "O", &mysql_link, mysqli_link_class_entry)==FAILURE) {
 				return;
 			}
-		break;
+			break;
 		case 2:
-	        if (zend_parse_parameters(2 TSRMLS_CC, "Ol", &mysql_link, mysqli_link_class_entry, &resmode)==FAILURE) {
+			if (zend_parse_parameters(2 TSRMLS_CC, "Ol", &mysql_link, mysqli_link_class_entry, &resmode)==FAILURE) {
 				return;
 			}
-		break;
+			break;
 		default:
 			WRONG_PARAM_COUNT;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	result = (resmode == MYSQLI_STORE_RESULT) ? mysql_store_result(mysql->mysql) :
-												mysql_use_result(mysql->mysql);
+	switch (resmode) {
+		case MYSQLI_STORE_RESULT:
+			result = mysql_store_result(mysql->mysql);
+			break;
+		case MYSQLI_USE_RESULT:
+			result = mysql_use_result(mysql->mysql);
+			break;
+		default:
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid value for resultmode");
+	}
 
 	if (!result) {
 		RETURN_FALSE;
@@ -829,7 +1077,7 @@
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = (void *)result;
 	mysqli_resource->status = MYSQLI_STATUS_VALID;
-	
+
 	((mysqli_object *) zend_object_store_get_object(getThis() TSRMLS_CC))->ptr = mysqli_resource;
 
 }
@@ -842,12 +1090,15 @@
 	MYSQL_RES		*result;
 	zval			*mysql_result;
 	long			fetchtype;
+	zval			*ctor_params = NULL;
+	zend_class_entry *ce = NULL;
+#if !defined(MYSQLI_USE_MYSQLND)
 	unsigned int	i;
 	MYSQL_FIELD		*fields;
 	MYSQL_ROW		row;
 	unsigned long	*field_len;
-	zval            *ctor_params = NULL;
-	zend_class_entry *ce = NULL;
+	zend_bool magic_quotes_warning_sent = FALSE;
+#endif
 
 	if (into_object) {
 		char *class_name;
@@ -879,13 +1130,14 @@
 			}
 		}
 	}
-	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID); 
+	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
 
-	if ((fetchtype & MYSQLI_BOTH) == 0) {
+	if (fetchtype < MYSQLI_ASSOC || fetchtype > MYSQLI_BOTH) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "The result type should be either MYSQLI_NUM, MYSQLI_ASSOC or MYSQLI_BOTH");
 		RETURN_FALSE;
 	}
 
+#if !defined(MYSQLI_USE_MYSQLND)
 	if (!(row = mysql_fetch_row(result))) {
 		RETURN_NULL();
 	}
@@ -903,12 +1155,41 @@
 
 			MAKE_STD_ZVAL(res);
 
-			/* check if we need magic quotes */
-			if (PG(magic_quotes_runtime)) {
-				Z_TYPE_P(res) = IS_STRING;
-				Z_STRVAL_P(res) = php_addslashes(row[i], field_len[i], &Z_STRLEN_P(res), 0 TSRMLS_CC);
-			} else {
-				ZVAL_STRINGL(res, row[i], field_len[i], 1);	
+#if MYSQL_VERSION_ID > 50002
+			if (mysql_fetch_field_direct(result, i)->type == MYSQL_TYPE_BIT) {
+				my_ulonglong llval;
+				char tmp[22];
+				switch (field_len[i]) {
+					case 8:llval = (my_ulonglong)  bit_uint8korr(row[i]);break;
+					case 7:llval = (my_ulonglong)  bit_uint7korr(row[i]);break;
+					case 6:llval = (my_ulonglong)  bit_uint6korr(row[i]);break;
+					case 5:llval = (my_ulonglong)  bit_uint5korr(row[i]);break;
+					case 4:llval = (my_ulonglong)  bit_uint4korr(row[i]);break;
+					case 3:llval = (my_ulonglong)  bit_uint3korr(row[i]);break;
+					case 2:llval = (my_ulonglong)  bit_uint2korr(row[i]);break;
+					case 1:llval = (my_ulonglong)  uint1korr(row[i]);break;
+				}
+				/* even though lval is declared as unsigned, the value
+				 * may be negative. Therefor we cannot use MYSQLI_LLU_SPEC and must
+				 * use MYSQLI_LL_SPEC.
+				 */
+				snprintf(tmp, sizeof(tmp), (mysql_fetch_field_direct(result, i)->flags & UNSIGNED_FLAG)? MYSQLI_LLU_SPEC : MYSQLI_LL_SPEC, llval);
+				ZVAL_STRING(res, tmp, 1);
+			} else
+#endif
+			{
+
+				/* check if we need magic quotes */
+				if (PG(magic_quotes_runtime)) {
+					if (magic_quotes_warning_sent == FALSE) {
+						magic_quotes_warning_sent = TRUE;
+						php_error_docref(NULL TSRMLS_CC, E_WARNING, "magic_quotes_runtime are deprecated since PHP 5.3");
+					}
+					Z_TYPE_P(res) = IS_STRING;
+					Z_STRVAL_P(res) = php_addslashes(row[i], field_len[i], &Z_STRLEN_P(res), 0 TSRMLS_CC);
+				} else {
+					ZVAL_STRINGL(res, row[i], field_len[i], 1);
+				}
 			}
 
 			if (fetchtype & MYSQLI_NUM) {
@@ -916,7 +1197,7 @@
 			}
 			if (fetchtype & MYSQLI_ASSOC) {
 				if (fetchtype & MYSQLI_NUM) {
-					ZVAL_ADDREF(res);
+					Z_ADDREF_P(res);
 				}
 				add_assoc_zval(return_value, fields[i].name, res);
 			}
@@ -929,30 +1210,79 @@
 			}
 		}
 	}
+#else
+	if (PG(magic_quotes_runtime)) {
+		HashPosition pos_values;
+		zval **entry_values;
+		zval new_return_value;
+		char * string_key;
+		uint   string_key_len;
+		ulong  num_key;
 
-	if (into_object) {
+		mysqlnd_fetch_into(result, ((fetchtype & MYSQLI_NUM)? MYSQLND_FETCH_NUM:0) | ((fetchtype & MYSQLI_ASSOC)? MYSQLND_FETCH_ASSOC:0), &new_return_value, MYSQLND_MYSQLI);
+		if (Z_TYPE(new_return_value) == IS_ARRAY) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "magic_quotes_runtime are deprecated since PHP 5.3");
+			array_init(return_value);
+			zend_hash_internal_pointer_reset_ex(Z_ARRVAL(new_return_value), &pos_values);
+			while (zend_hash_get_current_data_ex(Z_ARRVAL(new_return_value), (void **)&entry_values, &pos_values) == SUCCESS) {
+				if (Z_TYPE_PP(entry_values) == IS_STRING) {
+					int new_str_len;
+					char * new_str = php_addslashes(Z_STRVAL_PP(entry_values), Z_STRLEN_PP(entry_values), &new_str_len, 0 TSRMLS_CC);
+					switch (zend_hash_get_current_key_ex(Z_ARRVAL(new_return_value), &string_key, &string_key_len, &num_key, 0, &pos_values)) {
+						case HASH_KEY_IS_LONG:
+							add_index_stringl(return_value, num_key, new_str, new_str_len, 0);
+							break;
+						case HASH_KEY_IS_STRING:
+							add_assoc_stringl_ex(return_value, string_key, string_key_len, new_str, new_str_len, 0);
+							break;
+					}
+				} else {
+					zval_add_ref(entry_values);
+					switch (zend_hash_get_current_key_ex(Z_ARRVAL(new_return_value), &string_key, &string_key_len, &num_key, 0, &pos_values)) {
+						case HASH_KEY_IS_LONG:
+							add_index_zval(return_value, num_key, *entry_values);
+							break;
+						case HASH_KEY_IS_STRING:
+							add_assoc_zval_ex(return_value, string_key, string_key_len, *entry_values);
+							break;
+					}
+				}
+				zend_hash_move_forward_ex(Z_ARRVAL(new_return_value), &pos_values);
+			}
+		} else {
+			RETVAL_NULL();
+		}
+		zval_dtor(&new_return_value);
+	} else {
+		mysqlnd_fetch_into(result, ((fetchtype & MYSQLI_NUM)? MYSQLND_FETCH_NUM:0) | ((fetchtype & MYSQLI_ASSOC)? MYSQLND_FETCH_ASSOC:0), return_value, MYSQLND_MYSQLI);
+	}
+
+#endif
+
+	if (into_object && Z_TYPE_P(return_value) == IS_ARRAY) {
 		zval dataset = *return_value;
 		zend_fcall_info fci;
 		zend_fcall_info_cache fcc;
-		zval *retval_ptr; 
-	
+		zval *retval_ptr;
+
 		object_and_properties_init(return_value, ce, NULL);
-	
+		zend_merge_properties(return_value, Z_ARRVAL(dataset), 1 TSRMLS_CC);
+
 		if (ce->constructor) {
 			fci.size = sizeof(fci);
 			fci.function_table = &ce->function_table;
 			fci.function_name = NULL;
 			fci.symbol_table = NULL;
-			fci.object_pp = &return_value;
+			fci.object_pp = return_value;
 			fci.retval_ptr_ptr = &retval_ptr;
 			if (ctor_params && Z_TYPE_P(ctor_params) != IS_NULL) {
 				if (Z_TYPE_P(ctor_params) == IS_ARRAY) {
-					HashTable *ht = Z_ARRVAL_P(ctor_params);
+					HashTable *params_ht = Z_ARRVAL_P(ctor_params);
 					Bucket *p;
-	
+
 					fci.param_count = 0;
-					fci.params = safe_emalloc(sizeof(zval*), ht->nNumOfElements, 0);
-					p = ht->pListHead;
+					fci.params = safe_emalloc(sizeof(zval*), params_ht->nNumOfElements, 0);
+					p = params_ht->pListHead;
 					while (p != NULL) {
 						fci.params[fci.param_count++] = (zval**)p->pData;
 						p = p->pListNext;
@@ -960,7 +1290,7 @@
 				} else {
 					/* Two problems why we throw exceptions here: PHP is typeless
 					 * and hence passing one argument that's not an array could be
-					 * by mistake and the other way round is possible, too. The 
+					 * by mistake and the other way round is possible, too. The
 					 * single value is an array. Also we'd have to make that one
 					 * argument passed by reference.
 					 */
@@ -976,8 +1306,8 @@
 			fcc.initialized = 1;
 			fcc.function_handler = ce->constructor;
 			fcc.calling_scope = EG(scope);
-			fcc.object_pp = &return_value;
-		
+			fcc.object_pp = return_value;
+
 			if (zend_call_function(&fci, &fcc TSRMLS_CC) == FAILURE) {
 				zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, "Could not execute %s::%s()", ce->name, ce->constructor->common.function_name);
 			} else {
@@ -991,28 +1321,13 @@
 		} else if (ctor_params) {
 			zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, "Class %s does not have a constructor hence you cannot use ctor_params", ce->name);
 		}
-		
-		zend_merge_properties(return_value, Z_ARRVAL(dataset), 1 TSRMLS_CC);
 	}
 }
 /* }}} */
 
-/* {{{ php_mysqli_set_error
- */
-PHP_MYSQLI_API void php_mysqli_set_error(long mysql_errno, char *mysql_err TSRMLS_DC)
-{
-	MyG(error_no) = mysql_errno;
-	if (MyG(error_msg)) {
-		efree(MyG(error_msg));
-	}
-	if(mysql_err && *mysql_err) {
-		MyG(error_msg) = estrdup(mysql_err);
-	} else {
-		MyG(error_msg) = NULL;
-	}
-}
-/* }}} */
 
+#if !defined(MYSQLI_USE_MYSQLND)
+
 #define ALLOC_CALLBACK_ARGS(a, b, c)\
 if (c) {\
 	a = (zval ***)safe_emalloc(c, sizeof(zval **), 0);\
@@ -1032,26 +1347,18 @@
 }
 
 #define LOCAL_INFILE_ERROR_MSG(source,dest)\
-memset(source, 0, LOCAL_INFILE_ERROR_LEN);\
-memcpy(source, dest, LOCAL_INFILE_ERROR_LEN-1);
+	memset(source, 0, LOCAL_INFILE_ERROR_LEN);\
+	memcpy(source, dest, MIN(strlen(dest), LOCAL_INFILE_ERROR_LEN-1));\
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", dest);
 
-/* {{{ void php_set_local_infile_handler_default 
-*/
-void php_set_local_infile_handler_default(MY_MYSQL *mysql) {
-	/* register internal callback functions */
-	mysql_set_local_infile_handler(mysql->mysql, &php_local_infile_init, &php_local_infile_read,
-				&php_local_infile_end, &php_local_infile_error, (void *)mysql);
-	mysql->li_read = NULL;
-}
-/* }}} */
 
 /* {{{ php_local_infile_init
  */
-int php_local_infile_init(void **ptr, const char *filename, void *userdata)
+static int php_local_infile_init(void **ptr, const char *filename, void *userdata)
 {
 	mysqli_local_infile			*data;
-	MY_MYSQL 					*mysql;
-	php_stream_context 			*context = NULL;
+	MY_MYSQL					*mysql;
+	php_stream_context			*context = NULL;
 
 	TSRMLS_FETCH();
 
@@ -1076,7 +1383,7 @@
 	mysql->li_stream = php_stream_open_wrapper_ex((char *)filename, "r", 0, NULL, context);
 
 	if (mysql->li_stream == NULL) {
-		snprintf((char *)data->error_msg, sizeof(data->error_msg), "Can't find file '%-.64s'.", filename);	
+		snprintf((char *)data->error_msg, sizeof(data->error_msg), "Can't find file '%-.64s'.", filename);
 		return 1;
 	}
 
@@ -1087,10 +1394,10 @@
 /* }}} */
 
 /* {{{ int php_local_infile_read */
-int php_local_infile_read(void *ptr, char *buf, uint buf_len)
+static int php_local_infile_read(void *ptr, char *buf, uint buf_len)
 {
-	mysqli_local_infile 		*data;
-	MY_MYSQL 					*mysql;
+	mysqli_local_infile			*data;
+	MY_MYSQL					*mysql;
 	zval						***callback_args;
 	zval						*retval;
 	zval						*fp;
@@ -1105,10 +1412,8 @@
 
 	/* default processing */
 	if (!mysql->li_read) {
-		int			count;
+		int count = (int)php_stream_read(mysql->li_stream, buf, buf_len);
 
-		count = (int)php_stream_read(mysql->li_stream, buf, buf_len);
-
 		if (count < 0) {
 			LOCAL_INFILE_ERROR_MSG(data->error_msg, ER(2));
 		}
@@ -1117,21 +1422,21 @@
 	}
 
 	ALLOC_CALLBACK_ARGS(callback_args, 1, argc);
-	
+
 	/* set parameters: filepointer, buffer, buffer_len, errormsg */
 
 	MAKE_STD_ZVAL(fp);
 	php_stream_to_zval(mysql->li_stream, fp);
 	callback_args[0] = &fp;
-	ZVAL_STRING(*callback_args[1], "", 1);	
-	ZVAL_LONG(*callback_args[2], buf_len);	
-	ZVAL_STRING(*callback_args[3], "", 1);	
-	
-	if (call_user_function_ex(EG(function_table), 
+	ZVAL_STRING(*callback_args[1], "", 1);
+	ZVAL_LONG(*callback_args[2], buf_len);
+	ZVAL_STRING(*callback_args[3], "", 1);
+
+	if (call_user_function_ex(EG(function_table),
 						NULL,
 						mysql->li_read,
 						&retval,
-						argc,	 	
+						argc,
 						callback_args,
 						0,
 						NULL TSRMLS_CC) == SUCCESS) {
@@ -1140,22 +1445,36 @@
 		zval_ptr_dtor(&retval);
 
 		if (rc > 0) {
-			if (rc > buf_len) {
+			if (rc >= 0 && rc != Z_STRLEN_P(*callback_args[1])) {
+				LOCAL_INFILE_ERROR_MSG(data->error_msg,
+							"Mismatch between the return value of the callback and the content "
+							"length of the buffer.");
+				rc = -1;
+			} else if (rc > buf_len) {
 				/* check buffer overflow */
-				LOCAL_INFILE_ERROR_MSG(data->error_msg, "Read buffer too large");
+				LOCAL_INFILE_ERROR_MSG(data->error_msg, "Too much data returned");
 				rc = -1;
 			} else {
-				memcpy(buf, Z_STRVAL_P(*callback_args[1]), rc);
+				memcpy(buf, Z_STRVAL_P(*callback_args[1]), MIN(rc, Z_STRLEN_P(*callback_args[1])));
 			}
-		}
-		if (rc < 0) {
+		} else if (rc < 0) {
 			LOCAL_INFILE_ERROR_MSG(data->error_msg, Z_STRVAL_P(*callback_args[3]));
 		}
 	} else {
 		LOCAL_INFILE_ERROR_MSG(data->error_msg, "Can't execute load data local init callback function");
 		rc = -1;
 	}
-	
+	/*
+	  If the (ab)user has closed the file handle we should
+	  not try to use it anymore or even close it
+	*/
+	if (!zend_rsrc_list_get_rsrc_type(Z_LVAL_P(fp) TSRMLS_CC)) {
+		LOCAL_INFILE_ERROR_MSG(data->error_msg, "File handle closed");
+		rc = -1;
+		/* Thus the end handler won't try to free already freed memory */
+		mysql->li_stream = NULL;
+	}
+
 	FREE_CALLBACK_ARGS(callback_args, 1, argc);
 	efree(fp);
 	return rc;
@@ -1164,14 +1483,14 @@
 
 /* {{{ php_local_infile_error
  */
-int php_local_infile_error(void *ptr, char *error_msg, uint error_msg_len)
+static int php_local_infile_error(void *ptr, char *error_msg, uint error_msg_len)
 {
 	mysqli_local_infile *data = (mysqli_local_infile *) ptr;
 
 	if (data) {
 		strlcpy(error_msg, data->error_msg, error_msg_len);
 		return 2000;
-	} 
+	}
 	strlcpy(error_msg, ER(CR_OUT_OF_MEMORY), error_msg_len);
 	return CR_OUT_OF_MEMORY;
 }
@@ -1179,10 +1498,10 @@
 
 /* {{{ php_local_infile_end
  */
-void php_local_infile_end(void *ptr) 
+static void php_local_infile_end(void *ptr)
 {
-	mysqli_local_infile			*data;
-	MY_MYSQL 					*mysql;
+	mysqli_local_infile		*data;
+	MY_MYSQL				*mysql;
 
 	TSRMLS_FETCH();
 
@@ -1199,9 +1518,24 @@
 		php_stream_close(mysql->li_stream);
 	}
 	free(data);
-	return;	
+	return;
 }
 /* }}} */
+
+
+/* {{{ void php_set_local_infile_handler_default
+*/
+void php_set_local_infile_handler_default(MY_MYSQL *mysql) {
+	/* register internal callback functions */
+	mysql_set_local_infile_handler(mysql->mysql, &php_local_infile_init, &php_local_infile_read,
+				&php_local_infile_end, &php_local_infile_error, (void *)mysql);
+	if (mysql->li_read) {
+		zval_ptr_dtor(&mysql->li_read);
+		mysql->li_read = NULL;
+	}
+}
+/* }}} */
+#endif
 
 /*
  * Local variables:
--- a/ext/mysqli/mysqli_api.c
+++ b/ext/mysqli/mysqli_api.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -12,10 +12,12 @@
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
-  | Author: Georg Richter <georg@php.net>                                |
+  | Authors: Georg Richter <georg@php.net>                               |
+  |          Andrey Hristov <andrey@php.net>                             |
+  |          Ulf Wendel <uw@php.net>                                     |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli_api.c 298253 2010-04-21 12:52:24Z felipe $ 
+  $Id$
 */
 
 #ifdef HAVE_CONFIG_H
@@ -26,8 +28,10 @@
 
 #include "php.h"
 #include "php_ini.h"
+#include "php_globals.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_priv.h"
 
 /* {{{ proto mixed mysqli_affected_rows(object link)
    Get number of affected rows in previous MySQL operation */
@@ -41,7 +45,7 @@
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	rc = mysql_affected_rows(mysql->mysql);
 	if (rc == (my_ulonglong) -1) {
@@ -51,18 +55,19 @@
 }
 /* }}} */
 
+
 /* {{{ proto bool mysqli_autocommit(object link, bool mode)
    Turn auto commit on or of */
 PHP_FUNCTION(mysqli_autocommit)
 {
-	MY_MYSQL 		*mysql;
-	zval  			*mysql_link;
-	zend_bool		automode;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
+	zend_bool	automode;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ob", &mysql_link, mysqli_link_class_entry, &automode) == FAILURE) {
-		return;	
+		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (mysql_autocommit(mysql->mysql, (my_bool)automode)) {
 		RETURN_FALSE;
@@ -71,83 +76,42 @@
 }
 /* }}} */
 
-/* {{{ proto bool mysqli_stmt_bind_param(object stmt, string types, mixed variable [,mixed,....])
-   Bind variables to a prepared statement as parameters */
-PHP_FUNCTION(mysqli_stmt_bind_param)
+/* {{{ mysqli_stmt_bind_param_do_bind */
+#ifndef MYSQLI_USE_MYSQLND
+static
+int mysqli_stmt_bind_param_do_bind(MY_STMT *stmt, unsigned int argc, unsigned int num_vars,
+								   zval ***args, unsigned int start, const char * const types TSRMLS_DC)
 {
-	zval 			***args;
-	int     		argc = ZEND_NUM_ARGS();
-	int 	    	i;
-	int				num_vars;
-	int				start = 2;
-	int				ofs;
-	MY_STMT			*stmt;
-	zval 			*mysql_stmt;
+	int				i, ofs;
 	MYSQL_BIND		*bind;
-	char			*types;
-	int				typelen;
 	unsigned long	rc;
 
-	/* calculate and check number of parameters */
-	if (argc < 2) {
-		/* there has to be at least one pair */
-		WRONG_PARAM_COUNT;
-	}
-
-	if (zend_parse_method_parameters((getThis()) ? 1:2 TSRMLS_CC, getThis(), "Os", &mysql_stmt, mysqli_stmt_class_entry, &types, &typelen) == FAILURE) {
-		return;	
-	}
-
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID); 
-
-	num_vars = argc - 1;
-	if (getThis()) {
-		start = 1;
-	} else {
-		/* ignore handle parameter in procedural interface*/
-		--num_vars;
-	}
-
-	if (typelen != argc - start) {
-		/* number of bind variables doesn't match number of elements in type definition string */
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of elements in type definition string doesn't match number of bind variables");
-		RETURN_FALSE;
-	}
-
-	if (typelen != stmt->stmt->param_count) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of variables doesn't match number of parameters in prepared statement");
-		RETURN_FALSE;
-	}
-
 	/* prevent leak if variables are already bound */
 	if (stmt->param.var_cnt) {
 		php_free_stmt_bind_buffer(stmt->param, FETCH_SIMPLE);
 	}
 
-	args = (zval ***)safe_emalloc(argc, sizeof(zval **), 0);
-
-	if (zend_get_parameters_array_ex(argc, args) == FAILURE) {
-		efree(args);
-		WRONG_PARAM_COUNT;
-	}
-
 	stmt->param.is_null = ecalloc(num_vars, sizeof(char));
-	bind = (MYSQL_BIND *)ecalloc(num_vars, sizeof(MYSQL_BIND));
+	bind = (MYSQL_BIND *) ecalloc(num_vars, sizeof(MYSQL_BIND));
 
 	ofs = 0;
-	for (i=start; i < argc; i++) {
+	for (i = start; i < argc; i++) {
 
 		/* set specified type */
 		switch (types[ofs]) {
 			case 'd': /* Double */
 				bind[ofs].buffer_type = MYSQL_TYPE_DOUBLE;
-				bind[ofs].buffer = (char*)&Z_DVAL_PP(args[i]);
+				bind[ofs].buffer = &Z_DVAL_PP(args[i]);
 				bind[ofs].is_null = &stmt->param.is_null[ofs];
 				break;
 
 			case 'i': /* Integer */
+#if SIZEOF_LONG==8
+				bind[ofs].buffer_type = MYSQL_TYPE_LONGLONG;
+#elif SIZEOF_LONG==4
 				bind[ofs].buffer_type = MYSQL_TYPE_LONG;
-				bind[ofs].buffer = (char*)&Z_LVAL_PP(args[i]);
+#endif
+				bind[ofs].buffer = &Z_LVAL_PP(args[i]);
 				bind[ofs].is_null = &stmt->param.is_null[ofs];
 				break;
 
@@ -164,86 +128,166 @@
 
 			default:
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Undefined fieldtype %c (parameter %d)", types[ofs], i+1);
-				RETVAL_FALSE;
-				goto end;
+				rc = 1;
+				goto end_1;
 		}
 		ofs++;
 	}
 	rc = mysql_stmt_bind_param(stmt->stmt, bind);
-	MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
 
+end_1:
 	if (rc) {
-		RETVAL_FALSE;
-		goto end;
+		efree(stmt->param.is_null);
+	} else {
+		stmt->param.var_cnt = num_vars;
+		stmt->param.vars = (zval **)safe_emalloc(num_vars, sizeof(zval), 0);
+		for (i = 0; i < num_vars; i++) {
+			if (bind[i].buffer_type  != MYSQL_TYPE_LONG_BLOB) {
+				Z_ADDREF_P(*args[i+start]);
+				stmt->param.vars[i] = *args[i+start];
+			} else {
+				stmt->param.vars[i] = NULL;
+			}
+		}
 	}
+	efree(bind);
 
-	stmt->param.var_cnt = num_vars;
-	stmt->param.vars = (zval **)safe_emalloc(num_vars, sizeof(zval), 0);
-	for (i = 0; i < num_vars; i++) {
-		if (bind[i].buffer_type  != MYSQL_TYPE_LONG_BLOB) {
-			ZVAL_ADDREF(*args[i+start]);
-			stmt->param.vars[i] = *args[i+start];
-		} else {
-			stmt->param.vars[i] = NULL;
+	return rc;
+}
+#else
+static
+int mysqli_stmt_bind_param_do_bind(MY_STMT *stmt, unsigned int argc, unsigned int num_vars,
+								   zval ***args, unsigned int start, const char * const types TSRMLS_DC)
+{
+	unsigned int i;
+	MYSQLND_PARAM_BIND	*params;
+	enum_func_status	ret = FAIL;
+
+	/* If no params -> skip binding and return directly */
+	if (argc == start) {
+		return PASS;
+	}
+	params = mysqlnd_stmt_alloc_param_bind(stmt->stmt);
+	if (!params) {
+		goto end;
+	}
+	for (i = 0; i < (argc - start); i++) {
+		zend_uchar type;
+		switch (types[i]) {
+			case 'd': /* Double */
+				type = MYSQL_TYPE_DOUBLE;
+				break;
+			case 'i': /* Integer */
+#if SIZEOF_LONG==8
+				type = MYSQL_TYPE_LONGLONG;
+#elif SIZEOF_LONG==4
+				type = MYSQL_TYPE_LONG;
+#endif
+				break;
+			case 'b': /* Blob (send data) */
+				type = MYSQL_TYPE_LONG_BLOB;
+				break;
+			case 's': /* string */
+				type = MYSQL_TYPE_VAR_STRING;
+				break;
+			default:
+				/* We count parameters from 1 */
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Undefined fieldtype %c (parameter %d)", types[i], i + start + 1);
+				ret = FAIL;
+				mysqlnd_stmt_free_param_bind(stmt->stmt, params);
+				goto end;
 		}
+		params[i].zv = *(args[i + start]);
+		params[i].type = type;
 	}
-	RETVAL_TRUE;
+	ret = mysqlnd_stmt_bind_param(stmt->stmt, params);
+
 end:
-	efree(args);
-	efree(bind);
+	return ret;
 }
+#endif
 /* }}} */
 
-/* {{{ proto bool mysqli_stmt_bind_result(object stmt, mixed var, [,mixed, ...])
-   Bind variables to a prepared statement for result storage */
+/* {{{ proto bool mysqli_stmt_bind_param(object stmt, string types, mixed variable [,mixed,....]) U
+   Bind variables to a prepared statement as parameters */
+PHP_FUNCTION(mysqli_stmt_bind_param)
+{
+	zval			***args;
+	int				argc = ZEND_NUM_ARGS();
+	int				num_vars;
+	int				start = 2;
+	MY_STMT			*stmt;
+	zval			*mysql_stmt;
+	char			*types;
+	int				types_len;
+	unsigned long	rc;
 
-/* TODO:
-   do_alloca, free_alloca
-*/
+	/* calculate and check number of parameters */
+	if (argc < 2) {
+		/* there has to be at least one pair */
+		WRONG_PARAM_COUNT;
+	}
 
-PHP_FUNCTION(mysqli_stmt_bind_result)
-{
-	zval 		***args;
-	int     	argc = ZEND_NUM_ARGS();
-	int     	i;
-	int			start = 1;
-	int			var_cnt;
-	int			ofs;
-	long		col_type;
-	ulong		rc;
-	MY_STMT 	*stmt;
-	zval 		*mysql_stmt;
-	MYSQL_BIND 	*bind;
+	if (zend_parse_method_parameters((getThis()) ? 1:2 TSRMLS_CC, getThis(), "Os", &mysql_stmt, mysqli_stmt_class_entry,
+									&types, &types_len) == FAILURE) {
+		return;
+	}
 
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+	num_vars = argc - 1;
 	if (getThis()) {
-		start = 0;
+		start = 1;
+	} else {
+		/* ignore handle parameter in procedural interface*/
+		--num_vars;
 	}
+	if (!types_len) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type or no types specified");
+		RETURN_FALSE;
+	}
 
-	if (zend_parse_method_parameters((getThis()) ? 0:1 TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
-		return;	
+	if (types_len != argc - start) {
+		/* number of bind variables doesn't match number of elements in type definition string */
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of elements in type definition string doesn't match number of bind variables");
+		RETURN_FALSE;
 	}
 
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID); 
-
-	if (argc < (getThis() ? 1 : 2))  {
-		WRONG_PARAM_COUNT;
+	if (types_len != mysql_stmt_param_count(stmt->stmt)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of variables doesn't match number of parameters in prepared statement");
+		RETURN_FALSE;
 	}
 
 	args = (zval ***)safe_emalloc(argc, sizeof(zval **), 0);
 
 	if (zend_get_parameters_array_ex(argc, args) == FAILURE) {
-		efree(args);
-		WRONG_PARAM_COUNT;
+		zend_wrong_param_count(TSRMLS_C);
+		rc = 1;
+	} else {
+		rc = mysqli_stmt_bind_param_do_bind(stmt, argc, num_vars, args, start, types TSRMLS_CC);
+		MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
 	}
 
-	var_cnt = argc - start;
+	efree(args);
 
-	if (var_cnt != mysql_stmt_field_count(stmt->stmt)) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of bind variables doesn't match number of fields in prepared statement");
-		efree(args);
-		RETURN_FALSE;
-	}
+	RETURN_BOOL(!rc);
+}
+/* }}} */
 
+/* {{{ mysqli_stmt_bind_result_do_bind */
+#ifndef MYSQLI_USE_MYSQLND
+/* TODO:
+   do_alloca, free_alloca
+*/
+static int
+mysqli_stmt_bind_result_do_bind(MY_STMT *stmt, zval ***args, unsigned int argc, unsigned int start TSRMLS_DC)
+{
+	MYSQL_BIND	*bind;
+	int			i, ofs;
+	int			var_cnt = argc - start;
+	long		col_type;
+	ulong		rc;
+
 	/* prevent leak if variables are already bound */
 	if (stmt->result.var_cnt) {
 		php_free_stmt_bind_buffer(stmt->result, FETCH_RESULT);
@@ -268,7 +312,7 @@
 				convert_to_double_ex(args[i]);
 				stmt->result.buf[ofs].type = IS_DOUBLE;
 				stmt->result.buf[ofs].buflen = sizeof(double);
-				
+
 				/* allocate buffer for double */
 				stmt->result.buf[ofs].val = (char *)emalloc(sizeof(double));
 				bind[ofs].buffer_type = MYSQL_TYPE_DOUBLE;
@@ -305,17 +349,18 @@
 				break;
 
 			case MYSQL_TYPE_LONGLONG:
-#if MYSQL_VERSION_ID > 50002
+#if MYSQL_VERSION_ID > 50002 || defined(MYSQLI_USE_MYSQLND)
 			case MYSQL_TYPE_BIT:
 #endif
-				stmt->result.buf[ofs].type = IS_STRING; 
-				stmt->result.buf[ofs].buflen = sizeof(my_ulonglong); 
+				stmt->result.buf[ofs].type = IS_STRING;
+				stmt->result.buf[ofs].buflen = sizeof(my_ulonglong);
 				stmt->result.buf[ofs].val = (char *)emalloc(stmt->result.buf[ofs].buflen);
 				bind[ofs].buffer_type = col_type;
 				bind[ofs].buffer = stmt->result.buf[ofs].val;
 				bind[ofs].is_null = &stmt->result.is_null[ofs];
 				bind[ofs].buffer_length = stmt->result.buf[ofs].buflen;
 				bind[ofs].is_unsigned = (stmt->stmt->fields[ofs].flags & UNSIGNED_FLAG) ? 1 : 0;
+				bind[ofs].length = &stmt->result.buf[ofs].output_len;
 				break;
 
 			case MYSQL_TYPE_DATE:
@@ -324,33 +369,41 @@
 			case MYSQL_TYPE_NEWDATE:
 			case MYSQL_TYPE_VAR_STRING:
 			case MYSQL_TYPE_STRING:
-			case MYSQL_TYPE_BLOB:
 			case MYSQL_TYPE_TINY_BLOB:
+			case MYSQL_TYPE_BLOB:
 			case MYSQL_TYPE_MEDIUM_BLOB:
 			case MYSQL_TYPE_LONG_BLOB:
 			case MYSQL_TYPE_TIMESTAMP:
 			case MYSQL_TYPE_DECIMAL:
+			case MYSQL_TYPE_GEOMETRY:
 #ifdef FIELD_TYPE_NEWDECIMAL
 			case MYSQL_TYPE_NEWDECIMAL:
 #endif
 			{
-#if MYSQL_VERSION_ID > 50099
+#if MYSQL_VERSION_ID >= 50107
 				/* Changed to my_bool in MySQL 5.1. See MySQL Bug #16144 */
 				my_bool tmp;
 #else
-				ulong tmp = 0;
+				uint tmp = 0;
 #endif
 				stmt->result.buf[ofs].type = IS_STRING;
 				/*
 					If the user has called $stmt->store_result() then we have asked
 					max_length to be updated. this is done only for BLOBS because we don't want to allocate
-					big chunkgs of memory 2^16 or 2^24 
+					big chunkgs of memory 2^16 or 2^24
 				*/
 				if (stmt->stmt->fields[ofs].max_length == 0 &&
 					!mysql_stmt_attr_get(stmt->stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &tmp) && !tmp)
 				{
+					/*
+					  Allocate directly 256 because it's easier to allocate a bit more
+					  than update max length even for text columns. Try SELECT UNION SELECT UNION with
+					  different lengths and you will see that we get different lengths in stmt->stmt->fields[ofs].length
+					  The just take 256 and saves us from realloc-ing.
+					*/
 					stmt->result.buf[ofs].buflen =
 						(stmt->stmt->fields) ? (stmt->stmt->fields[ofs].length) ? stmt->stmt->fields[ofs].length + 1: 256: 256;
+
 				} else {
 					/*
 						the user has called store_result(). if he does not there is no way to determine the
@@ -385,43 +438,119 @@
 		}
 		/* Don't free stmt->result.is_null because is_null & buf are one block of memory  */
 		efree(stmt->result.buf);
-		RETVAL_FALSE;
 	} else {
 		stmt->result.var_cnt = var_cnt;
 		stmt->result.vars = (zval **)safe_emalloc((var_cnt), sizeof(zval), 0);
 		for (i = start; i < var_cnt+start; i++) {
 			ofs = i-start;
-			ZVAL_ADDREF(*args[i]);
+			Z_ADDREF_PP(args[i]);
 			stmt->result.vars[ofs] = *args[i];
 		}
-		RETVAL_TRUE;
 	}
-	efree(args);
 	efree(bind);
+
+	return rc;
 }
+#else
+static int
+mysqli_stmt_bind_result_do_bind(MY_STMT *stmt, zval ***args, unsigned int argc, unsigned int start TSRMLS_DC)
+{
+	unsigned int i;
+	MYSQLND_RESULT_BIND * params = mysqlnd_stmt_alloc_result_bind(stmt->stmt);
+	if (params) {
+		for (i = 0; i < (argc - start); i++) {
+			params[i].zv = *(args[i + start]);
+		}
+		return mysqlnd_stmt_bind_result(stmt->stmt, params);
+	}
+	return FAIL;
+}
+#endif
 /* }}} */
 
+/* {{{ proto bool mysqli_stmt_bind_result(object stmt, mixed var, [,mixed, ...]) U
+   Bind variables to a prepared statement for result storage */
+PHP_FUNCTION(mysqli_stmt_bind_result)
+{
+	zval		***args;
+	int			argc = ZEND_NUM_ARGS();
+	int			start = 1;
+	ulong		rc;
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
+
+	if (getThis()) {
+		start = 0;
+	}
+
+	if (zend_parse_method_parameters((getThis()) ? 0:1 TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
+		return;
+	}
+
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+	if (argc < (getThis() ? 1 : 2)) {
+		WRONG_PARAM_COUNT;
+	}
+
+	if ((argc - start) != mysql_stmt_field_count(stmt->stmt)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of bind variables doesn't match number of fields in prepared statement");
+		RETURN_FALSE;
+	}
+
+	args = (zval ***)safe_emalloc(argc, sizeof(zval **), 0);
+
+	if (zend_get_parameters_array_ex(argc, args) == FAILURE) {
+		efree(args);
+		WRONG_PARAM_COUNT;
+	}
+
+	rc = mysqli_stmt_bind_result_do_bind(stmt, args, argc, start TSRMLS_CC);
+
+	efree(args);
+
+	RETURN_BOOL(!rc);
+}
+/* }}} */
+
 /* {{{ proto bool mysqli_change_user(object link, string user, string password, string database)
    Change logged-in user of the active connection */
 PHP_FUNCTION(mysqli_change_user)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link = NULL;
-	char  		*user, *password, *dbname;
-	int   		user_len, password_len, dbname_len;
+	zval		*mysql_link = NULL;
+	char		*user, *password, *dbname;
+	int			user_len, password_len, dbname_len;
 	ulong		rc;
+#if !defined(MYSQLI_USE_MYSQLND) && defined(HAVE_MYSQLI_SET_CHARSET)
+	const		CHARSET_INFO * old_charset;
+#endif
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Osss", &mysql_link, mysqli_link_class_entry, &user, &user_len, &password, &password_len, &dbname, &dbname_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
+#if !defined(MYSQLI_USE_MYSQLND) && defined(HAVE_MYSQLI_SET_CHARSET)
+	old_charset = mysql->mysql->charset;
+#endif
+
 	rc = mysql_change_user(mysql->mysql, user, password, dbname);
 	MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 
 	if (rc) {
 		RETURN_FALSE;
 	}
+#if !defined(MYSQLI_USE_MYSQLND) && defined(HAVE_MYSQLI_SET_CHARSET)
+	if (mysql_get_server_version(mysql->mysql) < 501023L) {
+		/*
+		  Request the current charset, or it will be reset to the system one.
+		  5.0 doesn't support it. Support added in 5.1.23 by fixing the following bug :
+		  Bug #30472 libmysql doesn't reset charset, insert_id after succ. mysql_change_user() call
+		*/
+		rc = mysql_set_character_set(mysql->mysql, old_charset->csname);
+	}
+#endif
 
 	RETURN_TRUE;
 }
@@ -431,37 +560,70 @@
    Returns the name of the character set used for this connection */
 PHP_FUNCTION(mysqli_character_set_name)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	RETURN_STRING((char *) mysql_character_set_name(mysql->mysql), 1);
+	RETURN_STRING((char *)mysql_character_set_name(mysql->mysql), 1);
 }
 /* }}} */
 
+
+/* {{{ php_mysqli_close */
+void php_mysqli_close(MY_MYSQL * mysql, int close_type, int resource_status TSRMLS_DC)
+{
+	if (resource_status > MYSQLI_STATUS_INITIALIZED) {
+		MyG(num_links)--;
+	}
+
+	if (!mysql->persistent) {
+		mysqli_close(mysql->mysql, close_type);
+	} else {
+		zend_rsrc_list_entry *le;
+		if (zend_hash_find(&EG(persistent_list), mysql->hash_key, strlen(mysql->hash_key) + 1, (void **)&le) == SUCCESS) {
+			if (Z_TYPE_P(le) == php_le_pmysqli()) {
+				mysqli_plist_entry *plist = (mysqli_plist_entry *) le->ptr;
+#if defined(MYSQLI_USE_MYSQLND)
+				mysqlnd_end_psession(mysql->mysql);
+#endif
+				zend_ptr_stack_push(&plist->free_links, mysql->mysql);
+
+				MyG(num_active_persistent)--;
+				MyG(num_inactive_persistent)++;
+			}
+		}
+		mysql->persistent = FALSE;
+	}
+	mysql->mysql = NULL;
+
+	php_clear_mysql(mysql);
+}
+/* }}} */
+
+
 /* {{{ proto bool mysqli_close(object link)
    Close connection */
 PHP_FUNCTION(mysqli_close)
 {
-	zval 		*mysql_link;
-	MY_MYSQL 	*mysql;
-	
+	zval		*mysql_link;
+	MY_MYSQL	*mysql;
+
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_INITIALIZED);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_INITIALIZED);
 
-	mysql_close(mysql->mysql);
-	mysql->mysql = NULL;
-	php_clear_mysql(mysql);
+	php_mysqli_close(mysql, MYSQLI_CLOSE_EXPLICIT, ((MYSQLI_RESOURCE *)((mysqli_object *)zend_object_store_get_object(mysql_link TSRMLS_CC))->ptr)->status TSRMLS_CC);
+	((MYSQLI_RESOURCE *)((mysqli_object *)zend_object_store_get_object(mysql_link TSRMLS_CC))->ptr)->status = MYSQLI_STATUS_UNKNOWN;
+
+	MYSQLI_CLEAR_RESOURCE(&mysql_link);
 	efree(mysql);
-	MYSQLI_CLEAR_RESOURCE(&mysql_link);	
 	RETURN_TRUE;
 }
 /* }}} */
@@ -470,13 +632,13 @@
    Commit outstanding actions and close transaction */
 PHP_FUNCTION(mysqli_commit)
 {
-	MY_MYSQL 	*mysql;
-	zval 		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	if (mysql_commit(mysql->mysql)) {
 		RETURN_FALSE;
 	}
@@ -489,8 +651,8 @@
 PHP_FUNCTION(mysqli_data_seek)
 {
 	MYSQL_RES	*result;
-	zval  		*mysql_result;
-	long  		offset;
+	zval		*mysql_result;
+	long		offset;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ol", &mysql_result, mysqli_result_class_entry, &offset) == FAILURE) {
 		return;
@@ -498,13 +660,13 @@
 
 	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
 
-	if (result->handle && result->handle->status == MYSQL_STATUS_USE_RESULT) {
+	if (mysqli_result_is_unbuffered(result)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Function cannot be used with MYSQL_USE_RESULT");
 		RETURN_FALSE;
 	}
 
-	if (offset < 0 || offset >= result->row_count) {
-	   RETURN_FALSE;
+	if (offset < 0 || offset >= mysql_num_rows(result)) {
+		RETURN_FALSE;
 	}
 
 	mysql_data_seek(result, offset);
@@ -512,41 +674,36 @@
 }
 /* }}} */
 
-/* {{{ proto void mysqli_debug(string debug)
+/* {{{ proto void mysqli_debug(string debug) U
 */
 PHP_FUNCTION(mysqli_debug)
 {
-	char		*debug;
-	int			debug_len;
+	char	*debug;
+	int		debug_len;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &debug, &debug_len) == FAILURE) {
 		return;
 	}
-	
+
 	mysql_debug(debug);
 	RETURN_TRUE;
 }
 /* }}} */
 
+
 /* {{{ proto bool mysqli_dump_debug_info(object link)
 */
 PHP_FUNCTION(mysqli_dump_debug_info)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
-	ulong		rc;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	rc = mysql_dump_debug_info(mysql->mysql);
-
-	if (rc) {
-		RETURN_FALSE;
-	}
-	RETURN_TRUE;	
+	RETURN_BOOL(!mysql_dump_debug_info(mysql->mysql))
 }
 /* }}} */
 
@@ -554,101 +711,159 @@
    Returns the numerical value of the error message from previous MySQL operation */
 PHP_FUNCTION(mysqli_errno)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	RETURN_LONG(mysql_errno(mysql->mysql));
 }
 /* }}} */
 
 /* {{{ proto string mysqli_error(object link)
    Returns the text of the error message from previous MySQL operation */
-PHP_FUNCTION(mysqli_error) 
+PHP_FUNCTION(mysqli_error)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	RETURN_STRING((char *)mysql_error(mysql->mysql),1);
 }
 /* }}} */
 
+#ifndef MYSQLI_USE_MYSQLND
+/* {{{ php_mysqli_stmt_copy_it */
+static void
+php_mysqli_stmt_copy_it(zval *** copies, zval *original, uint param_count, uint current)
+{
+	if (!*copies) {
+		*copies = ecalloc(param_count, sizeof(zval *));
+	}
+	MAKE_STD_ZVAL((*copies)[current]);
+	*(*copies)[current] = *original;
+	Z_SET_REFCOUNT_P((*copies)[current], 1);
+	zval_copy_ctor((*copies)[current]);
+}
+/* }}} */
+#endif
+
 /* {{{ proto bool mysqli_stmt_execute(object stmt)
    Execute a prepared statement */
 PHP_FUNCTION(mysqli_stmt_execute)
 {
-	MY_STMT 		*stmt;
-	zval 			*mysql_stmt;
-	unsigned int 	i;
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
+#ifndef MYSQLI_USE_MYSQLND
+	unsigned int	i;
+	zval		**copies = NULL;
+#endif
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
-	
-	for (i = 0; i < stmt->param.var_cnt; i++) {		
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+#ifndef MYSQLI_USE_MYSQLND
+	if (stmt->param.var_cnt) {
+		int j;
+		for (i = 0; i < stmt->param.var_cnt; i++) {
+			for (j = i + 1; j < stmt->param.var_cnt; j++) {
+				/* Oops, someone binding the same variable - clone */
+				if (stmt->param.vars[j] == stmt->param.vars[i] && stmt->param.vars[i]) {
+					php_mysqli_stmt_copy_it(&copies, stmt->param.vars[i], stmt->param.var_cnt, i);
+					break;
+				}
+			}
+		}
+	}
+	for (i = 0; i < stmt->param.var_cnt; i++) {
 		if (stmt->param.vars[i]) {
 			if ( !(stmt->param.is_null[i] = (stmt->param.vars[i]->type == IS_NULL)) ) {
+				zval *the_var = copies && copies[i]? copies[i]:stmt->param.vars[i];
 				switch (stmt->stmt->params[i].buffer_type) {
 					case MYSQL_TYPE_VAR_STRING:
-						convert_to_string_ex(&stmt->param.vars[i]);
-						stmt->stmt->params[i].buffer = Z_STRVAL_PP(&stmt->param.vars[i]);
-						stmt->stmt->params[i].buffer_length = Z_STRLEN_PP(&stmt->param.vars[i]);
+						if (the_var == stmt->param.vars[i] && Z_TYPE_P(stmt->param.vars[i]) != IS_STRING) {
+							php_mysqli_stmt_copy_it(&copies, stmt->param.vars[i], stmt->param.var_cnt, i);
+							the_var = copies[i];
+						}
+						convert_to_string_ex(&the_var);
+						stmt->stmt->params[i].buffer = Z_STRVAL_P(the_var);
+						stmt->stmt->params[i].buffer_length = Z_STRLEN_P(the_var);
 						break;
 					case MYSQL_TYPE_DOUBLE:
-						convert_to_double_ex(&stmt->param.vars[i]);
-						stmt->stmt->params[i].buffer = (char*)&Z_LVAL_PP(&stmt->param.vars[i]);
+						if (the_var == stmt->param.vars[i] && Z_TYPE_P(stmt->param.vars[i]) != IS_DOUBLE) {
+							php_mysqli_stmt_copy_it(&copies, stmt->param.vars[i], stmt->param.var_cnt, i);
+							the_var = copies[i];
+						}
+						convert_to_double_ex(&the_var);
+						stmt->stmt->params[i].buffer = &Z_DVAL_P(the_var);
 						break;
+					case MYSQL_TYPE_LONGLONG:
 					case MYSQL_TYPE_LONG:
-						convert_to_long_ex(&stmt->param.vars[i]);
-						stmt->stmt->params[i].buffer = (char*)&Z_LVAL_PP(&stmt->param.vars[i]);
+						if (the_var == stmt->param.vars[i] && Z_TYPE_P(stmt->param.vars[i]) != IS_LONG) {
+							php_mysqli_stmt_copy_it(&copies, stmt->param.vars[i], stmt->param.var_cnt, i);
+							the_var = copies[i];
+						}
+						convert_to_long_ex(&the_var);
+						stmt->stmt->params[i].buffer = &Z_LVAL_P(the_var);
 						break;
 					default:
 						break;
 				}
-			}	
+			}
 		}
 	}
+#endif
+
 	if (mysql_stmt_execute(stmt->stmt)) {
 		MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
-		RETURN_FALSE;
+		RETVAL_FALSE;
+	} else {
+		RETVAL_TRUE;
 	}
 
+#ifndef MYSQLI_USE_MYSQLND
+	if (copies) {
+		for (i = 0; i < stmt->param.var_cnt; i++) {
+			if (copies[i]) {
+				zval_ptr_dtor(&copies[i]);
+			}
+		}
+		efree(copies);
+	}
+#endif
+
 	if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
-		php_mysqli_report_index(stmt->query, stmt->stmt->mysql->server_status TSRMLS_CC);
+		php_mysqli_report_index(stmt->query, mysqli_stmt_server_status(stmt->stmt) TSRMLS_CC);
 	}
-	
-	RETURN_TRUE;
 }
 /* }}} */
 
-/* {{{ proto mixed mysqli_stmt_fetch(object stmt)
+#ifndef MYSQLI_USE_MYSQLND
+/* {{{ void mysqli_stmt_fetch_libmysql
    Fetch results from a prepared statement into the bound variables */
-PHP_FUNCTION(mysqli_stmt_fetch)
+void mysqli_stmt_fetch_libmysql(INTERNAL_FUNCTION_PARAMETERS)
 {
-	MY_STMT 		*stmt;
-	zval 			*mysql_stmt;
-	unsigned int 	i;
-	ulong 			ret;
-	unsigned int    uval;
+	MY_STMT		*stmt;
+	zval			*mysql_stmt;
+	unsigned int	i;
+	ulong			ret;
+	unsigned int	uval;
 	my_ulonglong	llval;
-	
 
+
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
-	
-	/* reset buffers */
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
-
+	/* reset buffers */
 	for (i = 0; i < stmt->result.var_cnt; i++) {
 		if (stmt->result.buf[i].type == IS_STRING) {
 			memset(stmt->result.buf[i].val, 0, stmt->result.buf[i].buflen);
@@ -661,6 +876,11 @@
 	if (!ret) {
 #endif
 		for (i = 0; i < stmt->result.var_cnt; i++) {
+			/*
+			  QQ: Isn't it quite better to call zval_dtor(). What if the user has
+			  assigned a resource, or an array to the bound variable? We are going
+			  to leak probably. zval_dtor() will handle also Unicode/Non-unicode mode.
+			*/
 			/* Even if the string is of length zero there is one byte alloced so efree() in all cases */
 			if (Z_TYPE_P(stmt->result.vars[i]) == IS_STRING) {
 				efree(stmt->result.vars[i]->value.str.val);
@@ -668,28 +888,29 @@
 			if (!stmt->result.is_null[i]) {
 				switch (stmt->result.buf[i].type) {
 					case IS_LONG:
-						if ((stmt->stmt->fields[i].type == MYSQL_TYPE_LONG) 
-						    && (stmt->stmt->fields[i].flags & UNSIGNED_FLAG)) 
+						if ((stmt->stmt->fields[i].type == MYSQL_TYPE_LONG)
+						    && (stmt->stmt->fields[i].flags & UNSIGNED_FLAG))
 						{
 							/* unsigned int (11) */
 							uval= *(unsigned int *) stmt->result.buf[i].val;
-
+#if SIZEOF_LONG==4
 							if (uval > INT_MAX) {
 								char *tmp, *p;
 								int j=10;
 								tmp= emalloc(11);
 								p= &tmp[9];
-								do { 
+								do {
 									*p-- = (uval % 10) + 48;
-									uval = uval / 10;							
+									uval = uval / 10;
 								} while (--j > 0);
 								tmp[10]= '\0';
-								/* unsigned int > INT_MAX is 10 digis - ALWAYS */
+								/* unsigned int > INT_MAX is 10 digits - ALWAYS */
 								ZVAL_STRINGL(stmt->result.vars[i], tmp, 10, 0);
 								break;
 							}
+#endif
 						}
-						if (stmt->stmt->fields[i].flags & UNSIGNED_FLAG) { 
+						if (stmt->stmt->fields[i].flags & UNSIGNED_FLAG) {
 							ZVAL_LONG(stmt->result.vars[i], *(unsigned int *)stmt->result.buf[i].val);
 						} else {
 							ZVAL_LONG(stmt->result.vars[i], *(int *)stmt->result.buf[i].val);
@@ -699,14 +920,35 @@
 						ZVAL_DOUBLE(stmt->result.vars[i], *(double *)stmt->result.buf[i].val);
 						break;
 					case IS_STRING:
-						if (stmt->stmt->bind[i].buffer_type == MYSQL_TYPE_LONGLONG) {
+						if (stmt->stmt->bind[i].buffer_type == MYSQL_TYPE_LONGLONG
+#if MYSQL_VERSION_ID > 50002
+						 || stmt->stmt->bind[i].buffer_type == MYSQL_TYPE_BIT
+#endif
+						 ) {
 							my_bool uns= (stmt->stmt->fields[i].flags & UNSIGNED_FLAG)? 1:0;
-							llval= *(my_ulonglong *) stmt->result.buf[i].val;
-#if SIZEOF_LONG==8  
+#if MYSQL_VERSION_ID > 50002
+							if (stmt->stmt->bind[i].buffer_type == MYSQL_TYPE_BIT) {
+								switch (stmt->result.buf[i].output_len) {
+									case 8:llval = (my_ulonglong)  bit_uint8korr(stmt->result.buf[i].val);break;
+									case 7:llval = (my_ulonglong)  bit_uint7korr(stmt->result.buf[i].val);break;
+									case 6:llval = (my_ulonglong)  bit_uint6korr(stmt->result.buf[i].val);break;
+									case 5:llval = (my_ulonglong)  bit_uint5korr(stmt->result.buf[i].val);break;
+									case 4:llval = (my_ulonglong)  bit_uint4korr(stmt->result.buf[i].val);break;
+									case 3:llval = (my_ulonglong)  bit_uint3korr(stmt->result.buf[i].val);break;
+									case 2:llval = (my_ulonglong)  bit_uint2korr(stmt->result.buf[i].val);break;
+									case 1:llval = (my_ulonglong)  uint1korr(stmt->result.buf[i].val);break;
+								}
+							} else
+#endif
+							{
+								llval= *(my_ulonglong *) stmt->result.buf[i].val;
+							}
+#if SIZEOF_LONG==8
 							if (uns && llval > 9223372036854775807L) {
 #elif SIZEOF_LONG==4
-							if ((uns && llval > L64(2147483647)) || 
-							    (!uns && (( L64(2147483647) < (my_longlong) llval) || (L64(-2147483648) > (my_longlong) llval))))
+							if ((uns && llval > L64(2147483647)) ||
+								(!uns && (( L64(2147483647) < (my_longlong) llval) ||
+								(L64(-2147483648) > (my_longlong) llval))))
 							{
 #endif
 								char tmp[22];
@@ -719,28 +961,23 @@
 							} else {
 								ZVAL_LONG(stmt->result.vars[i], llval);
 							}
-						} 
-#if MYSQL_VERSION_ID > 50002
-						else if (stmt->stmt->bind[i].buffer_type == MYSQL_TYPE_BIT) {
-							llval = *(my_ulonglong *)stmt->result.buf[i].val;
-							ZVAL_LONG(stmt->result.vars[i], llval);
-						}
-#endif
-						else {
+						} else {
 #if defined(MYSQL_DATA_TRUNCATED) && MYSQL_VERSION_ID > 50002
-							if(ret == MYSQL_DATA_TRUNCATED && *(stmt->stmt->bind[i].error) != 0) {
+							if (ret == MYSQL_DATA_TRUNCATED && *(stmt->stmt->bind[i].error) != 0) {
 								/* result was truncated */
-								ZVAL_STRINGL(stmt->result.vars[i], stmt->result.buf[i].val, stmt->stmt->bind[i].buffer_length, 1);
+								ZVAL_STRINGL(stmt->result.vars[i], stmt->result.buf[i].val,
+											 stmt->stmt->bind[i].buffer_length, 1);
 							} else {
 #else
 							{
 #endif
-								ZVAL_STRINGL(stmt->result.vars[i], stmt->result.buf[i].val, stmt->result.buf[i].output_len, 1);
+								ZVAL_STRINGL(stmt->result.vars[i], stmt->result.buf[i].val,
+											 stmt->result.buf[i].output_len, 1);
 							}
 						}
 						break;
 					default:
-						break;	
+						break;
 				}
 			} else {
 				ZVAL_NULL(stmt->result.vars[i]);
@@ -754,7 +991,7 @@
 		case 0:
 #ifdef MYSQL_DATA_TRUNCATED
 		/* according to SQL standard truncation (e.g. loss of precision is
-		   not an error) - for detecting possible truncation you have to 
+		   not an error) - for detecting possible truncation you have to
 		   check mysqli_stmt_warning
 		*/
 		case MYSQL_DATA_TRUNCATED:
@@ -770,14 +1007,75 @@
 	}
 }
 /* }}} */
+#else
+/* {{{ mixed mysqli_stmt_fetch_mysqlnd */
+void mysqli_stmt_fetch_mysqlnd(INTERNAL_FUNCTION_PARAMETERS)
+{
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
+	zend_bool	fetched_anything;
 
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+	if (FAIL  == mysqlnd_stmt_fetch(stmt->stmt, &fetched_anything)) {
+		RETURN_BOOL(FALSE);
+	} else if (fetched_anything == TRUE) {
+		RETURN_BOOL(TRUE);
+	} else {
+		RETURN_NULL();
+	}
+}
+#endif
+/* }}} */
+
+
+/* {{{ proto mixed mysqli_stmt_fetch(object stmt) U
+   Fetch results from a prepared statement into the bound variables */
+PHP_FUNCTION(mysqli_stmt_fetch)
+{
+#if !defined(MYSQLI_USE_MYSQLND)
+	mysqli_stmt_fetch_libmysql(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+#else
+	mysqli_stmt_fetch_mysqlnd(INTERNAL_FUNCTION_PARAM_PASSTHRU);
+#endif
+}
+/* }}} */
+
+/* {{{  php_add_field_properties */
+static void php_add_field_properties(zval *value, const MYSQL_FIELD *field TSRMLS_DC)
+{
+	add_property_string(value, "name", (char *) (field->name ? field->name : ""), 1);
+	add_property_string(value, "orgname", (char *) (field->org_name ? field->org_name : ""), 1);
+	add_property_string(value, "table", (char *) (field->table ? field->table : ""), 1);
+	add_property_string(value, "orgtable", (char *) (field->org_table ? field->org_table : ""), 1);
+	add_property_string(value, "def", (field->def ? field->def : ""), 1);
+	add_property_string(value, "db", (field->db ? field->db : ""), 1);
+
+	/* FIXME: manually set the catalog to "def" due to bug in
+	 * libmysqlclient which does not initialize field->catalog
+	 * and in addition, the catalog is always be "def"
+	 */
+	add_property_string(value, "catalog", "def", 1);
+
+	add_property_long(value, "max_length", field->max_length);
+	add_property_long(value, "length", field->length);
+	add_property_long(value, "charsetnr", field->charsetnr);
+	add_property_long(value, "flags", field->flags);
+	add_property_long(value, "type", field->type);
+	add_property_long(value, "decimals", field->decimals);
+}
+/* }}} */
+
 /* {{{ proto mixed mysqli_fetch_field (object result)
    Get column information from a result and return as an object */
-PHP_FUNCTION(mysqli_fetch_field) 
+PHP_FUNCTION(mysqli_fetch_field)
 {
-	MYSQL_RES 	*result;
-	zval  		*mysql_result;
-	MYSQL_FIELD *field;
+	MYSQL_RES	*result;
+	zval		*mysql_result;
+	const MYSQL_FIELD	*field;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_result, mysqli_result_class_entry) == FAILURE) {
 		return;
@@ -790,29 +1088,17 @@
 	}
 
 	object_init(return_value);
-
-	add_property_string(return_value, "name",(field->name ? field->name : ""), 1);
-	add_property_string(return_value, "orgname",(field->org_name ? field->org_name : ""), 1);
-	add_property_string(return_value, "table",(field->table ? field->table : ""), 1);
-	add_property_string(return_value, "orgtable",(field->org_table ? field->org_table : ""), 1);
-	add_property_string(return_value, "def",(field->def ? field->def : ""), 1);
-	add_property_long(return_value, "max_length", field->max_length);
-	add_property_long(return_value, "length", field->length);
-	add_property_long(return_value, "charsetnr", field->charsetnr);
-	add_property_long(return_value, "flags", field->flags);
-	add_property_long(return_value, "type", field->type);
-	add_property_long(return_value, "decimals", field->decimals);
+	php_add_field_properties(return_value, field TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ proto mixed mysqli_fetch_fields (object result)
    Return array of objects containing field meta-data */
-PHP_FUNCTION(mysqli_fetch_fields) 
+PHP_FUNCTION(mysqli_fetch_fields)
 {
 	MYSQL_RES	*result;
-	zval  		*mysql_result;
-	MYSQL_FIELD	*field;
-	zval 		*obj;
+	zval		*mysql_result;
+	zval		*obj;
 
 	unsigned int i;
 
@@ -825,24 +1111,12 @@
 	array_init(return_value);
 
 	for (i = 0; i < mysql_num_fields(result); i++) {
-		field = mysql_fetch_field_direct(result, i);
+		const MYSQL_FIELD *field = mysql_fetch_field_direct(result, i);
 
-
 		MAKE_STD_ZVAL(obj);
 		object_init(obj);
 
-		add_property_string(obj, "name",(field->name ? field->name : ""), 1);
-		add_property_string(obj, "orgname",(field->org_name ? field->org_name : ""), 1);
-		add_property_string(obj, "table",(field->table ? field->table : ""), 1);
-		add_property_string(obj, "orgtable",(field->org_table ? field->org_table : ""), 1);
-		add_property_string(obj, "def",(field->def ? field->def : ""), 1);
-		add_property_long(obj, "max_length", field->max_length);
-		add_property_long(obj, "length", field->length);
-		add_property_long(obj, "charsetnr", field->charsetnr);
-		add_property_long(obj, "flags", field->flags);
-		add_property_long(obj, "type", field->type);
-		add_property_long(obj, "decimals", field->decimals);
-
+		php_add_field_properties(obj, field TSRMLS_CC);
 		add_index_zval(return_value, i, obj);
 	}
 }
@@ -850,22 +1124,22 @@
 
 /* {{{ proto mixed mysqli_fetch_field_direct (object result, int offset)
    Fetch meta-data for a single field */
-PHP_FUNCTION(mysqli_fetch_field_direct) 
+PHP_FUNCTION(mysqli_fetch_field_direct)
 {
 	MYSQL_RES	*result;
 	zval		*mysql_result;
-	MYSQL_FIELD *field;
-	long 		offset;
+	const MYSQL_FIELD	*field;
+	long		offset;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ol", &mysql_result, mysqli_result_class_entry, &offset) == FAILURE) {
 		return;
 	}
 
 	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
-	
-	if (offset < 0 || offset >= mysql_num_fields(result)) {
+
+	if (offset < 0 || offset >= (long) mysql_num_fields(result)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Field offset is invalid for resultset");
-		RETURN_FALSE; 
+		RETURN_FALSE;
 	}
 
 	if (!(field = mysql_fetch_field_direct(result,offset))) {
@@ -873,30 +1147,19 @@
 	}
 
 	object_init(return_value);
-
-	add_property_string(return_value, "name",(field->name ? field->name : ""), 1);
-	add_property_string(return_value, "orgname",(field->org_name ? field->org_name : ""), 1);
-	add_property_string(return_value, "table",(field->table ? field->table : ""), 1);
-	add_property_string(return_value, "orgtable",(field->org_table ? field->org_table : ""), 1);
-	add_property_string(return_value, "def",(field->def ? field->def : ""), 1);
-	add_property_long(return_value, "max_length", field->max_length);
-	add_property_long(return_value, "length", field->length);
-	add_property_long(return_value, "charsetnr", field->charsetnr);
-	add_property_long(return_value, "flags", field->flags);
-	add_property_long(return_value, "type", field->type);
-	add_property_long(return_value, "decimals", field->decimals);
+	php_add_field_properties(return_value, field TSRMLS_CC);
 }
 /* }}} */
 
 /* {{{ proto mixed mysqli_fetch_lengths (object result)
    Get the length of each output in a result */
-PHP_FUNCTION(mysqli_fetch_lengths) 
+PHP_FUNCTION(mysqli_fetch_lengths)
 {
 	MYSQL_RES		*result;
 	zval			*mysql_result;
 	unsigned int	i;
 	unsigned long	*ret;
-	
+
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_result, mysqli_result_class_entry) == FAILURE) {
 		return;
 	}
@@ -910,14 +1173,14 @@
 	array_init(return_value);
 
 	for (i = 0; i < mysql_num_fields(result); i++) {
-		add_index_long(return_value, i, ret[i]);	
+		add_index_long(return_value, i, ret[i]);
 	}
 }
 /* }}} */
 
 /* {{{ proto array mysqli_fetch_row (object result)
    Get a result row as an enumerated array */
-PHP_FUNCTION(mysqli_fetch_row) 
+PHP_FUNCTION(mysqli_fetch_row)
 {
 	php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, MYSQLI_NUM, 0);
 }
@@ -926,15 +1189,15 @@
 /* {{{ proto int mysqli_field_count(object link)
    Fetch the number of fields returned by the last query for the given link
 */
-PHP_FUNCTION(mysqli_field_count) 
+PHP_FUNCTION(mysqli_field_count)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	RETURN_LONG(mysql_field_count(mysql->mysql));
 }
@@ -956,9 +1219,9 @@
 
 	if (fieldnr < 0 || fieldnr >= mysql_num_fields(result)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid field offset");
-		RETURN_FALSE; 
+		RETURN_FALSE;
 	}
-	
+
 	mysql_field_seek(result, fieldnr);
 	RETURN_TRUE;
 }
@@ -975,14 +1238,14 @@
 		return;
 	}
 	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
-	
+
 	RETURN_LONG(mysql_field_tell(result));
 }
 /* }}} */
 
 /* {{{ proto void mysqli_free_result(object result)
    Free query result memory for the given result handle */
-PHP_FUNCTION(mysqli_free_result) 
+PHP_FUNCTION(mysqli_free_result)
 {
 	MYSQL_RES	*result;
 	zval		*mysql_result;
@@ -992,12 +1255,12 @@
 	}
 	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
 
-	mysql_free_result(result);
-	MYSQLI_CLEAR_RESOURCE(&mysql_result);	
+	mysqli_free_result(result, FALSE);
+	MYSQLI_CLEAR_RESOURCE(&mysql_result);
 }
 /* }}} */
 
-/* {{{ proto string mysqli_get_client_info(void) 
+/* {{{ proto string mysqli_get_client_info(void)
    Get MySQL client info */
 PHP_FUNCTION(mysqli_get_client_info)
 {
@@ -1005,7 +1268,7 @@
 }
 /* }}} */
 
-/* {{{ proto int mysqli_get_client_version(void) 
+/* {{{ proto int mysqli_get_client_version(void)
    Get MySQL client info */
 PHP_FUNCTION(mysqli_get_client_version)
 {
@@ -1013,17 +1276,17 @@
 }
 /* }}} */
 
-/* {{{ proto string mysqli_get_host_info (object link) 
+/* {{{ proto string mysqli_get_host_info (object link)
    Get MySQL host info */
 PHP_FUNCTION(mysqli_get_host_info)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link = NULL;
+	zval		*mysql_link = NULL;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	RETURN_STRING((mysql->mysql->host_info) ? mysql->mysql->host_info : "", 1);
 }
@@ -1033,36 +1296,35 @@
    Get MySQL protocol information */
 PHP_FUNCTION(mysqli_get_proto_info)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link = NULL;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link = NULL;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	RETURN_LONG(mysql_get_proto_info(mysql->mysql));
 }
 /* }}} */
 
-/* {{{ proto string mysqli_get_server_info(object link) 
+/* {{{ proto string mysqli_get_server_info(object link)
    Get MySQL server info */
 PHP_FUNCTION(mysqli_get_server_info)
 {
 	MY_MYSQL	*mysql;
-	zval	  	*mysql_link = NULL;
+	zval		*mysql_link = NULL;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	RETURN_STRING((char *)mysql_get_server_info(mysql->mysql), 1);
 }
 
 /* }}} */
 
-/* {{{ proto int mysqli_get_server_version(object link) 
+/* {{{ proto int mysqli_get_server_version(object link)
    Return the MySQL version for the server referenced by the given link */
 PHP_FUNCTION(mysqli_get_server_version)
 {
@@ -1072,7 +1334,7 @@
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	RETURN_LONG(mysql_get_server_version(mysql->mysql));
 }
@@ -1083,14 +1345,16 @@
 PHP_FUNCTION(mysqli_info)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link = NULL;
+	zval		*mysql_link = NULL;
+	const char	*info;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	RETURN_STRING((mysql->mysql->info) ? mysql->mysql->info : "", 1);
+	info = mysql_info(mysql->mysql);
+	RETURN_STRING((info) ? (char *)info : "", 1);
 }
 /* }}} */
 
@@ -1107,7 +1371,16 @@
 
 	mysql = (MY_MYSQL *)ecalloc(1, sizeof(MY_MYSQL));
 
-	if (!(mysql->mysql = mysql_init(NULL))) {
+#if !defined(MYSQLI_USE_MYSQLND)
+	if (!(mysql->mysql = mysql_init(NULL)))
+#else
+	/*
+	  We create always persistent, as if the user want to connecto
+	  to p:somehost, we can't convert the handle then
+	*/
+	if (!(mysql->mysql = mysql_init(TRUE)))
+#endif
+	{
 		efree(mysql);
 		RETURN_FALSE;
 	}
@@ -1117,11 +1390,10 @@
 	mysqli_resource->status = MYSQLI_STATUS_INITIALIZED;
 
 	if (!getThis() || !instanceof_function(Z_OBJCE_P(getThis()), mysqli_link_class_entry TSRMLS_CC)) {
-		MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_link_class_entry);	
+		MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_link_class_entry);
 	} else {
 		((mysqli_object *) zend_object_store_get_object(getThis() TSRMLS_CC))->ptr = mysqli_resource;
 	}
-
 }
 /* }}} */
 
@@ -1134,19 +1406,18 @@
 }
 /* }}} */
 
-
 /* {{{ proto mixed mysqli_insert_id(object link)
    Get the ID generated from the previous INSERT operation */
 PHP_FUNCTION(mysqli_insert_id)
 {
 	MY_MYSQL		*mysql;
-	my_ulonglong 	rc;
-	zval  			*mysql_link;
+	my_ulonglong	rc;
+	zval			*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	rc = mysql_insert_id(mysql->mysql);
 	MYSQLI_RETURN_LONG_LONG(rc)
 }
@@ -1156,15 +1427,20 @@
    Kill a mysql process on the server */
 PHP_FUNCTION(mysqli_kill)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
-	long   		processid;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
+	long		processid;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ol", &mysql_link, mysqli_link_class_entry, &processid) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-	
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
+
+	if (processid <= 0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "processid should have positive value");
+		RETURN_FALSE;
+	}
+
 	if (mysql_kill(mysql->mysql, processid)) {
 		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 		RETURN_FALSE;
@@ -1175,6 +1451,7 @@
 
 /* {{{ proto void mysqli_set_local_infile_default(object link)
    unsets user defined handler for load local infile command */
+#if !defined(MYSQLI_USE_MYSQLND)
 PHP_FUNCTION(mysqli_set_local_infile_default)
 {
 	MY_MYSQL	*mysql;
@@ -1184,7 +1461,7 @@
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (mysql->li_read) {
 		zval_ptr_dtor(&(mysql->li_read));
@@ -1198,7 +1475,7 @@
 PHP_FUNCTION(mysqli_set_local_infile_handler)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link;
+	zval		*mysql_link;
 	char		*callback_name;
 	zval		*callback_func;
 
@@ -1207,14 +1484,15 @@
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	/* check callback function */
-	if (!zend_is_callable(callback_func, 0, &callback_name)) {
+	if (!zend_is_callable(callback_func, 0, &callback_name TSRMLS_CC)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Not a valid callback function %s", callback_name);
 		efree(callback_name);
-		RETURN_FALSE;		
+		RETURN_FALSE;
 	}
+	efree(callback_name);
 
 	/* save callback function */
 	if (!mysql->li_read) {
@@ -1222,23 +1500,24 @@
 	} else {
 		zval_dtor(mysql->li_read);
 	}
-	ZVAL_STRING(mysql->li_read, callback_name, 0);
+	ZVAL_ZVAL(mysql->li_read, callback_func, 1, 0);
 
 	RETURN_TRUE;
 }
+#endif
 /* }}} */
 
 /* {{{ proto bool mysqli_more_results(object link)
    check if there any more query results from a multi query */
 PHP_FUNCTION(mysqli_more_results)
 {
-	MY_MYSQL		*mysql;
-	zval			*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	RETURN_BOOL(mysql_more_results(mysql->mysql));
 }
@@ -1247,18 +1526,65 @@
 /* {{{ proto bool mysqli_next_result(object link)
    read next result from multi_query */
 PHP_FUNCTION(mysqli_next_result) {
-	MY_MYSQL		*mysql;
-	zval			*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
+	if (!mysql_more_results(mysql->mysql)) {
+		php_error_docref(NULL TSRMLS_CC, E_STRICT, "There is no next result set. "
+						"Please, call mysqli_more_results()/mysqli::more_results() to check "
+						"whether to call this function/method");
+	}
+
 	RETURN_BOOL(!mysql_next_result(mysql->mysql));
 }
 /* }}} */
 
+#if defined(HAVE_STMT_NEXT_RESULT) && defined(MYSQLI_USE_MYSQLND)
+/* {{{ proto bool mysqli_stmt_next_result(object link)
+   check if there any more query results from a multi query */
+PHP_FUNCTION(mysqli_stmt_more_results)
+{
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+	RETURN_BOOL(mysqlnd_stmt_more_results(stmt->stmt));
+}
+/* }}} */
+
+
+/* {{{ proto bool mysqli_stmt_next_result(object link)
+   read next result from multi_query */
+PHP_FUNCTION(mysqli_stmt_next_result) {
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+	if (!mysqlnd_stmt_more_results(stmt->stmt)) {
+		php_error_docref(NULL TSRMLS_CC, E_STRICT, "There is no next result set. "
+						"Please, call mysqli_stmt_more_results()/mysqli_stmt::more_results() to check "
+						"whether to call this function/method");
+	}
+
+	RETURN_BOOL(!mysql_stmt_next_result(stmt->stmt));
+}
+/* }}} */
+#endif
+
+
 /* {{{ proto int mysqli_num_fields(object result)
    Get number of fields in result */
 PHP_FUNCTION(mysqli_num_fields)
@@ -1287,7 +1613,7 @@
 	}
 	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
 
-	if (result->handle && result->handle->status == MYSQL_STATUS_USE_RESULT) {
+	if (mysqli_result_is_unbuffered_and_not_everything_is_fetched(result)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Function cannot be used with MYSQL_USE_RESULT");
 		RETURN_LONG(0);
 	}
@@ -1296,41 +1622,125 @@
 }
 /* }}} */
 
+/* {{{ mysqli_options_get_option_zval_type */
+static int mysqli_options_get_option_zval_type(int option)
+{
+	switch (option) {
+#ifdef MYSQLI_USE_MYSQLND
+#if PHP_MAJOR_VERSION >= 6
+		case MYSQLND_OPT_NUMERIC_AND_DATETIME_AS_UNICODE:
+#endif
+		case MYSQLND_OPT_NET_CMD_BUFFER_SIZE:
+		case MYSQLND_OPT_NET_READ_BUFFER_SIZE:
+#ifdef MYSQLND_STRING_TO_INT_CONVERSION
+		case MYSQLND_OPT_INT_AND_FLOAT_NATIVE:
+#endif
+#endif /* MYSQLI_USE_MYSQLND */
+		case MYSQL_OPT_CONNECT_TIMEOUT:
+#ifdef MYSQL_REPORT_DATA_TRUNCATION
+                case MYSQL_REPORT_DATA_TRUNCATION:
+#endif
+                case MYSQL_OPT_LOCAL_INFILE:
+                case MYSQL_OPT_NAMED_PIPE:
+#ifdef MYSQL_OPT_PROTOCOL
+                case MYSQL_OPT_PROTOCOL:
+#endif /* MySQL 4.1.0 */
+#ifdef MYSQL_OPT_READ_TIMEOUT
+		case MYSQL_OPT_READ_TIMEOUT:
+		case MYSQL_OPT_WRITE_TIMEOUT:
+		case MYSQL_OPT_GUESS_CONNECTION:
+		case MYSQL_OPT_USE_EMBEDDED_CONNECTION:
+		case MYSQL_OPT_USE_REMOTE_CONNECTION:
+		case MYSQL_SECURE_AUTH:
+#endif /* MySQL 4.1.1 */
+#ifdef MYSQL_OPT_RECONNECT
+		case MYSQL_OPT_RECONNECT:
+#endif /* MySQL 5.0.13 */
+#ifdef MYSQL_OPT_SSL_VERIFY_SERVER_CERT
+                case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:
+#endif /* MySQL 5.0.23 */
+#ifdef MYSQL_OPT_COMPRESS
+		case MYSQL_OPT_COMPRESS:
+#endif /* mysqlnd @ PHP 5.3.2 */
+#ifdef MYSQL_OPT_SSL_VERIFY_SERVER_CERT
+	REGISTER_LONG_CONSTANT("MYSQLI_OPT_SSL_VERIFY_SERVER_CERT", MYSQL_OPT_SSL_VERIFY_SERVER_CERT, CONST_CS | CONST_PERSISTENT);
+#endif /* MySQL 5.1.1., mysqlnd @ PHP 5.3.3 */
+			return IS_LONG;
+
+#ifdef MYSQL_SHARED_MEMORY_BASE_NAME
+                case MYSQL_SHARED_MEMORY_BASE_NAME:
+#endif /* MySQL 4.1.0 */
+#ifdef MYSQL_SET_CLIENT_IP
+		case MYSQL_SET_CLIENT_IP:
+#endif /* MySQL 4.1.1 */
+		case MYSQL_READ_DEFAULT_FILE:
+		case MYSQL_READ_DEFAULT_GROUP:
+		case MYSQL_INIT_COMMAND:
+		case MYSQL_SET_CHARSET_NAME:
+		case MYSQL_SET_CHARSET_DIR:
+			return IS_STRING;
+
+		default:
+			return IS_NULL;
+	}
+}
+/* }}} */
+
+
 /* {{{ proto bool mysqli_options(object link, int flags, mixed values)
    Set options */
 PHP_FUNCTION(mysqli_options)
 {
-	MY_MYSQL 		*mysql;
-	zval  			*mysql_link = NULL;
-	zval  			**mysql_value;
-	long  			mysql_option;
-	unsigned int 	l_value;
-	long  			ret;
+	MY_MYSQL		*mysql;
+	zval			*mysql_link = NULL;
+	zval			**mysql_value;
+	long			mysql_option;
+	unsigned int	l_value;
+	long			ret;
+	int				expected_type;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "OlZ", &mysql_link, mysqli_link_class_entry, &mysql_option, &mysql_value) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_INITIALIZED);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_INITIALIZED);
 
+#if PHP_API_VERSION < 20100412
 	if ((PG(open_basedir) && PG(open_basedir)[0] != '\0') || PG(safe_mode)) {
+#else
+	if (PG(open_basedir) && PG(open_basedir)[0] != '\0') {
+#endif
 		if(mysql_option == MYSQL_OPT_LOCAL_INFILE) {
 			RETURN_FALSE;
 		}
 	}
-
-	switch (Z_TYPE_PP(mysql_value)) {
+	expected_type = mysqli_options_get_option_zval_type(mysql_option);
+	if (expected_type != Z_TYPE_PP(mysql_value)) {
+		switch (expected_type) {
+			case IS_STRING:
+				convert_to_string_ex(mysql_value);
+				break;
+			case IS_LONG:
+				convert_to_long_ex(mysql_value);
+				break;
+			default:
+				break;
+		}
+	}
+	switch (expected_type) {
 		case IS_STRING:
 			ret = mysql_options(mysql->mysql, mysql_option, Z_STRVAL_PP(mysql_value));
 			break;
-		default:
-			convert_to_long_ex(mysql_value);
+		case IS_LONG:
 			l_value = Z_LVAL_PP(mysql_value);
 			ret = mysql_options(mysql->mysql, mysql_option, (char *)&l_value);
 			break;
+		default:
+			ret = 1;
+			break;
 	}
 
 	RETURN_BOOL(!ret);
-}   
+}
 /* }}} */
 
 
@@ -1338,14 +1748,14 @@
    Ping a server connection or reconnect if there is no connection */
 PHP_FUNCTION(mysqli_ping)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 	long		rc;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	rc = mysql_ping(mysql->mysql);
 	MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 
@@ -1358,60 +1768,71 @@
 PHP_FUNCTION(mysqli_prepare)
 {
 	MY_MYSQL		*mysql;
-	MY_STMT 		*stmt;
+	MY_STMT			*stmt;
 	char			*query = NULL;
-	unsigned int	query_len;
+	int				query_len;
 	zval			*mysql_link;
-	MYSQLI_RESOURCE *mysqli_resource; 
+	MYSQLI_RESOURCE	*mysqli_resource;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os",&mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
+
+#if !defined(MYSQLI_USE_MYSQLND)
 	if (mysql->mysql->status == MYSQL_STATUS_GET_RESULT) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "All data must be fetched before a new statement prepare takes place");
 		RETURN_FALSE;
 	}
+#endif
 
 	stmt = (MY_STMT *)ecalloc(1,sizeof(MY_STMT));
 
 	if ((stmt->stmt = mysql_stmt_init(mysql->mysql))) {
 		if (mysql_stmt_prepare(stmt->stmt, query, query_len)) {
-  			char  last_error[MYSQL_ERRMSG_SIZE];
-  			char  sqlstate[SQLSTATE_LENGTH+1];	
+			/* mysql_stmt_close() clears errors, so we have to store them temporarily */
+#if !defined(MYSQLI_USE_MYSQLND)
+			char  last_error[MYSQL_ERRMSG_SIZE];
+			char  sqlstate[SQLSTATE_LENGTH+1];
 			unsigned int last_errno;
 
-			/* mysql_stmt_close clears errors, so we have to store them temporarily */
 			last_errno = stmt->stmt->last_errno;
 			memcpy(last_error, stmt->stmt->last_error, MYSQL_ERRMSG_SIZE);
 			memcpy(sqlstate, mysql->mysql->net.sqlstate, SQLSTATE_LENGTH+1);
-
-			mysql_stmt_close(stmt->stmt);
+#else
+			MYSQLND_ERROR_INFO error_info = mysql->mysql->error_info;
+#endif
+			mysqli_stmt_close(stmt->stmt, FALSE);
 			stmt->stmt = NULL;
 
 			/* restore error messages */
+#if !defined(MYSQLI_USE_MYSQLND)
 			mysql->mysql->net.last_errno = last_errno;
 			memcpy(mysql->mysql->net.last_error, last_error, MYSQL_ERRMSG_SIZE);
 			memcpy(mysql->mysql->net.sqlstate, sqlstate, SQLSTATE_LENGTH+1);
+#else
+			mysql->mysql->error_info = error_info;
+#endif
 		}
 	}
-	/* don't joing to the previous if because it won't work if mysql_stmt_prepare_fails */
+
+	/* don't initialize stmt->query with NULL, we ecalloc()-ed the memory */
+	/* Get performance boost if reporting is switched off */
+	if (stmt->stmt && query_len && (MyG(report_mode) & MYSQLI_REPORT_INDEX)) {
+		stmt->query = (char *)emalloc(query_len + 1);
+		memcpy(stmt->query, query, query_len);
+		stmt->query[query_len] = '\0';
+	}
+
+	/* don't join to the previous if because it won't work if mysql_stmt_prepare_fails */
 	if (!stmt->stmt) {
 		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 		efree(stmt);
 		RETURN_FALSE;
 	}
 
-
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = (void *)stmt;
-	/* don't initialize stmt->query with NULL, we ecalloc()-ed the memory */
-	/* Get performance boost if reporting is switched off */
-	if (query_len && (MyG(report_mode) & MYSQLI_REPORT_INDEX)) {
-		stmt->query = (char *)emalloc(query_len + 1);
-		memcpy(stmt->query, query, query_len);
-		stmt->query[query_len] = '\0';
-	}
 
 	/* change status */
 	mysqli_resource->status = MYSQLI_STATUS_VALID;
@@ -1419,98 +1840,29 @@
 }
 /* }}} */
 
+
 /* {{{ proto bool mysqli_real_connect(object link [,string hostname [,string username [,string passwd [,string dbname [,int port [,string socket [,int flags]]]]]]])
-   Open a connection to a mysql server */ 
+   Open a connection to a mysql server */
 PHP_FUNCTION(mysqli_real_connect)
 {
-	MY_MYSQL 		*mysql;
-	char 			*hostname = NULL, *username=NULL, *passwd=NULL, *dbname=NULL, *socket=NULL;
-	unsigned int 	hostname_len = 0, username_len = 0, passwd_len = 0, dbname_len = 0, socket_len = 0;
-	unsigned long 	port=0, flags=0;
-	zval			*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|sssslsl", &mysql_link, mysqli_link_class_entry,
-		&hostname, &hostname_len, &username, &username_len, &passwd, &passwd_len, &dbname, &dbname_len, &port, &socket, &socket_len,
-		&flags) == FAILURE) {
-		return;
-	}
-
-	if (!socket_len) {
-		socket = NULL;
-	}
-
-	/* TODO: safe mode handling */
-	if (PG(sql_safe_mode)) {
-	} else {
-		if (!socket_len || !socket) {
-			socket = MyG(default_socket);
-		}
-		if (!port) {
-			port = MyG(default_port);
-		}
-		if (!passwd) {
-			passwd = MyG(default_pw);
-		}
-		if (!username){
-			username = MyG(default_user);
-		}
-		if (!hostname) {
-			hostname = MyG(default_host);
-		}
-	}	
-
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_INITIALIZED);
-
-
-	/* set some required options */
-	flags |= CLIENT_MULTI_RESULTS; /* needed for mysql_multi_query() */
-	/* remove some insecure options */
-	flags &= ~CLIENT_MULTI_STATEMENTS;   /* don't allow multi_queries via connect parameter */
-	if ((PG(open_basedir) && PG(open_basedir)[0] != '\0') || PG(safe_mode)) {
-		flags &= ~CLIENT_LOCAL_FILES;
-	}
-
-	if (!socket) {
-		socket = MyG(default_socket);
-	}
-
-	if (mysql_real_connect(mysql->mysql,hostname,username,passwd,dbname,port,socket,flags) == NULL) {
-		php_mysqli_set_error(mysql_errno(mysql->mysql), (char *) mysql_error(mysql->mysql) TSRMLS_CC);
-		php_mysqli_throw_sql_exception( mysql->mysql->net.sqlstate, mysql->mysql->net.last_errno TSRMLS_CC,
-										"%s", mysql->mysql->net.last_error);
-
-		/* change status */
-		MYSQLI_SET_STATUS(&mysql_link, MYSQLI_STATUS_INITIALIZED);
-		RETURN_FALSE;
-	}
-
-	php_mysqli_set_error(mysql_errno(mysql->mysql), (char *)mysql_error(mysql->mysql) TSRMLS_CC);
-
-	mysql->mysql->reconnect = MyG(reconnect);
-
-	/* set our own local_infile handler */
-	php_set_local_infile_handler_default(mysql);
-
-	/* change status */
-	MYSQLI_SET_STATUS(&mysql_link, MYSQLI_STATUS_VALID);
-
-	RETURN_TRUE;
+	mysqli_common_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, TRUE, FALSE);
 }
 /* }}} */
 
+
 /* {{{ proto bool mysqli_real_query(object link, string query)
    Binary-safe version of mysql_query() */
 PHP_FUNCTION(mysqli_real_query)
 {
-	MY_MYSQL		*mysql;
-	zval			*mysql_link;
-	char			*query = NULL;
-	unsigned int 	query_len;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
+	char		*query = NULL;
+	int			query_len;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	MYSQLI_DISABLE_MQ; /* disable multi statements/queries */
 
@@ -1521,7 +1873,7 @@
 
 	if (!mysql_field_count(mysql->mysql)) {
 		if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
-			php_mysqli_report_index(query, mysql->mysql->server_status TSRMLS_CC);
+			php_mysqli_report_index(query, mysqli_server_status(mysql->mysql) TSRMLS_CC);
 		}
 	}
 
@@ -1529,7 +1881,7 @@
 }
 /* }}} */
 
-/* {{{ proto string mysqli_real_escape_string(object link, string escapestr) 
+/* {{{ proto string mysqli_real_escape_string(object link, string escapestr)
    Escapes special characters in a string for use in a SQL statement, taking into account the current charset of the connection */
 PHP_FUNCTION(mysqli_real_escape_string) {
 	MY_MYSQL	*mysql;
@@ -1539,13 +1891,13 @@
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &escapestr, &escapestr_len) == FAILURE) {
 		return;
-	}	
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	}
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	newstr = safe_emalloc(2, escapestr_len, 1);
 	newstr_len = mysql_real_escape_string(mysql->mysql, newstr, escapestr, escapestr_len);
 	newstr = erealloc(newstr, newstr_len + 1);
-		
+
 	RETURN_STRINGL(newstr, newstr_len, 0);
 }
 /* }}} */
@@ -1555,12 +1907,12 @@
 PHP_FUNCTION(mysqli_rollback)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (mysql_rollback(mysql->mysql)) {
 		RETURN_FALSE;
@@ -1574,16 +1926,15 @@
 PHP_FUNCTION(mysqli_stmt_send_long_data)
 {
 	MY_STMT *stmt;
-	zval  	*mysql_stmt;
+	zval	*mysql_stmt;
 	char	*data;
 	long	param_nr;
 	int		data_len;
 
-
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ols", &mysql_stmt, mysqli_stmt_class_entry, &param_nr, &data, &data_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	if (param_nr < 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid parameter number");
@@ -1601,14 +1952,14 @@
    Return the number of rows affected in the last query for the given link */
 PHP_FUNCTION(mysqli_stmt_affected_rows)
 {
-	MY_STMT 		*stmt;
-	zval    		*mysql_stmt;
+	MY_STMT			*stmt;
+	zval			*mysql_stmt;
 	my_ulonglong	rc;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	rc = mysql_stmt_affected_rows(stmt->stmt);
 	if (rc == (my_ulonglong) -1) {
@@ -1618,21 +1969,21 @@
 }
 /* }}} */
 
-/* {{{ proto bool mysqli_stmt_close(object stmt) 
+/* {{{ proto bool mysqli_stmt_close(object stmt)
    Close statement */
 PHP_FUNCTION(mysqli_stmt_close)
 {
-	MY_STMT 	*stmt;
-	zval    	*mysql_stmt;
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
-	mysql_stmt_close(stmt->stmt);
+	mysqli_stmt_close(stmt->stmt, FALSE);
 	stmt->stmt = NULL;
-	php_clear_stmt_bind(stmt); 
+	php_clear_stmt_bind(stmt TSRMLS_CC);
 	MYSQLI_CLEAR_RESOURCE(&mysql_stmt);
 	RETURN_TRUE;
 }
@@ -1642,9 +1993,9 @@
    Move internal result pointer */
 PHP_FUNCTION(mysqli_stmt_data_seek)
 {
-	MY_STMT 	*stmt;
-	zval  		*mysql_stmt;
-	long  		offset;
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
+	long		offset;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ol", &mysql_stmt, mysqli_stmt_class_entry, &offset) == FAILURE) {
 		return;
@@ -1654,7 +2005,7 @@
 		RETURN_FALSE;
 	}
 
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	mysql_stmt_data_seek(stmt->stmt, offset);
 }
@@ -1664,30 +2015,30 @@
    Return the number of result columns for the given statement */
 PHP_FUNCTION(mysqli_stmt_field_count)
 {
-	MY_STMT 	*stmt;
+	MY_STMT		*stmt;
 	zval		*mysql_stmt;
-	
+
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
-		
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
 	RETURN_LONG(mysql_stmt_field_count(stmt->stmt));
 }
 /* }}} */
 
 /* {{{ proto void mysqli_stmt_free_result(object stmt)
    Free stored result memory for the given statement handle */
-PHP_FUNCTION(mysqli_stmt_free_result) 
+PHP_FUNCTION(mysqli_stmt_free_result)
 {
-	MY_STMT 		*stmt;
-	zval    		*mysql_stmt;
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	mysql_stmt_free_result(stmt->stmt);
 }
@@ -1697,47 +2048,47 @@
    Get the ID generated from the previous INSERT operation */
 PHP_FUNCTION(mysqli_stmt_insert_id)
 {
-	MY_STMT		 	*stmt;
-	my_ulonglong 	rc;
-	zval  			*mysql_stmt;
+	MY_STMT			*stmt;
+	my_ulonglong	rc;
+	zval			*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 	rc = mysql_stmt_insert_id(stmt->stmt);
 	MYSQLI_RETURN_LONG_LONG(rc)
 }
 /* }}} */
 
-/* {{{ proto int mysqli_stmt_param_count(object stmt) {
+/* {{{ proto int mysqli_stmt_param_count(object stmt)
    Return the number of parameter for the given statement */
 PHP_FUNCTION(mysqli_stmt_param_count)
 {
-	MY_STMT 	*stmt;
+	MY_STMT		*stmt;
 	zval		*mysql_stmt;
-	
+
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
-		
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
 	RETURN_LONG(mysql_stmt_param_count(stmt->stmt));
 }
 /* }}} */
 
 /* {{{ proto bool mysqli_stmt_reset(object stmt)
    reset a prepared statement */
-PHP_FUNCTION(mysqli_stmt_reset) 
+PHP_FUNCTION(mysqli_stmt_reset)
 {
-	MY_STMT 		*stmt;
-	zval    		*mysql_stmt;
+	MY_STMT		*stmt;
+	zval		*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	if (mysql_stmt_reset(stmt->stmt)) {
 		RETURN_FALSE;
@@ -1750,75 +2101,73 @@
    Return the number of rows in statements result set */
 PHP_FUNCTION(mysqli_stmt_num_rows)
 {
-	MY_STMT 		*stmt;
-	zval    		*mysql_stmt;
+	MY_STMT			*stmt;
+	zval			*mysql_stmt;
 	my_ulonglong	rc;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
 
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	rc = mysql_stmt_num_rows(stmt->stmt);
 	MYSQLI_RETURN_LONG_LONG(rc)
 }
 /* }}} */
 
-/* {{{ proto string mysqli_select_db(object link, string dbname)
+/* {{{ proto bool mysqli_select_db(object link, string dbname)
    Select a MySQL database */
-PHP_FUNCTION(mysqli_select_db) 
+PHP_FUNCTION(mysqli_select_db)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link;
-	char  		*dbname;
-	int   		dbname_len;
+	zval		*mysql_link;
+	char		*dbname;
+	int			dbname_len;
 
-
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &dbname, &dbname_len) == FAILURE) {
 		return;
-	} 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-	
-	if (!mysql_select_db(mysql->mysql, dbname)) {
-		RETURN_TRUE;
 	}
-	
-	MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
-	RETURN_FALSE;
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
+
+	if (mysql_select_db(mysql->mysql, dbname)) {
+		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
+		RETURN_FALSE;
+	}
+	RETURN_TRUE;
 }
 /* }}} */
 
 /* {{{ proto string mysqli_sqlstate(object link)
    Returns the SQLSTATE error from previous MySQL operation */
-PHP_FUNCTION(mysqli_sqlstate) 
+PHP_FUNCTION(mysqli_sqlstate)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 	RETURN_STRING((char *)mysql_sqlstate(mysql->mysql),1);
 }
 /* }}} */
 
-/* {{{ proto bool mysqli_ssl_set(object link ,string key ,string cert ,string ca ,string capath ,string cipher])
+/* {{{ proto bool mysqli_ssl_set(object link ,string key ,string cert ,string ca ,string capath ,string cipher]) U
 */
 PHP_FUNCTION(mysqli_ssl_set)
 {
 	MY_MYSQL	*mysql;
-	zval  		*mysql_link;
-	char  		*ssl_parm[5];
+	zval		*mysql_link;
+	char		*ssl_parm[5];
 	int			ssl_parm_len[5], i;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Osssss", &mysql_link, mysqli_link_class_entry, &ssl_parm[0], &ssl_parm_len[0], &ssl_parm[1], &ssl_parm_len[1], &ssl_parm[2], &ssl_parm_len[2], &ssl_parm[3], &ssl_parm_len[3], &ssl_parm[4], &ssl_parm_len[4])   == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_INITIALIZED);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_INITIALIZED);
 
-	for (i=0; i < 5; i++) {
+	for (i = 0; i < 5; i++) {
 		if (!ssl_parm_len[i]) {
 			ssl_parm[i] = NULL;
 		}
@@ -1829,45 +2178,102 @@
 	RETURN_TRUE;
 }
 /* }}} */
-  
-/* {{{ proto mixed mysqli_stat(object link) 
+
+/* {{{ proto mixed mysqli_stat(object link)
    Get current system status */
 PHP_FUNCTION(mysqli_stat)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 	char		*stat;
+#if defined(MYSQLI_USE_MYSQLND)
+	uint		stat_len;
+#endif
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	if ((stat = (char *)mysql_stat(mysql->mysql))) {
+#if !defined(MYSQLI_USE_MYSQLND)
+	if ((stat = (char *)mysql_stat(mysql->mysql)))
+	{
 		RETURN_STRING(stat, 1);
+#else
+	if (mysqlnd_stat(mysql->mysql, &stat, &stat_len) == PASS)
+	{
+		RETURN_STRINGL(stat, stat_len, 0);
+#endif
+	} else {
+		RETURN_FALSE;
 	}
-	RETURN_FALSE;
 }
 
 /* }}} */
- 
+
+/* {{{ proto bool mysqli_refresh(object link, long options)
+   Flush tables or caches, or reset replication server information */
+PHP_FUNCTION(mysqli_refresh)
+{
+	MY_MYSQL *mysql;
+	zval *mysql_link = NULL;
+	long options;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ol", &mysql_link, mysqli_link_class_entry, &options) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_INITIALIZED);
+#ifdef MYSQLI_USE_MYSQLND
+	RETURN_BOOL(!mysql_refresh(mysql->mysql, (uint8_t) options));
+#else
+	RETURN_BOOL(!mysql_refresh(mysql->mysql, options));
+#endif
+}
+/* }}} */
+
 /* {{{ proto int mysqli_stmt_attr_set(object stmt, long attr, long mode)
 */
 PHP_FUNCTION(mysqli_stmt_attr_set)
 {
 	MY_STMT	*stmt;
-	zval 	*mysql_stmt;
-	ulong   mode;
+	zval	*mysql_stmt;
+	long	mode_in;
+#if MYSQL_VERSION_ID >= 50107
+	my_bool	mode_b;
+#endif
+	ulong	mode;
 	ulong	attr;
+	void	*mode_p;
 
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oll", &mysql_stmt, mysqli_stmt_class_entry, &attr, &mode) == FAILURE) {
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oll", &mysql_stmt, mysqli_stmt_class_entry, &attr, &mode_in) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
-	if (!mysql_stmt_attr_set(stmt->stmt, attr, (void *)&mode)) {
+	if (mode_in < 0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "mode should be non-negative, %ld passed", mode_in);
 		RETURN_FALSE;
 	}
+
+	switch (attr) {
+#if MYSQL_VERSION_ID >= 50107
+	case STMT_ATTR_UPDATE_MAX_LENGTH:
+		mode_b = (my_bool) mode_in;
+		mode_p = &mode_b;
+		break;
+#endif
+	default:
+		mode = mode_in;
+		mode_p = &mode;
+		break;
+	}
+#if !defined(MYSQLI_USE_MYSQLND)
+	if (mysql_stmt_attr_set(stmt->stmt, attr, mode_p)) {
+#else
+	if (FAIL == mysql_stmt_attr_set(stmt->stmt, attr, mode_p)) {
+#endif
+		RETURN_FALSE;
+	}
 	RETURN_TRUE;
 }
 /* }}} */
@@ -1877,23 +2283,24 @@
 PHP_FUNCTION(mysqli_stmt_attr_get)
 {
 	MY_STMT	*stmt;
-	zval 	*mysql_stmt;
-#if MYSQL_VERSION_ID > 50099
-	my_bool value;
-#else
+	zval	*mysql_stmt;
 	ulong	value = 0;
-#endif
 	ulong	attr;
 	int		rc;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Ol", &mysql_stmt, mysqli_stmt_class_entry, &attr) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	if ((rc = mysql_stmt_attr_get(stmt->stmt, attr, &value))) {
 		RETURN_FALSE;
 	}
+
+#if MYSQL_VERSION_ID >= 50107
+	if (attr == STMT_ATTR_UPDATE_MAX_LENGTH)
+		value = *((my_bool *)&value);
+#endif
 	RETURN_LONG((long)value);
 }
 /* }}} */
@@ -1903,12 +2310,12 @@
 PHP_FUNCTION(mysqli_stmt_errno)
 {
 	MY_STMT	*stmt;
-	zval 	*mysql_stmt;
+	zval	*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_INITIALIZED);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_INITIALIZED);
 
 	RETURN_LONG(mysql_stmt_errno(stmt->stmt));
 }
@@ -1916,7 +2323,7 @@
 
 /* {{{ proto string mysqli_stmt_error(object stmt)
 */
-PHP_FUNCTION(mysqli_stmt_error) 
+PHP_FUNCTION(mysqli_stmt_error)
 {
 	MY_STMT	*stmt;
 	zval 	*mysql_stmt;
@@ -1924,8 +2331,8 @@
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_INITIALIZED);
-	
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_INITIALIZED);
+
 	RETURN_STRING((char *)mysql_stmt_error(stmt->stmt),1);
 }
 /* }}} */
@@ -1936,14 +2343,14 @@
 PHP_FUNCTION(mysqli_stmt_init)
 {
 	MY_MYSQL		*mysql;
-	MY_STMT 		*stmt;
+	MY_STMT			*stmt;
 	zval			*mysql_link;
-	MYSQLI_RESOURCE *mysqli_resource; 
+	MYSQLI_RESOURCE	*mysqli_resource;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",&mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	stmt = (MY_STMT *)ecalloc(1,sizeof(MY_STMT));
 
@@ -1972,7 +2379,7 @@
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_stmt, mysqli_stmt_class_entry, &query, &query_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_INITIALIZED);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_INITIALIZED);
 
 	if (mysql_stmt_prepare(stmt->stmt, query, query_len)) {
 		MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
@@ -1988,15 +2395,15 @@
    return result set from statement */
 PHP_FUNCTION(mysqli_stmt_result_metadata)
 {
-	MY_STMT		*stmt;
+	MY_STMT			*stmt;
 	MYSQL_RES		*result;
-	zval 			*mysql_stmt;
+	zval			*mysql_stmt;
 	MYSQLI_RESOURCE	*mysqli_resource;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
 
 	if (!(result = mysql_stmt_result_metadata(stmt->stmt))){
 		MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
@@ -2006,7 +2413,7 @@
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = (void *)result;
 	mysqli_resource->status = MYSQLI_STATUS_VALID;
-	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);	
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);
 }
 /* }}} */
 
@@ -2014,33 +2421,43 @@
 */
 PHP_FUNCTION(mysqli_stmt_store_result)
 {
-	MY_STMT *stmt;
-	zval 	*mysql_stmt;
-	int		i=0;
+	MY_STMT	*stmt;
+	zval	*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
-	
-	/*
-	  If the user wants to store the data and we have BLOBs/TEXTs we try to allocate
-	  not the maximal length of the type (which is 16MB even for LONGBLOB) but
-	  the maximal length of the field in the result set. If he/she has quite big
-	  BLOB/TEXT columns after calling store_result() the memory usage of PHP will
-	  double - but this is a known problem of the simple MySQL API ;)
-	*/
-	for (i = mysql_stmt_field_count(stmt->stmt) - 1; i >=0; --i) {
-		if (stmt->stmt->fields && (stmt->stmt->fields[i].type == MYSQL_TYPE_BLOB ||
-			stmt->stmt->fields[i].type == MYSQL_TYPE_MEDIUM_BLOB ||
-			stmt->stmt->fields[i].type == MYSQL_TYPE_LONG_BLOB))
-		{
-			my_bool	tmp=1;
-			mysql_stmt_attr_set(stmt->stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &tmp);
-			break;
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+#if !defined(MYSQLI_USE_MYSQLND)
+	{
+		/*
+		  If the user wants to store the data and we have BLOBs/TEXTs we try to allocate
+		  not the maximal length of the type (which is 16MB even for LONGBLOB) but
+		  the maximal length of the field in the result set. If he/she has quite big
+		  BLOB/TEXT columns after calling store_result() the memory usage of PHP will
+		  double - but this is a known problem of the simple MySQL API ;)
+		*/
+		int	i = 0;
+
+		for (i = mysql_stmt_field_count(stmt->stmt) - 1; i >=0; --i) {
+			if (stmt->stmt->fields && (stmt->stmt->fields[i].type == MYSQL_TYPE_BLOB ||
+				stmt->stmt->fields[i].type == MYSQL_TYPE_MEDIUM_BLOB ||
+				stmt->stmt->fields[i].type == MYSQL_TYPE_LONG_BLOB ||
+				stmt->stmt->fields[i].type == MYSQL_TYPE_GEOMETRY))
+			{
+#if MYSQL_VERSION_ID >= 50107
+				my_bool	tmp=1;
+#else
+				uint tmp=1;
+#endif
+				mysql_stmt_attr_set(stmt->stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &tmp);
+				break;
+			}
 		}
 	}
-	
+#endif
+
 	if (mysql_stmt_store_result(stmt->stmt)){
 		MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
 		RETURN_FALSE;
@@ -2051,16 +2468,16 @@
 
 /* {{{ proto string mysqli_stmt_sqlstate(object stmt)
 */
-PHP_FUNCTION(mysqli_stmt_sqlstate) 
+PHP_FUNCTION(mysqli_stmt_sqlstate)
 {
-	MY_STMT *stmt;
-	zval 	*mysql_stmt;
+	MY_STMT	*stmt;
+	zval	*mysql_stmt;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &mysql_stmt, "mysqli_stmt", MYSQLI_STATUS_VALID);
-	
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
 	RETURN_STRING((char *)mysql_stmt_sqlstate(stmt->stmt),1);
 }
 /* }}} */
@@ -2069,44 +2486,45 @@
    Buffer result set on client */
 PHP_FUNCTION(mysqli_store_result)
 {
-	MY_MYSQL 		*mysql;
-	MYSQL_RES 		*result;
-	zval  			*mysql_link;
+	MY_MYSQL		*mysql;
+	MYSQL_RES		*result;
+	zval			*mysql_link;
 	MYSQLI_RESOURCE	*mysqli_resource;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (!(result = mysql_store_result(mysql->mysql))) {
 		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 		RETURN_FALSE;
 	}
 	if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
-		php_mysqli_report_index("from previous query", mysql->mysql->server_status TSRMLS_CC);
+		php_mysqli_report_index("from previous query", mysqli_server_status(mysql->mysql) TSRMLS_CC);
 	}
 
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = (void *)result;
 	mysqli_resource->status = MYSQLI_STATUS_VALID;
-	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);	
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);
 }
 /* }}} */
 
+
 /* {{{ proto int mysqli_thread_id(object link)
    Return the current thread ID */
 PHP_FUNCTION(mysqli_thread_id)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	RETURN_LONG(mysql_thread_id(mysql->mysql));
+	RETURN_LONG((long) mysql_thread_id(mysql->mysql));
 }
 /* }}} */
 
@@ -2116,22 +2534,21 @@
 {
 	RETURN_BOOL(mysql_thread_safe());
 }
-
 /* }}} */
 
 /* {{{ proto mixed mysqli_use_result(object link)
    Directly retrieve query results - do not buffer results on client side */
 PHP_FUNCTION(mysqli_use_result)
 {
-	MY_MYSQL 		*mysql;
-	MYSQL_RES 		*result;
-	zval  			*mysql_link;
-	MYSQLI_RESOURCE *mysqli_resource;
+	MY_MYSQL		*mysql;
+	MYSQL_RES		*result;
+	zval			*mysql_link;
+	MYSQLI_RESOURCE	*mysqli_resource;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (!(result = mysql_use_result(mysql->mysql))) {
 		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
@@ -2139,12 +2556,12 @@
 	}
 
 	if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
-		php_mysqli_report_index("from previous query", mysql->mysql->server_status TSRMLS_CC);
+		php_mysqli_report_index("from previous query", mysqli_server_status(mysql->mysql) TSRMLS_CC);
 	}
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = (void *)result;
 	mysqli_resource->status = MYSQLI_STATUS_VALID;
-	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);	
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);
 }
 /* }}} */
 
@@ -2152,13 +2569,13 @@
    Return number of warnings from the last query for the given link */
 PHP_FUNCTION(mysqli_warning_count)
 {
-	MY_MYSQL 	*mysql;
-	zval  		*mysql_link;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	RETURN_LONG(mysql_warning_count(mysql->mysql));
 }
--- a/ext/mysqli/mysqli_driver.c
+++ b/ext/mysqli/mysqli_driver.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -25,14 +25,14 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
 #include "zend_exceptions.h"
+#include "mysqli_fe.h"
 
-
 #define MAP_PROPERTY_MYG_BOOL_READ(name, value) \
 static int name(mysqli_object *obj, zval **retval TSRMLS_DC) \
 { \
-	ALLOC_ZVAL(*retval); \
+	MAKE_STD_ZVAL(*retval); \
 	ZVAL_BOOL(*retval, MyG(value)); \
 	return SUCCESS; \
 } \
@@ -47,7 +47,7 @@
 #define MAP_PROPERTY_MYG_LONG_READ(name, value) \
 static int name(mysqli_object *obj, zval **retval TSRMLS_DC) \
 { \
-	ALLOC_ZVAL(*retval); \
+	MAKE_STD_ZVAL(*retval); \
 	ZVAL_LONG(*retval, MyG(value)); \
 	return SUCCESS; \
 } \
@@ -62,7 +62,7 @@
 #define MAP_PROPERTY_MYG_STRING_READ(name, value) \
 static int name(mysqli_object *obj, zval **retval TSRMLS_DC) \
 { \
-	ALLOC_ZVAL(*retval); \
+	MAKE_STD_ZVAL(*retval); \
 	ZVAL_STRING(*retval, MyG(value), 1); \
 	return SUCCESS; \
 } \
@@ -78,8 +78,8 @@
 static int driver_report_write(mysqli_object *obj, zval *value TSRMLS_DC)
 {
 	MyG(report_mode) = Z_LVAL_P(value);
-	php_set_error_handling(MyG(report_mode) & MYSQLI_REPORT_STRICT ? EH_THROW : EH_NORMAL, 
-							zend_exception_get_default(TSRMLS_C) TSRMLS_CC);
+	/*FIXME*/
+	/* zend_replace_error_handling(MyG(report_mode) & MYSQLI_REPORT_STRICT ? EH_THROW : EH_NORMAL, NULL, NULL TSRMLS_CC); */
 	return SUCCESS;
 }
 /* }}} */
@@ -87,7 +87,7 @@
 /* {{{ property driver_embedded_read */
 static int driver_embedded_read(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
-	ALLOC_ZVAL(*retval);
+	MAKE_STD_ZVAL(*retval);
 #ifdef HAVE_EMBEDDED_MYSQLI
 	ZVAL_BOOL(*retval, 1);
 #else
@@ -100,7 +100,7 @@
 /* {{{ property driver_client_version_read */
 static int driver_client_version_read(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
-	ALLOC_ZVAL(*retval);
+	MAKE_STD_ZVAL(*retval);
 	ZVAL_LONG(*retval, MYSQL_VERSION_ID);
 	return SUCCESS;
 }
@@ -109,8 +109,8 @@
 /* {{{ property driver_client_info_read */
 static int driver_client_info_read(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
-	ALLOC_ZVAL(*retval);
-	ZVAL_STRING(*retval, MYSQL_SERVER_VERSION, 1);
+	MAKE_STD_ZVAL(*retval);
+	ZVAL_STRING(*retval, (char *)mysql_get_client_info(), 1);
 	return SUCCESS;
 }
 /* }}} */
@@ -118,35 +118,58 @@
 /* {{{ property driver_driver_version_read */
 static int driver_driver_version_read(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
-	ALLOC_ZVAL(*retval);
+	MAKE_STD_ZVAL(*retval);
 	ZVAL_LONG(*retval, MYSQLI_VERSION_ID);
 	return SUCCESS;
 }
 /* }}} */
 
-MAP_PROPERTY_MYG_BOOL_READ(driver_reconnect_read, reconnect);
-MAP_PROPERTY_MYG_BOOL_WRITE(driver_reconnect_write, reconnect);
-MAP_PROPERTY_MYG_LONG_READ(driver_report_read, report_mode);
+MAP_PROPERTY_MYG_BOOL_READ(driver_reconnect_read, reconnect)
+MAP_PROPERTY_MYG_BOOL_WRITE(driver_reconnect_write, reconnect)
+MAP_PROPERTY_MYG_LONG_READ(driver_report_read, report_mode)
 
 ZEND_FUNCTION(mysqli_driver_construct)
 {
+#if G0
+	MYSQLI_RESOURCE 	*mysqli_resource;
+
+	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
+	mysqli_resource->ptr = 1;
+	mysqli_resource->status = (ZEND_NUM_ARGS() == 1) ? MYSQLI_STATUS_INITIALIZED : MYSQLI_STATUS_VALID;
+	((mysqli_object *) zend_object_store_get_object(getThis() TSRMLS_CC))->ptr = mysqli_resource;
+#endif
 }
 
-mysqli_property_entry mysqli_driver_property_entries[] = {
-	{"client_info", driver_client_info_read, NULL},
-	{"client_version", driver_client_version_read, NULL},
-	{"driver_version", driver_driver_version_read, NULL},
-	{"embedded", driver_embedded_read, NULL},
-	{"reconnect", driver_reconnect_read, driver_reconnect_write},
-	{"report_mode", driver_report_read, driver_report_write},
-	{NULL, NULL, NULL}
+const mysqli_property_entry mysqli_driver_property_entries[] = {
+	{"client_info", sizeof("client_info") - 1, driver_client_info_read, NULL},
+	{"client_version", sizeof("client_version") - 1, driver_client_version_read, NULL},
+	{"driver_version", sizeof("driver_version") - 1, driver_driver_version_read, NULL},
+	{"embedded", sizeof("embedded") - 1, driver_embedded_read, NULL},
+	{"reconnect", sizeof("reconnect") - 1, driver_reconnect_read, driver_reconnect_write},
+	{"report_mode", sizeof("report_mode") - 1, driver_report_read, driver_report_write},
+	{NULL, 0, NULL, NULL}
 };
 
+/* {{{ mysqli_warning_property_info_entries */
+zend_property_info mysqli_driver_property_info_entries[] = {
+	{ZEND_ACC_PUBLIC, "client_info",	sizeof("client_info") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "client_version",	sizeof("client_version") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "driver_version",	sizeof("driver_version") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "embedded",		sizeof("embedded") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "reconnect",		sizeof("reconnect") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "report_mode",	sizeof("report_mode") - 1,		0, NULL, 0, NULL},
+	{0,					NULL, 			0,								0, NULL, 0, NULL},
+};
+/* }}} */
+
+
 /* {{{ mysqli_driver_methods[]
  */
-zend_function_entry mysqli_driver_methods[] = {
+const zend_function_entry mysqli_driver_methods[] = {
+#if defined(HAVE_EMBEDDED_MYSQLI)
 	PHP_FALIAS(embedded_server_start, mysqli_embedded_server_start, NULL)
 	PHP_FALIAS(embedded_server_end, mysqli_embedded_server_end, NULL)
+#endif
 	{NULL, NULL, NULL}
 };
 /* }}} */
--- a/ext/mysqli/mysqli_embedded.c
+++ b/ext/mysqli/mysqli_embedded.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -25,43 +25,42 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
 
 /* {{{ proto bool mysqli_embedded_server_start(bool start, array arguments, array groups)
    initialize and start embedded server */
 PHP_FUNCTION(mysqli_embedded_server_start)
 {
 #ifdef HAVE_EMBEDDED_MYSQLI
+	long start;
+	zval *args;
+	zval *grps;
+
 	int	argc = 0;
 	char **arguments;
 	char **groups;
-	zval **args, **grps, **start;
 	HashPosition pos;
 	int index, rc;
 
-	if (ZEND_NUM_ARGS() != 3 || zend_get_parameters_ex(3, &start, &args, &grps) == FAILURE) {
-		ZEND_WRONG_PARAM_COUNT();
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "laa", &start, &args, &grps) == FAILURE) {
+		return;
 	}
 
-	convert_to_long_ex(start);
-	convert_to_array_ex(args);
-	convert_to_array_ex(grps);
-
-	if (!Z_LVAL_PP(start)) {
+	if (!start) {
 		mysql_server_init(-1,NULL, NULL);
 		RETURN_TRUE;
 	}
 	/* get arguments */
-	if ((argc = zend_hash_num_elements(HASH_OF(*args)))) {
+	if ((argc = zend_hash_num_elements(HASH_OF(args)))) {
 		arguments = safe_emalloc(sizeof(char *), argc + 1, 0);
-		arguments[0] = NULL; 
+		arguments[0] = NULL;
 
-		zend_hash_internal_pointer_reset_ex(HASH_OF(*args), &pos);
+		zend_hash_internal_pointer_reset_ex(HASH_OF(args), &pos);
 
-		for (index = 0;; zend_hash_move_forward_ex(HASH_OF(*args), &pos))	{
+		for (index = 0;; zend_hash_move_forward_ex(HASH_OF(args), &pos))	{
 			zval **item;
 
-			if (zend_hash_get_current_data_ex(HASH_OF(*args), (void **) &item, &pos) == FAILURE) {
+			if (zend_hash_get_current_data_ex(HASH_OF(args), (void **) &item, &pos) == FAILURE) {
 				break;
 			}
 
@@ -73,16 +72,16 @@
 	}
 
 	/* get groups */
-	if ((zend_hash_num_elements(HASH_OF(*grps)))) {
-		groups = safe_emalloc(sizeof(char *), zend_hash_num_elements(HASH_OF(*grps)) + 1, 0);
-		groups[0] = NULL; 
+	if ((zend_hash_num_elements(HASH_OF(grps)))) {
+		groups = safe_emalloc(sizeof(char *), zend_hash_num_elements(HASH_OF(grps)) + 1, 0);
+		groups[0] = NULL;
 
-		zend_hash_internal_pointer_reset_ex(HASH_OF(*grps), &pos);
+		zend_hash_internal_pointer_reset_ex(HASH_OF(grps), &pos);
 
-		for (index = 0;; zend_hash_move_forward_ex(HASH_OF(*grps), &pos))	{
+		for (index = 0;; zend_hash_move_forward_ex(HASH_OF(grps), &pos))	{
 			zval ** item;
 
-			if (zend_hash_get_current_data_ex(HASH_OF(*grps), (void **) &item, &pos) == FAILURE) {
+			if (zend_hash_get_current_data_ex(HASH_OF(grps), (void **) &item, &pos) == FAILURE) {
 				break;
 			}
 
@@ -90,7 +89,7 @@
 
 			groups[++index] = Z_STRVAL_PP(item);
 		}
-		groups[index] = NULL;	
+		groups[index] = NULL;
 	} else {
 		groups = safe_emalloc(sizeof(char *), 1, 0);
 		groups[0] = NULL;
--- a/ext/mysqli/mysqli_exception.c
+++ b/ext/mysqli/mysqli_exception.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -25,23 +25,24 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_priv.h"
 #include "zend_exceptions.h"
 
 /* {{{ mysqli_exception_methods[]
  */
-zend_function_entry mysqli_exception_methods[] = {
+const zend_function_entry mysqli_exception_methods[] = {
 	{NULL, NULL, NULL}
 };
 /* }}} */
 
-void php_mysqli_throw_sql_exception(char *sqlstate, int errorno TSRMLS_DC, char *format, ...) 
+void php_mysqli_throw_sql_exception(char *sqlstate, int errorno TSRMLS_DC, char *format, ...)
 {
 	zval	*sql_ex;
 	va_list arg;
 	char 	*message;
 
-	va_start(arg, format); 
+	va_start(arg, format);
 	vspprintf(&message, 0, format, arg);
 	va_end(arg);;
 
--- a/ext/mysqli/mysqli_fe.c
+++ b/ext/mysqli/mysqli_fe.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -12,10 +12,12 @@
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
-  | Author: Georg Richter <georg@php.net>                                |
+  | Authors: Georg Richter <georg@php.net>                               |
+  |          Andrey Hristov <andrey@php.net>                             |
+  |          Ulf Wendel <uw@php.net>                                     |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli_fe.c 293036 2010-01-03 09:23:27Z sebastian $ 
+  $Id$
 */
 
 #ifdef HAVE_CONFIG_H
@@ -27,158 +29,446 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_fe.h"
+#include "mysqli_priv.h"
 
+#if PHP_VERSION_ID >= 50399
+#define MYSQLI_ZEND_ARG_OBJ_INFO_LINK() ZEND_ARG_OBJ_INFO(0, link, mysqli, 0)
+#define MYSQLI_ZEND_ARG_OBJ_INFO_RESULT() ZEND_ARG_OBJ_INFO(0, result, mysqli_result, 0)
+#define MYSQLI_ZEND_ARG_OBJ_INFO_STMT() ZEND_ARG_OBJ_INFO(0, stmt, mysqli_stmt, 0)
+#else
+#define MYSQLI_ZEND_ARG_OBJ_INFO_LINK() ZEND_ARG_INFO(0, link)
+#define MYSQLI_ZEND_ARG_OBJ_INFO_RESULT() ZEND_ARG_INFO(0, result)
+#define MYSQLI_ZEND_ARG_OBJ_INFO_STMT() ZEND_ARG_INFO(0, stmt)
+#endif
 
-static
-	ZEND_BEGIN_ARG_INFO(second_arg_force_by_ref_rest, 1)
-		ZEND_ARG_PASS_INFO(0)
-	ZEND_END_ARG_INFO();
+ZEND_BEGIN_ARG_INFO(arginfo_mysqli_stmt_bind_result, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+ZEND_END_ARG_INFO()
 
-static
-	ZEND_BEGIN_ARG_INFO(third_arg_force_by_ref_rest, 1)
-		ZEND_ARG_PASS_INFO(0)
-		ZEND_ARG_PASS_INFO(0)
-	ZEND_END_ARG_INFO();
+ZEND_BEGIN_ARG_INFO(arginfo_mysqli_stmt_bind_param, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+	ZEND_ARG_INFO(0, types)
+ZEND_END_ARG_INFO()
 
-static
-	ZEND_BEGIN_ARG_INFO(all_args_force_by_ref, 1)
-	ZEND_END_ARG_INFO();
+ZEND_BEGIN_ARG_INFO(arginfo_class_mysqli_stmt_bind_result, 1)
+ZEND_END_ARG_INFO()
 
+ZEND_BEGIN_ARG_INFO(arginfo_class_mysqli_stmt_bind_param, 1)
+	ZEND_ARG_INFO(0, types)
+ZEND_END_ARG_INFO()
 
+ZEND_BEGIN_ARG_INFO(all_args_force_by_ref, 1)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_poll, 0, 0, 4)
+	ZEND_ARG_ARRAY_INFO(1, read, 1)
+	ZEND_ARG_ARRAY_INFO(1, write, 1)
+	ZEND_ARG_ARRAY_INFO(1, error, 1)
+	ZEND_ARG_INFO(0, sec)
+	ZEND_ARG_INFO(0, usec)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_no_params, 0, 0, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_only_link, 0, 0, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_autocommit, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, mode)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_autocommit, 0, 0, 1)
+	ZEND_ARG_INFO(0, mode)
+ZEND_END_ARG_INFO()
+
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_change_user, 0, 0, 4)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, user)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, database)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_change_user, 0, 0, 3)
+	ZEND_ARG_INFO(0, user)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, database)
+ZEND_END_ARG_INFO()
+
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_connect, 0, 0, 0)
+	ZEND_ARG_INFO(0, host)
+	ZEND_ARG_INFO(0, user)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, database)
+	ZEND_ARG_INFO(0, port)
+	ZEND_ARG_INFO(0, socket)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_real_connect, 0, 0, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, host)
+	ZEND_ARG_INFO(0, user)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, database)
+	ZEND_ARG_INFO(0, port)
+	ZEND_ARG_INFO(0, socket)
+	ZEND_ARG_INFO(0, flags)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_real_connect, 0, 0, 0)
+	ZEND_ARG_INFO(0, host)
+	ZEND_ARG_INFO(0, user)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, database)
+	ZEND_ARG_INFO(0, port)
+	ZEND_ARG_INFO(0, socket)
+	ZEND_ARG_INFO(0, flags)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_only_result, 0, 0, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_RESULT()
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_only_statement, 0, 0, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_data_seek, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_RESULT()
+	ZEND_ARG_INFO(0, offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_stmt_data_seek, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+	ZEND_ARG_INFO(0, offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_data_seek, 0, 0, 1)
+	ZEND_ARG_INFO(0, offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_debug, 0, 0, 1)
+	ZEND_ARG_INFO(0, debug_options)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_result_and_fieldnr, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_RESULT()
+	ZEND_ARG_INFO(0, field_nr)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_result_and_fieldnr, 0, 0, 1)
+	ZEND_ARG_INFO(0, field_nr)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_fetch_array, 0, 0, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_RESULT()
+	ZEND_ARG_INFO(0, result_type)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_fetch_array, 0, 0, 0)
+	ZEND_ARG_INFO(0, result_type)
+ZEND_END_ARG_INFO()
+
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_fetch_object, 0, 0, 1)
+#if PHP_VERSION_ID > 50399
+	MYSQLI_ZEND_ARG_OBJ_INFO_RESULT()
+	ZEND_ARG_INFO(0, class_name)
+	ZEND_ARG_ARRAY_INFO(0, params, 0)
+#endif
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_fetch_object, 0, 0, 0)
+#if PHP_VERSION_ID > 50399
+	ZEND_ARG_INFO(0, class_name)
+	ZEND_ARG_ARRAY_INFO(0, params, 0)
+#endif
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_kill, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, connection_id)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_kill, 0, 0, 1)
+	ZEND_ARG_INFO(0, connection_id)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_set_local_infile_handler, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, read_callback)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_set_local_infile_handler, 0, 0, 1)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, read_callback)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_query, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, query)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_prepare, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, query)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_stmt_prepare, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+	ZEND_ARG_INFO(0, query)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_query, 0, 0, 1)
+	ZEND_ARG_INFO(0, query)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_options, 0, 0, 3)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, option)
+	ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_options, 0, 0, 2)
+	ZEND_ARG_INFO(0, option)
+	ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_report, 0, 0, 1)
+	ZEND_ARG_INFO(0, flags)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_real_escape_string, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, string_to_escape)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_real_escape_string, 0, 0, 1)
+	ZEND_ARG_INFO(0, string_to_escape)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_select_db, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, database)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_select_db, 0, 0, 1)
+	ZEND_ARG_INFO(0, database)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_set_charset, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, charset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_set_charset, 0, 0, 1)
+	ZEND_ARG_INFO(0, charset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_stmt_attr_get, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+	ZEND_ARG_INFO(0, attribute)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_stmt_attr_get, 0, 0, 1)
+	ZEND_ARG_INFO(0, attribute)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_stmt_attr_set, 0, 0, 3)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+	ZEND_ARG_INFO(0, attribute)
+	ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_stmt_attr_set, 0, 0, 2)
+	ZEND_ARG_INFO(0, attribute)
+	ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_stmt_send_long_data, 0, 0, 3)
+	MYSQLI_ZEND_ARG_OBJ_INFO_STMT()
+	ZEND_ARG_INFO(0, param_nr)
+	ZEND_ARG_INFO(0, data)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_stmt_send_long_data, 0, 0, 2)
+	ZEND_ARG_INFO(0, param_nr)
+	ZEND_ARG_INFO(0, data)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_ssl_set, 0, 0, 6)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, cert)
+	ZEND_ARG_INFO(0, certificate_authority)
+	ZEND_ARG_INFO(0, certificate_authority_path)
+	ZEND_ARG_INFO(0, cipher)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_ssl_set, 0, 0, 5)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, cert)
+	ZEND_ARG_INFO(0, certificate_authority)
+	ZEND_ARG_INFO(0, certificate_authority_path)
+	ZEND_ARG_INFO(0, cipher)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_mysqli_refresh, 0, 0, 2)
+	MYSQLI_ZEND_ARG_OBJ_INFO_LINK()
+	ZEND_ARG_INFO(0, options)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_class_mysqli_refresh, 0, 0, 1)
+	ZEND_ARG_INFO(0, options)
+ZEND_END_ARG_INFO()
+
+
 /* {{{ mysqli_functions[]
  *
  * Every user visible function must have an entry in mysqli_functions[].
  */
-zend_function_entry mysqli_functions[] = {
-	PHP_FE(mysqli_affected_rows,						NULL)
-	PHP_FE(mysqli_autocommit,							NULL)
-	PHP_FE(mysqli_change_user,							NULL)
-	PHP_FE(mysqli_character_set_name,					NULL)
-	PHP_FE(mysqli_close,								NULL)
-	PHP_FE(mysqli_commit,								NULL)
-	PHP_FE(mysqli_connect, 								NULL)
-	PHP_FE(mysqli_connect_errno,						NULL)
-	PHP_FE(mysqli_connect_error,						NULL)
-	PHP_FE(mysqli_data_seek,							NULL)
-	PHP_FE(mysqli_debug,								NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FE(mysqli_disable_reads_from_master,			NULL)
-	PHP_FE(mysqli_disable_rpl_parse,					NULL)
-#endif
-	PHP_FE(mysqli_dump_debug_info,						NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FE(mysqli_enable_reads_from_master,				NULL)
-	PHP_FE(mysqli_enable_rpl_parse,						NULL)
-#endif
+const zend_function_entry mysqli_functions[] = {
+	PHP_FE(mysqli_affected_rows,						arginfo_mysqli_only_link)
+	PHP_FE(mysqli_autocommit,							arginfo_mysqli_autocommit)
+	PHP_FE(mysqli_change_user,							arginfo_mysqli_change_user)
+	PHP_FE(mysqli_character_set_name,					arginfo_mysqli_only_link)
+	PHP_FE(mysqli_close,								arginfo_mysqli_only_link)
+	PHP_FE(mysqli_commit,								arginfo_mysqli_only_link)
+	PHP_FE(mysqli_connect, 								arginfo_mysqli_connect)
+	PHP_FE(mysqli_connect_errno,						arginfo_mysqli_no_params)
+	PHP_FE(mysqli_connect_error,						arginfo_mysqli_no_params)
+	PHP_FE(mysqli_data_seek,							arginfo_mysqli_data_seek)
+	PHP_FE(mysqli_dump_debug_info,						arginfo_mysqli_only_link)
+	PHP_FE(mysqli_debug,								arginfo_mysqli_debug)
+#if defined(HAVE_EMBEDDED_MYSQLI)
 	PHP_FE(mysqli_embedded_server_end,					NULL)
 	PHP_FE(mysqli_embedded_server_start,				NULL)
-	PHP_FE(mysqli_errno,								NULL)
-	PHP_FE(mysqli_error,								NULL)
-	PHP_FE(mysqli_stmt_execute,							NULL)
-	PHP_FALIAS(mysqli_execute, mysqli_stmt_execute,		NULL)
-	PHP_FE(mysqli_fetch_field,							NULL)
-	PHP_FE(mysqli_fetch_fields,							NULL)
-	PHP_FE(mysqli_fetch_field_direct,					NULL)
-	PHP_FE(mysqli_fetch_lengths,						NULL)
-	PHP_FE(mysqli_fetch_array,							NULL)
-	PHP_FE(mysqli_fetch_assoc,							NULL) 
-	PHP_FE(mysqli_fetch_object,							NULL) 
-	PHP_FE(mysqli_fetch_row,							NULL)
-	PHP_FE(mysqli_field_count,							NULL)
-	PHP_FE(mysqli_field_seek,							NULL)
-	PHP_FE(mysqli_field_tell,							NULL)
-	PHP_FE(mysqli_free_result,							NULL)
-#ifdef HAVE_MYSQLI_GET_CHARSET 
-	PHP_FE(mysqli_get_charset,							NULL)
 #endif
-	PHP_FE(mysqli_get_client_info,						NULL)
-	PHP_FE(mysqli_get_client_version,					NULL)
-	PHP_FE(mysqli_get_host_info,						NULL)
-	PHP_FE(mysqli_get_proto_info,						NULL)
-	PHP_FE(mysqli_get_server_info,						NULL)
-	PHP_FE(mysqli_get_server_version,					NULL)
-	PHP_FE(mysqli_get_warnings,							NULL)
-	PHP_FE(mysqli_init, 								NULL)
-	PHP_FE(mysqli_info,									NULL)
-	PHP_FE(mysqli_insert_id,							NULL)
-	PHP_FE(mysqli_kill,									NULL)
-	PHP_FE(mysqli_set_local_infile_default,				NULL)
-	PHP_FE(mysqli_set_local_infile_handler,				NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FE(mysqli_master_query,							NULL)
+	PHP_FE(mysqli_errno,								arginfo_mysqli_only_link)
+	PHP_FE(mysqli_error,								arginfo_mysqli_only_link)
+	PHP_FE(mysqli_stmt_execute,							arginfo_mysqli_only_statement)
+	PHP_FALIAS(mysqli_execute, mysqli_stmt_execute,		arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_fetch_field,							arginfo_mysqli_only_result)
+	PHP_FE(mysqli_fetch_fields,							arginfo_mysqli_only_result)
+	PHP_FE(mysqli_fetch_field_direct,					arginfo_mysqli_result_and_fieldnr)
+	PHP_FE(mysqli_fetch_lengths,						arginfo_mysqli_only_result)
+#ifdef MYSQLI_USE_MYSQLND
+	PHP_FE(mysqli_fetch_all,							arginfo_mysqli_only_result)
 #endif
-	PHP_FE(mysqli_more_results,							NULL)
-	PHP_FE(mysqli_multi_query, 							NULL)
-	PHP_FE(mysqli_next_result,							NULL)
-	PHP_FE(mysqli_num_fields,							NULL)
-	PHP_FE(mysqli_num_rows,								NULL)
-	PHP_FE(mysqli_options, 								NULL)
-	PHP_FE(mysqli_ping,									NULL)
-	PHP_FE(mysqli_prepare,								NULL)
-	PHP_FE(mysqli_report,								NULL)
-	PHP_FE(mysqli_query,								NULL)
-	PHP_FE(mysqli_real_connect,							NULL)
-	PHP_FE(mysqli_real_escape_string,					NULL)
-	PHP_FE(mysqli_real_query,							NULL)
-	PHP_FE(mysqli_rollback,								NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FE(mysqli_rpl_parse_enabled,					NULL)
-	PHP_FE(mysqli_rpl_probe,							NULL)
-	PHP_FE(mysqli_rpl_query_type,						NULL)
+	PHP_FE(mysqli_fetch_array,							arginfo_mysqli_fetch_array)
+	PHP_FE(mysqli_fetch_assoc,							arginfo_mysqli_only_result)
+	PHP_FE(mysqli_fetch_object,							arginfo_mysqli_fetch_object)
+	PHP_FE(mysqli_fetch_row,							arginfo_mysqli_only_result)
+	PHP_FE(mysqli_field_count,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_field_seek,							arginfo_mysqli_result_and_fieldnr)
+	PHP_FE(mysqli_field_tell,							arginfo_mysqli_only_result)
+	PHP_FE(mysqli_free_result,							arginfo_mysqli_only_result)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FE(mysqli_get_cache_stats,						arginfo_mysqli_no_params)
+	PHP_FE(mysqli_get_connection_stats,					arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_client_stats,						arginfo_mysqli_no_params)
 #endif
-	PHP_FE(mysqli_select_db,							NULL)
+#ifdef HAVE_MYSQLI_GET_CHARSET
+	PHP_FE(mysqli_get_charset,							arginfo_mysqli_only_link)
+#endif
+	PHP_FE(mysqli_get_client_info,						arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_client_version,					arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_host_info,						arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_proto_info,						arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_server_info,						arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_server_version,					arginfo_mysqli_only_link)
+	PHP_FE(mysqli_get_warnings,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_init, 								arginfo_mysqli_no_params)
+	PHP_FE(mysqli_info,									arginfo_mysqli_only_link)
+	PHP_FE(mysqli_insert_id,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_kill,									arginfo_mysqli_kill)
+#if !defined(MYSQLI_USE_MYSQLND)
+	PHP_FE(mysqli_set_local_infile_default,				arginfo_mysqli_only_link)
+	PHP_FE(mysqli_set_local_infile_handler,				arginfo_mysqli_set_local_infile_handler)
+#endif
+	PHP_FE(mysqli_more_results,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_multi_query, 							arginfo_mysqli_query)
+	PHP_FE(mysqli_next_result,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_num_fields,							arginfo_mysqli_only_result)
+	PHP_FE(mysqli_num_rows,								arginfo_mysqli_only_result)
+	PHP_FE(mysqli_options, 								arginfo_mysqli_options)
+	PHP_FE(mysqli_ping,									arginfo_mysqli_only_link)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FE(mysqli_poll,									arginfo_mysqli_poll)
+#endif
+	PHP_FE(mysqli_prepare,								arginfo_mysqli_prepare)
+	PHP_FE(mysqli_report,								arginfo_mysqli_report)
+	PHP_FE(mysqli_query,								arginfo_mysqli_query)
+	PHP_FE(mysqli_real_connect,							arginfo_mysqli_real_connect)
+	PHP_FE(mysqli_real_escape_string,					arginfo_mysqli_real_escape_string)
+	PHP_FE(mysqli_real_query,							arginfo_mysqli_query)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FE(mysqli_reap_async_query,						arginfo_mysqli_only_link)
+#endif
+	PHP_FE(mysqli_rollback,								arginfo_mysqli_only_link)
+	PHP_FE(mysqli_select_db,							arginfo_mysqli_select_db)
 #ifdef HAVE_MYSQLI_SET_CHARSET
-	PHP_FE(mysqli_set_charset,							NULL)
+	PHP_FE(mysqli_set_charset,							arginfo_mysqli_set_charset)
 #endif
-	PHP_FE(mysqli_stmt_attr_get,						NULL)
-	PHP_FE(mysqli_stmt_attr_set,						NULL)
-	PHP_FE(mysqli_stmt_field_count,						NULL)
-	PHP_FE(mysqli_stmt_init,							NULL)
-	PHP_FE(mysqli_stmt_prepare,							NULL)
-	PHP_FE(mysqli_stmt_result_metadata,					NULL)
-	PHP_FE(mysqli_stmt_send_long_data,					NULL)
-	PHP_FE(mysqli_stmt_bind_param,						third_arg_force_by_ref_rest)
-	PHP_FE(mysqli_stmt_bind_result,						second_arg_force_by_ref_rest)
-	PHP_FE(mysqli_stmt_fetch,							NULL)
-	PHP_FE(mysqli_stmt_free_result,						NULL)
-	PHP_FE(mysqli_stmt_get_warnings,					NULL)
-	PHP_FE(mysqli_stmt_insert_id,						NULL)
-	PHP_FE(mysqli_stmt_reset,							NULL)
-	PHP_FE(mysqli_stmt_param_count,						NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FE(mysqli_send_query,							NULL)
-	PHP_FE(mysqli_slave_query,							NULL)
+	PHP_FE(mysqli_stmt_affected_rows,					arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_attr_get,						arginfo_mysqli_stmt_attr_get)
+	PHP_FE(mysqli_stmt_attr_set,						arginfo_mysqli_stmt_attr_set)
+	PHP_FE(mysqli_stmt_bind_param,						arginfo_mysqli_stmt_bind_param)
+	PHP_FE(mysqli_stmt_bind_result,						arginfo_mysqli_stmt_bind_result)
+	PHP_FE(mysqli_stmt_close,							arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_data_seek,						arginfo_mysqli_stmt_data_seek)
+	PHP_FE(mysqli_stmt_errno,							arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_error,							arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_fetch,							arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_field_count,						arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_free_result,						arginfo_mysqli_only_statement)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FE(mysqli_stmt_get_result,						arginfo_mysqli_only_statement)
 #endif
-	PHP_FE(mysqli_sqlstate,   							NULL)
-	PHP_FE(mysqli_ssl_set,								NULL)
-	PHP_FE(mysqli_stat,									NULL)
-	PHP_FE(mysqli_stmt_affected_rows,					NULL)
-	PHP_FE(mysqli_stmt_close,							NULL)
-	PHP_FE(mysqli_stmt_data_seek,						NULL)
-	PHP_FE(mysqli_stmt_errno,							NULL)
-	PHP_FE(mysqli_stmt_error,							NULL)
-	PHP_FE(mysqli_stmt_num_rows,						NULL)
-	PHP_FE(mysqli_stmt_sqlstate,   						NULL)
-	PHP_FE(mysqli_store_result,							NULL)
-	PHP_FE(mysqli_stmt_store_result,					NULL)
-	PHP_FE(mysqli_thread_id,							NULL)
-	PHP_FE(mysqli_thread_safe,							NULL)
-	PHP_FE(mysqli_use_result,							NULL)
-	PHP_FE(mysqli_warning_count,						NULL)
+	PHP_FE(mysqli_stmt_get_warnings,					arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_init,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_stmt_insert_id,						arginfo_mysqli_only_statement)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FE(mysqli_stmt_more_results,					arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_next_result,						arginfo_mysqli_only_statement)
+#endif
+	PHP_FE(mysqli_stmt_num_rows,						arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_param_count,						arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_prepare,							arginfo_mysqli_stmt_prepare)
+	PHP_FE(mysqli_stmt_reset,							arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_result_metadata,					arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_send_long_data,					arginfo_mysqli_stmt_send_long_data)
+	PHP_FE(mysqli_stmt_store_result,					arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_stmt_sqlstate,   						arginfo_mysqli_only_statement)
+	PHP_FE(mysqli_sqlstate,   							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_ssl_set,								arginfo_mysqli_ssl_set)
+	PHP_FE(mysqli_stat,									arginfo_mysqli_only_link)
+	PHP_FE(mysqli_store_result,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_thread_id,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_thread_safe,							arginfo_mysqli_no_params)
+	PHP_FE(mysqli_use_result,							arginfo_mysqli_only_link)
+	PHP_FE(mysqli_warning_count,						arginfo_mysqli_only_link)
 
+	PHP_FE(mysqli_refresh,								arginfo_mysqli_refresh)
+
 	/* Aliases */
-	PHP_FALIAS(mysqli_bind_param,		mysqli_stmt_bind_param,		third_arg_force_by_ref_rest)
-	PHP_FALIAS(mysqli_bind_result,		mysqli_stmt_bind_result,	second_arg_force_by_ref_rest)
+	PHP_FALIAS(mysqli_bind_param,		mysqli_stmt_bind_param,		arginfo_mysqli_stmt_bind_param)
+	PHP_FALIAS(mysqli_bind_result,		mysqli_stmt_bind_result,	arginfo_mysqli_stmt_bind_result)
 	PHP_FALIAS(mysqli_client_encoding,	mysqli_character_set_name,	NULL)
-	PHP_FALIAS(mysqli_escape_string,	mysqli_real_escape_string,	NULL)
+	PHP_FALIAS(mysqli_escape_string,	mysqli_real_escape_string,	arginfo_mysqli_query)
 	PHP_FALIAS(mysqli_fetch,			mysqli_stmt_fetch,			NULL)
 	PHP_FALIAS(mysqli_param_count,		mysqli_stmt_param_count,	NULL)
-	PHP_FALIAS(mysqli_get_metadata,		mysqli_stmt_result_metadata,	NULL)
+	PHP_FALIAS(mysqli_get_metadata,		mysqli_stmt_result_metadata,NULL)
 	PHP_FALIAS(mysqli_send_long_data,	mysqli_stmt_send_long_data,	NULL)
 	PHP_FALIAS(mysqli_set_opt,			mysqli_options,				NULL)
 
-	{NULL, NULL, NULL}	/* Must be the last line in mysqli_functions[] */
+	{NULL, NULL, NULL}
 };
 /* }}} */
 
@@ -186,70 +476,62 @@
  *
  * Every user visible function must have an entry in mysqli_functions[].
  */
-zend_function_entry mysqli_link_methods[] = {
-	PHP_FALIAS(autocommit,mysqli_autocommit,NULL)
-	PHP_FALIAS(change_user,mysqli_change_user,NULL)
-	PHP_FALIAS(character_set_name, mysqli_character_set_name,NULL)
-	PHP_FALIAS(client_encoding, mysqli_character_set_name,NULL)
-	PHP_FALIAS(close,mysqli_close,NULL)
-	PHP_FALIAS(commit,mysqli_commit,NULL)
-	PHP_FALIAS(connect,mysqli_connect,NULL)
-	PHP_FALIAS(debug,mysqli_debug,NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FALIAS(disable_reads_from_master,mysqli_disable_reads_from_master,NULL)
-	PHP_FALIAS(disable_rpl_parse,mysqli_disable_rpl_parse,NULL)
+const zend_function_entry mysqli_link_methods[] = {
+	PHP_FALIAS(autocommit, mysqli_autocommit, arginfo_class_mysqli_autocommit)
+	PHP_FALIAS(change_user,mysqli_change_user, arginfo_class_mysqli_change_user)
+	PHP_FALIAS(character_set_name, mysqli_character_set_name, arginfo_mysqli_no_params)
+	PHP_FALIAS(client_encoding, mysqli_character_set_name, arginfo_mysqli_no_params) /* deprecated */
+	PHP_FALIAS(close, mysqli_close, arginfo_mysqli_no_params)
+	PHP_FALIAS(commit, mysqli_commit, arginfo_mysqli_no_params)
+	PHP_FALIAS(connect, mysqli_connect, arginfo_mysqli_connect)
+	PHP_FALIAS(dump_debug_info, mysqli_dump_debug_info, arginfo_mysqli_no_params)
+	PHP_FALIAS(debug, mysqli_debug, arginfo_mysqli_debug)
+#ifdef HAVE_MYSQLI_GET_CHARSET
+	PHP_FALIAS(get_charset, mysqli_get_charset, arginfo_mysqli_no_params)
 #endif
-	PHP_FALIAS(dump_debug_info,mysqli_dump_debug_info,NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FALIAS(enable_reads_from_master,mysqli_enable_reads_from_master,NULL)
-	PHP_FALIAS(enable_rpl_parse,mysqli_enable_rpl_parse,NULL)
+	PHP_FALIAS(get_client_info, mysqli_get_client_info, arginfo_mysqli_no_params)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FALIAS(get_connection_stats, mysqli_get_connection_stats, arginfo_mysqli_no_params)
 #endif
-#ifdef HAVE_MYSQLI_GET_CHARSET 
-	PHP_FALIAS(get_charset,mysqli_get_charset,NULL)
+	PHP_FALIAS(get_server_info, mysqli_get_server_info, arginfo_mysqli_no_params)
+	PHP_FALIAS(get_warnings, mysqli_get_warnings, arginfo_mysqli_no_params)
+	PHP_FALIAS(init,mysqli_init, arginfo_mysqli_no_params)
+	PHP_FALIAS(kill,mysqli_kill, arginfo_class_mysqli_kill)
+#if !defined(MYSQLI_USE_MYSQLND)
+	PHP_FALIAS(set_local_infile_default, mysqli_set_local_infile_default, arginfo_mysqli_no_params)
+	PHP_FALIAS(set_local_infile_handler, mysqli_set_local_infile_handler, arginfo_class_mysqli_set_local_infile_handler)
 #endif
-	PHP_FALIAS(get_client_info,mysqli_get_client_info,NULL)
-	PHP_FALIAS(get_server_info,mysqli_get_server_info,NULL)
-	PHP_FALIAS(get_warnings, mysqli_get_warnings, NULL)
-	PHP_FALIAS(init,mysqli_init,NULL)
-	PHP_FALIAS(kill,mysqli_kill,NULL)
-	PHP_FALIAS(set_local_infile_default,mysqli_set_local_infile_default,NULL)
-	PHP_FALIAS(set_local_infile_handler,mysqli_set_local_infile_handler,NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FALIAS(master_query,mysqli_master_query,NULL)
+	PHP_FALIAS(multi_query, mysqli_multi_query, arginfo_class_mysqli_query)
+	PHP_FALIAS(mysqli, mysqli_link_construct, arginfo_mysqli_connect)
+	PHP_FALIAS(more_results, mysqli_more_results, arginfo_mysqli_no_params)
+	PHP_FALIAS(next_result, mysqli_next_result, arginfo_mysqli_no_params)
+	PHP_FALIAS(options, mysqli_options, arginfo_class_mysqli_options)
+	PHP_FALIAS(ping, mysqli_ping, arginfo_mysqli_no_params)
+#if defined(MYSQLI_USE_MYSQLND)
+	ZEND_FENTRY(poll, ZEND_FN(mysqli_poll), arginfo_mysqli_poll, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
 #endif
-	PHP_FALIAS(multi_query,mysqli_multi_query,NULL)
-	PHP_FALIAS(mysqli,mysqli_connect,NULL)
-	PHP_FALIAS(more_results,mysqli_more_results, NULL)
-	PHP_FALIAS(next_result, mysqli_next_result, NULL)
-	PHP_FALIAS(options,mysqli_options,NULL)
-	PHP_FALIAS(ping,mysqli_ping,NULL)
-	PHP_FALIAS(prepare,mysqli_prepare,NULL)
-	PHP_FALIAS(query,mysqli_query,NULL)
-	PHP_FALIAS(real_connect,mysqli_real_connect,NULL)
-	PHP_FALIAS(real_escape_string,mysqli_real_escape_string,NULL)
-	PHP_FALIAS(escape_string, mysqli_real_escape_string,NULL)
-	PHP_FALIAS(real_query,mysqli_real_query,NULL)
-	PHP_FALIAS(rollback,mysqli_rollback,NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FALIAS(rpl_parse_enabled,mysqli_rpl_parse_enabled,NULL)
-	PHP_FALIAS(rpl_probe,mysqli_rpl_probe,NULL)
-	PHP_FALIAS(rpl_query_type,mysqli_rpl_query_type,NULL)
+	PHP_FALIAS(prepare, mysqli_prepare, arginfo_class_mysqli_query)
+	PHP_FALIAS(query, mysqli_query, arginfo_class_mysqli_query)
+	PHP_FALIAS(real_connect, mysqli_real_connect, arginfo_class_mysqli_real_connect)
+	PHP_FALIAS(real_escape_string, mysqli_real_escape_string, arginfo_class_mysqli_real_escape_string)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FALIAS(reap_async_query, mysqli_reap_async_query, arginfo_mysqli_no_params)
 #endif
-	PHP_FALIAS(select_db,mysqli_select_db,NULL)
+	PHP_FALIAS(escape_string, mysqli_real_escape_string, arginfo_class_mysqli_real_escape_string)
+	PHP_FALIAS(real_query, mysqli_real_query, arginfo_class_mysqli_query)
+	PHP_FALIAS(rollback,mysqli_rollback, arginfo_mysqli_no_params)
+	PHP_FALIAS(select_db,mysqli_select_db, arginfo_class_mysqli_select_db)
 #ifdef HAVE_MYSQLI_SET_CHARSET
-	PHP_FALIAS(set_charset,mysqli_set_charset,NULL)
+	PHP_FALIAS(set_charset, mysqli_set_charset, arginfo_class_mysqli_set_charset)
 #endif
-	PHP_FALIAS(set_opt, mysqli_options,NULL)
-#ifdef HAVE_LIBMYSQL_REPLICATION
-	PHP_FALIAS(send_query,mysqli_send_query,NULL)
-	PHP_FALIAS(slave_query,mysqli_slave_query,NULL)
-#endif
-	PHP_FALIAS(ssl_set,mysqli_ssl_set,NULL)
-	PHP_FALIAS(stat,mysqli_stat,NULL)
-	PHP_FALIAS(stmt_init,mysqli_stmt_init, NULL)
-	PHP_FALIAS(store_result,mysqli_store_result,NULL)
-	PHP_FALIAS(thread_safe,mysqli_thread_safe,NULL)
-	PHP_FALIAS(use_result,mysqli_use_result,NULL)
+	PHP_FALIAS(set_opt, mysqli_options, arginfo_class_mysqli_options)
+	PHP_FALIAS(ssl_set, mysqli_ssl_set, arginfo_class_mysqli_ssl_set)
+	PHP_FALIAS(stat, mysqli_stat, arginfo_mysqli_no_params)
+	PHP_FALIAS(stmt_init, mysqli_stmt_init, arginfo_mysqli_no_params)
+	PHP_FALIAS(store_result, mysqli_store_result, arginfo_mysqli_no_params)
+	PHP_FALIAS(thread_safe, mysqli_thread_safe, arginfo_mysqli_no_params)
+	PHP_FALIAS(use_result, mysqli_use_result, arginfo_mysqli_no_params)
+	PHP_FALIAS(refresh,mysqli_refresh, arginfo_class_mysqli_refresh)
 	{NULL, NULL, NULL}
 };
 /* }}} */
@@ -258,21 +540,23 @@
  *
  * Every user visible function must have an entry in mysqli_result_functions[].
  */
-zend_function_entry mysqli_result_methods[] = {
-	PHP_FALIAS(mysqli_result, mysqli_result_construct, NULL)
-	PHP_FALIAS(close,mysqli_free_result,NULL)
-	PHP_FALIAS(free,mysqli_free_result,NULL)
-	PHP_FALIAS(data_seek,mysqli_data_seek,NULL)
-	PHP_FALIAS(fetch_field,mysqli_fetch_field,NULL)
-	PHP_FALIAS(fetch_fields,mysqli_fetch_fields,NULL)
-	PHP_FALIAS(fetch_field_direct,mysqli_fetch_field_direct,NULL)
-	PHP_FALIAS(fetch_array,mysqli_fetch_array,NULL)
-	PHP_FALIAS(fetch_assoc,mysqli_fetch_assoc,NULL) 
-	PHP_FALIAS(fetch_object,mysqli_fetch_object,NULL) 
-	PHP_FALIAS(fetch_row,mysqli_fetch_row,NULL)
-	PHP_FALIAS(field_count,mysqli_field_count,NULL)
-	PHP_FALIAS(field_seek,mysqli_field_seek,NULL)
-	PHP_FALIAS(free_result,mysqli_free_result,NULL)
+const zend_function_entry mysqli_result_methods[] = {
+	PHP_FALIAS(__construct, mysqli_result_construct, NULL)
+	PHP_FALIAS(close, mysqli_free_result, arginfo_mysqli_no_params)
+	PHP_FALIAS(free, mysqli_free_result, arginfo_mysqli_no_params)
+	PHP_FALIAS(data_seek, mysqli_data_seek, arginfo_class_mysqli_data_seek)
+	PHP_FALIAS(fetch_field, mysqli_fetch_field, arginfo_mysqli_no_params)
+	PHP_FALIAS(fetch_fields, mysqli_fetch_fields, arginfo_mysqli_no_params)
+	PHP_FALIAS(fetch_field_direct, mysqli_fetch_field_direct, arginfo_class_mysqli_result_and_fieldnr)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FALIAS(fetch_all, mysqli_fetch_all, arginfo_mysqli_no_params)
+#endif
+	PHP_FALIAS(fetch_array, mysqli_fetch_array, arginfo_class_mysqli_fetch_array)
+	PHP_FALIAS(fetch_assoc, mysqli_fetch_assoc, arginfo_mysqli_no_params)
+	PHP_FALIAS(fetch_object,mysqli_fetch_object, arginfo_class_mysqli_fetch_object)
+	PHP_FALIAS(fetch_row, mysqli_fetch_row, arginfo_mysqli_no_params)
+	PHP_FALIAS(field_seek, mysqli_field_seek, arginfo_class_mysqli_result_and_fieldnr)
+	PHP_FALIAS(free_result, mysqli_free_result, arginfo_mysqli_no_params)
 	{NULL, NULL, NULL}
 };
 /* }}} */
@@ -281,25 +565,31 @@
  *
  * Every user visible function must have an entry in mysqli_stmt_functions[].
  */
-zend_function_entry mysqli_stmt_methods[] = {
-	PHP_FALIAS(mysqli_stmt, mysqli_stmt_construct, NULL)
-	PHP_FALIAS(attr_get,mysqli_stmt_attr_get,NULL)
-	PHP_FALIAS(attr_set,mysqli_stmt_attr_set,NULL)
-	PHP_FALIAS(bind_param,mysqli_stmt_bind_param,second_arg_force_by_ref_rest)
-	PHP_FALIAS(bind_result,mysqli_stmt_bind_result,all_args_force_by_ref)
-	PHP_FALIAS(close,mysqli_stmt_close,NULL)
-	PHP_FALIAS(data_seek,mysqli_stmt_data_seek,NULL)
-	PHP_FALIAS(execute,mysqli_stmt_execute,NULL)
-	PHP_FALIAS(fetch,mysqli_stmt_fetch,NULL)
-	PHP_FALIAS(get_warnings, mysqli_stmt_get_warnings,	NULL)
-	PHP_FALIAS(result_metadata, mysqli_stmt_result_metadata,NULL)
-	PHP_FALIAS(num_rows, mysqli_stmt_num_rows,NULL)
-	PHP_FALIAS(send_long_data,mysqli_stmt_send_long_data,NULL)
-	PHP_FALIAS(stmt,mysqli_prepare,NULL)
-	PHP_FALIAS(free_result,mysqli_stmt_free_result,NULL)
-	PHP_FALIAS(reset,mysqli_stmt_reset,NULL)
-	PHP_FALIAS(prepare,mysqli_stmt_prepare, NULL)
-	PHP_FALIAS(store_result,mysqli_stmt_store_result,NULL)
+const zend_function_entry mysqli_stmt_methods[] = {
+	PHP_FALIAS(__construct, mysqli_stmt_construct, NULL)
+	PHP_FALIAS(attr_get, mysqli_stmt_attr_get, arginfo_class_mysqli_stmt_attr_get)
+	PHP_FALIAS(attr_set,mysqli_stmt_attr_set, arginfo_class_mysqli_stmt_attr_set)
+	PHP_FALIAS(bind_param,mysqli_stmt_bind_param, arginfo_class_mysqli_stmt_bind_param)
+	PHP_FALIAS(bind_result,mysqli_stmt_bind_result, arginfo_class_mysqli_stmt_bind_result)
+	PHP_FALIAS(close, mysqli_stmt_close, arginfo_mysqli_no_params)
+	PHP_FALIAS(data_seek, mysqli_stmt_data_seek, arginfo_class_mysqli_data_seek)
+	PHP_FALIAS(execute, mysqli_stmt_execute, arginfo_mysqli_no_params)
+	PHP_FALIAS(fetch, mysqli_stmt_fetch, arginfo_mysqli_no_params)
+	PHP_FALIAS(get_warnings, mysqli_stmt_get_warnings,	arginfo_mysqli_no_params)
+	PHP_FALIAS(result_metadata, mysqli_stmt_result_metadata, arginfo_mysqli_no_params)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FALIAS(more_results, mysqli_stmt_more_results, arginfo_mysqli_no_params)
+	PHP_FALIAS(next_result, mysqli_stmt_next_result, arginfo_mysqli_no_params)
+#endif
+	PHP_FALIAS(num_rows, mysqli_stmt_num_rows, arginfo_mysqli_no_params)
+	PHP_FALIAS(send_long_data, mysqli_stmt_send_long_data, arginfo_class_mysqli_stmt_send_long_data)
+	PHP_FALIAS(free_result, mysqli_stmt_free_result, arginfo_mysqli_no_params)
+	PHP_FALIAS(reset, mysqli_stmt_reset, arginfo_mysqli_no_params)
+	PHP_FALIAS(prepare, mysqli_stmt_prepare, arginfo_class_mysqli_query)
+	PHP_FALIAS(store_result, mysqli_stmt_store_result, arginfo_mysqli_no_params)
+#if defined(MYSQLI_USE_MYSQLND)
+	PHP_FALIAS(get_result, mysqli_stmt_get_result, arginfo_mysqli_no_params)
+#endif
 	{NULL, NULL, NULL}
 };
 /* }}} */
--- /dev/null
+++ b/ext/mysqli/mysqli_fe.h
@@ -0,0 +1,135 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 1997-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Author: Georg Richter <georg@php.net>                                |
+            Andrey Hristov <andrey@php.net>                              |
+  +----------------------------------------------------------------------+
+
+  $Id: php_mysqli_structs.h 302179 2010-08-13 09:57:04Z andrey $
+*/
+
+#ifndef MYSQLI_FE_H
+#define MYSQLI_FE_H
+
+PHP_FUNCTION(mysqli);
+PHP_FUNCTION(mysqli_affected_rows);
+PHP_FUNCTION(mysqli_autocommit);
+PHP_FUNCTION(mysqli_change_user);
+PHP_FUNCTION(mysqli_character_set_name);
+PHP_FUNCTION(mysqli_set_charset);
+PHP_FUNCTION(mysqli_close);
+PHP_FUNCTION(mysqli_commit);
+PHP_FUNCTION(mysqli_connect);
+PHP_FUNCTION(mysqli_connect_errno);
+PHP_FUNCTION(mysqli_connect_error);
+PHP_FUNCTION(mysqli_data_seek);
+PHP_FUNCTION(mysqli_debug);
+PHP_FUNCTION(mysqli_dump_debug_info);
+PHP_FUNCTION(mysqli_errno);
+PHP_FUNCTION(mysqli_error);
+PHP_FUNCTION(mysqli_fetch_all);
+PHP_FUNCTION(mysqli_fetch_array);
+PHP_FUNCTION(mysqli_fetch_assoc);
+PHP_FUNCTION(mysqli_fetch_object);
+PHP_FUNCTION(mysqli_fetch_field);
+PHP_FUNCTION(mysqli_fetch_fields);
+PHP_FUNCTION(mysqli_fetch_field_direct);
+PHP_FUNCTION(mysqli_fetch_lengths);
+PHP_FUNCTION(mysqli_fetch_row);
+PHP_FUNCTION(mysqli_field_count);
+PHP_FUNCTION(mysqli_field_seek);
+PHP_FUNCTION(mysqli_field_tell);
+PHP_FUNCTION(mysqli_free_result);
+PHP_FUNCTION(mysqli_get_cache_stats);
+PHP_FUNCTION(mysqli_get_client_stats);
+PHP_FUNCTION(mysqli_get_connection_stats);
+PHP_FUNCTION(mysqli_get_charset);
+PHP_FUNCTION(mysqli_get_client_info);
+PHP_FUNCTION(mysqli_get_client_version);
+PHP_FUNCTION(mysqli_get_host_info);
+PHP_FUNCTION(mysqli_get_proto_info);
+PHP_FUNCTION(mysqli_get_server_info);
+PHP_FUNCTION(mysqli_get_server_version);
+PHP_FUNCTION(mysqli_get_warnings);
+PHP_FUNCTION(mysqli_info);
+PHP_FUNCTION(mysqli_insert_id);
+PHP_FUNCTION(mysqli_init);
+PHP_FUNCTION(mysqli_kill);
+PHP_FUNCTION(mysqli_link_construct);
+PHP_FUNCTION(mysqli_set_local_infile_default);
+PHP_FUNCTION(mysqli_set_local_infile_handler);
+PHP_FUNCTION(mysqli_more_results);
+PHP_FUNCTION(mysqli_multi_query);
+PHP_FUNCTION(mysqli_next_result);
+PHP_FUNCTION(mysqli_num_fields);
+PHP_FUNCTION(mysqli_num_rows);
+PHP_FUNCTION(mysqli_options);
+PHP_FUNCTION(mysqli_ping);
+PHP_FUNCTION(mysqli_poll);
+PHP_FUNCTION(mysqli_prepare);
+PHP_FUNCTION(mysqli_query);
+PHP_FUNCTION(mysqli_stmt_result_metadata);
+PHP_FUNCTION(mysqli_report);
+PHP_FUNCTION(mysqli_read_query_result);
+PHP_FUNCTION(mysqli_real_connect);
+PHP_FUNCTION(mysqli_real_query);
+PHP_FUNCTION(mysqli_real_escape_string);
+PHP_FUNCTION(mysqli_reap_async_query);
+PHP_FUNCTION(mysqli_rollback);
+PHP_FUNCTION(mysqli_row_seek);
+PHP_FUNCTION(mysqli_select_db);
+PHP_FUNCTION(mysqli_stmt_attr_get);
+PHP_FUNCTION(mysqli_stmt_attr_set);
+PHP_FUNCTION(mysqli_stmt_bind_param);
+PHP_FUNCTION(mysqli_stmt_bind_result);
+PHP_FUNCTION(mysqli_stmt_execute);
+PHP_FUNCTION(mysqli_stmt_field_count);
+PHP_FUNCTION(mysqli_stmt_init);
+PHP_FUNCTION(mysqli_stmt_prepare);
+PHP_FUNCTION(mysqli_stmt_fetch);
+PHP_FUNCTION(mysqli_stmt_param_count);
+PHP_FUNCTION(mysqli_stmt_send_long_data);
+PHP_FUNCTION(mysqli_embedded_server_end);
+PHP_FUNCTION(mysqli_embedded_server_start);
+PHP_FUNCTION(mysqli_sqlstate);
+PHP_FUNCTION(mysqli_ssl_set);
+PHP_FUNCTION(mysqli_stat);
+PHP_FUNCTION(mysqli_refresh);
+PHP_FUNCTION(mysqli_stmt_affected_rows);
+PHP_FUNCTION(mysqli_stmt_close);
+PHP_FUNCTION(mysqli_stmt_data_seek);
+PHP_FUNCTION(mysqli_stmt_errno);
+PHP_FUNCTION(mysqli_stmt_error);
+PHP_FUNCTION(mysqli_stmt_free_result);
+PHP_FUNCTION(mysqli_stmt_get_result);
+PHP_FUNCTION(mysqli_stmt_get_warnings);
+PHP_FUNCTION(mysqli_stmt_reset);
+PHP_FUNCTION(mysqli_stmt_insert_id);
+PHP_FUNCTION(mysqli_stmt_more_results);
+PHP_FUNCTION(mysqli_stmt_next_result);
+PHP_FUNCTION(mysqli_stmt_num_rows);
+PHP_FUNCTION(mysqli_stmt_sqlstate);
+PHP_FUNCTION(mysqli_stmt_store_result);
+PHP_FUNCTION(mysqli_store_result);
+PHP_FUNCTION(mysqli_thread_id);
+PHP_FUNCTION(mysqli_thread_safe);
+PHP_FUNCTION(mysqli_use_result);
+PHP_FUNCTION(mysqli_warning_count);
+
+PHP_FUNCTION(mysqli_stmt_construct);
+PHP_FUNCTION(mysqli_result_construct);
+PHP_FUNCTION(mysqli_driver_construct);
+PHP_METHOD(mysqli_warning,__construct);
+
+#endif /* MYSQLI_FE_H */
--- /dev/null
+++ b/ext/mysqli/mysqli_libmysql.h
@@ -0,0 +1,118 @@
+/*
+  ----------------------------------------------------------------------
+  | PHP Version 5                                                        |
+  ----------------------------------------------------------------------
+  | Copyright (c) 2007 The PHP Group                                     |
+  ----------------------------------------------------------------------
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  ----------------------------------------------------------------------
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  ----------------------------------------------------------------------
+
+*/
+
+#ifndef MYSQLI_LIBMYSQL_H
+#define MYSQLI_LIBMYSQL_H
+
+/* These are unused */
+#define MYSQLI_CLOSE_EXPLICIT 0
+#define MYSQLI_CLOSE_IMPLICIT 1
+#define MYSQLI_CLOSE_DISCONNECTED 2
+#define MYSQLND_OPT_NUMERIC_AND_DATETIME_AS_UNICODE	200
+#define MYSQLND_OPT_INT_AND_YEAR_AS_INT				201
+
+#define mysqli_result_is_unbuffered(r)		((r)->handle && (r)->handle->status == MYSQL_STATUS_USE_RESULT && (r)->data == NULL)
+#define mysqli_result_is_unbuffered_and_not_everything_is_fetched(r)   mysqli_result_is_unbuffered(r)
+#define mysqli_server_status(c)				(c)->server_status
+#define mysqli_stmt_get_id(s)				((s)->stmt_id)
+#define mysqli_stmt_warning_count(s)		mysql_warning_count((s)->mysql)
+#define mysqli_stmt_server_status(s)		(s)->mysql->server_status
+#define mysqli_stmt_get_connection(s)		(s)->mysql
+#define mysqli_close(c, is_forced)			mysql_close((c))
+#define mysqli_stmt_close(c, implicit)		mysql_stmt_close((c))
+#define mysqli_free_result(r, is_forced)	mysql_free_result((r))
+#define mysqli_change_user_silent(c, u, p, d)   mysql_change_user((c), (u), (p), (d))
+
+
+/*
+  These functions also reside in ext/mysqlnd/mysqlnd_portability.h but since it is only made
+  available if one wants to build mysqli against mysqlnd and they are useful for libmysql as
+  well, we check whether they're not defined [build with libmysql is desired] and define them.
+
+  Bit values are sent in reverted order of bytes, compared to normal !!!
+*/
+
+
+#ifndef uint1korr
+#define uint1korr(A)	(*(((uint8_t*)(A))))
+#endif
+
+#ifndef bit_uint2korr
+#define bit_uint2korr(A) ((uint16_t) (((uint16_t) (((unsigned char*) (A))[1])) +\
+                                   ((uint16_t) (((unsigned char*) (A))[0]) << 8)))
+#endif
+
+#ifndef bit_uint3korr
+#define bit_uint3korr(A) ((uint32_t) (((uint32_t) (((unsigned char*) (A))[2])) +\
+                                   (((uint32_t) (((unsigned char*) (A))[1])) << 8) +\
+                                   (((uint32_t) (((unsigned char*) (A))[0])) << 16)))
+#endif
+
+#ifndef bit_uint4korr
+#define bit_uint4korr(A) ((uint32_t) (((uint32_t) (((unsigned char*) (A))[3])) +\
+                                   (((uint32_t) (((unsigned char*) (A))[2])) << 8) +\
+                                   (((uint32_t) (((unsigned char*) (A))[1])) << 16) +\
+                                   (((uint32_t) (((unsigned char*) (A))[0])) << 24)))
+#endif
+
+#ifndef bit_uint5korr
+#define bit_uint5korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[4])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[3])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[2])) << 16) +\
+                                   (((uint32_t) (((unsigned char*) (A))[1])) << 24)) +\
+                                    (((uint64_t) (((unsigned char*) (A))[0])) << 32))
+#endif
+
+#ifndef bit_uint6korr
+#define bit_uint6korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[5])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[4])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[3])) << 16) +\
+                                    (((uint32_t) (((unsigned char*) (A))[2])) << 24)) +\
+                        (((uint64_t) (((uint32_t) (((unsigned char*) (A))[1])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[0]) << 8)))) <<\
+                                     32))
+#endif
+
+#ifndef bit_uint7korr
+#define bit_uint7korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[6])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[5])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[4])) << 16) +\
+                                   (((uint32_t) (((unsigned char*) (A))[3])) << 24)) +\
+                        (((uint64_t) (((uint32_t) (((unsigned char*) (A))[2])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[1])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[0])) << 16))) <<\
+                                     32))
+#endif
+
+#ifndef bit_uint8korr
+#define bit_uint8korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[7])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[6])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[5])) << 16) +\
+                                    (((uint32_t) (((unsigned char*) (A))[4])) << 24)) +\
+                        (((uint64_t) (((uint32_t) (((unsigned char*) (A))[3])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[2])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[1])) << 16) +\
+                                    (((uint32_t) (((unsigned char*) (A))[0])) << 24))) <<\
+                                    32))
+#endif
+
+#endif /* MYSQLI_LIBMYSQL_H */
+
--- /dev/null
+++ b/ext/mysqli/mysqli_mysqlnd.h
@@ -0,0 +1,48 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2009 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+
+*/
+
+#ifndef MYSQLI_MYSQLND_H
+#define MYSQLI_MYSQLND_H
+
+#include "ext/mysqlnd/mysqlnd_libmysql_compat.h"
+#include "ext/mysqlnd/mysqlnd_portability.h"
+
+/* Here comes non-libmysql API to have less ifdefs in mysqli*/
+#define MYSQLI_CLOSE_EXPLICIT                  MYSQLND_CLOSE_EXPLICIT
+#define MYSQLI_CLOSE_IMPLICIT                  MYSQLND_CLOSE_IMPLICIT
+#define MYSQLI_CLOSE_DISCONNECTED              MYSQLND_CLOSE_DISCONNECTED
+
+#define mysqli_result_is_unbuffered(r)	((r)->unbuf)
+#define mysqli_result_is_unbuffered_and_not_everything_is_fetched(r)	((r)->unbuf && !(r)->unbuf->eof_reached)
+#define mysqli_server_status(c)			(c)->upsert_status.server_status
+#define mysqli_stmt_get_id(s)			((s)->data->stmt_id)
+#define mysqli_stmt_warning_count(s)	mysqlnd_stmt_warning_count((s))
+#define mysqli_stmt_server_status(s)	mysqlnd_stmt_server_status((s))
+#define mysqli_stmt_get_connection(s)	(s)->data->conn
+#define mysqli_close(c, how)			mysqlnd_close((c), (how))
+#define mysqli_stmt_close(c, implicit)	mysqlnd_stmt_close((c), (implicit))
+#define mysqli_free_result(r, implicit)	mysqlnd_free_result((r), (implicit))
+#define mysqli_async_query(c, q, l)		mysqlnd_async_query((c), (q), (l))
+#define mysqli_change_user_silent(c, u, p, d)   mysqlnd_change_user((c), (u), (p), (d), TRUE)
+
+#define HAVE_STMT_NEXT_RESULT
+
+#endif
--- a/ext/mysqli/mysqli_nonapi.c
+++ b/ext/mysqli/mysqli_nonapi.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -12,10 +12,12 @@
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
-  | Author: Georg Richter <georg@php.net>                                |
+  | Authors: Georg Richter <georg@php.net>                               |
+  |          Andrey Hristov <andrey@php.net>                             |
+  |          Ulf Wendel <uw@php.net>                                     |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli_nonapi.c 293976 2010-01-25 13:23:32Z andrey $ 
+  $Id$
 */
 
 #ifdef HAVE_CONFIG_H
@@ -27,131 +29,301 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_priv.h"
 
-/* {{{ proto object mysqli_connect([string hostname [,string username [,string passwd [,string dbname [,int port [,string socket]]]]]])
-   Open a connection to a mysql server */ 
-PHP_FUNCTION(mysqli_connect)
+#define SAFE_STR(a) ((a)?a:"")
+
+#ifndef zend_parse_parameters_none
+#define zend_parse_parameters_none()	\
+        zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "")
+#endif
+
+/* {{{ php_mysqli_set_error
+ */
+static void php_mysqli_set_error(long mysql_errno, char *mysql_err TSRMLS_DC)
 {
-	MY_MYSQL 			*mysql = NULL;
-	MYSQLI_RESOURCE 	*mysqli_resource = NULL;
-	zval  				*object = getThis();
-	char 				*hostname = NULL, *username=NULL, *passwd=NULL, *dbname=NULL, *socket=NULL;
-	unsigned int 		hostname_len = 0, username_len = 0, passwd_len = 0, dbname_len = 0, socket_len = 0;
-	long				port=0;
+	MyG(error_no) = mysql_errno;
+	if (MyG(error_msg)) {
+		efree(MyG(error_msg));
+	}
+	if(mysql_err && *mysql_err) {
+		MyG(error_msg) = estrdup(mysql_err);
+	} else {
+		MyG(error_msg) = NULL;
+	}
+}
+/* }}} */
 
+
+void mysqli_common_connect(INTERNAL_FUNCTION_PARAMETERS, zend_bool is_real_connect, zend_bool in_ctor)
+{
+	MY_MYSQL			*mysql = NULL;
+	MYSQLI_RESOURCE		*mysqli_resource = NULL;
+	zval				*object = getThis();
+	char				*hostname = NULL, *username=NULL, *passwd=NULL, *dbname=NULL, *socket=NULL;
+	int					hostname_len = 0, username_len = 0, passwd_len = 0, dbname_len = 0, socket_len = 0;
+	zend_bool			persistent = FALSE;
+	long				port = 0, flags = 0;
+	uint				hash_len;
+	char				*hash_key = NULL;
+	zend_bool			new_connection = FALSE;
+	zend_rsrc_list_entry	*le;
+	mysqli_plist_entry *plist = NULL;
+	zend_bool			self_alloced = 0;
+
+
+#if !defined(MYSQL_USE_MYSQLND)
 	if ((MYSQL_VERSION_ID / 100) != (mysql_get_client_version() / 100)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING,
 						"Headers and client library minor version mismatch. Headers:%d Library:%ld",
 						MYSQL_VERSION_ID, mysql_get_client_version());
 	}
+#endif
 
-	if (getThis() && !ZEND_NUM_ARGS()) {
+	if (getThis() && !ZEND_NUM_ARGS() && in_ctor) {
 		php_mysqli_init(INTERNAL_FUNCTION_PARAM_PASSTHRU);
 		return;
 	}
+	hostname = username = dbname = passwd = socket = NULL;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ssssls", &hostname, &hostname_len, &username, &username_len, 
-		&passwd, &passwd_len, &dbname, &dbname_len, &port, &socket, &socket_len) == FAILURE) {
-		return;
-	}
+	if (!is_real_connect) {
+		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ssssls", &hostname, &hostname_len, &username, &username_len,
+									&passwd, &passwd_len, &dbname, &dbname_len, &port, &socket, &socket_len) == FAILURE) {
+			return;
+		}
 
-	if (!socket_len) {
-		socket = NULL;
-	}
-    
-	/* TODO: safe mode handling */
-	if (PG(sql_safe_mode)){
-	} else {
-		if (!socket_len || !socket) {
-			socket = MyG(default_socket);
+		if (object && instanceof_function(Z_OBJCE_P(object), mysqli_link_class_entry TSRMLS_CC)) {
+			mysqli_resource = ((mysqli_object *) zend_object_store_get_object(object TSRMLS_CC))->ptr;
+			if (mysqli_resource && mysqli_resource->ptr) {
+				mysql = (MY_MYSQL*) mysqli_resource->ptr;
+			}
 		}
-		if (!port) {
-			port = MyG(default_port);
+		if (!mysql) {
+			mysql = (MY_MYSQL *) ecalloc(1, sizeof(MY_MYSQL));
+			self_alloced = 1;
 		}
-		if (!passwd) {
-			passwd = MyG(default_pw);
+		flags |= CLIENT_MULTI_RESULTS; /* needed for mysql_multi_query() */
+	} else {
+		/* We have flags too */
+		if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|sssslsl", &object, mysqli_link_class_entry,
+										&hostname, &hostname_len, &username, &username_len, &passwd, &passwd_len, &dbname, &dbname_len, &port, &socket, &socket_len,
+										&flags) == FAILURE) {
+			return;
 		}
-		if (!username){
-			username = MyG(default_user);
+
+		mysqli_resource = ((mysqli_object *) zend_object_store_get_object(object TSRMLS_CC))->ptr;
+		MYSQLI_FETCH_RESOURCE_CONN(mysql, &object, MYSQLI_STATUS_INITIALIZED);
+
+		/* set some required options */
+		flags |= CLIENT_MULTI_RESULTS; /* needed for mysql_multi_query() */
+		/* remove some insecure options */
+		flags &= ~CLIENT_MULTI_STATEMENTS;   /* don't allow multi_queries via connect parameter */
+		if (PG(open_basedir) && PG(open_basedir)[0] != '\0') {
+			flags &= ~CLIENT_LOCAL_FILES;
 		}
-		if (!hostname) {
-			hostname = MyG(default_host);
-		}
 	}
 
-	if (object && instanceof_function(Z_OBJCE_P(object), mysqli_link_class_entry TSRMLS_CC)) {
-		mysqli_resource = ((mysqli_object *) zend_object_store_get_object(object TSRMLS_CC))->ptr;
-		if (mysqli_resource && mysqli_resource->ptr &&
-			mysqli_resource->status >= MYSQLI_STATUS_INITIALIZED)
-		{
-			mysql = (MY_MYSQL*)mysqli_resource->ptr;
-			php_clear_mysql(mysql);
-			if (mysql->mysql) {
-				mysql_close(mysql->mysql);
-				mysql->mysql = NULL;
+	if (!socket_len || !socket) {
+		socket = MyG(default_socket);
+	}
+	if (!port){
+		port = MyG(default_port);
+	}
+	if (!passwd) {
+		passwd = MyG(default_pw);
+		passwd_len = strlen(SAFE_STR(passwd));
+	}
+	if (!username){
+		username = MyG(default_user);
+	}
+	if (!hostname || !hostname_len) {
+		hostname = MyG(default_host);
+	}
+
+	if (mysql->mysql && mysqli_resource &&
+		(mysqli_resource->status > MYSQLI_STATUS_INITIALIZED))
+	{
+		/* already connected, we should close the connection */
+		php_mysqli_close(mysql, MYSQLI_CLOSE_IMPLICIT, mysqli_resource->status TSRMLS_CC);
+	}
+
+	if (strlen(SAFE_STR(hostname)) > 2 && !strncasecmp(hostname, "p:", 2)) {
+		hostname += 2;
+		if (!MyG(allow_persistent)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Persistent connections are disabled. Downgrading to normal");
+		} else {
+			mysql->persistent = persistent = TRUE;
+
+			hash_len = spprintf(&hash_key, 0, "mysqli_%s_%s%ld%s%s%s", SAFE_STR(hostname), SAFE_STR(socket),
+								port, SAFE_STR(username), SAFE_STR(dbname),
+								SAFE_STR(passwd));
+
+			mysql->hash_key = hash_key;
+
+			/* check if we can reuse exisiting connection ... */
+			if (zend_hash_find(&EG(persistent_list), hash_key, hash_len + 1, (void **)&le) == SUCCESS) {
+				if (Z_TYPE_P(le) == php_le_pmysqli()) {
+					plist = (mysqli_plist_entry *) le->ptr;
+
+					do {
+						if (zend_ptr_stack_num_elements(&plist->free_links)) {
+							mysql->mysql = zend_ptr_stack_pop(&plist->free_links);
+
+							MyG(num_inactive_persistent)--;
+							/* reset variables */
+
+#ifndef MYSQLI_NO_CHANGE_USER_ON_PCONNECT
+							if (!mysqli_change_user_silent(mysql->mysql, username, passwd, dbname)) {
+#else
+							if (!mysql_ping(mysql->mysql)) {
+#endif
+#ifdef MYSQLI_USE_MYSQLND
+								mysqlnd_restart_psession(mysql->mysql);
+#endif
+								MyG(num_active_persistent)++;
+								goto end;
+							} else {
+								mysqli_close(mysql->mysql, MYSQLI_CLOSE_IMPLICIT);
+								mysql->mysql = NULL;
+							}
+						}
+					} while (0);
+				}
+			} else {
+				zend_rsrc_list_entry le;
+				le.type = php_le_pmysqli();
+				le.ptr = plist = calloc(1, sizeof(mysqli_plist_entry));
+
+				zend_ptr_stack_init(&plist->free_links);
+				zend_hash_update(&EG(persistent_list), hash_key, hash_len + 1, (void *)&le, sizeof(le), NULL);
 			}
 		}
 	}
-	if (!mysql) {
-		mysql = (MY_MYSQL *) ecalloc(1, sizeof(MY_MYSQL));
+	if (MyG(max_links) != -1 && MyG(num_links) >= MyG(max_links)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Too many open links (%ld)", MyG(num_links));
+		goto err;
 	}
 
-	if (!(mysql->mysql = mysql_init(NULL))) {
-		efree(mysql);
-		RETURN_FALSE;
+	if (persistent && MyG(max_persistent) != -1 &&
+		(MyG(num_active_persistent) + MyG(num_inactive_persistent))>= MyG(max_persistent))
+	{
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Too many open persistent links (%ld)",
+								MyG(num_active_persistent) + MyG(num_inactive_persistent));
+		goto err;
 	}
+	if (!mysql->mysql) {
+#if !defined(MYSQLI_USE_MYSQLND)
+		if (!(mysql->mysql = mysql_init(NULL))) {
+#else
+		if (!(mysql->mysql = mysqlnd_init(persistent))) {
+#endif
+			goto err;
+		}
+		new_connection = TRUE;
+	}
 
 #ifdef HAVE_EMBEDDED_MYSQLI
-	if (strcmp(hostname, ":embedded")) {
+	if (hostname_len) {
 		unsigned int external=1;
 		mysql_options(mysql->mysql, MYSQL_OPT_USE_REMOTE_CONNECTION, (char *)&external);
 	} else {
-		hostname[0] = '\0';
 		mysql_options(mysql->mysql, MYSQL_OPT_USE_EMBEDDED_CONNECTION, 0);
 	}
 #endif
 
-	if (!socket) {
-		socket = MyG(default_socket);
-	}
+#if !defined(MYSQLI_USE_MYSQLND)
+	/* BC for prior to bug fix #53425 */
+	flags |= CLIENT_MULTI_RESULTS;
 
-	if (mysql_real_connect(mysql->mysql,hostname,username,passwd,dbname,port,socket,CLIENT_MULTI_RESULTS) == NULL) {
-		/* Save error messages */
-
-		php_mysqli_throw_sql_exception( mysql->mysql->net.sqlstate, mysql->mysql->net.last_errno TSRMLS_CC,
-										"%s", mysql->mysql->net.last_error);
-
+	if (mysql_real_connect(mysql->mysql, hostname, username, passwd, dbname, port, socket, flags) == NULL)
+#else
+	if (mysqlnd_connect(mysql->mysql, hostname, username, passwd, passwd_len, dbname, dbname_len,
+						port, socket, flags TSRMLS_CC) == NULL)
+#endif
+	{
+		/* Save error messages - for mysqli_connect_error() & mysqli_connect_errno() */
 		php_mysqli_set_error(mysql_errno(mysql->mysql), (char *) mysql_error(mysql->mysql) TSRMLS_CC);
-
-		/* free mysql structure */
-		mysql_close(mysql->mysql);
-		efree(mysql);
-		RETURN_FALSE;
+		php_mysqli_throw_sql_exception((char *)mysql_sqlstate(mysql->mysql), mysql_errno(mysql->mysql) TSRMLS_CC,
+										"%s", mysql_error(mysql->mysql));
+		if (!is_real_connect) {
+			/* free mysql structure */
+			mysqli_close(mysql->mysql, MYSQLI_CLOSE_DISCONNECTED);
+			mysql->mysql = NULL;
+		}
+		goto err;
 	}
 
 	/* clear error */
 	php_mysqli_set_error(mysql_errno(mysql->mysql), (char *) mysql_error(mysql->mysql) TSRMLS_CC);
 
+#if !defined(MYSQLI_USE_MYSQLND)
 	mysql->mysql->reconnect = MyG(reconnect);
 
 	/* set our own local_infile handler */
 	php_set_local_infile_handler_default(mysql);
+#endif
 
+	mysql_options(mysql->mysql, MYSQL_OPT_LOCAL_INFILE, (char *)&MyG(allow_local_infile));
+
+end:
 	if (!mysqli_resource) {
 		mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 		mysqli_resource->ptr = (void *)mysql;
 	}
 	mysqli_resource->status = MYSQLI_STATUS_VALID;
 
+	/* store persistent connection */
+	if (persistent && (new_connection || is_real_connect)) {
+		MyG(num_active_persistent)++;
+	}
+
+	MyG(num_links)++;
+
+	mysql->multi_query = 0;
+
 	if (!object || !instanceof_function(Z_OBJCE_P(object), mysqli_link_class_entry TSRMLS_CC)) {
-		MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_link_class_entry);	
+		MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_link_class_entry);
 	} else {
 		((mysqli_object *) zend_object_store_get_object(object TSRMLS_CC))->ptr = mysqli_resource;
 	}
+	if (!is_real_connect) {
+		return;
+	} else {
+		RETURN_TRUE;
+	}
+
+err:
+	if (mysql->hash_key) {
+		efree(mysql->hash_key);
+		mysql->hash_key = NULL;
+		mysql->persistent = FALSE;
+	}
+	if (!is_real_connect && self_alloced) {
+		efree(mysql);
+	}
+	RETVAL_FALSE;
 }
+
+
+/* {{{ proto object mysqli_connect([string hostname [,string username [,string passwd [,string dbname [,int port [,string socket]]]]]])
+   Open a connection to a mysql server */
+PHP_FUNCTION(mysqli_connect)
+{
+	mysqli_common_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, FALSE, FALSE);
+}
 /* }}} */
 
+
+/* {{{ proto object mysqli_link_construct()
+  */
+PHP_FUNCTION(mysqli_link_construct)
+{
+	mysqli_common_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, FALSE, TRUE);
+}
+/* }}} */
+
+
 /* {{{ proto int mysqli_connect_errno(void)
    Returns the numerical value of the error message from last connect command */
 PHP_FUNCTION(mysqli_connect_errno)
@@ -162,7 +334,7 @@
 
 /* {{{ proto string mysqli_connect_error(void)
    Returns the text of the error message from previous MySQL operation */
-PHP_FUNCTION(mysqli_connect_error) 
+PHP_FUNCTION(mysqli_connect_error)
 {
 	if (MyG(error_msg)) {
 		RETURN_STRING(MyG(error_msg),1);
@@ -172,9 +344,10 @@
 }
 /* }}} */
 
+
 /* {{{ proto mixed mysqli_fetch_array (object result [,int resulttype])
    Fetch a result row as an associative array, a numeric array, or both */
-PHP_FUNCTION(mysqli_fetch_array) 
+PHP_FUNCTION(mysqli_fetch_array)
 {
 	php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
 }
@@ -182,55 +355,129 @@
 
 /* {{{ proto mixed mysqli_fetch_assoc (object result)
    Fetch a result row as an associative array */
-PHP_FUNCTION(mysqli_fetch_assoc) 
+PHP_FUNCTION(mysqli_fetch_assoc)
 {
 	php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, MYSQLI_ASSOC, 0);
 }
 /* }}} */
 
+
+/* {{{ proto mixed mysqli_fetch_all (object result [,int resulttype])
+   Fetches all result rows as an associative array, a numeric array, or both */
+#if defined(MYSQLI_USE_MYSQLND)
+PHP_FUNCTION(mysqli_fetch_all)
+{
+	MYSQL_RES	*result;
+	zval		*mysql_result;
+	long		mode = MYSQLND_FETCH_NUM;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|l", &mysql_result, mysqli_result_class_entry, &mode) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE(result, MYSQL_RES *, &mysql_result, "mysqli_result", MYSQLI_STATUS_VALID);
+
+	if (!mode || (mode & ~MYSQLND_FETCH_BOTH)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Mode can be only MYSQLI_FETCH_NUM, "
+		                 "MYSQLI_FETCH_ASSOC or MYSQLI_FETCH_BOTH");
+		RETURN_FALSE;
+	}
+
+	mysqlnd_fetch_all(result, mode, return_value);
+}
+/* }}} */
+
+
+/* {{{ proto array mysqli_cache_stats(void) U
+   Returns statistics about the zval cache */
+PHP_FUNCTION(mysqli_get_cache_stats)
+{
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+	array_init(return_value);
+}
+/* }}} */
+
+
+/* {{{ proto array mysqli_get_client_stats(void)
+   Returns statistics about the zval cache */
+PHP_FUNCTION(mysqli_get_client_stats)
+{
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+	mysqlnd_get_client_stats(return_value);
+}
+/* }}} */
+
+
+/* {{{ proto array mysqli_get_connection_stats(void)
+   Returns statistics about the zval cache */
+PHP_FUNCTION(mysqli_get_connection_stats)
+{
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",
+									 &mysql_link, mysqli_link_class_entry) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
+
+	mysqlnd_get_connection_stats(mysql->mysql, return_value);
+}
+#endif
+/* }}} */
+
+
 /* {{{ proto mixed mysqli_fetch_object (object result [, string class_name [, NULL|array ctor_params]])
    Fetch a result row as an object */
-PHP_FUNCTION(mysqli_fetch_object) 
+PHP_FUNCTION(mysqli_fetch_object)
 {
-	php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, MYSQLI_ASSOC, 1);	
+	php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, MYSQLI_ASSOC, 1);
 }
 /* }}} */
 
 /* {{{ proto bool mysqli_multi_query(object link, string query)
-   Binary-safe version of mysql_query() */
+   allows to execute multiple queries  */
 PHP_FUNCTION(mysqli_multi_query)
 {
-	MY_MYSQL		*mysql;
-	zval			*mysql_link;
-	char			*query = NULL;
-	unsigned int 	query_len;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
+	char		*query = NULL;
+	int 		query_len;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	MYSQLI_ENABLE_MQ;	
+	MYSQLI_ENABLE_MQ;
 	if (mysql_real_query(mysql->mysql, query, query_len)) {
+#ifndef MYSQLI_USE_MYSQLND
 		char s_error[MYSQL_ERRMSG_SIZE], s_sqlstate[SQLSTATE_LENGTH+1];
 		unsigned int s_errno;
-		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
-
-		/* we have to save error information, cause 
+		/* we have to save error information, cause
 		MYSQLI_DISABLE_MQ will reset error information */
 		strcpy(s_error, mysql_error(mysql->mysql));
 		strcpy(s_sqlstate, mysql_sqlstate(mysql->mysql));
 		s_errno = mysql_errno(mysql->mysql);
-
+#else
+		MYSQLND_ERROR_INFO error_info = mysql->mysql->error_info;
+#endif
+		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 		MYSQLI_DISABLE_MQ;
 
+#ifndef MYSQLI_USE_MYSQLND
 		/* restore error information */
 		strcpy(mysql->mysql->net.last_error, s_error);
 		strcpy(mysql->mysql->net.sqlstate, s_sqlstate);
-		mysql->mysql->net.last_errno = s_errno;	
-
+		mysql->mysql->net.last_errno = s_errno;
+#else
+		mysql->mysql->error_info = error_info;
+#endif
 		RETURN_FALSE;
-	}	
+	}
 	RETURN_TRUE;
 }
 /* }}} */
@@ -243,8 +490,8 @@
 	MYSQLI_RESOURCE		*mysqli_resource;
 	MYSQL_RES 			*result;
 	char				*query = NULL;
-	unsigned int 		query_len;
-	unsigned long 		resultmode = MYSQLI_STORE_RESULT;
+	int 				query_len;
+	long 				resultmode = MYSQLI_STORE_RESULT;
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os|l", &mysql_link, mysqli_link_class_entry, &query, &query_len, &resultmode) == FAILURE) {
 		return;
@@ -254,15 +501,27 @@
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Empty query");
 		RETURN_FALSE;
 	}
-	if (resultmode != MYSQLI_USE_RESULT && resultmode != MYSQLI_STORE_RESULT) {
+	if ((resultmode & ~MYSQLI_ASYNC) != MYSQLI_USE_RESULT && (resultmode & ~MYSQLI_ASYNC) != MYSQLI_STORE_RESULT) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid value for resultmode");
 		RETURN_FALSE;
 	}
 
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL*, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	MYSQLI_DISABLE_MQ;
 
+
+#ifdef MYSQLI_USE_MYSQLND
+	if (resultmode & MYSQLI_ASYNC) {
+		if (mysqli_async_query(mysql->mysql, query, query_len)) {
+			MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
+			RETURN_FALSE;
+		}
+		mysql->async_result_fetch_type = resultmode & ~MYSQLI_ASYNC;
+		RETURN_TRUE;
+	}
+#endif
+
 	if (mysql_real_query(mysql->mysql, query, query_len)) {
 		MYSQLI_REPORT_MYSQL_ERROR(mysql->mysql);
 		RETURN_FALSE;
@@ -271,21 +530,272 @@
 	if (!mysql_field_count(mysql->mysql)) {
 		/* no result set - not a SELECT */
 		if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
-			php_mysqli_report_index(query, mysql->mysql->server_status TSRMLS_CC);
+			php_mysqli_report_index(query, mysqli_server_status(mysql->mysql) TSRMLS_CC);
 		}
 		RETURN_TRUE;
 	}
 
-	result = (resultmode == MYSQLI_USE_RESULT) ? mysql_use_result(mysql->mysql) : mysql_store_result(mysql->mysql);
+	switch (resultmode) {
+		case MYSQLI_STORE_RESULT:
+			result = mysql_store_result(mysql->mysql);
+			break;
+		case MYSQLI_USE_RESULT:
+			result = mysql_use_result(mysql->mysql);
+			break;
+	}
+	if (!result) {
+		php_mysqli_throw_sql_exception((char *)mysql_sqlstate(mysql->mysql), mysql_errno(mysql->mysql) TSRMLS_CC,
+										"%s", mysql_error(mysql->mysql));
+		RETURN_FALSE;
+	}
 
+	if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
+		php_mysqli_report_index(query, mysqli_server_status(mysql->mysql) TSRMLS_CC);
+	}
+
+	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
+	mysqli_resource->ptr = (void *)result;
+	mysqli_resource->status = MYSQLI_STATUS_VALID;
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);
+}
+/* }}} */
+
+
+#if defined(MYSQLI_USE_MYSQLND)
+#include "php_network.h"
+/* {{{ mysqlnd_zval_array_to_mysqlnd_array functions */
+static int mysqlnd_zval_array_to_mysqlnd_array(zval *in_array, MYSQLND ***out_array TSRMLS_DC)
+{
+	zval **elem;
+	int i = 0, current = 0;
+
+	if (Z_TYPE_P(in_array) != IS_ARRAY) {
+		return 0;
+	}
+	*out_array = ecalloc(zend_hash_num_elements(Z_ARRVAL_P(in_array)) + 1, sizeof(MYSQLND *));
+	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(in_array));
+		 zend_hash_get_current_data(Z_ARRVAL_P(in_array), (void **) &elem) == SUCCESS;
+		 zend_hash_move_forward(Z_ARRVAL_P(in_array))) {
+		i++;
+		if (Z_TYPE_PP(elem) != IS_OBJECT ||
+			!instanceof_function(Z_OBJCE_PP(elem), mysqli_link_class_entry TSRMLS_CC)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Parameter %d not a mysqli object", i);
+		} else {
+			MY_MYSQL *mysql;
+			MYSQLI_RESOURCE *my_res;
+			mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*elem TSRMLS_CC);
+			if (!(my_res = (MYSQLI_RESOURCE *)intern->ptr)) {
+		  		php_error_docref(NULL TSRMLS_CC, E_WARNING, "[%d] Couldn't fetch %s", i, intern->zo.ce->name);
+				continue;
+		  	}
+			mysql = (MY_MYSQL*) my_res->ptr;
+			if (MYSQLI_STATUS_VALID && my_res->status < MYSQLI_STATUS_VALID) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid object %d or resource %s", i, intern->zo.ce->name);
+				continue;
+			}
+			(*out_array)[current++] = mysql->mysql;
+		}
+	}
+	return 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zval_array_from_mysqlnd_array */
+static int mysqlnd_zval_array_from_mysqlnd_array(MYSQLND **in_array, zval *out_array TSRMLS_DC)
+{
+	MYSQLND **p = in_array;
+	HashTable *new_hash;
+	zval **elem, **dest_elem;
+	int ret = 0, i = 0;
+
+	ALLOC_HASHTABLE(new_hash);
+	zend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(out_array)), NULL, ZVAL_PTR_DTOR, 0);
+
+	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(out_array));
+		 zend_hash_get_current_data(Z_ARRVAL_P(out_array), (void **) &elem) == SUCCESS;
+		 zend_hash_move_forward(Z_ARRVAL_P(out_array)))
+	{
+		i++;
+		if (Z_TYPE_PP(elem) != IS_OBJECT || !instanceof_function(Z_OBJCE_PP(elem), mysqli_link_class_entry TSRMLS_CC)) {
+			continue;
+		}
+		{
+			MY_MYSQL *mysql;
+			MYSQLI_RESOURCE *my_res;
+			mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*elem TSRMLS_CC);
+			if (!(my_res = (MYSQLI_RESOURCE *)intern->ptr)) {
+		  		php_error_docref(NULL TSRMLS_CC, E_WARNING, "[%d] Couldn't fetch %s", i, intern->zo.ce->name);
+				continue;
+		  	}
+			mysql = (MY_MYSQL *) my_res->ptr;
+			if (mysql->mysql == *p) {
+				zend_hash_next_index_insert(new_hash, (void *)elem, sizeof(zval *), (void **)&dest_elem);
+				if (dest_elem) {
+					zval_add_ref(dest_elem);
+				}
+				ret++;
+				p++;
+			}
+		}
+	}
+
+	/* destroy old array and add new one */
+	zend_hash_destroy(Z_ARRVAL_P(out_array));
+	efree(Z_ARRVAL_P(out_array));
+
+	zend_hash_internal_pointer_reset(new_hash);
+	Z_ARRVAL_P(out_array) = new_hash;
+
+	return 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_dont_poll_zval_array_from_mysqlnd_array */
+static int mysqlnd_dont_poll_zval_array_from_mysqlnd_array(MYSQLND **in_array, zval *in_zval_array, zval *out_array TSRMLS_DC)
+{
+	MYSQLND **p = in_array;
+	HashTable *new_hash;
+	zval **elem, **dest_elem;
+	int ret = 0;
+
+	ALLOC_HASHTABLE(new_hash);
+	zend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(in_zval_array)), NULL, ZVAL_PTR_DTOR, 0);
+	if (in_array) {
+		for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(in_zval_array));
+			 zend_hash_get_current_data(Z_ARRVAL_P(in_zval_array), (void **) &elem) == SUCCESS;
+			 zend_hash_move_forward(Z_ARRVAL_P(in_zval_array)))
+		{
+			MY_MYSQL *mysql;
+			mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*elem TSRMLS_CC);
+			mysql = (MY_MYSQL *) ((MYSQLI_RESOURCE *)intern->ptr)->ptr;
+			if (mysql->mysql == *p) {
+				zend_hash_next_index_insert(new_hash, (void *)elem, sizeof(zval *), (void **)&dest_elem);
+				if (dest_elem) {
+					zval_add_ref(dest_elem);
+				}
+				ret++;
+				p++;
+			}
+		}
+	}
+
+	/* destroy old array and add new one */
+	zend_hash_destroy(Z_ARRVAL_P(out_array));
+	efree(Z_ARRVAL_P(out_array));
+
+	zend_hash_internal_pointer_reset(new_hash);
+	Z_ARRVAL_P(out_array) = new_hash;
+
+	return 0;
+}
+/* }}} */
+
+
+/* {{{ proto int mysqli_poll(array read, array write, array error, long sec [, long usec]) U
+   Poll connections */
+PHP_FUNCTION(mysqli_poll)
+{
+	zval			*r_array, *e_array, *dont_poll_array;
+	MYSQLND			**new_r_array = NULL, **new_e_array = NULL, **new_dont_poll_array = NULL;
+	long			sec = 0, usec = 0;
+	enum_func_status ret;
+	uint 			desc_num;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "a!a!al|l", &r_array, &e_array, &dont_poll_array, &sec, &usec) == FAILURE) {
+		return;
+	}
+	if (sec < 0 || usec < 0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Negative values passed for sec and/or usec");
+		RETURN_FALSE;
+	}
+
+	if (!r_array && !e_array) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "No stream arrays were passed");
+		RETURN_FALSE;
+	}
+
+	if (r_array != NULL) {
+		mysqlnd_zval_array_to_mysqlnd_array(r_array, &new_r_array TSRMLS_CC);
+	}
+	if (e_array != NULL) {
+		mysqlnd_zval_array_to_mysqlnd_array(e_array, &new_e_array TSRMLS_CC);
+	}
+
+	ret = mysqlnd_poll(new_r_array, new_e_array, &new_dont_poll_array, sec, usec, &desc_num);
+
+	mysqlnd_dont_poll_zval_array_from_mysqlnd_array(r_array != NULL ? new_dont_poll_array:NULL, r_array, dont_poll_array TSRMLS_CC);
+
+	if (r_array != NULL) {
+		mysqlnd_zval_array_from_mysqlnd_array(new_r_array, r_array TSRMLS_CC);
+	}
+	if (e_array != NULL) {
+		mysqlnd_zval_array_from_mysqlnd_array(new_e_array, e_array TSRMLS_CC);
+	}
+
+	if (new_dont_poll_array) {
+		efree(new_dont_poll_array);
+	}
+	if (new_r_array) {
+		efree(new_r_array);
+	}
+	if (new_e_array) {
+		efree(new_e_array);
+	}
+	if (ret == PASS) {
+		RETURN_LONG(desc_num);
+	} else {
+		RETURN_FALSE;
+	}
+}
+/* }}} */
+
+
+/* {{{ proto int mysqli_reap_async_query(object link) U
+   Poll connections */
+PHP_FUNCTION(mysqli_reap_async_query)
+{
+	MY_MYSQL		*mysql;
+	zval			*mysql_link;
+	MYSQLI_RESOURCE		*mysqli_resource;
+	MYSQL_RES 			*result;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
+		return;
+	}
+
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
+
+	if (FAIL == mysqlnd_reap_async_query(mysql->mysql)) {
+		RETURN_FALSE;
+	}
+
+	if (!mysql_field_count(mysql->mysql)) {
+		/* no result set - not a SELECT */
+		if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
+/*			php_mysqli_report_index("n/a", mysqli_server_status(mysql->mysql) TSRMLS_CC); */
+		}
+		RETURN_TRUE;
+	}
+
+	switch (mysql->async_result_fetch_type) {
+		case MYSQLI_STORE_RESULT:
+			result = mysql_store_result(mysql->mysql);
+			break;
+		case MYSQLI_USE_RESULT:
+			result = mysql_use_result(mysql->mysql);
+			break;
+	}
+
 	if (!result) {
-		php_mysqli_throw_sql_exception(mysql->mysql->net.sqlstate, mysql->mysql->net.last_errno TSRMLS_CC,
-										"%s", mysql->mysql->net.last_error); 
+		php_mysqli_throw_sql_exception((char *)mysql_sqlstate(mysql->mysql), mysql_errno(mysql->mysql) TSRMLS_CC,
+										"%s", mysql_error(mysql->mysql));
 		RETURN_FALSE;
 	}
 
 	if (MyG(report_mode) & MYSQLI_REPORT_INDEX) {
-		php_mysqli_report_index(query, mysql->mysql->server_status TSRMLS_CC);
+/*		php_mysqli_report_index("n/a", mysqli_server_status(mysql->mysql) TSRMLS_CC); */
 	}
 
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
@@ -295,6 +805,35 @@
 }
 /* }}} */
 
+
+/* {{{ proto object mysqli_stmt_get_result(object link) U
+   Buffer result set on client */
+PHP_FUNCTION(mysqli_stmt_get_result)
+{
+	MYSQL_RES 		*result;
+	MYSQLI_RESOURCE	*mysqli_resource;
+	MY_STMT			*stmt;
+	zval 			*mysql_stmt;
+
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_stmt, mysqli_stmt_class_entry) == FAILURE) {
+		return;
+	}
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &mysql_stmt, MYSQLI_STATUS_VALID);
+
+	if (!(result = mysqlnd_stmt_get_result(stmt->stmt))) {
+		MYSQLI_REPORT_STMT_ERROR(stmt->stmt);
+		RETURN_FALSE;
+	}
+
+	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
+	mysqli_resource->ptr = (void *)result;
+	mysqli_resource->status = MYSQLI_STATUS_VALID;
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_result_class_entry);
+}
+/* }}} */
+#endif
+
+
 /* {{{ proto object mysqli_get_warnings(object link) */
 PHP_FUNCTION(mysqli_get_warnings)
 {
@@ -306,16 +845,17 @@
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL*, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (mysql_warning_count(mysql->mysql)) {
-		w = php_get_warnings(mysql->mysql); 
+		w = php_get_warnings(mysql->mysql TSRMLS_CC);
 	} else {
 		RETURN_FALSE;
 	}
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = mysqli_resource->info = (void *)w;
-	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_warning_class_entry);	
+	mysqli_resource->status = MYSQLI_STATUS_VALID;
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_warning_class_entry);
 }
 /* }}} */
 
@@ -330,16 +870,17 @@
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &stmt_link, mysqli_stmt_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(stmt, MY_STMT*, &stmt_link, "mysqli_stmt", 1);
+	MYSQLI_FETCH_RESOURCE_STMT(stmt, &stmt_link, MYSQLI_STATUS_VALID);
 
-	if (mysql_warning_count(stmt->stmt->mysql)) {
-		w = php_get_warnings(stmt->stmt->mysql); 
+	if (mysqli_stmt_warning_count(stmt->stmt)) {
+		w = php_get_warnings(mysqli_stmt_get_connection(stmt->stmt) TSRMLS_CC);
 	} else {
 		RETURN_FALSE;
 	}
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
 	mysqli_resource->ptr = mysqli_resource->info = (void *)w;
-	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_warning_class_entry);	
+	mysqli_resource->status = MYSQLI_STATUS_VALID;
+	MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_warning_class_entry);
 }
 /* }}} */
 
@@ -348,15 +889,15 @@
    sets client character set */
 PHP_FUNCTION(mysqli_set_charset)
 {
-	MY_MYSQL			*mysql;
-	zval				*mysql_link;
-	char				*cs_name = NULL;
-	unsigned int 		len;
+	MY_MYSQL	*mysql;
+	zval		*mysql_link;
+	char		*cs_name;
+	int			csname_len;
 
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &cs_name, &len) == FAILURE) {
+	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &cs_name, &csname_len) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL*, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
 	if (mysql_set_character_set(mysql->mysql, cs_name)) {
 		RETURN_FALSE;
@@ -366,32 +907,61 @@
 /* }}} */
 #endif
 
-#ifdef HAVE_MYSQLI_GET_CHARSET 
-/* {{{ proto object mysqli_get_charset(object link) 
+#ifdef HAVE_MYSQLI_GET_CHARSET
+/* {{{ proto object mysqli_get_charset(object link) U
    returns a character set object */
 PHP_FUNCTION(mysqli_get_charset)
 {
 	MY_MYSQL				*mysql;
 	zval					*mysql_link;
+	const char 				*name = NULL, *collation = NULL, *dir = NULL, *comment = NULL;
+	uint					minlength, maxlength, number, state;
+#if !defined(MYSQLI_USE_MYSQLND)
 	MY_CHARSET_INFO			cs;
+#else
+	const MYSQLND_CHARSET	*cs;
+#endif
 
 	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
 		return;
 	}
-	MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL*, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
+	MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
 
-	object_init(return_value);
 
+#if !defined(MYSQLI_USE_MYSQLND)
 	mysql_get_character_set_info(mysql->mysql, &cs);
+	name = (char *)cs.csname;
+	collation = (char *)cs.name;
+	dir = (char *)cs.dir;
+	minlength = cs.mbminlen;
+	maxlength = cs.mbmaxlen;
+	number = cs.number;
+	state = cs.state;
+	comment = cs.comment;
+#else
+	cs = mysql->mysql->charset;
+	if (!cs) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "The connection has no charset associated");
+		RETURN_NULL();
+	}
+	name = cs->name;
+	collation = cs->collation;
+	minlength = cs->char_minlen;
+	maxlength = cs->char_maxlen;
+	number = cs->nr;
+	comment = cs->comment;
+	state = 1;	/* all charsets are compiled in */
+#endif
+	object_init(return_value);
 
-	add_property_string(return_value, "charset", (cs.name) ? (char *)cs.csname : "", 1);
-	add_property_string(return_value, "collation",(cs.name) ? (char *)cs.name : "", 1);
-	add_property_string(return_value, "comment", (cs.comment) ? (char *)cs.comment : "", 1);
-	add_property_string(return_value, "dir", (cs.dir) ? (char *)cs.dir : "", 1);
-	add_property_long(return_value, "min_length", cs.mbminlen);
-	add_property_long(return_value, "max_length", cs.mbmaxlen);
-	add_property_long(return_value, "number", cs.number);
-	add_property_long(return_value, "state", cs.state);
+	add_property_string(return_value, "charset", (name) ? (char *)name : "", 1);
+	add_property_string(return_value, "collation",(collation) ? (char *)collation : "", 1);
+	add_property_string(return_value, "dir", (dir) ? (char *)dir : "", 1);
+	add_property_long(return_value, "min_length", minlength);
+	add_property_long(return_value, "max_length", maxlength);
+	add_property_long(return_value, "number", number);
+	add_property_long(return_value, "state", state);
+	add_property_string(return_value, "comment", (comment) ? (char *)comment : "", 1);
 }
 /* }}} */
 #endif
--- /dev/null
+++ b/ext/mysqli/mysqli_priv.h
@@ -0,0 +1,156 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 1997-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Author: Georg Richter <georg@php.net>                                |
+  +----------------------------------------------------------------------+
+
+  $Id: php_mysqli_structs.h 302179 2010-08-13 09:57:04Z andrey $
+*/
+
+#ifndef MYSQLI_PRIV_H
+#define MYSQLI_PRIV_H
+
+#ifdef PHP_MYSQL_UNIX_SOCK_ADDR
+#ifdef MYSQL_UNIX_ADDR
+#undef MYSQL_UNIX_ADDR
+#endif
+#define MYSQL_UNIX_ADDR PHP_MYSQL_UNIX_SOCK_ADDR
+#endif
+
+/* character set support */
+#if defined(MYSQLND_VERSION_ID) || MYSQL_VERSION_ID > 50009
+#define HAVE_MYSQLI_GET_CHARSET
+#endif
+
+#if defined(MYSQLND_VERSION_ID) || (MYSQL_VERSION_ID > 40112 && MYSQL_VERSION_ID < 50000) || MYSQL_VERSION_ID > 50005
+#define HAVE_MYSQLI_SET_CHARSET
+#endif
+
+
+extern const zend_function_entry mysqli_functions[];
+extern const zend_function_entry mysqli_link_methods[];
+extern const zend_function_entry mysqli_stmt_methods[];
+extern const zend_function_entry mysqli_result_methods[];
+extern const zend_function_entry mysqli_driver_methods[];
+extern const zend_function_entry mysqli_warning_methods[];
+extern const zend_function_entry mysqli_exception_methods[];
+
+extern const mysqli_property_entry mysqli_link_property_entries[];
+extern const mysqli_property_entry mysqli_result_property_entries[];
+extern const mysqli_property_entry mysqli_stmt_property_entries[];
+extern const mysqli_property_entry mysqli_driver_property_entries[];
+extern const mysqli_property_entry mysqli_warning_property_entries[];
+
+extern zend_property_info mysqli_link_property_info_entries[];
+extern zend_property_info mysqli_result_property_info_entries[];
+extern zend_property_info mysqli_stmt_property_info_entries[];
+extern zend_property_info mysqli_driver_property_info_entries[];
+extern zend_property_info mysqli_warning_property_info_entries[];
+
+extern int php_le_pmysqli(void);
+extern void php_mysqli_dtor_p_elements(void *data);
+
+extern void php_mysqli_close(MY_MYSQL * mysql, int close_type, int resource_status TSRMLS_DC);
+
+extern void php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAMETERS, int override_flag, int into_object);
+extern void php_clear_stmt_bind(MY_STMT *stmt TSRMLS_DC);
+extern void php_clear_mysql(MY_MYSQL *);
+extern MYSQLI_WARNING *php_get_warnings(MYSQL *mysql TSRMLS_DC);
+extern void php_clear_warnings(MYSQLI_WARNING *w);
+extern void php_free_stmt_bind_buffer(BIND_BUFFER bbuf, int type);
+extern void php_mysqli_report_error(const char *sqlstate, int errorno, const char *error TSRMLS_DC);
+extern void php_mysqli_report_index(const char *query, unsigned int status TSRMLS_DC);
+extern void php_set_local_infile_handler_default(MY_MYSQL *);
+extern void php_mysqli_throw_sql_exception(char *sqlstate, int errorno TSRMLS_DC, char *format, ...);
+
+#ifdef HAVE_SPL
+extern PHPAPI zend_class_entry *spl_ce_RuntimeException;
+#endif
+
+#define REGISTER_MYSQLI_CLASS_ENTRY(name, mysqli_entry, class_functions) { \
+	zend_class_entry tmp_ce; \
+	INIT_CLASS_ENTRY(tmp_ce, name,class_functions); \
+	tmp_ce.create_object = mysqli_objects_new; \
+	mysqli_entry = zend_register_internal_class(&tmp_ce TSRMLS_CC); \
+} \
+
+#define PHP_MYSQLI_EXPORT(__type) PHP_MYSQLI_API __type
+
+PHP_MYSQLI_EXPORT(zend_object_value) mysqli_objects_new(zend_class_entry * TSRMLS_DC);
+
+
+#define MYSQLI_DISABLE_MQ if (mysql->multi_query) { \
+	mysql_set_server_option(mysql->mysql, MYSQL_OPTION_MULTI_STATEMENTS_OFF); \
+	mysql->multi_query = 0; \
+}
+
+#define MYSQLI_ENABLE_MQ if (!mysql->multi_query) { \
+	mysql_set_server_option(mysql->mysql, MYSQL_OPTION_MULTI_STATEMENTS_ON); \
+	mysql->multi_query = 1; \
+}
+
+
+#define MYSQLI_RETURN_LONG_LONG(__val) \
+{ \
+	if ((__val) < LONG_MAX) {		\
+		RETURN_LONG((long) (__val));		\
+	} else {				\
+		char *ret;			\
+		/* always used with my_ulonglong -> %llu */ \
+		int l = spprintf(&ret, 0, MYSQLI_LLU_SPEC, (__val));	\
+		RETURN_STRINGL(ret, l, 0);		\
+	}					\
+}
+
+#define MYSQLI_STORE_RESULT 0
+#define MYSQLI_USE_RESULT 	1
+#ifdef MYSQLI_USE_MYSQLND
+#define MYSQLI_ASYNC	 	8
+#else
+/* libmysql */
+#define MYSQLI_ASYNC	 	0
+#endif
+
+/* for mysqli_fetch_assoc */
+#define MYSQLI_ASSOC	1
+#define MYSQLI_NUM		2
+#define MYSQLI_BOTH		3
+
+/* fetch types */
+#define FETCH_SIMPLE		1
+#define FETCH_RESULT		2
+
+/*** REPORT MODES ***/
+#define MYSQLI_REPORT_OFF           0
+#define MYSQLI_REPORT_ERROR			1
+#define MYSQLI_REPORT_STRICT		2
+#define MYSQLI_REPORT_INDEX			4
+#define MYSQLI_REPORT_CLOSE			8
+#define MYSQLI_REPORT_ALL		  255
+
+#define MYSQLI_REPORT_MYSQL_ERROR(mysql) \
+if ((MyG(report_mode) & MYSQLI_REPORT_ERROR) && mysql_errno(mysql)) { \
+	php_mysqli_report_error(mysql_sqlstate(mysql), mysql_errno(mysql), mysql_error(mysql) TSRMLS_CC); \
+}
+
+#define MYSQLI_REPORT_STMT_ERROR(stmt) \
+if ((MyG(report_mode) & MYSQLI_REPORT_ERROR) && mysql_stmt_errno(stmt)) { \
+	php_mysqli_report_error(mysql_stmt_sqlstate(stmt), mysql_stmt_errno(stmt), mysql_stmt_error(stmt) TSRMLS_CC); \
+}
+
+void mysqli_common_connect(INTERNAL_FUNCTION_PARAMETERS, zend_bool is_real_connect, zend_bool in_ctor);
+
+void php_mysqli_init(INTERNAL_FUNCTION_PARAMETERS);
+
+#endif /* MYSQLI_PRIV_H */
--- a/ext/mysqli/mysqli_prop.c
+++ b/ext/mysqli/mysqli_prop.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -15,7 +15,7 @@
   | Author: Georg Richter <georg@php.net>                                |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli_prop.c 294298 2010-02-01 11:37:48Z andrey $ 
+  $Id$
 */
 
 #ifdef HAVE_CONFIG_H
@@ -27,7 +27,8 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_priv.h"
 
 #define CHECK_STATUS(value) \
 	if (!obj->ptr || ((MYSQLI_RESOURCE *)obj->ptr)->status < value ) { \
@@ -83,7 +84,7 @@
 	} else {\
 		l = (__ret_type)__int_func(p);\
 		if (l < LONG_MAX) {\
-			ZVAL_LONG(*retval, l);\
+			ZVAL_LONG(*retval, (long) l);\
 		} else { \
 			char *ret; \
 			int ret_len = spprintf(&ret, 0, __ret_type_sprint_mod, l); \
@@ -158,12 +159,12 @@
 	MY_MYSQL *mysql;
 	my_ulonglong rc;
 
-	MAKE_STD_ZVAL(*retval); 
+	MAKE_STD_ZVAL(*retval);
 
 	CHECK_STATUS(MYSQLI_STATUS_INITIALIZED);
 
  	mysql = (MY_MYSQL *)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
-	
+
 	if (!mysql) {
 		ZVAL_NULL(*retval);
 	} else {
@@ -174,10 +175,10 @@
 		if (rc == (my_ulonglong) -1) {
 			ZVAL_LONG(*retval, -1);
 			return SUCCESS;
-		} 
+		}
 
 		if (rc < LONG_MAX) {
-			ZVAL_LONG(*retval, rc);
+			ZVAL_LONG(*retval, (long) rc);
 		} else {
 			char *ret;
 			int l = spprintf(&ret, 0, MYSQLI_LLU_SPEC, rc);
@@ -189,18 +190,52 @@
 /* }}} */
 
 /* link properties */
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_errno_read, mysql_errno, MYSQLI_GET_MYSQL(MYSQLI_STATUS_INITIALIZED), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_STRING(link_error_read, mysql_error, MYSQLI_GET_MYSQL(MYSQLI_STATUS_INITIALIZED));
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_field_count_read, mysql_field_count, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_STRING(link_host_info_read, mysql_get_host_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID));
-MYSQLI_MAP_PROPERTY_FUNC_STRING(link_info_read, mysql_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID));
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_insert_id_read, mysql_insert_id, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC);
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_protocol_version_read, mysql_get_proto_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_STRING(link_server_info_read, mysql_get_server_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID));
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_server_version_read, mysql_get_server_version, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_STRING(link_sqlstate_read, mysql_sqlstate, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID));
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_thread_id_read, mysql_thread_id, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_LONG(link_warning_count_read, mysql_warning_count, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu");
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_errno_read, mysql_errno, MYSQLI_GET_MYSQL(MYSQLI_STATUS_INITIALIZED), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_STRING(link_error_read, mysql_error, MYSQLI_GET_MYSQL(MYSQLI_STATUS_INITIALIZED))
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_field_count_read, mysql_field_count, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_STRING(link_host_info_read, mysql_get_host_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID))
+MYSQLI_MAP_PROPERTY_FUNC_STRING(link_info_read, mysql_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID))
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_insert_id_read, mysql_insert_id, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC)
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_protocol_version_read, mysql_get_proto_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_STRING(link_server_info_read, mysql_get_server_info, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID))
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_server_version_read, mysql_get_server_version, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_STRING(link_sqlstate_read, mysql_sqlstate, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID))
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_thread_id_read, mysql_thread_id, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_LONG(link_warning_count_read, mysql_warning_count, MYSQLI_GET_MYSQL(MYSQLI_STATUS_VALID), ulong, "%lu")
+
+/* {{{ property link_stat_read */
+static int link_stat_read(mysqli_object *obj, zval **retval TSRMLS_DC)\
+{\
+	MY_MYSQL *mysql;
+
+	MAKE_STD_ZVAL(*retval);
+	ZVAL_NULL(*retval);
+
+#if defined(MYSQLI_USE_MYSQLND)
+	CHECK_STATUS(MYSQLI_STATUS_INITIALIZED);
+#else
+	CHECK_STATUS(MYSQLI_STATUS_VALID);
+#endif
+
+ 	mysql = (MY_MYSQL *)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
+
+	if (mysql) {
+		char * stat_msg;
+#if defined(MYSQLI_USE_MYSQLND)
+		uint stat_msg_len;
+		if (mysqlnd_stat(mysql->mysql, &stat_msg, &stat_msg_len) == PASS) {
+			ZVAL_STRINGL(*retval, stat_msg, stat_msg_len, 0);
+		}
+#else
+		if ((stat_msg = (char *) mysql_stat(mysql->mysql))) {
+			ZVAL_STRING(*retval, stat_msg, 1);
+		}
+#endif
+	}
+	return SUCCESS;
+}
+/* }}} */
+
 /* result properties */
 
 /* {{{ property result_type_read */
@@ -215,7 +250,7 @@
 	if (!p) {
 		ZVAL_NULL(*retval);
 	} else {
-		ZVAL_LONG(*retval, (p->data) ? MYSQLI_STORE_RESULT : MYSQLI_USE_RESULT);
+		ZVAL_LONG(*retval, mysqli_result_is_unbuffered(p) ? MYSQLI_USE_RESULT:MYSQLI_STORE_RESULT);
 	}
 	return SUCCESS;
 }
@@ -247,9 +282,9 @@
 /* }}} */
 
 
-MYSQLI_MAP_PROPERTY_FUNC_LONG(result_current_field_read, mysql_field_tell, MYSQLI_GET_RESULT(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_LONG(result_field_count_read, mysql_num_fields, MYSQLI_GET_RESULT(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_LONG(result_num_rows_read, mysql_num_rows, MYSQLI_GET_RESULT(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC);
+MYSQLI_MAP_PROPERTY_FUNC_LONG(result_current_field_read, mysql_field_tell, MYSQLI_GET_RESULT(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_LONG(result_field_count_read, mysql_num_fields, MYSQLI_GET_RESULT(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_LONG(result_num_rows_read, mysql_num_rows, MYSQLI_GET_RESULT(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC)
 
 /* statement properties */
 
@@ -258,7 +293,7 @@
 {
 	MY_STMT *p;
 
-	MAKE_STD_ZVAL(*retval); 
+	MAKE_STD_ZVAL(*retval);
 	CHECK_STATUS(MYSQLI_STATUS_VALID);
 
  	p = (MY_STMT*)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
@@ -266,7 +301,7 @@
 	if (!p) {
 		ZVAL_NULL(*retval);
 	} else {
-		ZVAL_LONG(*retval, p->stmt->stmt_id);
+		ZVAL_LONG(*retval, mysqli_stmt_get_id(p->stmt));
 	}
 	return SUCCESS;
 }
@@ -278,7 +313,7 @@
 	MY_STMT *p;
 	my_ulonglong rc;
 
-	MAKE_STD_ZVAL(*retval); 
+	MAKE_STD_ZVAL(*retval);
 	CHECK_STATUS(MYSQLI_STATUS_VALID);
 
  	p = (MY_STMT *)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
@@ -287,14 +322,14 @@
 		ZVAL_NULL(*retval);
 	} else {
 		rc = mysql_stmt_affected_rows(p->stmt);
-	
+
 		if (rc == (my_ulonglong) -1) {
 			ZVAL_LONG(*retval, -1);
 			return SUCCESS;
-		} 
-	
+		}
+
 		if (rc < LONG_MAX) {
-			ZVAL_LONG(*retval, rc);
+			ZVAL_LONG(*retval, (long) rc);
 		} else {
 			char *ret;
 			int l = spprintf(&ret, 0, MYSQLI_LLU_SPEC, rc);
@@ -305,56 +340,104 @@
 }
 /* }}} */
 
-MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_insert_id_read, mysql_stmt_insert_id, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC);
-MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_num_rows_read, mysql_stmt_num_rows, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC);
-MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_param_count_read, mysql_stmt_param_count, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_field_count_read, mysql_stmt_field_count, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_errno_read, mysql_stmt_errno, MYSQLI_GET_STMT(MYSQLI_STATUS_INITIALIZED), ulong, "%lu");
-MYSQLI_MAP_PROPERTY_FUNC_STRING(stmt_error_read, mysql_stmt_error, MYSQLI_GET_STMT(MYSQLI_STATUS_INITIALIZED));
-MYSQLI_MAP_PROPERTY_FUNC_STRING(stmt_sqlstate_read, mysql_stmt_sqlstate, MYSQLI_GET_STMT(MYSQLI_STATUS_INITIALIZED));
+MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_insert_id_read, mysql_stmt_insert_id, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC)
+MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_num_rows_read, mysql_stmt_num_rows, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), my_ulonglong, MYSQLI_LLU_SPEC)
+MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_param_count_read, mysql_stmt_param_count, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_field_count_read, mysql_stmt_field_count, MYSQLI_GET_STMT(MYSQLI_STATUS_VALID), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_LONG(stmt_errno_read, mysql_stmt_errno, MYSQLI_GET_STMT(MYSQLI_STATUS_INITIALIZED), ulong, "%lu")
+MYSQLI_MAP_PROPERTY_FUNC_STRING(stmt_error_read, mysql_stmt_error, MYSQLI_GET_STMT(MYSQLI_STATUS_INITIALIZED))
+MYSQLI_MAP_PROPERTY_FUNC_STRING(stmt_sqlstate_read, mysql_stmt_sqlstate, MYSQLI_GET_STMT(MYSQLI_STATUS_INITIALIZED))
 
 /* }}} */
-mysqli_property_entry mysqli_link_property_entries[] = {
-	{"affected_rows", link_affected_rows_read, NULL},
-	{"client_info", link_client_info_read, NULL},
-	{"client_version", link_client_version_read, NULL},
-	{"connect_errno", link_connect_errno_read, NULL},
-	{"connect_error", link_connect_error_read, NULL},
-	{"errno", link_errno_read, NULL},
-	{"error", link_error_read, NULL},
-	{"field_count", link_field_count_read, NULL},
-	{"host_info", link_host_info_read, NULL},
-	{"info", link_info_read, NULL},
-	{"insert_id", link_insert_id_read, NULL},
-	{"server_info", link_server_info_read, NULL},
-	{"server_version", link_server_version_read, NULL},
-	{"sqlstate", link_sqlstate_read, NULL},
-	{"protocol_version", link_protocol_version_read, NULL},
-	{"thread_id", link_thread_id_read, NULL},
-	{"warning_count", link_warning_count_read, NULL},
-	{NULL, NULL, NULL}	
+const mysqli_property_entry mysqli_link_property_entries[] = {
+	{"affected_rows", 	sizeof("affected_rows") - 1,	link_affected_rows_read, NULL},
+	{"client_info", 	sizeof("client_info") - 1,		link_client_info_read, NULL},
+	{"client_version",	sizeof("client_version") - 1,	link_client_version_read, NULL},
+	{"connect_errno",	sizeof("connect_errno") - 1,	link_connect_errno_read, NULL},
+	{"connect_error",	sizeof("connect_error") - 1,	link_connect_error_read, NULL},
+	{"errno",			sizeof("errno") - 1,			link_errno_read, NULL},
+	{"error",			sizeof("error") - 1,			link_error_read, NULL},
+	{"field_count",		sizeof("field_count") - 1,		link_field_count_read, NULL},
+	{"host_info",		sizeof("host_info") - 1,		link_host_info_read, NULL},
+	{"info",			sizeof("info") - 1,				link_info_read, NULL},
+	{"insert_id",		sizeof("insert_id") - 1,		link_insert_id_read, NULL},
+	{"server_info",		sizeof("server_info") - 1,		link_server_info_read, NULL},
+	{"server_version",	sizeof("server_version") - 1,	link_server_version_read, NULL},
+	{"stat",			sizeof("stat") - 1,				link_stat_read, NULL},
+	{"sqlstate",		sizeof("sqlstate") - 1,			link_sqlstate_read, NULL},
+	{"protocol_version",sizeof("protocol_version") - 1,	link_protocol_version_read, NULL},
+	{"thread_id",		sizeof("thread_id") - 1, 		link_thread_id_read, NULL},
+	{"warning_count",	sizeof("warning_count") - 1, 	link_warning_count_read, NULL},
+	{NULL, 0, NULL, NULL}
 };
 
-mysqli_property_entry mysqli_result_property_entries[] = {
-	{"current_field", result_current_field_read, NULL},
-	{"field_count", result_field_count_read, NULL},
-	{"lengths", result_lengths_read, NULL},
-	{"num_rows", result_num_rows_read, NULL},
-	{"type", result_type_read, NULL},
-	{NULL, NULL, NULL}
+/* should not be const, as it is patched during runtime */
+zend_property_info mysqli_link_property_info_entries[] = {
+	{ZEND_ACC_PUBLIC, "affected_rows",	sizeof("affected_rows") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "client_info",	sizeof("client_info") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "client_version",	sizeof("client_version") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "connect_errno",	sizeof("connect_errno") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "connect_error",	sizeof("connect_error") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "errno",			sizeof("errno") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "error",			sizeof("error") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "field_count",	sizeof("field_count") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "host_info",		sizeof("host_info") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "info",			sizeof("info") - 1,				0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "insert_id",		sizeof("insert_id") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "server_info",	sizeof("server_info") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "server_version",	sizeof("server_version") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "stat",			sizeof("stat") - 1,				0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "sqlstate",		sizeof("sqlstate") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "protocol_version", sizeof("protocol_version")-1, 0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "thread_id", 		sizeof("thread_id") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "warning_count",	sizeof("warning_count") - 1,	0, NULL, 0, NULL},
+	{0,					NULL, 			0,								0, NULL, 0, NULL}
 };
 
-mysqli_property_entry mysqli_stmt_property_entries[] = {
-	{"affected_rows", stmt_affected_rows_read, NULL},
-	{"insert_id", stmt_insert_id_read, NULL},
-	{"num_rows", stmt_num_rows_read, NULL},
-	{"param_count", stmt_param_count_read, NULL},
-	{"field_count", stmt_field_count_read, NULL},
-	{"errno", stmt_errno_read, NULL},
-	{"error", stmt_error_read, NULL},
-	{"sqlstate", stmt_sqlstate_read, NULL},
-	{"id", stmt_id_read, NULL},
-	{NULL, NULL, NULL}
+
+const mysqli_property_entry mysqli_result_property_entries[] = {
+	{"current_field",sizeof("current_field")-1,	result_current_field_read, NULL},
+	{"field_count", sizeof("field_count") - 1,	result_field_count_read, NULL},
+	{"lengths", 	sizeof("lengths") - 1,		result_lengths_read, NULL},
+	{"num_rows", 	sizeof("num_rows") - 1,		result_num_rows_read, NULL},
+	{"type", 		sizeof("type") - 1,			result_type_read, NULL},
+	{NULL, 0, NULL, NULL}
+};
+
+zend_property_info mysqli_result_property_info_entries[] = {
+	{ZEND_ACC_PUBLIC, "current_field",	sizeof("current_field")-1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "field_count",	sizeof("field_count") - 1, 	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "lengths",		sizeof("lengths") - 1, 		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "num_rows",		sizeof("num_rows") - 1, 	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "type",			sizeof("type") - 1, 		0, NULL, 0, NULL},
+	{0,					NULL, 			0,							0, NULL, 0, NULL}
+};
+
+const mysqli_property_entry mysqli_stmt_property_entries[] = {
+	{"affected_rows", sizeof("affected_rows")-1,stmt_affected_rows_read, NULL},
+	{"insert_id",	sizeof("insert_id") - 1, 	stmt_insert_id_read, NULL},
+	{"num_rows",	sizeof("num_rows") - 1, 	stmt_num_rows_read, NULL},
+	{"param_count", sizeof("param_count") - 1,	stmt_param_count_read, NULL},
+	{"field_count", sizeof("field_count") - 1,	stmt_field_count_read, NULL},
+	{"errno",		sizeof("errno") - 1,		stmt_errno_read, NULL},
+	{"error",		sizeof("error") - 1, 		stmt_error_read, NULL},
+	{"sqlstate",	sizeof("sqlstate") - 1,		stmt_sqlstate_read, NULL},
+	{"id",			sizeof("id") - 1,			stmt_id_read, NULL},
+	{NULL, 0, NULL, NULL}
+};
+
+
+zend_property_info mysqli_stmt_property_info_entries[] = {
+	{ZEND_ACC_PUBLIC, "affected_rows", sizeof("affected_rows") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "insert_id",	sizeof("insert_id") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "num_rows",	sizeof("num_rows") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "param_count",sizeof("param_count") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "field_count",sizeof("field_count") - 1,		0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "errno",		sizeof("errno") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "error",		sizeof("error") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "sqlstate",	sizeof("sqlstate") - 1,			0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "id",			sizeof("id") - 1,				0, NULL, 0, NULL},
+	{0,					NULL, 			0,							0, NULL, 0, NULL}
 };
 
 /*
--- a/ext/mysqli/mysqli_repl.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
-  +----------------------------------------------------------------------+
-  | PHP Version 5                                                        |
-  +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
-  +----------------------------------------------------------------------+
-  | This source file is subject to version 3.01 of the PHP license,      |
-  | that is bundled with this package in the file LICENSE, and is        |
-  | available through the world-wide-web at the following url:           |
-  | http://www.php.net/license/3_01.txt                                  |
-  | If you did not receive a copy of the PHP license and are unable to   |
-  | obtain it through the world-wide-web, please send a note to          |
-  | license@php.net so we can mail you a copy immediately.               |
-  +----------------------------------------------------------------------+
-  | Author: Georg Richter <georg@php.net>                                |
-  +----------------------------------------------------------------------+
-
-  $Id: mysqli_repl.c 293036 2010-01-03 09:23:27Z sebastian $
-*/
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <signal.h>
-
-#include "php.h"
-#include "php_ini.h"
-#include "ext/standard/info.h"
-#include "php_mysqli.h"
-
-#ifdef HAVE_LIBMYSQL_REPLICATION
-/* {{{ proto void mysqli_disable_reads_from_master(object link)
-*/
-PHP_FUNCTION(mysqli_disable_reads_from_master)
-{
-	MYSQL		*mysql;
-	zval		*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-	mysql_disable_reads_from_master(mysql);
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto void mysqli_disable_rpl_parse(object link)
-*/
-PHP_FUNCTION(mysqli_disable_rpl_parse)
-{
-	MYSQL		*mysql;
-	zval    	*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-	mysql_disable_rpl_parse(mysql);
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto void mysqli_enable_reads_from_master(object link)
-*/
-PHP_FUNCTION(mysqli_enable_reads_from_master)
-{
-	MYSQL		*mysql;
-	zval		*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	mysql_enable_reads_from_master(mysql);
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto void mysqli_enable_rpl_parse(object link)
-*/
-PHP_FUNCTION(mysqli_enable_rpl_parse)
-{
-	MYSQL		*mysql;
-	zval		*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	mysql_enable_rpl_parse(mysql);
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto bool mysqli_master_query(object link, string query)
-   Enforce execution of a query on the master in a master/slave setup */
-PHP_FUNCTION(mysqli_master_query) {
-	MYSQL			*mysql;
-	zval			*mysql_link;
-	char			*query = NULL;
-	unsigned int 	query_len;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	if (mysql_master_query(mysql, query, query_len)) {
-		RETURN_FALSE;
-	}	
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto int mysqli_rpl_parse_enabled(object link)
-*/
-PHP_FUNCTION(mysqli_rpl_parse_enabled)
-{
-	MYSQL		*mysql;
-	zval  		*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	RETURN_LONG(mysql_rpl_parse_enabled(mysql));
-}
-/* }}} */
-
-/* {{{ proto bool mysqli_rpl_probe(object link)
-*/
-PHP_FUNCTION(mysqli_rpl_probe)
-{
-	MYSQL		*mysql;
-	zval  		*mysql_link;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &mysql_link, mysqli_link_class_entry) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-
-	if (mysql_rpl_probe(mysql)) {
-		RETURN_FALSE;
-	}
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto int mysqli_rpl_query_type(string query)
-*/
-PHP_FUNCTION(mysqli_rpl_query_type)
-{
-	MYSQL		*mysql;
-	zval		*mysql_link;
-	char		*query;
-	int	 		query_len;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	RETURN_LONG(mysql_rpl_query_type(query, query_len));
-}
-/* }}} */
-
-/* {{{ proto bool mysqli_send_query(object link, string query)
-*/
-PHP_FUNCTION(mysqli_send_query)
-{
-	MYSQL			*mysql;
-	zval			*mysql_link;
-	char			*query = NULL;
-	unsigned int 	query_len;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	if (mysql_send_query(mysql, query, query_len)) {
-		RETURN_FALSE;
-	}	
-	RETURN_TRUE;
-}
-/* }}} */
-
-/* {{{ proto bool mysqli_slave_query(object link, string query)
-   Enforce execution of a query on a slave in a master/slave setup */
-PHP_FUNCTION(mysqli_slave_query)
-{
-	MYSQL			*mysql;
-	zval			*mysql_link;
-	char			*query = NULL;
-	unsigned int	query_len;
-
-	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Os", &mysql_link, mysqli_link_class_entry, &query, &query_len) == FAILURE) {
-		return;
-	}
-	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, &mysql_link, "mysqli_link", MYSQLI_STATUS_VALID);
-
-	if (mysql_slave_query(mysql, query, query_len)) {
-		RETURN_FALSE;
-	}	
-	RETURN_TRUE;
-}
-/* }}} */
-
-#endif /* HAVE_LIBMYSQL_REPLICATION */
-
-/*
- * Local variables:
- * tab-width: 4
- * c-basic-offset: 4
- * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim<600: noet sw=4 ts=4
- */
--- a/ext/mysqli/mysqli_report.c
+++ b/ext/mysqli/mysqli_report.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -15,7 +15,7 @@
   | Author: Georg Richter <georg@php.net>                                |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli_report.c 293036 2010-01-03 09:23:27Z sebastian $ 
+  $Id$
 */
 
 #ifdef HAVE_CONFIG_H
@@ -25,15 +25,17 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
 
+extern void php_mysqli_throw_sql_exception(char *sqlstate, int errorno TSRMLS_DC, char *format, ...);
+
 /* {{{ proto bool mysqli_report(int flags)
    sets report level */
 PHP_FUNCTION(mysqli_report)
 {
-	long		flags;
+	long flags;
 
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &flags) == FAILURE) {
 		return;
 	}
@@ -44,14 +46,15 @@
 }
 /* }}} */
 
-/* {{{ void php_mysqli_report_error(char *sqlstate, int errorno, char *error) */ 
-void php_mysqli_report_error(char *sqlstate, int errorno, char *error TSRMLS_DC) {
-	php_mysqli_throw_sql_exception(sqlstate, errorno TSRMLS_CC, "%s", error);
+/* {{{ void php_mysqli_report_error(char *sqlstate, int errorno, char *error) */
+void php_mysqli_report_error(const char *sqlstate, int errorno, const char *error TSRMLS_DC)
+{
+	php_mysqli_throw_sql_exception((char *)sqlstate, errorno TSRMLS_CC, "%s", error);
 }
 /* }}} */
 
-/* {{{ void php_mysqli_report_index() */ 
-void php_mysqli_report_index(char *query, unsigned int status TSRMLS_DC) {
+/* {{{ void php_mysqli_report_index() */
+void php_mysqli_report_index(const char *query, unsigned int status TSRMLS_DC) {
 	char index[15];
 
 	if (status & SERVER_QUERY_NO_GOOD_INDEX_USED) {
--- a/ext/mysqli/mysqli_report.h
+++ b/ext/mysqli/mysqli_report.h
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -15,7 +15,7 @@
   | Author: Georg Richter <georg@php.net>                                |
   +----------------------------------------------------------------------+
 
-  $Id: mysqli_report.h 293036 2010-01-03 09:23:27Z sebastian $
+  $Id$
 */
 
 #ifndef __HAVE_MYSQLI_PROFILER_H__
@@ -34,7 +34,7 @@
 #endif
 
 typedef struct {
-	struct timeval	starttime, 
+	struct timeval	starttime,
 					endtime;		/* execution time */
 } PR_TIME_INFO;
 
--- a/ext/mysqli/mysqli_warning.c
+++ b/ext/mysqli/mysqli_warning.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -25,84 +25,179 @@
 #include "php.h"
 #include "php_ini.h"
 #include "ext/standard/info.h"
-#include "php_mysqli.h"
+#include "php_mysqli_structs.h"
+#include "mysqli_priv.h"
 
+/* Define these in the PHP5 tree to make merging easy process */
+#define ZSTR_DUPLICATE (1<<0)
+#define ZSTR_AUTOFREE  (1<<1)
+
+#define ZVAL_UTF8_STRING(z, s, flags)          ZVAL_STRING((z), (char*)(s), ((flags) & ZSTR_DUPLICATE))
+#define ZVAL_UTF8_STRINGL(z, s, l, flags)      ZVAL_STRINGL((z), (char*)(s), (l), ((flags) & ZSTR_DUPLICATE))
+
+
 /* {{{ void php_clear_warnings() */
 void php_clear_warnings(MYSQLI_WARNING *w)
 {
-	MYSQLI_WARNING	*n;
+	MYSQLI_WARNING *n;
 
 	while (w) {
 		n = w;
-		efree(w->reason);
+		zval_dtor(&(w->reason));
+		zval_dtor(&(w->sqlstate));
 		w = w->next;
 		efree(n);
-	} 
+	}
 }
 /* }}} */
 
+
+#ifndef MYSQLI_USE_MYSQLND
 /* {{{ MYSQLI_WARNING *php_new_warning */
-MYSQLI_WARNING *php_new_warning(char *reason, char *sqlstate, int errorno)
+static
+MYSQLI_WARNING *php_new_warning(const char *reason, int errorno TSRMLS_DC)
 {
-	MYSQLI_WARNING	*w;
+	MYSQLI_WARNING *w;
 
 	w = (MYSQLI_WARNING *)ecalloc(1, sizeof(MYSQLI_WARNING));
 
-	w->reason = safe_estrdup(reason);
-	if (sqlstate) {
-		strcpy(w->sqlstate, sqlstate);
-	} else {
-		strcpy(w->sqlstate, "00000");
-	}
+	ZVAL_UTF8_STRING(&(w->reason), reason, ZSTR_DUPLICATE);
+
+	ZVAL_UTF8_STRINGL(&(w->sqlstate), "HY000", sizeof("HY000") - 1,  ZSTR_DUPLICATE);
+
 	w->errorno = errorno;
 
 	return w;
 }
 /* }}} */
 
-/* {{{ MYSQLI_WARNING *php_get_warnings(MYSQL *mysql) */
-MYSQLI_WARNING *php_get_warnings(MYSQL *mysql)
+
+/* {{{ MYSQLI_WARNING *php_get_warnings(MYSQL *mysql TSRMLS_DC) */
+MYSQLI_WARNING *php_get_warnings(MYSQL *mysql TSRMLS_DC)
 {
-	MYSQLI_WARNING	*w, *first = NULL, *prev = NULL;
+	MYSQLI_WARNING *w, *first = NULL, *prev = NULL;
 	MYSQL_RES		*result;
 	MYSQL_ROW 		row;
 
-	if (mysql_query(mysql, "SHOW WARNINGS")) {
+	if (mysql_real_query(mysql, "SHOW WARNINGS", 13)) {
 		return NULL;
 	}
 
 	result = mysql_store_result(mysql);
+
 	while ((row = mysql_fetch_row(result))) {
-		w = php_new_warning(row[2], "HY000", atoi(row[1]));
+		w = php_new_warning(row[2], atoi(row[1]) TSRMLS_CC);
 		if (!first) {
 			first = w;
 		}
 		if (prev) {
+			prev->next = w;
+		}
+		prev = w;
+	}
+	mysql_free_result(result);
+	return first;
+}
+/* }}} */
+#else
+/* {{{ MYSQLI_WARNING *php_new_warning */
+static
+MYSQLI_WARNING *php_new_warning(const zval *reason, int errorno TSRMLS_DC)
+{
+	MYSQLI_WARNING *w;
+
+	w = (MYSQLI_WARNING *)ecalloc(1, sizeof(MYSQLI_WARNING));
+
+	w->reason = *reason;
+	zval_copy_ctor(&(w->reason));
+
+	ZVAL_UTF8_STRINGL(&(w->reason),  Z_STRVAL(w->reason), Z_STRLEN(w->reason),  ZSTR_AUTOFREE);
+
+	ZVAL_UTF8_STRINGL(&(w->sqlstate), "HY000", sizeof("HY000") - 1,  ZSTR_DUPLICATE);
+
+	w->errorno = errorno;
+
+	return w;
+}
+/* }}} */
+
+
+/* {{{ MYSQLI_WARNING *php_get_warnings(MYSQL *mysql TSRMLS_DC) */
+MYSQLI_WARNING *php_get_warnings(MYSQL *mysql TSRMLS_DC)
+{
+	MYSQLI_WARNING	*w, *first = NULL, *prev = NULL;
+	MYSQL_RES		*result;
+	zval			*row;
+
+	if (mysql_real_query(mysql, "SHOW WARNINGS", 13)) {
+		return NULL;
+	}
+
+	result = mysql_use_result(mysql);
+
+	for (;;) {
+		zval **entry;
+		int errno;
+
+		MAKE_STD_ZVAL(row);
+		mysqlnd_fetch_into(result, MYSQLND_FETCH_NUM, row, MYSQLND_MYSQLI);
+		if (Z_TYPE_P(row) != IS_ARRAY) {
+			zval_ptr_dtor(&row);
+			break;
+		}
+		zend_hash_internal_pointer_reset(Z_ARRVAL_P(row));
+		/* 0. we don't care about the first */
+		zend_hash_move_forward(Z_ARRVAL_P(row));
+
+		/* 1. Here comes the error no */
+		zend_hash_get_current_data(Z_ARRVAL_P(row), (void **)&entry);
+		convert_to_long_ex(entry);
+		errno = Z_LVAL_PP(entry);
+		zend_hash_move_forward(Z_ARRVAL_P(row));
+
+		/* 2. Here comes the reason */
+		zend_hash_get_current_data(Z_ARRVAL_P(row), (void **)&entry);
+
+		w = php_new_warning(*entry, errno TSRMLS_CC);
+		/*
+		  Don't destroy entry, because the row destroy will decrease
+		  the refcounter. Decreased twice then mysqlnd_free_result()
+		  will crash, because it will try to access already freed memory.
+		*/
+		if (!first) {
+			first = w;
+		}
+		if (prev) {
 			prev->next = (void *)w;
 		}
 		prev = w;
+
+		zval_ptr_dtor(&row);
 	}
+
 	mysql_free_result(result);
 	return first;
 }
 /* }}} */
+#endif
 
+
 /* {{{ bool mysqli_warning::next() */
-PHP_METHOD(mysqli_warning, next) 
+PHP_METHOD(mysqli_warning, next)
 {
 	MYSQLI_WARNING 	*w;
 	zval  			*mysqli_warning;
 	mysqli_object *obj = (mysqli_object *)zend_objects_get_address(getThis() TSRMLS_CC);
 
 	if (obj->ptr) {
-		if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", 
+		if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O",
 										 &mysqli_warning, mysqli_warning_class_entry) == FAILURE) {
 			return;
 		}
 
 		MYSQLI_FETCH_RESOURCE(w, MYSQLI_WARNING *, &mysqli_warning, "mysqli_warning", MYSQLI_STATUS_VALID);
 
-		if (w->next) {
+		if (w && w->next) {
 			w = w->next;
 	        ((MYSQLI_RESOURCE *)(obj->ptr))->ptr = w;
 			RETURN_TRUE;
@@ -112,7 +207,9 @@
 }
 /* }}} */
 
+
 /* {{{ property mysqli_warning_message */
+static
 int mysqli_warning_message(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
 	MYSQLI_WARNING *w;
@@ -122,33 +219,35 @@
 	}
 
 	w = (MYSQLI_WARNING *)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
-	ALLOC_ZVAL(*retval);
-	if (w->reason) {
-		ZVAL_STRING(*retval, w->reason, 1);
-	} else {
-		ZVAL_NULL(*retval);
-	}
+	MAKE_STD_ZVAL(*retval);
+	**retval = w->reason;
+	zval_copy_ctor(*retval);
 	return SUCCESS;
 }
 /* }}} */
 
+
 /* {{{ property mysqli_warning_sqlstate */
+static
 int mysqli_warning_sqlstate(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
 	MYSQLI_WARNING *w;
-	
+
 	if (!obj->ptr || !((MYSQLI_RESOURCE *)(obj->ptr))->ptr) {
 		return FAILURE;
 	}
 
 	w = (MYSQLI_WARNING *)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
-	ALLOC_ZVAL(*retval);
-	ZVAL_STRING(*retval, w->sqlstate, 1);
+	MAKE_STD_ZVAL(*retval);
+	**retval = w->sqlstate;
+	zval_copy_ctor(*retval);
 	return SUCCESS;
 }
 /* }}} */
 
+
 /* {{{ property mysqli_warning_error */
+static
 int mysqli_warning_errno(mysqli_object *obj, zval **retval TSRMLS_DC)
 {
 	MYSQLI_WARNING *w;
@@ -157,7 +256,7 @@
 		return FAILURE;
 	}
 	w = (MYSQLI_WARNING *)((MYSQLI_RESOURCE *)(obj->ptr))->ptr;
-	ALLOC_ZVAL(*retval);
+	MAKE_STD_ZVAL(*retval);
 	ZVAL_LONG(*retval, w->errorno);
 	return SUCCESS;
 }
@@ -182,28 +281,30 @@
 
 	if (obj->zo.ce == mysqli_link_class_entry) {
 		MY_MYSQL *mysql;
-		MYSQLI_FETCH_RESOURCE(mysql, MY_MYSQL *, &z, "mysqli_link", MYSQLI_STATUS_VALID);
+		MYSQLI_FETCH_RESOURCE_CONN(mysql, &z, MYSQLI_STATUS_VALID);
 		hdl = mysql->mysql;
 	} else if (obj->zo.ce == mysqli_stmt_class_entry) {
 		MY_STMT *stmt;
-		MYSQLI_FETCH_RESOURCE(stmt, MY_STMT *, &z, "mysqli_stmt", MYSQLI_STATUS_VALID);
-		hdl = stmt->stmt->mysql;
+		MYSQLI_FETCH_RESOURCE_STMT(stmt, &z, MYSQLI_STATUS_VALID);
+		hdl = mysqli_stmt_get_connection(stmt->stmt);
 	} else {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "invalid class argument");
 		RETURN_FALSE;
 	}
 
 	if (mysql_warning_count(hdl)) {
-		w = php_get_warnings(hdl); 
+		w = php_get_warnings(hdl TSRMLS_CC);
 	} else {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "No warnings found");
 		RETURN_FALSE;
 	}
 
 	mysqli_resource = (MYSQLI_RESOURCE *)ecalloc (1, sizeof(MYSQLI_RESOURCE));
-	mysqli_resource->status = MYSQLI_STATUS_VALID;
 	mysqli_resource->ptr = mysqli_resource->info = (void *)w;
+	mysqli_resource->status = MYSQLI_STATUS_VALID;
 
 	if (!getThis() || !instanceof_function(Z_OBJCE_P(getThis()), mysqli_warning_class_entry TSRMLS_CC)) {
-		MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_warning_class_entry);	
+		MYSQLI_RETURN_RESOURCE(mysqli_resource, mysqli_warning_class_entry);
 	} else {
 		((mysqli_object *) zend_object_store_get_object(getThis() TSRMLS_CC))->ptr = mysqli_resource;
 	}
@@ -211,18 +312,32 @@
 }
 /* }}} */
 
-zend_function_entry mysqli_warning_methods[] = {
+/* {{{ mysqli_warning_methods */
+const zend_function_entry mysqli_warning_methods[] = {
 	PHP_ME(mysqli_warning, __construct,		NULL, ZEND_ACC_PROTECTED)
 	PHP_ME(mysqli_warning, next, 			NULL, ZEND_ACC_PUBLIC)
 	{NULL, NULL, NULL}
 };
+/* }}} */
 
-mysqli_property_entry mysqli_warning_property_entries[] = {
-	{"message", mysqli_warning_message, NULL},
-	{"sqlstate", mysqli_warning_sqlstate, NULL},
-	{"errno", mysqli_warning_errno, NULL},
-	{NULL, NULL, NULL}
+/* {{{ mysqli_warning_property_entries */
+const mysqli_property_entry mysqli_warning_property_entries[] = {
+	{"message", sizeof("message") - 1, mysqli_warning_message, NULL},
+	{"sqlstate", sizeof("sqlstate") - 1, mysqli_warning_sqlstate, NULL},
+	{"errno", sizeof("errno") - 1, mysqli_warning_errno, NULL},
+	{NULL, 0, NULL, NULL}
 };
+/* }}} */
+
+/* {{{ mysqli_warning_property_info_entries */
+zend_property_info mysqli_warning_property_info_entries[] = {
+	{ZEND_ACC_PUBLIC, "message", 	sizeof("message") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "sqlstate",	sizeof("sqlstate") - 1,	0, NULL, 0, NULL},
+	{ZEND_ACC_PUBLIC, "errno",		sizeof("errno") - 1, 	0, NULL, 0, NULL},
+	{0,					NULL, 			0,					0, NULL, 0, NULL}
+};
+/* }}} */
+
 
 /*
  * Local variables:
--- a/ext/mysqli/php_mysqli.h
+++ b/ext/mysqli/php_mysqli.h
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -12,473 +12,21 @@
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
-  | Author: Georg Richter <georg@php.net>                                |
+  | Authors: Georg Richter <georg@php.net>                               |
+  |          Andrey Hristov <andrey@php.net>                             |
+  |          Ulf Wendel <uw@php.net>                                     |
   +----------------------------------------------------------------------+
 
-  $Id: php_mysqli.h 293976 2010-01-25 13:23:32Z andrey $ 
+  $Id$
 */
 
-/* A little hack to prevent build break, when mysql is used together with
- * c-client, which also defines LIST.
- */
-#ifdef LIST
-#undef LIST
-#endif
-
-#include <mysql.h>
-
-/* character set support */
-#if MYSQL_VERSION_ID > 50009
-#define HAVE_MYSQLI_GET_CHARSET
-#endif
-
-#if (MYSQL_VERSION_ID > 40112 && MYSQL_VERSION_ID < 50000) || MYSQL_VERSION_ID > 50005
-#define HAVE_MYSQLI_SET_CHARSET
-#endif
-
-
-#include <errmsg.h>
-
 #ifndef PHP_MYSQLI_H
 #define PHP_MYSQLI_H
 
-#define MYSQLI_VERSION_ID		101009
-
-enum mysqli_status {
-	MYSQLI_STATUS_UNKNOWN=0,
-	MYSQLI_STATUS_CLEARED,
-	MYSQLI_STATUS_INITIALIZED,
-	MYSQLI_STATUS_VALID
-};
-
-typedef struct {
-        char            *val;
-	ulong		buflen;
-        ulong           output_len;
-	ulong		type;
-} VAR_BUFFER;
-
-typedef struct {
-	unsigned int	var_cnt;
-	VAR_BUFFER		*buf;
-	zval			**vars;
-	char			*is_null;
-} BIND_BUFFER;
-
-typedef struct {
-	MYSQL_STMT			*stmt;
-	BIND_BUFFER			param;
-	BIND_BUFFER			result;
-	char				*query;
-} MY_STMT;
-
-typedef struct {
-	MYSQL				*mysql;
-	zval				*li_read;
-	php_stream			*li_stream;
-	unsigned int 		multi_query;	
-} MY_MYSQL;
-
-typedef struct {
-	int			mode;
-	int			socket;
-	FILE		*fp;
-} PROFILER;
-
-typedef struct {
-	void				*ptr;		/* resource: (mysql, result, stmt)   */
-	void				*info;		/* additional buffer				 */
-    enum mysqli_status	status;
-} MYSQLI_RESOURCE;
-
-typedef struct _mysqli_object {
-	zend_object 		zo;
-	void 				*ptr;
-	HashTable 			*prop_handler;
-} mysqli_object; /* extends zend_object */
-
-typedef struct {
-	char			*reason;
-	char			sqlstate[6];
-	int				errorno;
-   	void			*next;
-} MYSQLI_WARNING;
-
-typedef struct _mysqli_property_entry {
-	char *pname;
-	int (*r_func)(mysqli_object *obj, zval **retval TSRMLS_DC);
-	int (*w_func)(mysqli_object *obj, zval *value TSRMLS_DC);
-} mysqli_property_entry;
-
-typedef struct {
-	char	error_msg[LOCAL_INFILE_ERROR_LEN];
-	void	*userdata;
-} mysqli_local_infile;
-
 #define phpext_mysqli_ptr &mysqli_module_entry
-
-#ifdef PHP_WIN32
-#define PHP_MYSQLI_API __declspec(dllexport)
-#define MYSQLI_LLU_SPEC "%I64u"
-#define MYSQLI_LL_SPEC "%I64d"
-#else
-#define PHP_MYSQLI_API
-#define MYSQLI_LLU_SPEC "%llu"
-#define MYSQLI_LL_SPEC "%lld"
-#endif
-
-#ifdef ZTS
-#include "TSRM.h"
-#endif
-
-#define PHP_MYSQLI_EXPORT(__type) PHP_MYSQLI_API __type
-
 extern zend_module_entry mysqli_module_entry;
-extern zend_function_entry mysqli_functions[];
-extern zend_function_entry mysqli_link_methods[];
-extern zend_function_entry mysqli_stmt_methods[];
-extern zend_function_entry mysqli_result_methods[];
-extern zend_function_entry mysqli_driver_methods[];
-extern zend_function_entry mysqli_warning_methods[];
-extern zend_function_entry mysqli_exception_methods[];
 
-extern mysqli_property_entry mysqli_link_property_entries[];
-extern mysqli_property_entry mysqli_result_property_entries[];
-extern mysqli_property_entry mysqli_stmt_property_entries[];
-extern mysqli_property_entry mysqli_driver_property_entries[];
-extern mysqli_property_entry mysqli_warning_property_entries[];
-
-extern void php_mysqli_fetch_into_hash(INTERNAL_FUNCTION_PARAMETERS, int override_flag, int into_object);
-extern void php_clear_stmt_bind(MY_STMT *stmt);
-extern void php_clear_mysql(MY_MYSQL *);
-extern MYSQLI_WARNING *php_get_warnings(MYSQL *mysql);
-extern void php_clear_warnings(MYSQLI_WARNING *w);
-extern void php_free_stmt_bind_buffer(BIND_BUFFER bbuf, int type);
-extern void php_mysqli_report_error(char *sqlstate, int errorno, char *error TSRMLS_DC);
-extern void php_mysqli_report_index(char *query, unsigned int status TSRMLS_DC);
-extern int php_local_infile_init(void **, const char *, void *);
-extern int php_local_infile_read(void *, char *, uint);
-extern void php_local_infile_end(void *);
-extern int php_local_infile_error(void *, char *, uint);
-extern void php_set_local_infile_handler_default(MY_MYSQL *);
-extern void php_mysqli_throw_sql_exception(char *sqlstate, int errorno TSRMLS_DC, char *format, ...);
-extern zend_class_entry *mysqli_link_class_entry;
-extern zend_class_entry *mysqli_stmt_class_entry;
-extern zend_class_entry *mysqli_result_class_entry;
-extern zend_class_entry *mysqli_driver_class_entry;
-extern zend_class_entry *mysqli_warning_class_entry;
-extern zend_class_entry *mysqli_exception_class_entry;
-
-#ifdef HAVE_SPL
-extern PHPAPI zend_class_entry *spl_ce_RuntimeException;
-#endif
-
-PHP_MYSQLI_EXPORT(zend_object_value) mysqli_objects_new(zend_class_entry * TSRMLS_DC);
-
-#define MYSQLI_DISABLE_MQ if (mysql->multi_query) { \
-	mysql_set_server_option(mysql->mysql, MYSQL_OPTION_MULTI_STATEMENTS_OFF); \
-	mysql->multi_query = 0; \
-} 
-
-#define MYSQLI_ENABLE_MQ if (!mysql->multi_query) { \
-	mysql_set_server_option(mysql->mysql, MYSQL_OPTION_MULTI_STATEMENTS_ON); \
-	mysql->multi_query = 1; \
-} 
-
-#define REGISTER_MYSQLI_CLASS_ENTRY(name, mysqli_entry, class_functions) { \
-	zend_class_entry ce; \
-	INIT_CLASS_ENTRY(ce, name,class_functions); \
-	ce.create_object = mysqli_objects_new; \
-	mysqli_entry = zend_register_internal_class(&ce TSRMLS_CC); \
-} \
-
-#define MYSQLI_REGISTER_RESOURCE_EX(__ptr, __zval)  \
-	((mysqli_object *) zend_object_store_get_object(__zval TSRMLS_CC))->ptr = __ptr; \
-
-#define MYSQLI_RETURN_RESOURCE(__ptr, __ce) \
-	Z_TYPE_P(return_value) = IS_OBJECT; \
-	(return_value)->value.obj = mysqli_objects_new(__ce TSRMLS_CC); \
-	MYSQLI_REGISTER_RESOURCE_EX(__ptr, return_value)
-
-#define MYSQLI_REGISTER_RESOURCE(__ptr, __ce) \
-{\
-	zval *object = getThis();\
-	if (!object || !instanceof_function(Z_OBJCE_P(object), mysqli_link_class_entry TSRMLS_CC)) {\
-		object = return_value;\
-		Z_TYPE_P(object) = IS_OBJECT;\
-		(object)->value.obj = mysqli_objects_new(__ce TSRMLS_CC);\
-	}\
-	MYSQLI_REGISTER_RESOURCE_EX(__ptr, object)\
-}
-
-#define MYSQLI_FETCH_RESOURCE(__ptr, __type, __id, __name, __check) \
-{ \
-	MYSQLI_RESOURCE *my_res; \
-	mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
-	if (!(my_res = (MYSQLI_RESOURCE *)intern->ptr)) {\
-  		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Couldn't fetch %s", intern->zo.ce->name);\
-  		RETURN_NULL();\
-  	}\
-	__ptr = (__type)my_res->ptr; \
-	if (__check && my_res->status < __check) { \
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "invalid object or resource %s\n", intern->zo.ce->name); \
-		RETURN_NULL();\
-	}\
-} 
-
-#define MYSQLI_SET_STATUS(__id, __value) \
-{ \
-	mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
-	((MYSQLI_RESOURCE *)intern->ptr)->status = __value; \
-} \
-
-#define MYSQLI_CLEAR_RESOURCE(__id) \
-{ \
-	mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
-	efree(intern->ptr); \
-	intern->ptr = NULL; \
-}
-
-#define MYSQLI_RETURN_LONG_LONG(__val) \
-{ \
-	if ((__val) < LONG_MAX) {		\
-		RETURN_LONG((long) (__val));		\
-	} else {				\
-		char *ret;			\
-		/* always used with my_ulonglong -> %llu */ \
-		int l = spprintf(&ret, 0, "%llu", (__val));	\
-		RETURN_STRINGL(ret, l, 0);		\
-	}					\
-}
-
-#define MYSQLI_ADD_PROPERTIES(a,b) \
-{ \
-	int i = 0; \
-	while (b[i].pname != NULL) { \
-		mysqli_add_property(a, b[i].pname, (mysqli_read_t)b[i].r_func, (mysqli_write_t)b[i].w_func TSRMLS_CC); \
-		i++; \
-	}\
-}
-
-#if WIN32|WINNT
-#define SCLOSE(a) closesocket(a)
-#else
-#define SCLOSE(a) close(a)
-#endif
-
-#define MYSQLI_STORE_RESULT 0
-#define MYSQLI_USE_RESULT 	1
-
-/* for mysqli_fetch_assoc */
-#define MYSQLI_ASSOC	1
-#define MYSQLI_NUM		2
-#define MYSQLI_BOTH		3
-
-/* for mysqli_bind_param */
-#define MYSQLI_BIND_INT		1
-#define MYSQLI_BIND_DOUBLE	2
-#define MYSQLI_BIND_STRING	3
-#define MYSQLI_BIND_SEND_DATA	4
-
-/* fetch types */
-#define FETCH_SIMPLE		1
-#define FETCH_RESULT		2
-
-/*** REPORT MODES ***/
-#define MYSQLI_REPORT_OFF           0
-#define MYSQLI_REPORT_ERROR			1
-#define MYSQLI_REPORT_STRICT		2
-#define MYSQLI_REPORT_INDEX			4
-#define MYSQLI_REPORT_CLOSE			8	
-#define MYSQLI_REPORT_ALL		  255
-
-#define MYSQLI_REPORT_MYSQL_ERROR(mysql) \
-if ((MyG(report_mode) & MYSQLI_REPORT_ERROR) && mysql->net.last_errno) { \
-	php_mysqli_report_error(mysql->net.sqlstate, mysql->net.last_errno, mysql->net.last_error TSRMLS_CC); \
-}
-
-#define MYSQLI_REPORT_STMT_ERROR(stmt) \
-if ((MyG(report_mode) & MYSQLI_REPORT_ERROR) && stmt->last_errno) { \
-	php_mysqli_report_error(stmt->sqlstate, stmt->last_errno, stmt->last_error TSRMLS_CC); \
-}
-
-#if MYSQL_VERSION_ID > 32300 && MYSQL_VERSION_ID < 50500
-#define HAVE_LIBMYSQL_REPLICATION
-#endif
-
-
-PHP_MYSQLI_API void mysqli_register_link(zval *return_value, void *link TSRMLS_DC);
-PHP_MYSQLI_API void mysqli_register_stmt(zval *return_value, void *stmt TSRMLS_DC);
-PHP_MYSQLI_API void mysqli_register_result(zval *return_value, void *result TSRMLS_DC);
-PHP_MYSQLI_API void php_mysqli_set_error(long mysql_errno, char *mysql_err TSRMLS_DC);
-
-void php_mysqli_init(INTERNAL_FUNCTION_PARAMETERS);
-
-PHP_MINIT_FUNCTION(mysqli);
-PHP_MSHUTDOWN_FUNCTION(mysqli);
-PHP_RINIT_FUNCTION(mysqli);
-PHP_RSHUTDOWN_FUNCTION(mysqli);
-PHP_MINFO_FUNCTION(mysqli);
-
-PHP_FUNCTION(mysqli);
-PHP_FUNCTION(mysqli_affected_rows);
-PHP_FUNCTION(mysqli_autocommit);
-PHP_FUNCTION(mysqli_change_user);
-PHP_FUNCTION(mysqli_character_set_name);
-#ifdef HAVE_MYSQLI_SET_CHARSET
-PHP_FUNCTION(mysqli_set_charset);
-#endif
-PHP_FUNCTION(mysqli_close);
-PHP_FUNCTION(mysqli_commit);
-PHP_FUNCTION(mysqli_connect);
-PHP_FUNCTION(mysqli_connect_errno);
-PHP_FUNCTION(mysqli_connect_error);
-PHP_FUNCTION(mysqli_data_seek);
-PHP_FUNCTION(mysqli_debug);
-PHP_FUNCTION(mysqli_disable_reads_from_master);
-PHP_FUNCTION(mysqli_disable_rpl_parse);
-PHP_FUNCTION(mysqli_dump_debug_info);
-PHP_FUNCTION(mysqli_enable_reads_from_master);
-PHP_FUNCTION(mysqli_enable_rpl_parse);
-PHP_FUNCTION(mysqli_errno);
-PHP_FUNCTION(mysqli_error);
-PHP_FUNCTION(mysqli_fetch_array);
-PHP_FUNCTION(mysqli_fetch_assoc);
-PHP_FUNCTION(mysqli_fetch_object);
-PHP_FUNCTION(mysqli_fetch_field);
-PHP_FUNCTION(mysqli_fetch_fields);
-PHP_FUNCTION(mysqli_fetch_field_direct);
-PHP_FUNCTION(mysqli_fetch_lengths);
-PHP_FUNCTION(mysqli_fetch_row);
-PHP_FUNCTION(mysqli_field_count);
-PHP_FUNCTION(mysqli_field_seek);
-PHP_FUNCTION(mysqli_field_tell);
-PHP_FUNCTION(mysqli_free_result);
-#ifdef HAVE_MYSQLI_GET_CHARSET 
-PHP_FUNCTION(mysqli_get_charset);
-#endif
-PHP_FUNCTION(mysqli_get_client_info);
-PHP_FUNCTION(mysqli_get_client_version);
-PHP_FUNCTION(mysqli_get_host_info);
-PHP_FUNCTION(mysqli_get_proto_info);
-PHP_FUNCTION(mysqli_get_server_info);
-PHP_FUNCTION(mysqli_get_server_version);
-PHP_FUNCTION(mysqli_get_warnings);
-PHP_FUNCTION(mysqli_info);
-PHP_FUNCTION(mysqli_insert_id);
-PHP_FUNCTION(mysqli_init);
-PHP_FUNCTION(mysqli_kill);
-PHP_FUNCTION(mysqli_set_local_infile_default);
-PHP_FUNCTION(mysqli_set_local_infile_handler);
-PHP_FUNCTION(mysqli_master_query);
-PHP_FUNCTION(mysqli_more_results);
-PHP_FUNCTION(mysqli_multi_query);
-PHP_FUNCTION(mysqli_next_result);
-PHP_FUNCTION(mysqli_num_fields);
-PHP_FUNCTION(mysqli_num_rows);
-PHP_FUNCTION(mysqli_options);
-PHP_FUNCTION(mysqli_ping);
-PHP_FUNCTION(mysqli_prepare);
-PHP_FUNCTION(mysqli_query);
-PHP_FUNCTION(mysqli_stmt_result_metadata);
-PHP_FUNCTION(mysqli_report);
-PHP_FUNCTION(mysqli_read_query_result);
-PHP_FUNCTION(mysqli_real_connect);
-PHP_FUNCTION(mysqli_real_query);
-PHP_FUNCTION(mysqli_real_escape_string);
-PHP_FUNCTION(mysqli_rollback);
-PHP_FUNCTION(mysqli_row_seek);
-PHP_FUNCTION(mysqli_rpl_parse_enabled);
-PHP_FUNCTION(mysqli_rpl_probe);
-PHP_FUNCTION(mysqli_rpl_query_type);
-PHP_FUNCTION(mysqli_select_db);
-PHP_FUNCTION(mysqli_stmt_attr_get);
-PHP_FUNCTION(mysqli_stmt_attr_set);
-PHP_FUNCTION(mysqli_stmt_bind_param);
-PHP_FUNCTION(mysqli_stmt_bind_result);
-PHP_FUNCTION(mysqli_stmt_execute);
-PHP_FUNCTION(mysqli_stmt_field_count);
-PHP_FUNCTION(mysqli_stmt_init);
-PHP_FUNCTION(mysqli_stmt_prepare);
-PHP_FUNCTION(mysqli_stmt_fetch);
-PHP_FUNCTION(mysqli_stmt_param_count);
-PHP_FUNCTION(mysqli_stmt_send_long_data);
-PHP_FUNCTION(mysqli_send_query);
-PHP_FUNCTION(mysqli_embedded_server_end);
-PHP_FUNCTION(mysqli_embedded_server_start);
-PHP_FUNCTION(mysqli_slave_query);
-PHP_FUNCTION(mysqli_sqlstate);
-PHP_FUNCTION(mysqli_ssl_set);
-PHP_FUNCTION(mysqli_stat);
-PHP_FUNCTION(mysqli_stmt_affected_rows);
-PHP_FUNCTION(mysqli_stmt_close);
-PHP_FUNCTION(mysqli_stmt_data_seek);
-PHP_FUNCTION(mysqli_stmt_errno);
-PHP_FUNCTION(mysqli_stmt_error);
-PHP_FUNCTION(mysqli_stmt_free_result);
-PHP_FUNCTION(mysqli_stmt_get_warnings);
-PHP_FUNCTION(mysqli_stmt_reset);
-PHP_FUNCTION(mysqli_stmt_insert_id);
-PHP_FUNCTION(mysqli_stmt_num_rows);
-PHP_FUNCTION(mysqli_stmt_sqlstate);
-PHP_FUNCTION(mysqli_stmt_store_result);
-PHP_FUNCTION(mysqli_store_result);
-PHP_FUNCTION(mysqli_thread_id);
-PHP_FUNCTION(mysqli_thread_safe);
-PHP_FUNCTION(mysqli_use_result);
-PHP_FUNCTION(mysqli_warning_count);
-
-ZEND_FUNCTION(mysqli_stmt_construct);
-ZEND_FUNCTION(mysqli_result_construct);
-ZEND_FUNCTION(mysqli_driver_construct);
-ZEND_METHOD(mysqli_warning,__construct);
-
-ZEND_BEGIN_MODULE_GLOBALS(mysqli)
-	long			default_link;
-	long			num_links;
-	long			max_links;
-	unsigned int	default_port;
-	char			*default_host;
-	char			*default_user;
-	char			*default_socket;
-	char            *default_pw;
-	int				reconnect;
-	int				strict;
-	long			error_no;
-	char			*error_msg;
-	int				report_mode;
-	HashTable		*report_ht;
-	unsigned int	multi_query;
-	unsigned int	embedded;
-ZEND_END_MODULE_GLOBALS(mysqli)
-
-
-#define MYSQLI_PROPERTY(a) extern int a(mysqli_object *obj, zval **retval TSRMLS_DC)
-
-MYSQLI_PROPERTY(my_prop_link_host);
-
-#ifdef ZTS
-#define MyG(v) TSRMG(mysqli_globals_id, zend_mysqli_globals *, v)
-#else
-#define MyG(v) (mysqli_globals.v)
-#endif
-
-#define my_estrdup(x) (x) ? estrdup(x) : NULL
-#define my_efree(x) if (x) efree(x)
-
-#ifdef PHP_WIN32
-#define L64(x) x##i64
-typedef __int64 my_longlong;
-#else
-#define L64(x) x##LL
-typedef long long my_longlong;
-#endif
-
-
-ZEND_EXTERN_MODULE_GLOBALS(mysqli)
-
 #endif	/* PHP_MYSQLI.H */
-
 
 /*
  * Local variables:
--- /dev/null
+++ b/ext/mysqli/php_mysqli_structs.h
@@ -0,0 +1,328 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 1997-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Author: Georg Richter <georg@php.net>                                |
+  +----------------------------------------------------------------------+
+
+  $Id$
+*/
+
+#ifndef PHP_MYSQLI_STRUCTS_H
+#define PHP_MYSQLI_STRUCTS_H
+
+/* A little hack to prevent build break, when mysql is used together with
+ * c-client, which also defines LIST.
+ */
+#ifdef LIST
+#undef LIST
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifdef MYSQLI_USE_MYSQLND
+#include "ext/mysqlnd/mysqlnd.h"
+#include "mysqli_mysqlnd.h"
+#else
+
+/*
+  The libmysql headers (a PITA) also define it and there will be an warning.
+  Undef it and later we might need to define it again.
+*/
+#ifdef HAVE_MBRLEN
+#undef HAVE_MBRLEN
+#define WE_HAD_MBRLEN
+#endif
+#ifdef HAVE_MBSTATE_T
+#undef HAVE_MBSTATE_T
+#define WE_HAD_MBSTATE_T
+#endif
+
+#if defined(ulong) && !defined(HAVE_ULONG)
+#define HAVE_ULONG
+#endif
+
+#include <my_global.h>
+
+#if !defined(HAVE_MBRLEN) && defined(WE_HAD_MBRLEN)
+#define HAVE_MBRLEN 1
+#endif
+
+#if !defined(HAVE_MBSTATE_T) && defined(WE_HAD_MBSTATE_T)
+#define HAVE_MBSTATE_T 1
+#endif
+
+/*
+  We need more than mysql.h because we need CHARSET_INFO in one place.
+  This order has been borrowed from the ODBC driver. Nothing can be removed
+  from the list of headers :(
+*/
+
+#include <my_sys.h>
+#include <mysql.h>
+#include <errmsg.h>
+#include <my_list.h>
+#include <m_string.h>
+#include <mysqld_error.h>
+#include <my_list.h>
+#include <m_ctype.h>
+#include "mysqli_libmysql.h"
+#endif /* MYSQLI_USE_MYSQLND */
+
+
+#define MYSQLI_VERSION_ID		101009
+
+enum mysqli_status {
+	MYSQLI_STATUS_UNKNOWN=0,
+	MYSQLI_STATUS_CLEARED,
+	MYSQLI_STATUS_INITIALIZED,
+	MYSQLI_STATUS_VALID
+};
+
+typedef struct {
+	char		*val;
+	ulong		buflen;
+	ulong		output_len;
+	ulong		type;
+} VAR_BUFFER;
+
+typedef struct {
+	unsigned int	var_cnt;
+	VAR_BUFFER		*buf;
+	zval			**vars;
+	char			*is_null;
+} BIND_BUFFER;
+
+typedef struct {
+	MYSQL_STMT	*stmt;
+	BIND_BUFFER	param;
+	BIND_BUFFER	result;
+	char		*query;
+} MY_STMT;
+
+typedef struct {
+	MYSQL			*mysql;
+	char			*hash_key;
+	zval			*li_read;
+	php_stream		*li_stream;
+	unsigned int 	multi_query;
+	zend_bool		persistent;
+#if defined(MYSQLI_USE_MYSQLND)
+	int				async_result_fetch_type;
+#endif
+} MY_MYSQL;
+
+typedef struct {
+	int			mode;
+	int			socket;
+	FILE		*fp;
+} PROFILER;
+
+typedef struct {
+	void				*ptr;		/* resource: (mysql, result, stmt)   */
+	void				*info;		/* additional buffer				 */
+	enum mysqli_status	status;		/* object status */
+} MYSQLI_RESOURCE;
+
+typedef struct _mysqli_object {
+	zend_object 		zo;
+	void 				*ptr;
+	HashTable 			*prop_handler;
+} mysqli_object; /* extends zend_object */
+
+typedef struct st_mysqli_warning MYSQLI_WARNING;
+
+struct st_mysqli_warning {
+	zval	reason;
+	zval	sqlstate;
+	int		errorno;
+   	MYSQLI_WARNING	*next;
+};
+
+typedef struct _mysqli_property_entry {
+	const char *pname;
+	size_t pname_length;
+	int (*r_func)(mysqli_object *obj, zval **retval TSRMLS_DC);
+	int (*w_func)(mysqli_object *obj, zval *value TSRMLS_DC);
+} mysqli_property_entry;
+
+#if !defined(MYSQLI_USE_MYSQLND)
+typedef struct {
+	char	error_msg[LOCAL_INFILE_ERROR_LEN];
+  	void	*userdata;
+} mysqli_local_infile;
+#endif
+
+typedef struct {
+	zend_ptr_stack free_links;
+} mysqli_plist_entry;
+
+#ifdef PHP_WIN32
+#define PHP_MYSQLI_API __declspec(dllexport)
+#define MYSQLI_LLU_SPEC "%I64u"
+#define MYSQLI_LL_SPEC "%I64d"
+#ifndef L64
+#define L64(x) x##i64
+#endif
+typedef __int64 my_longlong;
+#else
+# if defined(__GNUC__) && __GNUC__ >= 4
+#  define PHP_MYSQLI_API __attribute__ ((visibility("default")))
+# else
+#  define PHP_MYSQLI_API
+# endif
+/* we need this for PRIu64 and PRId64 */
+#include <inttypes.h>
+#define MYSQLI_LLU_SPEC "%" PRIu64
+#define MYSQLI_LL_SPEC "%" PRId64
+#ifndef L64
+#define L64(x) x##LL
+#endif
+typedef int64_t my_longlong;
+#endif
+
+#ifdef ZTS
+#include "TSRM.h"
+#endif
+
+extern zend_class_entry *mysqli_link_class_entry;
+extern zend_class_entry *mysqli_stmt_class_entry;
+extern zend_class_entry *mysqli_result_class_entry;
+extern zend_class_entry *mysqli_driver_class_entry;
+extern zend_class_entry *mysqli_warning_class_entry;
+extern zend_class_entry *mysqli_exception_class_entry;
+
+#define MYSQLI_REGISTER_RESOURCE_EX(__ptr, __zval)  \
+	((mysqli_object *) zend_object_store_get_object(__zval TSRMLS_CC))->ptr = __ptr;
+
+#define MYSQLI_RETURN_RESOURCE(__ptr, __ce) \
+	Z_TYPE_P(return_value) = IS_OBJECT; \
+	(return_value)->value.obj = mysqli_objects_new(__ce TSRMLS_CC); \
+	MYSQLI_REGISTER_RESOURCE_EX(__ptr, return_value)
+
+#define MYSQLI_REGISTER_RESOURCE(__ptr, __ce) \
+{\
+	zval *object = getThis();\
+	if (!object || !instanceof_function(Z_OBJCE_P(object), mysqli_link_class_entry TSRMLS_CC)) {\
+		object = return_value;\
+		Z_TYPE_P(object) = IS_OBJECT;\
+		(object)->value.obj = mysqli_objects_new(__ce TSRMLS_CC);\
+	}\
+	MYSQLI_REGISTER_RESOURCE_EX(__ptr, object)\
+}
+
+#define MYSQLI_FETCH_RESOURCE(__ptr, __type, __id, __name, __check) \
+{ \
+	MYSQLI_RESOURCE *my_res; \
+	mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
+	if (!(my_res = (MYSQLI_RESOURCE *)intern->ptr)) {\
+  		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Couldn't fetch %s", intern->zo.ce->name);\
+  		RETURN_NULL();\
+  	}\
+	__ptr = (__type)my_res->ptr; \
+	if (__check && my_res->status < __check) { \
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "invalid object or resource %s\n", intern->zo.ce->name); \
+		RETURN_NULL();\
+	}\
+}
+
+#define MYSQLI_FETCH_RESOURCE_CONN(__ptr, __id, __check) \
+{ \
+	MYSQLI_FETCH_RESOURCE((__ptr), MY_MYSQL *, (__id), "mysqli_link", (__check)); \
+	if (!(__ptr)->mysql) { \
+		mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "invalid object or resource %s\n", intern->zo.ce->name); \
+		RETURN_NULL();\
+	} \
+}
+
+#define MYSQLI_FETCH_RESOURCE_STMT(__ptr, __id, __check) \
+{ \
+	MYSQLI_FETCH_RESOURCE((__ptr), MY_STMT *, (__id), "mysqli_stmt", (__check)); \
+	if (!(__ptr)->stmt) { \
+		mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "invalid object or resource %s\n", intern->zo.ce->name); \
+		RETURN_NULL();\
+	} \
+}
+
+
+#define MYSQLI_SET_STATUS(__id, __value) \
+{ \
+	mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
+	((MYSQLI_RESOURCE *)intern->ptr)->status = __value; \
+} \
+
+#define MYSQLI_CLEAR_RESOURCE(__id) \
+{ \
+	mysqli_object *intern = (mysqli_object *)zend_object_store_get_object(*(__id) TSRMLS_CC);\
+	efree(intern->ptr); \
+	intern->ptr = NULL; \
+}
+
+
+ZEND_BEGIN_MODULE_GLOBALS(mysqli)
+	long			default_link;
+	long			num_links;
+	long			max_links;
+	long 			num_active_persistent;
+	long 			num_inactive_persistent;
+	long			max_persistent;
+	long			allow_persistent;
+	long			cache_size;
+	unsigned long	default_port;
+	char			*default_host;
+	char			*default_user;
+	char			*default_socket;
+	char			*default_pw;
+	long			reconnect;
+	long			allow_local_infile;
+	long			strict;
+	long			error_no;
+	char			*error_msg;
+	long			report_mode;
+	HashTable		*report_ht;
+	unsigned long	multi_query;
+	unsigned long	embedded;
+ZEND_END_MODULE_GLOBALS(mysqli)
+
+
+#ifdef ZTS
+#define MyG(v) TSRMG(mysqli_globals_id, zend_mysqli_globals *, v)
+#else
+#define MyG(v) (mysqli_globals.v)
+#endif
+
+#define my_estrdup(x) (x) ? estrdup(x) : NULL
+#define my_efree(x) if (x) efree(x)
+
+ZEND_EXTERN_MODULE_GLOBALS(mysqli)
+
+#endif	/* PHP_MYSQLI_STRUCTS.H */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * indent-tabs-mode: t
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- a/ext/mysqli/tests/001.phpt
+++ b/ext/mysqli/tests/001.phpt
@@ -1,47 +1,63 @@
 --TEST--
 mysqli connect
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$dbname = "test";
 	$test = "";
 
 	/*** test mysqli_connect localhost:port ***/
-	$link = mysqli_connect($host, $user, $passwd, "", 3306);
+	$link = my_mysqli_connect($host, $user, $passwd, "", $port, $socket);
 	$test .= ($link) ? "1" : "0";
 	mysqli_close($link);
 
 	/*** test mysqli_real_connect ***/
-	$link = mysqli_init();	
-	$test.= (mysqli_real_connect($link, $host, $user, $passwd)) 
+	$link = mysqli_init();
+	$test.= (my_mysqli_real_connect($link, $host, $user, $passwd, "", $port, $socket) )
 		? "1" : "0";
 	mysqli_close($link);
 
 	/*** test mysqli_real_connect with db ***/
-	$link = mysqli_init();	
-	$test .= (mysqli_real_connect($link, $host, $user, $passwd, $dbname)) 
+	$link = mysqli_init();
+	$test .= (my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
 		? "1" : "0";
 	mysqli_close($link);
 
 	/*** test mysqli_real_connect with port ***/
-	$link = mysqli_init();	
-	$test .= (mysqli_real_connect($link, $host, $user, $passwd, $dbname, 3306))
+	$link = mysqli_init();
+	$test .= (my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
 		? "1":"0";
 	mysqli_close($link);
 
+	/* temporary addition for Kent's setup, Win32 box */
+	for ($i = 0; $i < 10; $i++) {
+		if (!$link = mysqli_init())
+			printf("[001 + %d] mysqli_init() failed, [%d] %s\n", $i, mysqli_connect_errno(), mysqli_connect_error());
+
+		if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
+			printf("[002 + %d] mysqli_real_connect() failed, [%d] %s\n", $i, mysqli_connect_errno(), mysqli_connect_error());
+
+		mysqli_close($link);
+	}
+
 	/*** test mysqli_real_connect compressed ***/
-	$link = mysqli_init();	
-	$test .= (mysqli_real_connect($link, $host, $user, $passwd, $dbname, 0, NULL, MYSQLI_CLIENT_COMPRESS)) 
+	/*
+	$link = mysqli_init();
+	$test .= (my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, MYSQLI_CLIENT_COMPRESS))
 		? "1" : "0";
 	mysqli_close($link);
-
+  */
 	/* todo ssl connections */
 
 	var_dump($test);
+	print "done!";
 ?>
---EXPECT--
-string(5) "11111"
+--EXPECTF--
+%s(4) "1111"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/002.phpt
+++ b/ext/mysqli/tests/002.phpt
@@ -1,42 +1,63 @@
 --TEST--
-mysqli bind_result 1 
+mysqli bind_result 1
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
-    $link->query("CREATE SCHEMA test");
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	   printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
 
-	mysqli_select_db($link, "test");		
-	$rc = mysqli_query($link,"DROP TABLE IF EXISTS test_fetch_null");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_fetch_null"))
+		printf("[002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	$rc = mysqli_query($link,"CREATE TABLE test_fetch_null(col1 tinyint, col2 smallint,
-                                                       col3 int, col4 bigint, 
-                                                       col5 float, col6 double,
-                                                       col7 date, col8 time, 
-                                                       col9 varbinary(10), 
-                                                       col10 varchar(50),
-                                                       col11 char(20))");
-  
-	$rc = mysqli_query($link,"INSERT INTO test_fetch_null(col1,col10, col11) VALUES(1,'foo1', 1000),(2,'foo2', 88),(3,'foo3', 389789)");
+	$rc = mysqli_query($link,"CREATE TABLE test_fetch_null(col1 tinyint, col2 smallint,
+		col3 int, col4 bigint,
+		col5 float, col6 double,
+		col7 date, col8 time,
+		col9 varbinary(10),
+		col10 varchar(50),
+		col11 char(20)) ENGINE=" . $engine);
 
-	$stmt = mysqli_prepare($link, "SELECT col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11 from test_fetch_null");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8, $c9, $c10, $c11); 
-	mysqli_execute($stmt);
+	if (!$rc)
+		printf("[003] Cannot create table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_fetch($stmt);
+	$rc = mysqli_query($link, "INSERT INTO test_fetch_null(col1,col10, col11) VALUES(1,'foo1', 1000),(2,'foo2', 88),(3,'foo3', 389789)");
+	if (!$rc)
+		printf("[004] Cannot insert records, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	$stmt = mysqli_prepare($link, "SELECT col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11 from test_fetch_null ORDER BY col1");
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8, $c9, $c10, $c11);
+	mysqli_stmt_execute($stmt);
+
+	mysqli_stmt_fetch($stmt);
+
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8,$c9,$c10,$c11);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	@mysqli_query($link, "DROP TABLE IF EXISTS test_fetch_null");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_fetch_null"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(11) {
   [0]=>
   int(1)
@@ -57,7 +78,8 @@
   [8]=>
   NULL
   [9]=>
-  string(4) "foo1"
+  %unicode|string%(4) "foo1"
   [10]=>
-  string(4) "1000"
+  %unicode|string%(4) "1000"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/003.phpt
+++ b/ext/mysqli/tests/003.phpt
@@ -1,58 +1,103 @@
 --TEST--
 mysqli connect
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
-	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd, "test");
+	require_once("connect.inc");
 
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+
 	mysqli_query($link, "SET sql_mode=''");
-		
-	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_result");
-  	mysqli_query($link,"CREATE TABLE test_bind_result(c1 date, c2 time, 
-                                                        c3 timestamp(14), 
-                                                        c4 year, 
-                                                        c5 datetime, 
-                                                        c6 timestamp(4), 
-                                                        c7 timestamp(6))");
 
-  	mysqli_query($link,"INSERT INTO test_bind_result VALUES('2002-01-02',
-                                                              '12:49:00',
-                                                              '2002-01-02 17:46:59', 
-                                                              2010,
-                                                              '2010-07-10', 
-                                                              '2020','1999-12-29')");
+	if (!mysqli_query($link,"DROP TABLE IF EXISTS test_bind_result"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	$rc = @mysqli_query($link,"CREATE TABLE test_bind_result(
+		c1 date,
+		c2 time,
+		c3 timestamp(14),
+		c4 year,
+		c5 datetime,
+		c6 timestamp(4),
+		c7 timestamp(6)) ENGINE=" . $engine);
 
-	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_result");
-  	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
- 	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	/*
+	Seems that not all MySQL 6.0 installations use defaults that ignore the display widths.
+	From the manual:
+	From MySQL 4.1.0 on, TIMESTAMP display format differs from that of earlier MySQL releases:
+	[...]
+	Display widths (used as described in the preceding section) are no longer supported.
+	In other words, for declarations such as TIMESTAMP(2), TIMESTAMP(4), and so on,
+	the display width is ignored.
+	[...]
+	*/
+	if (!$rc)
+		$rc = @mysqli_query($link,"CREATE TABLE test_bind_result(
+			c1 date,
+			c2 time,
+			c3 timestamp,
+			c4 year,
+			c5 datetime,
+			c6 timestamp,
+			c7 timestamp) ENGINE=" . $engine);
 
+	if (!$rc)
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$rc = mysqli_query($link, "INSERT INTO test_bind_result VALUES(
+		'2002-01-02',
+		'12:49:00',
+		'2002-01-02 17:46:59',
+		2010,
+		'2010-07-10',
+		'2020','1999-12-29')");
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$stmt = mysqli_prepare($link, "SELECT c1, c2, c3, c4, c5, c6, c7 FROM test_bind_result");
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
+
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(7) {
   [0]=>
-  string(10) "2002-01-02"
+  %unicode|string%(10) "2002-01-02"
   [1]=>
-  string(8) "12:49:00"
+  %unicode|string%(8) "12:49:00"
   [2]=>
-  string(19) "2002-01-02 17:46:59"
+  %unicode|string%(19) "2002-01-02 17:46:59"
   [3]=>
   int(2010)
   [4]=>
-  string(19) "2010-07-10 00:00:00"
+  %unicode|string%(19) "2010-07-10 00:00:00"
   [5]=>
-  string(19) "0000-00-00 00:00:00"
+  %unicode|string%(19) "0000-00-00 00:00:00"
   [6]=>
-  string(19) "1999-12-29 00:00:00"
+  %unicode|string%(19) "1999-12-29 00:00:00"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/004.phpt
+++ b/ext/mysqli/tests/004.phpt
@@ -1,60 +1,89 @@
 --TEST--
-mysqli fetch char/text 
+mysqli fetch char/text
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 	include ("connect.inc");
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text)");
+	if (!mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567890', 'this is a test0')");
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567891', 'this is a test1')");
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567892', 'this is a test2')");
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567893', 'this is a test3')");
+	if (!mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text) ENGINE=" . $engine))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch ORDER BY c1");
-	mysqli_bind_result($stmt, $c1, $c2);
-	mysqli_execute($stmt);
-	$i=4;
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567890', 'this is a test0')"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567891', 'this is a test1')"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567892', 'this is a test2')"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567893', 'this is a test3')"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch ORDER BY c1"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	
+	$c1 = $c2 = NULL;
+	mysqli_stmt_bind_result($stmt, $c1, $c2);
+	mysqli_stmt_execute($stmt);
+	$i = 4;
 	while ($i--) {
-		mysqli_fetch($stmt);
-		$test = array($c1,$c2);
+		mysqli_stmt_fetch($stmt);
+		$test = array($c1, $c2);
 		var_dump($test);
 	}
 
-
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(10) "1234567890"
+  %unicode|string%(10) "1234567890"
   [1]=>
-  string(15) "this is a test0"
+  %unicode|string%(15) "this is a test0"
 }
 array(2) {
   [0]=>
-  string(10) "1234567891"
+  %unicode|string%(10) "1234567891"
   [1]=>
-  string(15) "this is a test1"
+  %unicode|string%(15) "this is a test1"
 }
 array(2) {
   [0]=>
-  string(10) "1234567892"
+  %unicode|string%(10) "1234567892"
   [1]=>
-  string(15) "this is a test2"
+  %unicode|string%(15) "this is a test2"
 }
 array(2) {
   [0]=>
-  string(10) "1234567893"
+  %unicode|string%(10) "1234567893"
   [1]=>
-  string(15) "this is a test3"
+  %unicode|string%(15) "this is a test3"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/005.phpt
+++ b/ext/mysqli/tests/005.phpt
@@ -1,40 +1,61 @@
 --TEST--
-mysqli fetch char/text long 
+mysqli fetch char/text long
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text)");
+	if (!mysqli_query($link, "CREATE TABLE test_bind_fetch(c1 char(10), c2 text) ENGINE=" . $engine))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
 	$a = str_repeat("A1", 32000);
 
 	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES ('1234567890', '$a')");
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test[] = $c1;
 	$test[] = ($a == $c2) ? "32K String ok" : "32K String failed";
 
 	var_dump($test);
 
+	/* this will crash with libmysql from PHP 5.0.6 (or earlier) to 5.3.0 */
+	mysqli_stmt_fetch($stmt);
+
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(10) "1234567890"
+  %unicode|string%(10) "1234567890"
   [1]=>
-  string(13) "32K String ok"
+  %unicode|string%(13) "32K String ok"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/006.phpt
+++ b/ext/mysqli/tests/006.phpt
@@ -1,40 +1,61 @@
 --TEST--
 mysqli fetch long values
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
-	mysqli_query($link, "SET sql_mode=''");
+	if (!mysqli_query($link, "SET sql_mode=''"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 int unsigned,
-                                                     c2 int unsigned,
-                                                     c3 int,
-                                                     c4 int,
-                                                     c5 int,
-                                                     c6 int unsigned,
-                                                     c7 int)");
+	if (!mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,35999,NULL,-500,-9999999,-0,0)");
+	$rc = mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 int unsigned,
+													c2 int unsigned,
+													c3 int,
+													c4 int,
+													c5 int,
+													c6 int unsigned,
+													c7 int) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,35999,NULL,-500,-9999999,-0,0)"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -52,3 +73,4 @@
   [6]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/007.phpt
+++ b/ext/mysqli/tests/007.phpt
@@ -1,40 +1,61 @@
 --TEST--
 mysqli fetch short values
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
-	mysqli_query($link, "SET sql_mode=''");
+	if (!mysqli_query($link, "SET sql_mode=''"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 smallint unsigned,
-                                                     c2 smallint unsigned,
-                                                     c3 smallint,
-                                                     c4 smallint,
-                                                     c5 smallint,
-                                                     c6 smallint unsigned,
-                                                     c7 smallint)");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,35999,NULL,-500,-9999999,+30,0)");
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_fetch(c1 smallint unsigned,
+													 c2 smallint unsigned,
+													 c3 smallint,
+													 c4 smallint,
+													 c5 smallint,
+													 c6 smallint unsigned,
+													 c7 smallint) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,35999,NULL,-500,-9999999,+30,0)"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -52,3 +73,4 @@
   [6]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/008.phpt
+++ b/ext/mysqli/tests/008.phpt
@@ -1,40 +1,61 @@
 --TEST--
 mysqli fetch tinyint values
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
-	mysqli_query($link, "SET sql_mode=''");
+	if (!mysqli_query($link, "SET sql_mode=''"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 tinyint,
-                                                     c2 tinyint unsigned,
-                                                     c3 tinyint not NULL,
-                                                     c4 tinyint,
-                                                     c5 tinyint,
-                                                     c6 tinyint unsigned,
-                                                     c7 tinyint)");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,300,0,-100,-127,+30,0)");
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_fetch(c1 tinyint,
+													c2 tinyint unsigned,
+													c3 tinyint not NULL,
+													c4 tinyint,
+													c5 tinyint,
+													c6 tinyint unsigned,
+													c7 tinyint) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,300,0,-100,-127,+30,0)"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -52,3 +73,4 @@
   [6]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/009.phpt
+++ b/ext/mysqli/tests/009.phpt
@@ -7,59 +7,93 @@
 		exit;
 	}
 	require_once('skipif.inc');
+	require_once('skipifconnectfailure.inc');
 ?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
-	mysqli_query($link, "SET sql_mode=''");
+	if (!mysqli_query($link, "SET sql_mode=''"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 bigint default 5,
-                                                     c2 bigint,
-                                                     c3 bigint not NULL,
-                                                     c4 bigint unsigned,
-                                                     c5 bigint unsigned,
-                                                     c6 bigint unsigned,
-                                                     c7 bigint unsigned)");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO test_bind_fetch (c2,c3,c4,c5,c6,c7) VALUES (-23,4.0,33333333333333,0,-333333333333,99.9)");
+	$rc = mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 bigint default 5,
+													c2 bigint,
+													c3 bigint not NULL,
+													c4 bigint unsigned,
+													c5 bigint unsigned,
+													c6 bigint unsigned,
+													c7 bigint unsigned,
+													c8 bigint unsigned) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	$rc = mysqli_query($link, "INSERT INTO test_bind_fetch (c2,c3,c4,c5,c6,c7,c8) ".
+							  "VALUES (-23,4.0,33333333333333,0,-333333333333,99.9,1234)");
+	if (!$rc)
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	$rc = mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8);
+	mysqli_stmt_execute($stmt);
+	$rc = mysqli_stmt_fetch($stmt);
 
-	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
+	if (mysqli_get_server_version($link) < 50000) {
+		// 4.1 is faulty and will return big number for $c6
+		if ($c6 == "18446743740376218283") {
+			$c6 = 0;
+		}
+	}
+	$c8 = 4567;// change this to test how mysqli/mysqlnd handles is_ref changing
+	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch_uint");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch_uint(c1 integer unsigned, c2 integer unsigned)");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch_uint"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_fetch_uint(c1 integer unsigned, c2 integer unsigned) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO test_bind_fetch_uint (c1,c2) VALUES (20123456, 3123456789)");
+	if (!mysqli_query($link, "INSERT INTO test_bind_fetch_uint (c1,c2) VALUES (20123456, 3123456789)"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch_uint");
-	mysqli_bind_result($stmt, $c1, $c2);
-	mysqli_execute($stmt);
-	$rc = mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2);
+	mysqli_stmt_execute($stmt);
+	$rc = mysqli_stmt_fetch($stmt);
 
 	echo $c1, "\n", $c2, "\n";
 
 	mysqli_stmt_close($stmt);
-
-
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch_uint");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
 
---EXPECT--
-array(7) {
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch_uint"))
+	printf("[002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(8) {
   [0]=>
   int(5)
   [1]=>
@@ -67,13 +101,16 @@
   [2]=>
   int(4)
   [3]=>
-  string(14) "33333333333333"
+  %unicode|string%(14) "33333333333333"
   [4]=>
   int(0)
   [5]=>
   int(0)
   [6]=>
   int(100)
+  [7]=>
+  int(4567)
 }
 20123456
 3123456789
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/010.phpt
+++ b/ext/mysqli/tests/010.phpt
@@ -3,43 +3,62 @@
 --INI--
 precision=12
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
-	mysqli_query($link, "SET sql_mode=''");
+	if (!mysqli_query($link, "SET sql_mode=''"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
- 	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 float(3),
-                                                     c2 float,
-                                                     c3 float unsigned,
-                                                     c4 float,
-                                                     c5 float,
-                                                     c6 float,
-                                                     c7 float(10) unsigned)");
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_fetch(c1 float(3),
+													 c2 float,
+													 c3 float unsigned,
+													 c4 float,
+													 c5 float,
+													 c6 float,
+													 c7 float(10) unsigned) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
 
 	mysqli_query($link, "INSERT INTO test_bind_fetch (c1,c2,c3,c4,c5,c6,c7) VALUES (3.1415926535,-0.000001, -5, 999999999999,
 											sin(0.6), 1.00000000000001, 888888888888888)");
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -57,3 +76,4 @@
   [6]=>
   float(8.88888914608E+14)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/011.phpt
+++ b/ext/mysqli/tests/011.phpt
@@ -3,40 +3,60 @@
 --INI--
 precision=12
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_result");
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_result(c1 tinyint, c2 smallint,
+														c3 int, c4 bigint,
+														c5 float, c6 double,
+														c7 varbinary(10),
+														c8 varchar(50)) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link,"CREATE TABLE test_bind_result(c1 tinyint, c2 smallint, 
-                                                        c3 int, c4 bigint, 
-                                                        c5 float, c6 double,
-                                                        c7 varbinary(10), 
-                                                        c8 varchar(50))");
+	$rc = mysqli_query($link,"INSERT INTO test_bind_result VALUES(19,2999,3999,4999999,
+															  2345.6,5678.89563,
+															  'foobar','mysql rulez')");
+	if (!$rc)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"INSERT INTO test_bind_result VALUES(19,2999,3999,4999999,
-                                                              2345.6,5678.89563,
-                                                              'foobar','mysql rulez')");
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_result");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(8) {
   [0]=>
   int(19)
@@ -53,5 +73,6 @@
   [6]=>
   string(6) "foobar"
   [7]=>
-  string(11) "mysql rulez"
+  %unicode|string%(11) "mysql rulez"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/012.phpt
+++ b/ext/mysqli/tests/012.phpt
@@ -3,41 +3,59 @@
 --INI--
 precision=12
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_result");
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_result(c1 tinyint, c2 smallint,
+														c3 int, c4 bigint,
+														c5 float, c6 double,
+														c7 varbinary(10),
+														c8 varchar(10)) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link,"CREATE TABLE test_bind_result(c1 tinyint, c2 smallint, 
-                                                        c3 int, c4 bigint, 
-                                                        c5 float, c6 double,
-                                                        c7 varbinary(10), 
-                                                        c8 varchar(10))");
+	if (!mysqli_query($link, "INSERT INTO test_bind_result VALUES(120,2999,3999,54,
+															2.6,58.89,
+															'206','6.7')"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"INSERT INTO test_bind_result VALUES(120,2999,3999,54,
-                                                              2.6,58.89,
-                                                              '206','6.7')");
-
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_result");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(8) {
   [0]=>
   int(120)
@@ -54,5 +72,6 @@
   [6]=>
   string(3) "206"
   [7]=>
-  string(3) "6.7"
+  %unicode|string%(3) "6.7"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/013.phpt
+++ b/ext/mysqli/tests/013.phpt
@@ -1,52 +1,72 @@
 --TEST--
 mysqli fetch mixed / mysql_query (may fail when using 4.1 library with 5.x server)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_result");
+	$rc = mysqli_query($link, "CREATE TABLE test_bind_result(c1 tinyint, c2 smallint,
+														c3 int, c4 bigint,
+														c5 decimal(4,2), c6 double,
+														c7 varbinary(10),
+														c8 varchar(10)) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link,"CREATE TABLE test_bind_result(c1 tinyint, c2 smallint, 
-                                                        c3 int, c4 bigint, 
-                                                        c5 decimal(4,2), c6 double,
-                                                        c7 varbinary(10), 
-                                                        c8 varchar(10))");
+	if (!mysqli_query($link, "INSERT INTO test_bind_result VALUES(120,2999,3999,54,
+															  2.6,58.89,
+															  '206','6.7')"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"INSERT INTO test_bind_result VALUES(120,2999,3999,54,
-                                                              2.6,58.89,
-                                                              '206','6.7')");
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_result");
 
 	$c = array(0,0,0,0,0,0,0,0);
-	$b_res= mysqli_bind_result($stmt, $c[0], $c[1], $c[2], $c[3], $c[4], $c[5], $c[6], $c[7]);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt); 
-	mysqli_fetch($stmt);  
+	$b_res= mysqli_stmt_bind_result($stmt, $c[0], $c[1], $c[2], $c[3], $c[4], $c[5], $c[6], $c[7]);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
+	mysqli_stmt_fetch($stmt);
 	mysqli_stmt_close($stmt);
 
 	$result = mysqli_query($link, "select * from test_bind_result");
-	$d = mysqli_fetch_row($result); 
+	$d = mysqli_fetch_row($result);
 	mysqli_free_result($result);
 
 	$test = "";
 	for ($i=0; $i < count($c); $i++)
-		$test .= ($c[0] == $d[0]) ? "1" : "0";
+		$test .= ($c[$i] == $d[$i]) ? "1" : "0";
 	if ($test == "11111111")
-		echo "ok";
+		echo "ok\n";
 	else if ($b_res == FALSE && mysqli_get_client_version() > 40100 && mysqli_get_client_version() < 50000 &&
-                 mysqli_get_server_version($link) > 50000)
+				 mysqli_get_server_version($link) > 50000)
 		echo "error (4.1 library with 5.x server)";
 	else
 		echo "error";
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECTF--
 ok
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/014.phpt
+++ b/ext/mysqli/tests/014.phpt
@@ -1,69 +1,97 @@
 --TEST--
-mysqli autocommit/commit/rollback 
+mysqli autocommit/commit/rollback
 --SKIPIF--
 <?php
 	require_once('skipif.inc');
-	include "connect.inc";
-	$link = mysqli_connect($host, $user, $passwd);
-	$result = mysqli_query($link, "SHOW VARIABLES LIKE 'have_innodb'");
-	$row = mysqli_fetch_row($result);
-	mysqli_free_result($result);
-	mysqli_close($link);
-	if ($row[1] == "DISABLED" || $row[1] == "NO") {
-		printf ("skip innodb support is not installed or enabled.");
-		exit;
-	}
+	require_once('skipifconnectfailure.inc');
+	require_once("connect.inc");
+
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+	if (!$link)
+		die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+	if (!have_innodb($link))
+		die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
 ?>
 --FILE--
 <?php
-	include "connect.inc";
-	$link = mysqli_connect($host, $user, $passwd);
+	require_once("connect.inc");
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_autocommit($link, TRUE))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_autocommit($link, TRUE);
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS ac_01");
+	if (!mysqli_query($link, "CREATE TABLE test(a int, b varchar(10)) engine=InnoDB"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link,"CREATE TABLE ac_01(a int, b varchar(10)) type=InnoDB");
+	if (!mysqli_query($link, "INSERT INTO test VALUES (1, 'foobar')"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO ac_01 VALUES (1, 'foobar')");
-	mysqli_autocommit($link, FALSE);
-	mysqli_query($link, "DELETE FROM ac_01");
-	mysqli_query($link, "INSERT INTO ac_01 VALUES (2, 'egon')");
+	if (!mysqli_autocommit($link, FALSE))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_rollback($link);
+	if (!mysqli_query($link, "DELETE FROM test"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	$result = mysqli_query($link, "SELECT * FROM ac_01");
+	if (!mysqli_query($link, "INSERT INTO test VALUES (2, 'egon')"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_rollback($link))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$result = mysqli_query($link, "SELECT * FROM test"))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	printf("Num_of_rows=%d\n", mysqli_num_rows($result));
-	$row = mysqli_fetch_row($result);
+	if (!$row = mysqli_fetch_row($result))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	mysqli_free_result($result);
 
 	var_dump($row);
 
-	mysqli_query($link, "DELETE FROM ac_01");
-	mysqli_query($link, "INSERT INTO ac_01 VALUES (2, 'egon')");
-	mysqli_commit($link);
+	if (!mysqli_query($link, "DELETE FROM test"))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	$result = mysqli_query($link, "SELECT * FROM ac_01");
-	$row = mysqli_fetch_row($result);
+	if (!mysqli_query($link, "INSERT INTO test VALUES (2, 'egon')"))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_commit($link))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$result = mysqli_query($link, "SELECT * FROM test"))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_row($result))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
 	mysqli_free_result($result);
 
 	var_dump($row);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
 Num_of_rows=1
 array(2) {
   [0]=>
-  string(1) "1"
+  %unicode|string%(1) "1"
   [1]=>
-  string(6) "foobar"
+  %unicode|string%(6) "foobar"
 }
 array(2) {
   [0]=>
-  string(1) "2"
+  %unicode|string%(1) "2"
   [1]=>
-  string(4) "egon"
+  %unicode|string%(4) "egon"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/015.phpt
+++ b/ext/mysqli/tests/015.phpt
@@ -1,69 +1,94 @@
 --TEST--
-mysqli autocommit/commit/rollback with myisam 
+mysqli autocommit/commit/rollback with innodb
 --SKIPIF--
-<?php	
+<?php
 	require_once('skipif.inc');
-	include "connect.inc";
-	$link = mysqli_connect($host, $user, $passwd);
-	$result = mysqli_query($link, "SHOW VARIABLES LIKE 'have_innodb'");
-	$row = mysqli_fetch_row($result);
-	mysqli_free_result($result);
-	mysqli_close($link);
-	
-	if ($row[1] == "NO") {
-		printf ("skip innodb support not installed.");
-	}
+	require_once('skipifconnectfailure.inc');
+
+	require_once('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+	if (!have_innodb($link))
+		die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
 ?>
 --FILE--
 <?php
-	include "connect.inc";
-	
-	$link = mysqli_connect($host, $user, $passwd);
+	require_once("connect.inc");
 
-	mysqli_select_db($link, "test");
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+	if (!$link)
+		printf("[001] Cannot connect, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
 
-	mysqli_autocommit($link, TRUE);
+	if (!mysqli_select_db($link, $db))
+		printf("[002] Cannot select DB '%s', [%d] %s\n", $db,
+			mysqli_errno($link), mysqli_error($link));
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS ac_01");
+	if (!mysqli_autocommit($link, TRUE))
+		printf("[003] Cannot turn on autocommit mode, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link,"CREATE TABLE ac_01(a int, b varchar(10))");
+	if (!mysqli_query($link,"DROP TABLE IF EXISTS test") ||
+		!mysqli_query($link,"CREATE TABLE test(a int, b varchar(10)) Engine=InnoDB") ||
+		!mysqli_query($link, "INSERT INTO test VALUES (1, 'foobar')"))
+		printf("[004] Cannot create test data, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "INSERT INTO ac_01 VALUES (1, 'foobar')");
-	mysqli_autocommit($link, FALSE);
+	if (!mysqli_autocommit($link, FALSE))
+		printf("[005] Cannot turn off autocommit mode, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "DELETE FROM ac_01");
-	mysqli_query($link, "INSERT INTO ac_01 VALUES (2, 'egon')");
+	if (!mysqli_query($link, "DELETE FROM test") ||
+			!mysqli_query($link, "INSERT INTO test VALUES (2, 'egon')"))
+		printf("[006] Cannot modify test data, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
 
-	mysqli_rollback($link);
+	if (!mysqli_rollback($link))
+		printf("[007] Cannot call rollback, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
 
-	$result = mysqli_query($link, "SELECT * FROM ac_01");
+	$result = mysqli_query($link, "SELECT SQL_NO_CACHE * FROM test");
+	if (!$result)
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 	$row = mysqli_fetch_row($result);
 	mysqli_free_result($result);
 
 	var_dump($row);
 
-	mysqli_query($link, "DELETE FROM ac_01");
-	mysqli_query($link, "INSERT INTO ac_01 VALUES (2, 'egon')");
+	if (!mysqli_query($link, "DELETE FROM test") ||
+			!mysqli_query($link, "INSERT INTO test VALUES (2, 'egon')"))
+		printf("[009] Cannot modify test data, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
 	mysqli_commit($link);
 
-	$result = mysqli_query($link, "SELECT * FROM ac_01");
+	$result = mysqli_query($link, "SELECT * FROM test");
+	if (!$result)
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 	$row = mysqli_fetch_row($result);
 	mysqli_free_result($result);
 
 	var_dump($row);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(1) "2"
+  %unicode|string%(1) "1"
   [1]=>
-  string(4) "egon"
+  %unicode|string%(6) "foobar"
 }
 array(2) {
   [0]=>
-  string(1) "2"
+  %unicode|string%(1) "2"
   [1]=>
-  string(4) "egon"
+  %unicode|string%(4) "egon"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/016.phpt
+++ b/ext/mysqli/tests/016.phpt
@@ -1,27 +1,33 @@
 --TEST--
-mysqli fetch user variable 
+mysqli fetch user variable
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_query($link, "SET @dummy='foobar'"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "SET @dummy='foobar'");
+	if (!$stmt = mysqli_prepare($link, "SELECT @dummy"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	$stmt = mysqli_prepare($link, "SELECT @dummy");
-	mysqli_bind_result($stmt, $dummy);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $dummy);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	var_dump($dummy);
 
 	mysqli_stmt_close($stmt);
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
-string(6) "foobar"
+--EXPECTF--
+%unicode|string%(6) "foobar"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/017.phpt
+++ b/ext/mysqli/tests/017.phpt
@@ -1,35 +1,43 @@
 --TEST--
-mysqli fetch functions 
+mysqli fetch functions
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!$stmt = mysqli_prepare($link, "SELECT md5('bar'), database(), 'foo'"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	$stmt = mysqli_prepare($link, "SELECT md5('bar'), database(), 'foo'");
-	mysqli_bind_result($stmt, $c0, $c1, $c2); 
-	mysqli_execute($stmt);
+	mysqli_stmt_bind_result($stmt, $c0, $c1, $c2);
+	mysqli_stmt_execute($stmt);
 
-	mysqli_fetch($stmt);
+	mysqli_stmt_fetch($stmt);
 	mysqli_stmt_close($stmt);
 
 	$test = array($c0, $c1, $c2);
+	if ($c1 !== $db) {
+		echo "Different data\n";
+	}
 
 	var_dump($test);
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--EXPECTF--
 array(3) {
   [0]=>
   string(32) "37b51d194a7513e45b56f6524f2d51f2"
   [1]=>
-  string(4) "test"
+  %unicode|string%(%d) "%s"
   [2]=>
-  string(3) "foo"
+  %unicode|string%(3) "foo"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/018.phpt
+++ b/ext/mysqli/tests/018.phpt
@@ -1,27 +1,33 @@
 --TEST--
 mysqli fetch system variables
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	if (!mysqli_query($link, "SET AUTOCOMMIT=0"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "SET AUTOCOMMIT=0");
+	if (!$stmt = mysqli_prepare($link, "SELECT @@autocommit"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	$stmt = mysqli_prepare($link, "SELECT @@autocommit");
-	mysqli_bind_result($stmt, $c0); 
-	mysqli_execute($stmt);
+	mysqli_stmt_bind_result($stmt, $c0);
+	mysqli_stmt_execute($stmt);
 
-	mysqli_fetch($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	var_dump($c0);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 int(0)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/019.phpt
+++ b/ext/mysqli/tests/019.phpt
@@ -1,52 +1,72 @@
 --TEST--
-mysqli fetch (bind_param + bind_result) 
+mysqli fetch (bind_param + bind_result)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
---INI--
-precision=14
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");		
-	$rc = mysqli_query($link,"DROP TABLE IF EXISTS insert_read");
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS insert_read"))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-  	$rc = mysqli_query($link,"CREATE TABLE insert_read(col1 tinyint, col2 smallint,
-                                                       col3 int, col4 bigint, 
-                                                       col5 float, col6 double,
-                                                       col7 date, col8 time, 
-                                                       col9 varbinary(10), 
-                                                       col10 varchar(50),
-                                                       col11 char(20))");
-  
-	$stmt=  mysqli_prepare($link,"INSERT INTO insert_read(col1,col10, col11, col6) VALUES(?,?,?,?)");
-	mysqli_bind_param($stmt, "issd", $c1, $c2, $c3, $c4);
+	$rc = mysqli_query($link,"CREATE TABLE insert_read(col1 tinyint, col2 smallint,
+													col3 int, col4 bigint,
+													col5 float, col6 double,
+													col7 date, col8 time,
+													col9 varbinary(10),
+													col10 varchar(50),
+													col11 char(20)) ENGINE=" . $engine);
+	if (!$rc)
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
+	if (!$stmt = mysqli_prepare($link, "INSERT INTO insert_read(col1,col10, col11, col6) VALUES (?,?,?,?)"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_stmt_bind_param($stmt, "issd", $c1, $c2, $c3, $c4);
+
 	$c1 = 1;
 	$c2 = "foo";
 	$c3 = "foobar";
 	$c4 = 3.14;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
-	$stmt = mysqli_prepare($link, "SELECT col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11 from insert_read");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8, $c9, $c10, $c11); 
-	mysqli_execute($stmt);
+	if (!$stmt = mysqli_prepare($link, "SELECT col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11 FROM insert_read"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8, $c9, $c10, $c11);
+	mysqli_stmt_execute($stmt);
 
+	mysqli_stmt_fetch($stmt);
+
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8,$c9,$c10,$c11);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS insert_read");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS insert_read"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(11) {
   [0]=>
   int(1)
@@ -67,7 +87,8 @@
   [8]=>
   NULL
   [9]=>
-  string(3) "foo"
+  %unicode|string%(3) "foo"
   [10]=>
-  string(6) "foobar"
+  %unicode|string%(6) "foobar"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/020.phpt
+++ b/ext/mysqli/tests/020.phpt
@@ -1,67 +1,98 @@
 --TEST--
 mysqli bind_param/bind_result date
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
-		
+
 	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_result");
-  	mysqli_query($link,"CREATE TABLE test_bind_result(c1 date, c2 time, 
-                                                        c3 timestamp(14), 
-                                                        c4 year, 
-                                                        c5 datetime, 
-                                                        c6 timestamp(4), 
-                                                        c7 timestamp(6))");
 
+	$rc = @mysqli_query($link,"CREATE TABLE test_bind_result(
+		c1 date,
+		c2 time,
+		c3 timestamp(14),
+		c4 year,
+		c5 datetime,
+		c6 timestamp(4),
+		c7 timestamp(6))");
+
+	if (!$rc)
+		$rc = mysqli_query($link,"CREATE TABLE test_bind_result(
+		c1 date,
+		c2 time,
+		c3 timestamp,
+		c4 year,
+		c5 datetime,
+		c6 timestamp,
+		c7 timestamp)");
+
 	$stmt = mysqli_prepare($link, "INSERT INTO test_bind_result VALUES (?,?,?,?,?,?,?)");
-	mysqli_bind_param($stmt, "sssssss", $d1, $d2, $d3, $d4, $d5, $d6, $d7);
+	mysqli_stmt_bind_param($stmt, "sssssss", $d1, $d2, $d3, $d4, $d5, $d6, $d7);
 
-  	$d1 = '2002-01-02';
-	$d2 = '12:49:00';
-	$d3 = '2002-01-02 17:46:59';
-	$d4 = 2010;
-	$d5 ='2010-07-10';
-	$d6 = '2020';
-	$d7 = '1999-12-29';
+	$d1 = "2002-01-02";
+	$d2 = "12:49:00";
+	$d3 = "2002-01-02 17:46:59";
+	$d4 = "2010";
+	$d5 = "2010-07-10";
+	$d6 = "2020";
+	$d7 = "1999-12-29";
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
-	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_result");
+	$stmt = mysqli_prepare($link, "SELECT c1, c2, c3, c4, c5, c6, c7 FROM test_bind_result");
 
-  	mysqli_bind_result($stmt,$c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	
- 	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt,$c1, $c2, $c3, $c4, $c5, $c6, $c7);
 
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
+
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result");
 	mysqli_close($link);
+
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(7) {
   [0]=>
-  string(10) "2002-01-02"
+  %s(10) "2002-01-02"
   [1]=>
-  string(8) "12:49:00"
+  %s(8) "12:49:00"
   [2]=>
-  string(19) "2002-01-02 17:46:59"
+  %s(19) "2002-01-02 17:46:59"
   [3]=>
   int(2010)
   [4]=>
-  string(19) "2010-07-10 00:00:00"
+  %s(19) "2010-07-10 00:00:00"
   [5]=>
-  string(19) "0000-00-00 00:00:00"
+  %s(19) "0000-00-00 00:00:00"
   [6]=>
-  string(19) "1999-12-29 00:00:00"
+  %s(19) "1999-12-29 00:00:00"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/021.phpt
+++ b/ext/mysqli/tests/021.phpt
@@ -1,42 +1,59 @@
 --TEST--
-mysqli bind_param+bind_result char/text 
+mysqli bind_param+bind_result char/text
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text)");
 
 	$stmt = mysqli_prepare($link, "INSERT INTO test_bind_fetch VALUES (?,?)");
-	mysqli_bind_param($stmt, "ss", $q1, $q2);
+	mysqli_stmt_bind_param($stmt, "ss", $q1, $q2);
 	$q1 = "1234567890";
 	$q2 = "this is a test";
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(10) "1234567890"
+  %unicode|string%(10) "1234567890"
   [1]=>
-  string(14) "this is a test"
+  %unicode|string%(14) "this is a test"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/022.phpt
+++ b/ext/mysqli/tests/022.phpt
@@ -1,33 +1,36 @@
 --TEST--
-mysqli bind_param/bind_result char/text long 
+mysqli bind_param/bind_result char/text long
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 char(10), c2 text)");
 
 
 	$stmt = mysqli_prepare($link, "INSERT INTO test_bind_fetch VALUES (?,?)");
-	mysqli_bind_param($stmt, "ss", $a1, $a2);
+	mysqli_stmt_bind_param($stmt, "ss", $a1, $a2);
 
 	$a1 = "1234567890";
 	$a2 = str_repeat("A1", 32000);
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test[] = $c1;
 	$test[] = ($a2 == $c2) ? "32K String ok" : "32K String failed";
@@ -35,12 +38,27 @@
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(10) "1234567890"
+  %unicode|string%(10) "1234567890"
   [1]=>
-  string(13) "32K String ok"
+  %s(13) "32K String ok"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/023.phpt
+++ b/ext/mysqli/tests/023.phpt
@@ -1,28 +1,31 @@
 --TEST--
 mysqli bind_param/bind_prepare fetch long values
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 int unsigned,
-                                                     c2 int unsigned,
-                                                     c3 int,
-                                                     c4 int,
-                                                     c5 int,
-                                                     c6 int unsigned,
-                                                     c7 int)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 int unsigned,
+		c2 int unsigned,
+		c3 int,
+		c4 int,
+		c5 int,
+		c6 int unsigned,
+		c7 int)");
 
 	$stmt = mysqli_prepare($link, "INSERT INTO test_bind_fetch VALUES (?,?,?,?,?,?,?)");
-	mysqli_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
+	mysqli_stmt_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
 	$c1 = -23;
 	$c2 = 35999;
 	$c3 = NULL;
@@ -31,21 +34,35 @@
 	$c6 = -0;
 	$c7 = 0;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -63,3 +80,4 @@
   [6]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/024.phpt
+++ b/ext/mysqli/tests/024.phpt
@@ -1,28 +1,31 @@
 --TEST--
 mysqli bind_param/bind_result short values
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 smallint unsigned,
-                                                     c2 smallint unsigned,
-                                                     c3 smallint,
-                                                     c4 smallint,
-                                                     c5 smallint,
-                                                     c6 smallint unsigned,
-                                                     c7 smallint)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 smallint unsigned,
+		c2 smallint unsigned,
+		c3 smallint,
+		c4 smallint,
+		c5 smallint,
+		c6 smallint unsigned,
+		c7 smallint)");
 
 	$stmt = mysqli_prepare($link, "INSERT INTO test_bind_fetch VALUES (?,?,?,?,?,?,?)");
-	mysqli_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
+	mysqli_stmt_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	$c1 = -23;
 	$c2 = 35999;
@@ -32,21 +35,34 @@
 	$c6 = -0;
 	$c7 = 0;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -64,3 +80,4 @@
   [6]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/025.phpt
+++ b/ext/mysqli/tests/025.phpt
@@ -1,28 +1,31 @@
 --TEST--
 mysqli bind_param/bind_result tinyint values
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 tinyint,
-                                                     c2 tinyint unsigned,
-                                                     c3 tinyint not NULL,
-                                                     c4 tinyint,
-                                                     c5 tinyint,
-                                                     c6 tinyint unsigned,
-                                                     c7 tinyint)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 tinyint,
+		c2 tinyint unsigned,
+		c3 tinyint not NULL,
+		c4 tinyint,
+		c5 tinyint,
+		c6 tinyint unsigned,
+		c7 tinyint)");
 
 	$stmt = mysqli_prepare ($link, "INSERT INTO test_bind_fetch VALUES(?,?,?,?,?,?,?)");
-	mysqli_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
+	mysqli_stmt_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	$c1 = -23;
 	$c2 = 300;
@@ -32,7 +35,7 @@
 	$c6 = 30;
 	$c7 = 0;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	mysqli_query($link, "INSERT INTO test_bind_fetch VALUES (-23,300,0,-100,-127,+30,0)");
@@ -40,17 +43,31 @@
 	$c1 = $c2 = $c3 = $c4 = $c5 = $c6 = $c7 = NULL;
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $c1, $c2, $c3, $c4, $c5, $c6, $c7);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(7) {
   [0]=>
@@ -68,3 +85,4 @@
   [6]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/026.phpt
+++ b/ext/mysqli/tests/026.phpt
@@ -1,49 +1,65 @@
 --TEST--
-mysqli bind_param/bind_result with send_long_data 
+mysqli bind_param/bind_result with send_long_data
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 varchar(10), c2 text)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 varchar(10), c2 text)");
 
 	$stmt = mysqli_prepare ($link, "INSERT INTO test_bind_fetch VALUES (?,?)");
-	mysqli_bind_param($stmt, "sb", $c1, $c2);
+	mysqli_stmt_bind_param($stmt, "sb", $c1, $c2);
 
 	$c1 = "Hello World";
 
-	mysqli_send_long_data($stmt, 1, "This is the first sentence.");
-	mysqli_send_long_data($stmt, 1, " And this is the second sentence.");
-	mysqli_send_long_data($stmt, 1, " And finally this is the last sentence.");
+	mysqli_stmt_send_long_data($stmt, 1, "This is the first sentence.");
+	mysqli_stmt_send_long_data($stmt, 1, " And this is the second sentence.");
+	mysqli_stmt_send_long_data($stmt, 1, " And finally this is the last sentence.");
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_bind_fetch");
-	mysqli_bind_result($stmt, $d1, $d2);
-	mysqli_execute($stmt);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $d1, $d2);
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_fetch($stmt);
 
 	$test = array($d1,$d2);
 
 	var_dump($test);
 
 	mysqli_stmt_close($stmt);
-
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(10) "Hello Worl"
+  %unicode|string%(10) "Hello Worl"
   [1]=>
-  string(99) "This is the first sentence. And this is the second sentence. And finally this is the last sentence."
+  %unicode|string%(99) "This is the first sentence. And this is the second sentence. And finally this is the last sentence."
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/027.phpt
+++ b/ext/mysqli/tests/027.phpt
@@ -1,20 +1,24 @@
 --TEST--
 function test: mysqli_stat
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$status = mysqli_stat($link);
 
-
 	var_dump(strlen($status) > 0);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 bool(true)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/028.phpt
+++ b/ext/mysqli/tests/028.phpt
@@ -1,19 +1,24 @@
 --TEST--
 function test: mysqli_character_set_name
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$cset = substr(mysqli_character_set_name($link),0,6);
 
 	var_dump($cset);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECTF--
-string(%d) "%s"
+%unicode|string%(%d) "%s"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/029.phpt
+++ b/ext/mysqli/tests/029.phpt
@@ -1,25 +1,42 @@
 --TEST--
 function test: mysqli_affected_rows
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-	mysqli_query($link, "drop table if exists general_test");
-	mysqli_query($link, "create table general_test (a int)");
-	mysqli_query($link, "insert into general_test values (1),(2),(3)");
+	mysqli_query($link, "DROP TABLE IF EXISTS general_test");
+	mysqli_query($link, "CREATE TABLE general_test (a INT)");
+	mysqli_query($link, "INSERT INTO general_test VALUES (1),(2),(3)");
 
 	$afc = mysqli_affected_rows($link);
 
 	var_dump($afc);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS general_test");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS general_test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 int(3)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/030.phpt
+++ b/ext/mysqli/tests/030.phpt
@@ -1,25 +1,30 @@
 --TEST--
 function test: mysqli_errno
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 	$errno = mysqli_errno($link);
 	var_dump($errno);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-	mysqli_query($link, "select * from non_exisiting_table");
-	$errno = mysqli_errno($link);	
+	mysqli_query($link, "SELECT * FROM non_exisiting_table");
+	$errno = mysqli_errno($link);
 
 	var_dump($errno);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 int(0)
 int(1146)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/031.phpt
+++ b/ext/mysqli/tests/031.phpt
@@ -1,25 +1,30 @@
 --TEST--
 function test: mysqli_error
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 	$error = mysqli_error($link);
 	var_dump($error);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-	mysqli_query($link, "select * from non_exisiting_table");
-	$error = mysqli_error($link);	
+	mysqli_query($link, "SELECT * FROM non_exisiting_table");
+	$error = mysqli_error($link);
 
 	var_dump($error);
 
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
-string(0) ""
-string(46) "Table 'test.non_exisiting_table' doesn't exist"
+--EXPECTF--
+%unicode|string%(0) ""
+%unicode|string%(%d) "%s"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/032.phpt
+++ b/ext/mysqli/tests/032.phpt
@@ -1,25 +1,42 @@
 --TEST--
 function test: mysqli_info
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-	mysqli_query($link, "drop table if exists general_test");
-	mysqli_query($link, "create table general_test (a int)");
-	mysqli_query($link, "insert into general_test values (1),(2),(3)");
+	mysqli_query($link, "DROP TABLE IF EXISTS general_test");
+	mysqli_query($link, "CREATE TABLE general_test (a INT)");
+	mysqli_query($link, "INSERT INTO general_test VALUES (1),(2),(3)");
 
 	$afc = mysqli_info($link);
 
 	var_dump($afc);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS general_test");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
-string(38) "Records: 3  Duplicates: 0  Warnings: 0"
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS general_test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+%unicode|string%(38) "Records: 3  Duplicates: 0  Warnings: 0"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/033.phpt
+++ b/ext/mysqli/tests/033.phpt
@@ -1,20 +1,25 @@
 --TEST--
 function test: mysqli_get_host_info
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$hinfo = mysqli_get_host_info($link);
 
 	var_dump(str_replace('/','', $hinfo));
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECTF--
-string(%d) "%s via %s"
+%unicode|string%(%d) "%s via %s"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/034.phpt
+++ b/ext/mysqli/tests/034.phpt
@@ -1,20 +1,25 @@
 --TEST--
 function test: mysqli_get_proto_info
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$pinfo = mysqli_get_proto_info($link);
 
 	var_dump($pinfo);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 int(10)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/035.phpt
+++ b/ext/mysqli/tests/035.phpt
@@ -1,19 +1,24 @@
 --TEST--
 function test: mysqli_get_server_info
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$sinfo = substr(mysqli_get_server_info($link),0,1);
 
 	var_dump(strlen($sinfo));
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 int(1)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/036.phpt
+++ b/ext/mysqli/tests/036.phpt
@@ -1,47 +1,58 @@
 --TEST--
 function test: mysqli_insert_id()
 --SKIPIF--
-<?php 
+<?php
 	if (PHP_INT_SIZE == 8) {
 		echo 'skip test valid only for 32bit systems';
 		exit;
 	}
 	require_once('skipif.inc');
+	require_once('skipifconnectfailure.inc');
 ?>
 --FILE--
 <?php
+	require_once("connect.inc");
 
-	include "connect.inc";
-	
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS t036");
+	mysqli_query($link, "CREATE TABLE t036 (a bigint not null auto_increment primary key, b varchar(10)) ENGINE = " . $engine);
 
-	mysqli_query($link, "CREATE TABLE t036 (a bigint not null auto_increment primary key, b varchar(10))");
-
-
 	mysqli_query($link, "INSERT INTO t036 (b) VALUES ('foo1')");
 	$test[] = mysqli_insert_id($link);
 
 	/* we have to insert more values, cause lexer sets auto_increment to max_int
 	   see mysql bug #54. So we don't check for the value, only for type (which must
-	   be type string) 
-	*/	
-	   
+	   be type string)
+	*/
+
 	mysqli_query($link, "ALTER TABLE t036 AUTO_INCREMENT=9999999999999998");
 	mysqli_query($link, "INSERT INTO t036 (b) VALUES ('foo2')");
 	mysqli_query($link, "INSERT INTO t036 (b) VALUES ('foo3')");
 	mysqli_query($link, "INSERT INTO t036 (b) VALUES ('foo4')");
 	$x = mysqli_insert_id($link);
 	$test[] = is_string($x);
-	
+
 	var_dump($test);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS t036");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS t036"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(2) {
   [0]=>
@@ -49,3 +60,4 @@
   [1]=>
   bool(true)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/037.phpt
+++ b/ext/mysqli/tests/037.phpt
@@ -1,32 +1,48 @@
 --TEST--
 function test: mysqli_field_count()
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS test_result");
 
-	mysqli_query($link, "CREATE TABLE test_result (a int, b varchar(10))");
+	mysqli_query($link, "CREATE TABLE test_result (a int, b varchar(10)) ENGINE = " . $engine);
 
 	mysqli_query($link, "INSERT INTO test_result VALUES (1, 'foo')");
 	$ir[] = mysqli_field_count($link);
 
 	mysqli_real_query($link, "SELECT * FROM test_result");
 	$ir[] = mysqli_field_count($link);
-	
-	
+
+
 	var_dump($ir);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_result");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 array(2) {
   [0]=>
@@ -34,3 +50,4 @@
   [1]=>
   int(2)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/038.phpt
+++ b/ext/mysqli/tests/038.phpt
@@ -1,20 +1,22 @@
 --TEST--
 function test: mysqli_num_fields()
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+	require_once("connect.inc");
 
-	include "connect.inc";
-	
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS test_result");
 
-	mysqli_query($link, "CREATE TABLE test_result (a int, b varchar(10))");
+	mysqli_query($link, "CREATE TABLE test_result (a int, b varchar(10)) ENGINE = " . $engine);
 
 	mysqli_query($link, "INSERT INTO test_result VALUES (1, 'foo')");
 
@@ -27,7 +29,19 @@
 
 	var_dump($num);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_result");
 	mysqli_close($link);
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
 ?>
 --EXPECT--
 int(2)
--- a/ext/mysqli/tests/039.phpt
+++ b/ext/mysqli/tests/039.phpt
@@ -1,14 +1,16 @@
 --TEST--
 function test: mysqli_num_fields() 2
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+	require_once("connect.inc");
 
-	include "connect.inc";
-	
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	mysqli_real_query($link, "SHOW VARIABLES");
 
@@ -21,6 +23,8 @@
 	var_dump($num);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 int(2)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/040.phpt
+++ b/ext/mysqli/tests/040.phpt
@@ -1,21 +1,21 @@
 --TEST--
 function test: mysqli_num_rows()
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+	require_once("connect.inc");
 
-	include "connect.inc";
-	
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS test_result");
-
-	mysqli_query($link, "CREATE TABLE test_result (a int, b varchar(10))");
-
+	mysqli_query($link, "CREATE TABLE test_result (a int, b varchar(10)) ENGINE=" . $engine);
 	mysqli_query($link, "INSERT INTO test_result VALUES (1, 'foo')");
 
 	mysqli_real_query($link, "SELECT * FROM test_result");
@@ -27,7 +27,21 @@
 
 	var_dump($num);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_result");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 int(1)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/041.phpt
+++ b/ext/mysqli/tests/041.phpt
@@ -1,15 +1,18 @@
 --TEST--
 function test: mysqli_warning_count()
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
-	mysqli_select_db($link, "test");
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS test_warnings");
 	mysqli_query($link, "DROP TABLE IF EXISTS test_warnings");
@@ -17,6 +20,19 @@
 	var_dump(mysqli_warning_count($link));
 
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_warnings"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 int(1)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/042.phpt
+++ b/ext/mysqli/tests/042.phpt
@@ -1,28 +1,31 @@
 --TEST--
 mysqli_fetch_object
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
-  	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 smallint unsigned,
-                                                     c2 smallint unsigned,
-                                                     c3 smallint,
-                                                     c4 smallint,
-                                                     c5 smallint,
-                                                     c6 smallint unsigned,
-                                                     c7 smallint)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_bind_fetch");
+	mysqli_query($link,"CREATE TABLE test_bind_fetch(c1 smallint unsigned,
+		c2 smallint unsigned,
+		c3 smallint,
+		c4 smallint,
+		c5 smallint,
+		c6 smallint unsigned,
+		c7 smallint) ENGINE=" . $engine);
 
 	$stmt = mysqli_prepare($link, "INSERT INTO test_bind_fetch VALUES (?,?,?,?,?,?,?)");
-	mysqli_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
+	mysqli_stmt_bind_param($stmt, "iiiiiii", $c1,$c2,$c3,$c4,$c5,$c6,$c7);
 
 	$c1 = -23;
 	$c2 = 35999;
@@ -32,7 +35,7 @@
 	$c6 = -0;
 	$c7 = 0;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$result = mysqli_query($link, "SELECT * FROM test_bind_fetch");
@@ -41,22 +44,36 @@
 
 	var_dump($test);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch");
 	mysqli_close($link);
+	print "done!"
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECTF--
 object(stdClass)#%d (7) {
-  ["c1"]=>
-  string(1) "0"
-  ["c2"]=>
-  string(5) "35999"
-  ["c3"]=>
+  [%u|b%"c1"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"c2"]=>
+  %unicode|string%(5) "35999"
+  [%u|b%"c3"]=>
   NULL
-  ["c4"]=>
-  string(4) "-500"
-  ["c5"]=>
-  string(6) "-32768"
-  ["c6"]=>
-  string(1) "0"
-  ["c7"]=>
-  string(1) "0"
+  [%u|b%"c4"]=>
+  %unicode|string%(4) "-500"
+  [%u|b%"c5"]=>
+  %unicode|string%(6) "-32768"
+  [%u|b%"c6"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"c7"]=>
+  %unicode|string%(1) "0"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/043.phpt
+++ b/ext/mysqli/tests/043.phpt
@@ -1,30 +1,33 @@
 --TEST--
-mysqli_bind_param (UPDATE)
+mysqli_stmt_bind_param (UPDATE)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_update");
-  	mysqli_query($link,"CREATE TABLE test_update(a varchar(10),
-                                                     b int)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_update");
+	mysqli_query($link,"CREATE TABLE test_update(a varchar(10),
+		b int) ENGINE=" . $engine);
 
 	mysqli_query($link, "INSERT INTO test_update VALUES ('foo', 2)");
 
 	$stmt = mysqli_prepare($link, "UPDATE test_update SET a=?,b=? WHERE b=?");
-	mysqli_bind_param($stmt, "sii", $c1, $c2, $c3);
+	mysqli_stmt_bind_param($stmt, "sii", $c1, $c2, $c3);
 
 	$c1 = "Rasmus";
 	$c2 = 1;
 	$c3 = 2;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$result = mysqli_query($link, "SELECT concat(a, ' is No. ', b) FROM test_update");
@@ -33,10 +36,24 @@
 
 	var_dump($test);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_update");
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_update"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(1) {
   [0]=>
   string(15) "Rasmus is No. 1"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/044.phpt
+++ b/ext/mysqli/tests/044.phpt
@@ -1,13 +1,16 @@
 --TEST--
 mysqli_get_server_version
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$i = mysqli_get_server_version($link);
 
@@ -16,6 +19,8 @@
 	var_dump($test);
 
 	mysqli_close($link);
+	print "done!";
 ?>
 --EXPECT--
 int(1)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/045.phpt
+++ b/ext/mysqli/tests/045.phpt
@@ -1,16 +1,16 @@
 --TEST--
-mysqli_bind_result (SHOW)
+mysqli_stmt_bind_result (SHOW)
 --SKIPIF--
-<?php	
+<?php
 	require_once('skipif.inc');
-	require_once('skipifemb.inc'); 
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
 
-	include "connect.inc";
-	$link = mysqli_connect($host, $user, $passwd);
+	require_once("connect.inc");
+	$link = my_mysqli_connect($host, $user, $passwd);
 
-
 	$stmt = mysqli_prepare($link, "SHOW VARIABLES LIKE 'port'");
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
 	if (!$stmt->field_count) {
 		printf("skip SHOW command is not supported in prepared statements.");
@@ -20,27 +20,34 @@
 ?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt = mysqli_prepare($link, "SHOW VARIABLES LIKE 'port'");
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
-	mysqli_bind_result($stmt, $c1, $c2); 	
-	mysqli_fetch($stmt);
-	mysqli_stmt_close($stmt);	
+	mysqli_stmt_bind_result($stmt, $c1, $c2);
+	mysqli_stmt_fetch($stmt);
+	mysqli_stmt_close($stmt);
+	if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && mysqli_get_server_version($link) < 50000) {
+		/* variables are binary */
+		settype($c1, "unicode");
+		settype($c2, "unicode");
+	}
 	$test = array ($c1,$c2);
 
 	var_dump($test);
 
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--EXPECTF--
 array(2) {
   [0]=>
-  string(4) "port"
+  %unicode|string%(4) "port"
   [1]=>
-  string(4) "3306"
+  %unicode|string%(%d) "%s"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/046.phpt
+++ b/ext/mysqli/tests/046.phpt
@@ -1,33 +1,50 @@
 --TEST--
 mysqli_stmt_affected_rows (delete)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS test_affected");
-	mysqli_query($link, "CREATE TABLE test_affected (foo int)");
+	mysqli_query($link, "CREATE TABLE test_affected (foo int) ENGINE=" . $engine);
 
 	mysqli_query($link, "INSERT INTO test_affected VALUES (1),(2),(3),(4),(5)");
 
 	$stmt = mysqli_prepare($link, "DELETE FROM test_affected WHERE foo=?");
-	mysqli_bind_param($stmt, "i", $c1);
+	mysqli_stmt_bind_param($stmt, "i", $c1);
 
 	$c1 = 2;
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	$x = mysqli_stmt_affected_rows($stmt);
 
-	mysqli_stmt_close($stmt);	
+	mysqli_stmt_close($stmt);
 	var_dump($x==1);
 
+	mysqli_query($link, "DROP TABLE IF EXISTS test_affected");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_affected"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 bool(true)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/047.phpt
+++ b/ext/mysqli/tests/047.phpt
@@ -1,24 +1,27 @@
 --TEST--
-mysqli_get_metadata
+mysqli_stmt_result_metadata
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "DROP TABLE IF EXISTS test_affected");
-	mysqli_query($link, "CREATE TABLE test_affected (foo int, bar varchar(10) character set latin1)");
+	mysqli_query($link, "CREATE TABLE test_affected (foo int, bar varchar(10) character set latin1) ENGINE=" . $engine);
 
 	mysqli_query($link, "INSERT INTO test_affected VALUES (1, 'Zak'),(2, 'Greant')");
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_affected");
-	mysqli_execute($stmt);
-	$result = mysqli_get_metadata($stmt);
+	mysqli_stmt_execute($stmt);
+	$result = mysqli_stmt_result_metadata($stmt);
 
 	echo "\n=== fetch_fields ===\n";
 	var_dump(mysqli_fetch_fields($result));
@@ -31,166 +34,204 @@
 	while ($field = mysqli_fetch_field($result)) {
 		var_dump($field);
 	}
-    
+
 	print_r(mysqli_fetch_lengths($result));
-    
+
 	mysqli_free_result($result);
 
 
-	mysqli_stmt_close($stmt);	
+	mysqli_stmt_close($stmt);
+	mysqli_query($link, "DROP TABLE IF EXISTS test_affected");
 	mysqli_close($link);
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_affected"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECTF--
 === fetch_fields ===
 array(2) {
   [0]=>
-  object(stdClass)#5 (11) {
-    ["name"]=>
-    string(3) "foo"
-    ["orgname"]=>
-    string(3) "foo"
-    ["table"]=>
-    string(13) "test_affected"
-    ["orgtable"]=>
-    string(13) "test_affected"
-    ["def"]=>
-    string(0) ""
-    ["max_length"]=>
+  object(stdClass)#5 (13) {
+    [%u|b%"name"]=>
+    %unicode|string%(3) "foo"
+    [%u|b%"orgname"]=>
+    %unicode|string%(3) "foo"
+    [%u|b%"table"]=>
+    %unicode|string%(13) "test_affected"
+    [%u|b%"orgtable"]=>
+    %unicode|string%(13) "test_affected"
+    [%u|b%"def"]=>
+    %unicode|string%(0) ""
+    [%u|b%"db"]=>
+    %unicode|string%(%d) "%s"
+    [%u|b%"catalog"]=>
+    %unicode|string%(%d) "%s"
+    [%u|b%"max_length"]=>
     int(0)
-    ["length"]=>
+    [%u|b%"length"]=>
     int(%d)
-    ["charsetnr"]=>
+    [%u|b%"charsetnr"]=>
     int(%d)
-    ["flags"]=>
+    [%u|b%"flags"]=>
     int(32768)
-    ["type"]=>
+    [%u|b%"type"]=>
     int(3)
-    ["decimals"]=>
+    [%u|b%"decimals"]=>
     int(0)
   }
   [1]=>
-  object(stdClass)#6 (11) {
-    ["name"]=>
-    string(3) "bar"
-    ["orgname"]=>
-    string(3) "bar"
-    ["table"]=>
-    string(13) "test_affected"
-    ["orgtable"]=>
-    string(13) "test_affected"
-    ["def"]=>
-    string(0) ""
-    ["max_length"]=>
+  object(stdClass)#6 (13) {
+    [%u|b%"name"]=>
+    %unicode|string%(3) "bar"
+    [%u|b%"orgname"]=>
+    %unicode|string%(3) "bar"
+    [%u|b%"table"]=>
+    %unicode|string%(13) "test_affected"
+    [%u|b%"orgtable"]=>
+    %unicode|string%(13) "test_affected"
+    [%u|b%"def"]=>
+    %unicode|string%(0) ""
+    [%u|b%"db"]=>
+    %unicode|string%(%d) "%s"
+    [%u|b%"catalog"]=>
+    %unicode|string%(%d) "%s"
+    [%u|b%"max_length"]=>
     int(0)
-    ["length"]=>
+    [%u|b%"length"]=>
     int(%d)
-    ["charsetnr"]=>
+    [%u|b%"charsetnr"]=>
     int(%d)
-    ["flags"]=>
+    [%u|b%"flags"]=>
     int(0)
-    ["type"]=>
+    [%u|b%"type"]=>
     int(253)
-    ["decimals"]=>
+    [%u|b%"decimals"]=>
     int(0)
   }
 }
 
 === fetch_field_direct ===
-object(stdClass)#6 (11) {
-  ["name"]=>
-  string(3) "foo"
-  ["orgname"]=>
-  string(3) "foo"
-  ["table"]=>
-  string(13) "test_affected"
-  ["orgtable"]=>
-  string(13) "test_affected"
-  ["def"]=>
-  string(0) ""
-  ["max_length"]=>
+object(stdClass)#6 (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(3) "foo"
+  [%u|b%"orgname"]=>
+  %unicode|string%(3) "foo"
+  [%u|b%"table"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
   int(0)
-  ["length"]=>
+  [%u|b%"length"]=>
   int(%d)
-  ["charsetnr"]=>
+  [%u|b%"charsetnr"]=>
   int(%d)
-  ["flags"]=>
+  [%u|b%"flags"]=>
   int(32768)
-  ["type"]=>
+  [%u|b%"type"]=>
   int(3)
-  ["decimals"]=>
+  [%u|b%"decimals"]=>
   int(0)
 }
-object(stdClass)#6 (11) {
-  ["name"]=>
-  string(3) "bar"
-  ["orgname"]=>
-  string(3) "bar"
-  ["table"]=>
-  string(13) "test_affected"
-  ["orgtable"]=>
-  string(13) "test_affected"
-  ["def"]=>
-  string(0) ""
-  ["max_length"]=>
+object(stdClass)#6 (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(3) "bar"
+  [%u|b%"orgname"]=>
+  %unicode|string%(3) "bar"
+  [%u|b%"table"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
   int(0)
-  ["length"]=>
+  [%u|b%"length"]=>
   int(%d)
-  ["charsetnr"]=>
+  [%u|b%"charsetnr"]=>
   int(%d)
-  ["flags"]=>
+  [%u|b%"flags"]=>
   int(0)
-  ["type"]=>
+  [%u|b%"type"]=>
   int(253)
-  ["decimals"]=>
+  [%u|b%"decimals"]=>
   int(0)
 }
 
 === fetch_field ===
-object(stdClass)#6 (11) {
-  ["name"]=>
-  string(3) "foo"
-  ["orgname"]=>
-  string(3) "foo"
-  ["table"]=>
-  string(13) "test_affected"
-  ["orgtable"]=>
-  string(13) "test_affected"
-  ["def"]=>
-  string(0) ""
-  ["max_length"]=>
+object(stdClass)#6 (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(3) "foo"
+  [%u|b%"orgname"]=>
+  %unicode|string%(3) "foo"
+  [%u|b%"table"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
   int(0)
-  ["length"]=>
+  [%u|b%"length"]=>
   int(%d)
-  ["charsetnr"]=>
+  [%u|b%"charsetnr"]=>
   int(%d)
-  ["flags"]=>
+  [%u|b%"flags"]=>
   int(32768)
-  ["type"]=>
+  [%u|b%"type"]=>
   int(3)
-  ["decimals"]=>
+  [%u|b%"decimals"]=>
   int(0)
 }
-object(stdClass)#5 (11) {
-  ["name"]=>
-  string(3) "bar"
-  ["orgname"]=>
-  string(3) "bar"
-  ["table"]=>
-  string(13) "test_affected"
-  ["orgtable"]=>
-  string(13) "test_affected"
-  ["def"]=>
-  string(0) ""
-  ["max_length"]=>
+object(stdClass)#5 (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(3) "bar"
+  [%u|b%"orgname"]=>
+  %unicode|string%(3) "bar"
+  [%u|b%"table"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(13) "test_affected"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
   int(0)
-  ["length"]=>
+  [%u|b%"length"]=>
   int(%d)
-  ["charsetnr"]=>
+  [%u|b%"charsetnr"]=>
   int(%d)
-  ["flags"]=>
+  [%u|b%"flags"]=>
   int(0)
-  ["type"]=>
+  [%u|b%"type"]=>
   int(253)
-  ["decimals"]=>
+  [%u|b%"decimals"]=>
   int(0)
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/048.phpt
+++ b/ext/mysqli/tests/048.phpt
@@ -1,29 +1,32 @@
 --TEST--
-mysqli bind_result (OO-Style) 
+mysqli bind_result (OO-Style)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$mysql = mysqli_connect($host, $user, $passwd);
+	$mysql = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	$mysql->select_db("test");		
+	$mysql->select_db($db);
 	$mysql->query("DROP TABLE IF EXISTS test_fetch_null");
 
-  	$mysql->query("CREATE TABLE test_fetch_null(col1 tinyint, col2 smallint,
-                                                       col3 int, col4 bigint, 
-                                                       col5 float, col6 double,
-                                                       col7 date, col8 time, 
-                                                       col9 varbinary(10), 
-                                                       col10 varchar(50),
-                                                       col11 char(20))");
-  
+	$mysql->query("CREATE TABLE test_fetch_null(col1 tinyint, col2 smallint,
+		col3 int, col4 bigint,
+		col5 float, col6 double,
+		col7 date, col8 time,
+		col9 varbinary(10),
+		col10 varchar(50),
+		col11 char(20)) ENGINE=" . $engine);
+
 	$mysql->query("INSERT INTO test_fetch_null(col1,col10, col11) VALUES(1,'foo1', 1000),(2,'foo2', 88),(3,'foo3', 389789)");
 
 	$stmt = $mysql->prepare("SELECT col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11 from test_fetch_null");
-	$stmt->bind_result($c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8, $c9, $c10, $c11); 
+	$stmt->bind_result($c1, $c2, $c3, $c4, $c5, $c6, $c7, $c8, $c9, $c10, $c11);
 	$stmt->execute();
 
 	$stmt->fetch();
@@ -33,9 +36,22 @@
 	var_dump($test);
 
 	$stmt->close();
+	$mysql->query("DROP TABLE IF EXISTS test_fetch_null");
 	$mysql->close();
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_fetch_null"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(11) {
   [0]=>
   int(1)
@@ -56,7 +72,8 @@
   [8]=>
   NULL
   [9]=>
-  string(4) "foo1"
+  %unicode|string%(4) "foo1"
   [10]=>
-  string(4) "1000"
+  %unicode|string%(4) "1000"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/049.phpt
+++ b/ext/mysqli/tests/049.phpt
@@ -1,26 +1,33 @@
 --TEST--
-mysql_fetch_row (OO-Style) 
+mysql_fetch_row (OO-Style)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$mysql = mysqli_connect($host, $user, $passwd);
+	$mysql = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	$mysql->select_db("test");		
+	$mysql->select_db($db);
 	$result = $mysql->query("SELECT DATABASE()");
 	$row = $result->fetch_row();
 	$result->close();
 
 	var_dump($row);
+	if ($row[0] != $db)
+		printf("[001] Expecting '%s' got '%s'\n", $db, $row[0]);
 
 	$mysql->close();
+	print "done!";
 ?>
---EXPECT--
+--EXPECTF--
 array(1) {
   [0]=>
-  string(4) "test"
+  %unicode|string%(%d) "%s"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/050.phpt
+++ b/ext/mysqli/tests/050.phpt
@@ -1,18 +1,21 @@
 --TEST--
-non freed statement test 
+non freed statement test
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/************************
 	 * non freed stamement
 	 ************************/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt = mysqli_prepare($link, "SELECT CURRENT_USER()");
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
 	mysqli_close($link);
 	printf("Ok\n");
--- a/ext/mysqli/tests/051.phpt
+++ b/ext/mysqli/tests/051.phpt
@@ -1,18 +1,21 @@
 --TEST--
-free statement after close 
+free statement after close
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/************************
-	 * free statement after close 
+	 * free statement after close
 	 ************************/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt1 = mysqli_prepare($link, "SELECT CURRENT_USER()");
-	mysqli_execute($stmt1);
+	mysqli_stmt_execute($stmt1);
 
 	mysqli_close($link);
 	@mysqli_stmt_close($stmt1);
--- a/ext/mysqli/tests/052.phpt
+++ b/ext/mysqli/tests/052.phpt
@@ -1,20 +1,23 @@
 --TEST--
 call statement after close
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/************************
-	 * statement call  after close 
+	 * statement call  after close
 	 ************************/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt2 = mysqli_prepare($link, "SELECT CURRENT_USER()");
 
 	mysqli_close($link);
-	@mysqli_execute($stmt2);
+	@mysqli_stmt_execute($stmt2);
 	@mysqli_stmt_close($stmt2);
 	printf("Ok\n");
 ?>
--- a/ext/mysqli/tests/053.phpt
+++ b/ext/mysqli/tests/053.phpt
@@ -1,15 +1,18 @@
 --TEST--
-not freed resultset 
+not freed resultset
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/************************
-	 * non freed resultset 
+	 * non freed resultset
 	 ************************/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$result = mysqli_query($link, "SELECT CURRENT_USER()");
 	mysqli_close($link);
--- a/ext/mysqli/tests/054.phpt
+++ b/ext/mysqli/tests/054.phpt
@@ -1,15 +1,18 @@
 --TEST--
-free resultset after close 
+free resultset after close
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/************************
-	 * free resultset after close 
+	 * free resultset after close
 	 ************************/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$result1 = mysqli_query($link, "SELECT CURRENT_USER()");
 	mysqli_close($link);
--- a/ext/mysqli/tests/055.phpt
+++ b/ext/mysqli/tests/055.phpt
@@ -1,15 +1,18 @@
 --TEST--
-free nothing 
+free nothing
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/************************
-	 * don't free anything 
+	 * don't free anything
 	 ************************/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$result2 = mysqli_query($link, "SELECT CURRENT_USER()");
 	$stmt2 = mysqli_prepare($link, "SELECT CURRENT_USER()");
--- a/ext/mysqli/tests/056.phpt
+++ b/ext/mysqli/tests/056.phpt
@@ -1,21 +1,24 @@
 --TEST--
-extend mysqli 
+extend mysqli
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
 	class foobar extends mysqli {
 		function test () {
-			return ("I like MySQL 4.1");
+			return ("I do not like MySQL 4.1");
 		}
 	}
 
 	$foo = new foobar();
-	$foo->connect($host, $user, $passwd);
+	$foo->connect($host, $user, $passwd, $db, $port, $socket);
 	$foo->close();
 	printf("%s\n", $foo->test());
 ?>
 --EXPECT--
-I like MySQL 4.1
+I do not like MySQL 4.1
--- a/ext/mysqli/tests/057.phpt
+++ b/ext/mysqli/tests/057.phpt
@@ -1,23 +1,26 @@
 --TEST--
-mysqli_get_metadata
+mysqli_stmt_result_metadata
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_store_result");
-  	mysqli_query($link,"CREATE TABLE test_store_result (a int)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_store_result");
+	mysqli_query($link,"CREATE TABLE test_store_result (a int)");
 
 	mysqli_query($link, "INSERT INTO test_store_result VALUES (1),(2),(3)");
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_store_result");
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
 	/* this should produce an out of sync error */
 	if ($result = mysqli_query($link, "SELECT * FROM test_store_result")) {
@@ -26,9 +29,22 @@
 	}
 	mysqli_stmt_close($stmt);
 
+	/* now we should try mysqli_stmt_reset() */
 	$stmt = mysqli_prepare($link, "SELECT * FROM test_store_result");
-	mysqli_execute($stmt);
-	$result1 = mysqli_get_metadata($stmt);
+	var_dump(mysqli_stmt_execute($stmt));
+	var_dump(mysqli_stmt_reset($stmt));
+
+	var_dump($stmt = mysqli_prepare($link, "SELECT * FROM test_store_result"));
+	if ($IS_MYSQLND && $stmt->affected_rows !== -1)
+			printf("[001] Expecting -1, got %d\n", $stmt->affected_rows);
+
+	var_dump(mysqli_stmt_execute($stmt));
+	var_dump($stmt = @mysqli_prepare($link, "SELECT * FROM test_store_result"), mysqli_error($link));
+	var_dump(mysqli_stmt_reset($stmt));
+
+	$stmt = mysqli_prepare($link, "SELECT * FROM test_store_result");
+	mysqli_stmt_execute($stmt);
+	$result1 = mysqli_stmt_result_metadata($stmt);
 	mysqli_stmt_store_result($stmt);
 
 	printf ("Rows: %d\n", mysqli_stmt_affected_rows($stmt));
@@ -37,18 +53,58 @@
 	if ($result = mysqli_query($link, "SELECT * FROM test_store_result")) {
 		$row = mysqli_fetch_row($result);
 		mysqli_free_result($result);
-	} 
-	
+	}
 
-	var_dump($row);	
+	var_dump($row);
 
 	mysqli_free_result($result1);
 	mysqli_stmt_close($stmt);
 	mysqli_close($link);
+	echo "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_store_result"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+object(mysqli_stmt)#%d (%d) {
+  [%u|b%"affected_rows"]=>
+  int(%i)
+  [%u|b%"insert_id"]=>
+  int(0)
+  [%u|b%"num_rows"]=>
+  int(0)
+  [%u|b%"param_count"]=>
+  int(0)
+  [%u|b%"field_count"]=>
+  int(1)
+  [%u|b%"errno"]=>
+  int(0)
+  [%u|b%"error"]=>
+  %unicode|string%(0) ""
+  [%u|b%"sqlstate"]=>
+  %unicode|string%(5) "00000"
+  [%u|b%"id"]=>
+  int(3)
+}
+bool(true)
+bool(false)
+%unicode|string%(0) ""
+
+Warning: mysqli_stmt_reset() expects parameter 1 to be mysqli_stmt, boolean given in %s on line %d
+NULL
 Rows: 3
 array(1) {
   [0]=>
-  string(1) "1"
+  %unicode|string%(1) "1"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/058.phpt
+++ b/ext/mysqli/tests/058.phpt
@@ -1,57 +1,73 @@
 --TEST--
 multiple binds
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS mbind");
-  	mysqli_query($link,"CREATE TABLE mbind (a int, b varchar(10))");
+	mysqli_query($link,"DROP TABLE IF EXISTS mbind");
+	mysqli_query($link,"CREATE TABLE mbind (a int, b varchar(10))");
 
 	$stmt = mysqli_prepare($link, "INSERT INTO mbind VALUES (?,?)");
-	
-	mysqli_bind_param($stmt, "is", $a, $b);
 
+	mysqli_stmt_bind_param($stmt, "is", $a, $b);
+
 	$a = 1;
 	$b = "foo";
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
-	mysqli_bind_param($stmt, "is", $c, $d);
+	mysqli_stmt_bind_param($stmt, "is", $c, $d);
 
 	$c = 2;
 	$d = "bar";
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM mbind");
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
-	mysqli_bind_result($stmt, $e, $f);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $e, $f);
+	mysqli_stmt_fetch($stmt);
 
-	mysqli_bind_result($stmt, $g, $h);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $g, $h);
+	mysqli_stmt_fetch($stmt);
 
 	var_dump((array($e,$f,$g,$h)));
 
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS mbind"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 array(4) {
   [0]=>
   int(1)
   [1]=>
-  string(3) "foo"
+  %unicode|string%(3) "foo"
   [2]=>
   int(2)
   [3]=>
-  string(3) "bar"
+  %unicode|string%(3) "bar"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/059.phpt
+++ b/ext/mysqli/tests/059.phpt
@@ -1,41 +1,57 @@
 --TEST--
 sqlmode + bind
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 
 	mysqli_query($link, "SET SQL_MODE='PIPES_AS_CONCAT'");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS mbind");
-  	mysqli_query($link,"CREATE TABLE mbind (b varchar(25))");
+	mysqli_query($link,"DROP TABLE IF EXISTS mbind");
+	mysqli_query($link,"CREATE TABLE mbind (b varchar(25))");
 
 	$stmt = mysqli_prepare($link, "INSERT INTO mbind VALUES (?||?)");
-	
-	mysqli_bind_param($stmt, "ss", $a, $b);
 
+	mysqli_stmt_bind_param($stmt, "ss", $a, $b);
+
 	$a = "foo";
 	$b = "bar";
 
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
 	mysqli_stmt_close($stmt);
 
 	$stmt = mysqli_prepare($link, "SELECT * FROM mbind");
-	mysqli_execute($stmt);
+	mysqli_stmt_execute($stmt);
 
-	mysqli_bind_result($stmt, $e);
-	mysqli_fetch($stmt);
+	mysqli_stmt_bind_result($stmt, $e);
+	mysqli_stmt_fetch($stmt);
 
 	var_dump($e);
 
 	mysqli_close($link);
+	print "done!";
 ?>
---EXPECT--
-string(6) "foobar"
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS mbind"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+%unicode|string%(6) "foobar"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/060.phpt
+++ b/ext/mysqli/tests/060.phpt
@@ -1,60 +1,74 @@
 --TEST--
 mysqli_fetch_object with classes
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	class test_class {
 		function __construct($arg1, $arg2) {
 			echo __METHOD__ . "($arg1,$arg2)\n";
 		}
 	}
-	
+
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
-	mysqli_select_db($link, "test");
+	mysqli_select_db($link, $db);
 	mysqli_query($link, "SET sql_mode=''");
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS test_fetch");
-  	mysqli_query($link,"CREATE TABLE test_fetch(c1 smallint unsigned,
-                                                     c2 smallint unsigned,
-                                                     c3 smallint,
-                                                     c4 smallint,
-                                                     c5 smallint,
-                                                     c6 smallint unsigned,
-                                                     c7 smallint)");
+	mysqli_query($link,"DROP TABLE IF EXISTS test_fetch");
+	mysqli_query($link,"CREATE TABLE test_fetch(c1 smallint unsigned,
+		c2 smallint unsigned,
+		c3 smallint,
+		c4 smallint,
+		c5 smallint,
+		c6 smallint unsigned,
+		c7 smallint)");
 
-	mysqli_query($link, "INSERT INTO test_fetch VALUES ( -23, 35999, NULL, -500, -9999999, -0, 0)"); 
+	mysqli_query($link, "INSERT INTO test_fetch VALUES ( -23, 35999, NULL, -500, -9999999, -0, 0)");
 
-	$result = mysqli_query($link, "SELECT * FROM test_bind_fetch");
+	$result = mysqli_query($link, "SELECT * FROM test_fetch");
 	$test = mysqli_fetch_object($result, 'test_class', array(1, 2));
 	mysqli_free_result($result);
 
 	var_dump($test);
 
 	mysqli_close($link);
-	
+
 	echo "Done\n";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECTF--
 test_class::__construct(1,2)
 object(test_class)#%d (7) {
-  ["c1"]=>
-  string(1) "0"
-  ["c2"]=>
-  string(5) "35999"
-  ["c3"]=>
+  [%u|b%"c1"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"c2"]=>
+  %unicode|string%(5) "35999"
+  [%u|b%"c3"]=>
   NULL
-  ["c4"]=>
-  string(4) "-500"
-  ["c5"]=>
-  string(6) "-32768"
-  ["c6"]=>
-  string(1) "0"
-  ["c7"]=>
-  string(1) "0"
+  [%u|b%"c4"]=>
+  %unicode|string%(4) "-500"
+  [%u|b%"c5"]=>
+  %unicode|string%(6) "-32768"
+  [%u|b%"c6"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"c7"]=>
+  %unicode|string%(1) "0"
 }
-Done
+Done
\ No newline at end of file
--- a/ext/mysqli/tests/061.phpt
+++ b/ext/mysqli/tests/061.phpt
@@ -1,46 +1,78 @@
 --TEST--
 local infile handler
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+if (!$link)
+	die(sprintf("skip Can't connect [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
 	function my_read($fp, &$buffer, $buflen, &$error) {
 		$buffer = strrev(fread($fp, $buflen));
 		return(strlen($buffer));
 	}
-	
-	/*** test mysqli_real_connect 127.0.0.1 ***/
-	$link = mysqli_init();
-	mysqli_options($link, MYSQLI_OPT_LOCAL_INFILE, 1);
-	mysqli_real_connect($link, $host, $user, $passwd, "test");
 
+	/*** test mysqli_connect 127.0.0.1 ***/
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+
 	/* create temporary file */
-	$filename = dirname(__FILE__) . "/061.csv";
+	$filename = dirname(__FILE__) . "061.csv";
 	$fp = fopen($filename, "w");
-	fwrite($fp, "foo;bar");
+	fwrite($fp, b"foo;bar");
 	fclose($fp);
 
-  	mysqli_query($link,"DROP TABLE IF EXISTS t_061");
-  	mysqli_query($link,"CREATE TABLE t_061 (c1 varchar(10), c2 varchar(10))");
+	if (!mysqli_query($link,"DROP TABLE IF EXISTS t_061"))
+		printf("Cannot drop table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	if (!mysqli_query($link,"CREATE TABLE t_061 (c1 varchar(10), c2 varchar(10))"))
+		printf("Cannot create table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
-	mysqli_query($link, "LOAD DATA LOCAL INFILE '{$filename}' INTO TABLE t_061 FIELDS TERMINATED BY ';'"); 
+	if (!mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE t_061 FIELDS TERMINATED BY ';'", mysqli_real_escape_string($link, $filename))))
+		printf("Cannot load data: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
 	mysqli_set_local_infile_handler($link, "my_read");
-	mysqli_query($link, "LOAD DATA LOCAL INFILE '{$filename}' INTO TABLE t_061 FIELDS TERMINATED BY ';'"); 
+	if (!mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE t_061 FIELDS TERMINATED BY ';'", mysqli_real_escape_string($link, $filename))))
+		printf("Cannot load data using infile handler: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
 
 	if ($result = mysqli_query($link, "SELECT c1,c2 FROM t_061")) {
 		while (($row = mysqli_fetch_row($result))) {
 			printf("%s-%s\n", $row[0], $row[1]);
+			printf("%s-%s\n", gettype($row[0]), gettype($row[1]));
 		}
 		mysqli_free_result($result);
 	}
 
 	mysqli_close($link);
 	unlink($filename);
+	print "done!";
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS t_061"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 foo-bar
+%unicode|string%-%unicode|string%
 rab-oof
+%unicode|string%-%unicode|string%
+done!
--- a/ext/mysqli/tests/062.phpt
+++ b/ext/mysqli/tests/062.phpt
@@ -1,12 +1,15 @@
 --TEST--
-resultset constructor 
+resultset constructor
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd);
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$mysql->real_query("SELECT 'foo' FROM DUAL");
 
@@ -17,9 +20,11 @@
 	$mysql->close();
 
 	var_dump($row);
+	print "done!";
 ?>
---EXPECT--
+--EXPECTF--
 array(1) {
   [0]=>
-  string(3) "foo"
+  %unicode|string%(3) "foo"
 }
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/063.phpt
+++ b/ext/mysqli/tests/063.phpt
@@ -1,12 +1,15 @@
 --TEST--
-resultset constructor 
+resultset constructor
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd);
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt = new mysqli_stmt($mysql, "SELECT 'foo' FROM DUAL");
 	$stmt->execute();
@@ -17,5 +20,5 @@
 
 	var_dump($foo);
 ?>
---EXPECT--
-string(3) "foo"
+--EXPECTF--
+%unicode|string%(3) "foo"
\ No newline at end of file
--- a/ext/mysqli/tests/064.phpt
+++ b/ext/mysqli/tests/064.phpt
@@ -1,12 +1,15 @@
 --TEST--
-NULL binding 
+NULL binding
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd);
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt = new mysqli_stmt($mysql, "SELECT NULL FROM DUAL");
 	$stmt->execute();
--- a/ext/mysqli/tests/065.phpt
+++ b/ext/mysqli/tests/065.phpt
@@ -1,44 +1,55 @@
 --TEST--
-set character set 
+set character set
 --SKIPIF--
-<?php 
-require_once('skipif.inc'); 
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
 if (!function_exists('mysqli_set_charset')) {
 	die('skip mysqli_set_charset() not available');
 }
-if (!mysqli_set_charset($con, "gbh") && mysqli_errno($con) == 2019) {
-    die('skip mysql compiled without gbh charset support');
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip set character set not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
 }
 ?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd);
-	mysqli_query($mysql, "SET sql_mode=''");
+	if (!$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
 
+	if (!mysqli_query($mysql, "SET sql_mode=''"))
+		printf("[002] Cannot set SQL-Mode, [%d] %s\n", mysqli_errno($mysql), mysqli_error($mysql));
+
 	$esc_str = chr(0xbf) . chr(0x5c);
+	$len = $charset = array();
+	$tmp = null;
 
 	if ($mysql->set_charset("latin1")) {
 		/* 5C should be escaped */
-		$len[0] = strlen($mysql->real_escape_string($esc_str));
-		$charset[0] = $mysql->client_encoding();
-	}
+		if (3 !== ($tmp = strlen($mysql->real_escape_string($esc_str))))
+			printf("[003] Expecting 3/int got %s/%s\n", gettype($tmp), $tmp);
 
-	if ($mysql->set_charset("gbk")) {
-		/* nothing should be escaped, it's a valid gbk character */
-		$len[1] = strlen($mysql->real_escape_string($esc_str));
-		$charset[1] = $mysql->client_encoding();
+		if ('latin1' !== ($tmp = $mysql->character_set_name()))
+			printf("[004] Expecting latin1/string got %s/%s\n", gettype($tmp), $tmp);
 	}
 
+	if ($res = $mysql->query("SHOW CHARACTER SET LIKE 'gbk'")) {
+		$res->free_result();
+		if ($mysql->set_charset("gbk")) {
+			/* nothing should be escaped, it's a valid gbk character */
+
+			if (2 !== ($tmp = strlen($mysql->real_escape_string($esc_str))))
+					printf("[005] Expecting 2/int got %s/%s\n", gettype($tmp), $tmp);
+
+			if ('gbk' !== ($tmp = $mysql->character_set_name()))
+					printf("[005] Expecting gbk/string got %s/%s\n", gettype($tmp), $tmp);;
+		}
+	}
 	$mysql->close();
-	var_dump($len[0]);
-	var_dump($len[1]);
-	var_dump($charset[0]);
-	var_dump($charset[1]);
+
+	print "done!";
 ?>
 --EXPECT--
-int(3)
-int(2)
-string(6) "latin1"
-string(3) "gbk"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/066.phpt
+++ b/ext/mysqli/tests/066.phpt
@@ -1,28 +1,43 @@
 --TEST--
 function test: mysqli_warning object
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+	require_once("connect.inc");
 
-	include "connect.inc";
-	
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$mysql->query("DROP TABLE IF EXISTS test_warnings");
 
-	$mysql->query("CREATE TABLE test_warnings (a int not null)");
+	$mysql->query("CREATE TABLE test_warnings (a int not null) ENGINE=myisam");
 
 	$mysql->query("INSERT INTO test_warnings VALUES (1),(2),(NULL)");
-	
-	if (($warning = new mysqli_warning($mysql))) {
+
+	if (($warning = $mysql->get_warnings())) {
 		do {
 			printf("Warning\n");
 		} while ($warning->next());
 	}
 
 	$mysql->close();
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_warnings"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECT--
 Warning
+done!
--- a/ext/mysqli/tests/067.phpt
+++ b/ext/mysqli/tests/067.phpt
@@ -1,38 +1,55 @@
 --TEST--
 function test: nested selects (cursors)
 --SKIPIF--
-<?php 
-	require_once('skipif.inc'); 
+<?php
+	require_once('skipif.inc');
+	require_once('skipifconnectfailure.inc');
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		die("skip Cannot connect to check required version");
+
 	/* skip cursor test for versions < 50004 */
-	if (mysqli_get_client_version() < 50009) {
-		die("skip Client library doesn't support cursors");	
+	if ((!$IS_MYSQLND && (mysqli_get_client_version() < 50009)) ||
+			(mysqli_get_server_version($link) < 50009)) {
+			die(sprintf("skip Client library doesn't support cursors (%s/%s)",
+					mysqli_get_client_version(), mysqli_get_server_version($link)));
 	}
+	mysqli_close($link);
 ?>
 --FILE--
 <?php
-
 	function open_cursor($mysql, $query) {
-		$stmt = $mysql->prepare($query);
+		if (!is_object($stmt = $mysql->prepare($query))) {
+			printf("[001] Cannot create statement object for '%s', [%d] %s\n",
+					$query, $mysql->errno, $mysql->error);
+		}
+
 		$stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_READ_ONLY);
 		return $stmt;
 	}
 
-	include "connect.inc";
+	require_once("connect.inc");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+
+	if ((!$IS_MYSQLND && mysqli_get_client_version() < 50009) ||
+		(mysqli_get_server_version($mysql) < 50009)) {
+		/* we really want to skip it... */
+		die(var_dump(63));
+	}
+
 	$a = array();
-	
-	/*** test mysqli_connect 127.0.0.1 ***/
-	$mysql = new mysqli($host, $user, $passwd, "test");
 
 	for ($i=0;$i < 3; $i++) {
 		$mysql->query("DROP TABLE IF EXISTS cursor$i");
-		$mysql->query("CREATE TABLE cursor$i (a int not null)");
+		$mysql->query("CREATE TABLE cursor$i (a int not null) ENGINE=" . $engine);
 		$mysql->query("INSERT INTO cursor$i VALUES (1),(2),(3),(4),(5),(6)");
 		$stmt[$i] = open_cursor($mysql, "SELECT a FROM cursor$i");
 		$stmt[$i]->execute();
 		$stmt[$i]->bind_result($a[$i]);
 	}
 
-	
+
 	$cnt = 0;
 	while ($stmt[0]->fetch()) {
 		$stmt[1]->fetch();
@@ -47,5 +64,18 @@
 	$mysql->close();
 	var_dump($cnt);
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+for ($i =0; $i < 3; $i++) {
+	if (!mysqli_query($link, sprintf("DROP TABLE IF EXISTS cursor%d", $i)))
+		printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+}
+
+mysqli_close($link);
+?>
 --EXPECT--
-int(63)
+int(63)
\ No newline at end of file
--- a/ext/mysqli/tests/068.phpt
+++ b/ext/mysqli/tests/068.phpt
@@ -1,33 +1,11 @@
 --TEST--
-mysqli_autocommit() tests
+mysqli get_client_info
 --SKIPIF--
-<?php 
-	require_once('skipif.inc'); 
-?>
+<?php	require_once('skipif.inc'); ?>
 --FILE--
 <?php
-
-include "connect.inc";
-
-$mysqli = new mysqli($host, $user, $passwd, "test");
-
-var_dump($mysqli->autocommit(false));
-$result = $mysqli->query("SELECT @@autocommit");
-var_dump($result->fetch_row());
-
-var_dump($mysqli->autocommit(true));
-$result = $mysqli->query("SELECT @@autocommit");
-var_dump($result->fetch_row());
-
+	$s = mysqli_get_client_info();
+	echo gettype($s);
 ?>
---EXPECT--
-bool(true)
-array(1) {
-  [0]=>
-  string(1) "0"
-}
-bool(true)
-array(1) {
-  [0]=>
-  string(1) "1"
-}
+--EXPECTF--
+%unicode|string%
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/069.phpt
@@ -0,0 +1,38 @@
+--TEST--
+mysqli multi_query, next_result, more_results
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	$mysql->multi_query('SELECT 1;SELECT 2');
+	do {
+		$res = $mysql->store_result();
+		if ($mysql->errno == 0) {
+			while ($arr = $res->fetch_assoc()) {
+				var_dump($arr);
+			}
+			$res->free();
+		}
+		if (!$mysql->more_results()) {
+			break;
+		}
+	} while (@$mysql->next_result());
+	$mysql->close();
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [1]=>
+  %unicode|string%(1) "1"
+}
+array(1) {
+  [2]=>
+  %unicode|string%(1) "2"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/070.phpt
@@ -0,0 +1,19 @@
+--TEST--
+mysqli ping
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	var_dump($mysql->ping());
+	$mysql->close();
+	print "done!";
+?>
+--EXPECT--
+bool(true)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/071.phpt
+++ b/ext/mysqli/tests/071.phpt
@@ -1,36 +1,74 @@
 --TEST--
 mysqli thread_id & kill
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	$version = $mysql->server_version;
 
 	var_dump($mysql->ping());
 
-	var_dump($mysql->kill($mysql->thread_id));
+	$ret = $mysql->kill($mysql->thread_id);
+	if ($IS_MYSQLND) {
+		if ($ret !== true){
+			printf("[001] Expecting boolean/true got %s/%s\n", gettype($ret), var_export($ret, true));
+		}
+	} else {
+		/* libmysql return value seems to depend on server version */
+		if ((($version >= 50123) || ($version <= 40200)) && $version != 50200) {
+			/* TODO: find exact version */
+			if ($ret !== true){
+				printf("[001] Expecting boolean/true got %s/%s @\n", gettype($ret), var_export($ret, true), $version);
+			}
+		} else {
+			if ($ret !== false){
+				printf("[001] Expecting boolean/false got %s/%s @\n", gettype($ret), var_export($ret, true), $version);
+			}
+		}
+	}
 
 	var_dump($mysql->ping());
 
 	$mysql->close();
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	var_dump(mysqli_ping($mysql));
 
-	var_dump(mysqli_kill($mysql, mysqli_thread_id($mysql)));
+	$ret = $mysql->kill($mysql->thread_id);
+	if ($IS_MYSQLND) {
+		if ($ret !== true){
+			printf("[002] Expecting boolean/true got %s/%s\n", gettype($ret), var_export($ret, true));
+		}
+	} else {
+		/* libmysql return value seems to depend on server version */
+		if ((($version >= 50123) || ($version <= 40200)) && $version != 50200) {
+			/* TODO: find exact version */
+			if ($ret !== true){
+				printf("[002] Expecting boolean/true got %s/%s @\n", gettype($ret), var_export($ret, true), $version);
+			}
+		} else {
+			if ($ret !== false){
+			printf("[002] Expecting boolean/false got %s/%s @\n", gettype($ret), var_export($ret, true), $version);
+			}
+		}
+	}
 
 	var_dump(mysqli_ping($mysql));
 
 	$mysql->close();
+	print "done!";
 ?>
 --EXPECT--
 bool(true)
-bool(true)
 bool(false)
 bool(true)
-bool(true)
 bool(false)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/072.phpt
+++ b/ext/mysqli/tests/072.phpt
@@ -1,13 +1,15 @@
 --TEST--
 mysqli warning_count, get_warnings
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php die('skip mysqli_warning class not functional yet?'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$mysql->query("DROP TABLE IF EXISTS not_exists");
 
@@ -17,11 +19,14 @@
 
 	var_dump($w->errno);
 	var_dump($w->message);
-#	var_dump($w->sqlstate);
+	var_dump($w->sqlstate);
 
 	$mysql->close();
+	echo "done!"
 ?>
---EXPECT--
-1
-1051
-Unknown table 'not_exists'
\ No newline at end of file
+--EXPECTF--
+int(1)
+int(1051)
+%unicode|string%(%d) "Unknown table %snot_exists%s"
+%unicode|string%(5) "HY000"
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/073.phpt
+++ b/ext/mysqli/tests/073.phpt
@@ -4,20 +4,21 @@
 <?php require_once('skipif.inc'); ?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-    var_dump( $driver->embedded);
-    var_dump( $driver->client_version);
-    var_dump( $driver->client_info);
-    var_dump( $driver->driver_version);
-	var_dump( $driver->reconnect);
-	var_dump( $driver->report_mode);
-    
+	var_dump($driver->embedded);
+	var_dump($driver->client_version);
+	var_dump($driver->client_info);
+	var_dump($driver->driver_version);
+	var_dump($driver->reconnect);
+	var_dump($driver->report_mode);
+	print "done!";
 ?>
 --EXPECTF--
 bool(%s)
 int(%d)
-string(%d) "%s"
+%unicode|string%(%d) "%s"
 int(%d)
 bool(%s)
 int(%d)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/074.phpt
@@ -0,0 +1,34 @@
+--TEST--
+mysqli_autocommit() tests
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+
+	require_once("connect.inc");
+
+	$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+
+	var_dump($mysqli->autocommit(false));
+	$result = $mysqli->query("SELECT @@autocommit");
+	var_dump($result->fetch_row());
+
+	var_dump($mysqli->autocommit(true));
+	$result = $mysqli->query("SELECT @@autocommit");
+	var_dump($result->fetch_row());
+
+?>
+--EXPECTF--
+bool(true)
+array(1) {
+  [0]=>
+  %unicode|string%(1) "0"
+}
+bool(true)
+array(1) {
+  [0]=>
+  %unicode|string%(1) "1"
+}
\ No newline at end of file
--- a/ext/mysqli/tests/bug28817.phpt
+++ b/ext/mysqli/tests/bug28817.phpt
@@ -1,11 +1,14 @@
 --TEST--
 Bug #28817 (problems with properties declared in the class extending MySQLi)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	class my_mysql extends mysqli {
 		public $p_test;
 
@@ -21,19 +24,19 @@
 	var_dump($mysql->p_test);
 	@var_dump($mysql->errno);
 
-	$mysql->connect($host, $user, $passwd);
+	$mysql->connect($host, $user, $passwd, $db, $port, $socket);
 	$mysql->select_db("nonexistingdb");
 
 	var_dump($mysql->errno > 0);
 
-	$mysql->close();	
+	$mysql->close();
 ?>
 --EXPECTF--
 array(2) {
   [0]=>
-  string(3) "foo"
+  %s(3) "foo"
   [1]=>
-  string(3) "bar"
+  %s(3) "bar"
 }
 NULL
-bool(true)
+bool(true)
\ No newline at end of file
--- a/ext/mysqli/tests/bug29311.phpt
+++ b/ext/mysqli/tests/bug29311.phpt
@@ -1,48 +1,51 @@
 --TEST--
-constructor test
+Bug #29311 (Cannot override mysqli constructor)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	/* class 1 calls parent constructor */
 	class mysql1 extends mysqli {
 		function __construct() {
-			global $host, $user, $passwd;
-			parent::__construct($host, $user, $passwd, "test");
+			global $host, $user, $passwd, $db, $port, $socket;
+			parent::__construct($host, $user, $passwd, $db, $port, $socket);
 		}
 	}
 
 	/* class 2 has an own constructor */
 	class mysql2 extends mysqli {
-		
+
 		function __construct() {
-			global $host, $user, $passwd;
-			$this->connect($host, $user, $passwd, "test");
+			global $host, $user, $passwd, $db, $port, $socket;
+			$this->connect($host, $user, $passwd, $db, $port, $socket);
 		}
 	}
 
 	/* class 3 has no constructor */
 	class mysql3 extends mysqli {
-		
+
 	}
 
-	$foo[0] = new mysql1();	
-	$foo[1] = new mysql2();	
-	$foo[2] = new mysql3($host, $user, $passwd, "test");
+	$foo[0] = new mysql1();
+	$foo[1] = new mysql2();
+	$foo[2] = new mysql3($host, $user, $passwd, $db, $port, $socket);
 
 
 	for ($i=0; $i < 3; $i++) {
 		if (($result = $foo[$i]->query("SELECT DATABASE()"))) {
 			$row = $result->fetch_row();
-			printf("%d: %s\n", $i, $row[0]);
+			if ($row[0] != $db)
+				printf("%d: %s\n", $i, $row[0]);
 			$result->close();
 		}
 		$foo[$i]->close();
 	}
+	print "done!";
 ?>
 --EXPECTF--
-0: test
-1: test
-2: test
+done!
--- a/ext/mysqli/tests/bug30967.phpt
+++ b/ext/mysqli/tests/bug30967.phpt
@@ -1,23 +1,26 @@
 --TEST--
 Bug #30967 (problems with properties declared in the class extending the class extending MySQLi)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
-	
+	require_once("connect.inc");
+
 	class mysql1 extends mysqli {
 	}
 
 	class mysql2 extends mysql1 {
 	}
 
-	$mysql = new mysql2($host, $user, $passwd, "test");
+	$mysql = new mysql2($host, $user, $passwd, $db, $port, $socket);
 
 	$mysql->query("THIS DOES NOT WORK");
 	printf("%d\n", $mysql->errno);
 
-	$mysql->close();	
+	$mysql->close();
 ?>
 --EXPECTF--
 1064
--- a/ext/mysqli/tests/bug31141.phpt
+++ b/ext/mysqli/tests/bug31141.phpt
@@ -22,7 +22,7 @@
 --EXPECTF--
 array(2) {
   [0]=>
-  string(3) "foo"
+  %s(3) "foo"
   [1]=>
-  string(3) "bar"
+  %s(3) "bar"
 }
--- a/ext/mysqli/tests/bug31668.phpt
+++ b/ext/mysqli/tests/bug31668.phpt
@@ -1,15 +1,20 @@
 --TEST--
 Bug #31668 (multi_query works exactly every other time (multi_query was global, now per connection))
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+error_reporting = E_ALL & ~E_STRICT
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 	$mysql->multi_query('SELECT 1;SELECT 2');
 	do {
-		$res = $mysql->store_result();	
+		$res = $mysql->store_result();
 		if ($mysql->errno == 0) {
 			while ($arr = $res->fetch_assoc()) {
 				var_dump($arr);
@@ -20,10 +25,10 @@
 	var_dump($mysql->error, __LINE__);
 	$mysql->close();
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 	$mysql->multi_query('SELECT 1;SELECT 2');
 	do {
-		$res = $mysql->store_result();	
+		$res = $mysql->store_result();
 		if ($mysql->errno == 0) {
 			while ($arr = $res->fetch_assoc()) {
 				var_dump($arr);
@@ -36,21 +41,21 @@
 --EXPECTF--
 array(1) {
   [1]=>
-  string(1) "1"
+  %s(1) "1"
 }
 array(1) {
   [2]=>
-  string(1) "2"
+  %s(1) "2"
 }
-string(0) ""
+%s(0) ""
 int(%d)
 array(1) {
   [1]=>
-  string(1) "1"
+  %s(1) "1"
 }
 array(1) {
   [2]=>
-  string(1) "2"
+  %s(1) "2"
 }
-string(0) ""
+%s(0) ""
 int(%d)
--- a/ext/mysqli/tests/bug32405.phpt
+++ b/ext/mysqli/tests/bug32405.phpt
@@ -1,16 +1,19 @@
 --TEST--
 Bug #32405 (mysqli->fetch() is returning bad data)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include ("connect.inc");
+	require_once("connect.inc");
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 	mysqli_select_db($link, "test");
 	mysqli_query($link, "SET sql_mode=''");
-	
+
 	/* two fields are needed. the problem does not occur with 1 field only selected. */
 	$link->query("CREATE TABLE test_users(user_id int(10) unsigned NOT NULL auto_increment, login varchar(50) default '', PRIMARY KEY (user_id))");
 	$link->query('INSERT INTO test_users VALUES (NULL, "user1"), (NULL, "user2"), (NULL, "user3"), (NULL, "user4")');
@@ -28,12 +31,23 @@
 	mysqli_query($link,"DROP TABLE test_users");
 	mysqli_close($link);
 ?>
---EXPECT--
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_users"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
 int(1)
-string(5) "user1"
+%s(5) "user1"
 int(2)
-string(5) "user2"
+%s(5) "user2"
 int(3)
-string(5) "user3"
+%s(5) "user3"
 int(4)
-string(5) "user4"
+%s(5) "user4"
--- a/ext/mysqli/tests/bug33090.phpt
+++ b/ext/mysqli/tests/bug33090.phpt
@@ -1,19 +1,22 @@
 --TEST--
 Bug #33090 (mysql_prepare doesn't return an error)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 	include ("connect.inc");
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
-	mysqli_select_db($link, "test");
+	$link = my_mysqli_connect($host, $user, $passwd, null, $port, $socket);
+	mysqli_select_db($link, $db);
 
 	if (!($link->prepare("this makes no sense"))) {
 		printf("%d\n", $link->errno);
 		printf("%s\n", $link->sqlstate);
-	}	
+	}
 	$link->close();
 ?>
 --EXPECT--
--- a/ext/mysqli/tests/bug33263.phpt
+++ b/ext/mysqli/tests/bug33263.phpt
@@ -1,32 +1,37 @@
 --TEST--
-Bug #33263 (mysqli_real_connect in __construct) 
+Bug #33263 (mysqli_real_connect in __construct)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
-<?php require_once('skipifemb.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
+	require_once("connect.inc");
 
-	include "connect.inc";
-
 	class test extends mysqli
 	{
-		public function __construct($host, $user, $passwd, $db) {
+		public function __construct($host, $user, $passwd, $db, $port, $socket) {
 			parent::init();
-			parent::real_connect($host, $user, $passwd, $db);
+			parent::real_connect($host, $user, $passwd, $db, $port, $socket);
 		}
 	}
 
-	$mysql = new test($host, $user, $passwd, "test");
+	$mysql = new test($host, $user, $passwd, $db, $port, $socket);
 
 	$stmt = $mysql->prepare("SELECT DATABASE()");
 	$stmt->execute();
-	$stmt->bind_result($db);
+	$stmt->bind_result($database);
 	$stmt->fetch();
 	$stmt->close();
 
-	var_dump($db);
+	if ($database != $db)
+		printf("[001] Expecting '%s' got %s/'%s'.\n",
+			gettype($database), $database);
 
-	$mysql->close();	
+	$mysql->close();
+	print "done!";
 ?>
---EXPECT--
-string(4) "test"
+--EXPECTF--
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/bug33491.phpt
+++ b/ext/mysqli/tests/bug33491.phpt
@@ -3,7 +3,10 @@
 --INI--
 error_reporting=4095
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php 
+require_once('skipif.inc'); 
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
@@ -15,10 +18,10 @@
   }
 }
 
-require_once dirname(__FILE__)."/connect.inc";
+require_once("connect.inc");
 
 // Segfault when using the DB class which extends mysqli
-$DB = new DB($host, $user, $passwd, '');
+$DB = new DB($host, $user, $passwd, $db, $port, $socket);
 $DB->query_single('SELECT DATE()');
 
 ?>
--- a/ext/mysqli/tests/bug34785.phpt
+++ b/ext/mysqli/tests/bug34785.phpt
@@ -1,7 +1,10 @@
 --TEST--
 Bug #34785 (Can not properly subclass mysqli_stmt)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 	include ("connect.inc");
@@ -21,7 +24,7 @@
 	}
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$link = mysqli_connect($host, $user, $passwd);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 	mysqli_query($link, "SET sql_mode=''");
 
 	$stmt = new my_stmt($link, "SELECT 'foo' FROM DUAL");
@@ -42,6 +45,6 @@
 
 	mysqli_close($link);
 ?>
---EXPECT--
-string(3) "foo"
-string(3) "bar"
+--EXPECTF--
+%s(3) "foo"
+%s(3) "bar"
--- a/ext/mysqli/tests/bug34810.phpt
+++ b/ext/mysqli/tests/bug34810.phpt
@@ -1,39 +1,141 @@
 --TEST--
 Bug #34810 (mysqli::init() and others use wrong $this pointer without checks)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
-class DbConnection { 
+class DbConnection {
 	public function connect() {
-		include "connect.inc";
+		require_once("connect.inc");
 
-		$link = mysqli_connect($host, $user, $passwd);
-		var_dump($link); 
-		
-		$link = mysqli_init();
+		$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 		var_dump($link);
-		
-		$mysql = new mysqli($host, $user, $passwd, "test");
+
+		$link = mysqli_init();
+		/* @ is to supress 'Property access is not allowed yet' */
+		@var_dump($link);
+
+		$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 		$mysql->query("DROP TABLE IF EXISTS test_warnings");
 		$mysql->query("CREATE TABLE test_warnings (a int not null)");
 		$mysql->query("SET sql_mode=''");
 		$mysql->query("INSERT INTO test_warnings VALUES (1),(2),(NULL)");
-		var_dump(mysqli_warning::__construct($mysql));
-	} 
-} 
 
-$db = new DbConnection(); 
+		$warning = $mysql->get_warnings();
+		if (!$warning)
+			printf("[001] No warning!\n");
+
+		if ($warning->errno == 1048 || $warning->errno == 1253) {
+			/* 1048 - Column 'a' cannot be null, 1263 - Data truncated; NULL supplied to NOT NULL column 'a' at row */
+			if ("HY000" != $warning->sqlstate)
+				printf("[003] Wrong sql state code: %s\n", $warning->sqlstate);
+
+			if ("" == $warning->message)
+				printf("[004] Message string must not be empty\n");
+
+
+		} else {
+			printf("[002] Empty error message!\n");
+			var_dump($warning);
+		}
+	}
+}
+
+$db = new DbConnection();
 $db->connect();
 
 echo "Done\n";
 ?>
---EXPECTF--	
-object(mysqli)#%d (0) {
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_warnings"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+object(mysqli)#%d (%d) {
+  [%u|b%"affected_rows"]=>
+  int(0)
+  [%u|b%"client_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"client_version"]=>
+  int(%d)
+  [%u|b%"connect_errno"]=>
+  int(0)
+  [%u|b%"connect_error"]=>
+  NULL
+  [%u|b%"errno"]=>
+  int(0)
+  [%u|b%"error"]=>
+  %unicode|string%(0) ""
+  [%u|b%"field_count"]=>
+  int(0)
+  [%u|b%"host_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"info"]=>
+  NULL
+  [%u|b%"insert_id"]=>
+  int(0)
+  [%u|b%"server_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"server_version"]=>
+  int(%d)
+  ["stat"]=>
+  %s
+  [%u|b%"sqlstate"]=>
+  %unicode|string%(5) "00000"
+  [%u|b%"protocol_version"]=>
+  int(10)
+  [%u|b%"thread_id"]=>
+  int(%d)
+  [%u|b%"warning_count"]=>
+  int(0)
 }
-object(mysqli)#%d (0) {
-}
-object(mysqli_warning)#%d (0) {
+object(mysqli)#%d (%d) {
+  [%u|b%"affected_rows"]=>
+  NULL
+  [%u|b%"client_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"client_version"]=>
+  int(%d)
+  [%u|b%"connect_errno"]=>
+  int(0)
+  [%u|b%"connect_error"]=>
+  NULL
+  [%u|b%"errno"]=>
+  int(0)
+  [%u|b%"error"]=>
+  %unicode|string%(0) ""
+  [%u|b%"field_count"]=>
+  NULL
+  [%u|b%"host_info"]=>
+  NULL
+  [%u|b%"info"]=>
+  NULL
+  [%u|b%"insert_id"]=>
+  NULL
+  [%u|b%"server_info"]=>
+  NULL
+  [%u|b%"server_version"]=>
+  NULL
+  ["stat"]=>
+  NULL
+  [%u|b%"sqlstate"]=>
+  NULL
+  [%u|b%"protocol_version"]=>
+  NULL
+  [%u|b%"thread_id"]=>
+  NULL
+  [%u|b%"warning_count"]=>
+  NULL
 }
 Done
--- a/ext/mysqli/tests/bug35103.phpt
+++ b/ext/mysqli/tests/bug35103.phpt
@@ -1,7 +1,10 @@
 --TEST--
 Bug #35103 (Bad handling of unsigned bigint)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
@@ -9,9 +12,9 @@
 DROP TABLE test_bint;
 DROP TABLE test_buint;
 EOSQL;
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 	$mysql->query("DROP TABLE IF EXISTS test_bint");
 	$mysql->query("CREATE TABLE test_bint (a bigint(20) default NULL) ENGINE=MYISAM");
 	$mysql->query("INSERT INTO test_bint VALUES (9223372036854775807),(-9223372036854775808),(-2147483648),(-2147483649),(-2147483647),(2147483647),(2147483648),(2147483649)");
@@ -19,7 +22,7 @@
 	$mysql->query("DROP TABLE IF EXISTS test_buint");
 	$mysql->query("CREATE TABLE test_buint (a bigint(20) unsigned default NULL)");
 	$mysql->query("INSERT INTO test_buint VALUES (18446744073709551615),(9223372036854775807),(9223372036854775808),(2147483647),(2147483649),(4294967295)");
-	
+
 	$stmt = $mysql->prepare("SELECT a FROM test_bint ORDER BY a");
 	$stmt->bind_result($v);
 	$stmt->execute();
@@ -47,6 +50,17 @@
 	$mysql->multi_query($drop);
 
 	$mysql->close();
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bint") || !mysqli_query($link, "DROP TABLE IF EXISTS test_buint"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
 ?>
 --EXPECT--
 BIG INT SIGNED, TEST
--- a/ext/mysqli/tests/bug35517.phpt
+++ b/ext/mysqli/tests/bug35517.phpt
@@ -1,29 +1,56 @@
 --TEST--
 Bug #35517 (mysqli_stmt_fetch returns NULL)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$mysql->query("CREATE TABLE temp (id INT UNSIGNED NOT NULL)");
 	$mysql->query("INSERT INTO temp (id) VALUES (3000000897),(3800001532),(3900002281),(3100059612)");
-
 	$stmt = $mysql->prepare("SELECT id FROM temp");
 	$stmt->execute();
 	$stmt->bind_result($id);
 	while ($stmt->fetch()) {
-		var_dump($id);
+		if (PHP_INT_SIZE == 8) {
+			if ((gettype($id) !== 'int') && (gettype($id) != 'integer'))
+				printf("[001] Expecting integer on 64bit got %s/%s\n", gettype($id), var_export($id, true));
+		} else {
+			if (gettype($id) !== 'string') {
+				printf("[002] Expecting string on 32bit got %s/%s\n", gettype($id), var_export($id, true));
+			}
+			if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($id)) {
+				printf("[003] Expecting unicode string\n");
+			}
+		}
+		print $id;
+		print "\n";
 	}
 	$stmt->close();
 
 	$mysql->query("DROP TABLE temp");
 	$mysql->close();
+	print "done!";
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS temp"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECTF--
-string(10) "3000000897"
-string(10) "3800001532"
-string(10) "3900002281"
-string(10) "3100059612"
+3000000897
+3800001532
+3900002281
+3100059612
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/bug35759.phpt
+++ b/ext/mysqli/tests/bug35759.phpt
@@ -1,44 +1,58 @@
 --TEST--
 Bug #35759 (mysqli_stmt_bind_result() makes huge allocation when column empty)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
-$sql=<<<EOSQL
-CREATE TABLE blobby (
-  a1 MEDIUMBLOB NOT NULL,
-
-
-EOSQL;
-	include "connect.inc";
+	require_once("connect.inc");
 	$col_num= 1000;
 
-	$mysql = new mysqli($host, $user, $passwd, "test");
-	$mysql->query("DROP TABLE IF EXISTS blobby");
-	$create = "CREATE TABLE blobby (a0 MEDIUMBLOB NOT NULL DEFAULT ''";
+	$mysql = new mysqli($host, $user, $passwd, $db, $port, $socket);
+	$mysql->query("DROP TABLE IF EXISTS test");
+	$create = "CREATE TABLE test (a0 MEDIUMBLOB NOT NULL DEFAULT ''";
 	$i= 0;
 	while (++$i < $col_num) {
 		$create .= ", a$i MEDIUMBLOB NOT NULL DEFAULT ''";
 	}
-        $create .= ")";	
-          
-        $mysql->query($create);
-	$mysql->query("INSERT INTO blobby (a0) VALUES ('')");
-	
-	$stmt = $mysql->prepare("SELECT * FROM blobby");
-	$stmt->execute();
-	$stmt->store_result();
-	$params= array_pad(array(), $col_num, "");
-	call_user_func_array(array($stmt, "bind_result"), $params);
-	$stmt->fetch();
-	
-	$stmt->close();
+	$create .= ") ENGINE=MyISAM"; // doesn't work with InnoDB, which is default in 5.5
 
-	$mysql->query("DROP TABLE blobby");
+	if (!$mysql->query($create)) {
+		if (1101 == $mysql->errno) {
+			/* SQL strict mode - [1101] BLOB/TEXT column 'a0' can't have a default value */
+			print "done!";
+			exit(0);
+		}
+		printf("[001] [%d] %s\n", $mysql->errno, $mysql->error);
+	}
 
+	if (!$mysql->query("INSERT INTO test (a0) VALUES ('')"))
+		printf("[002] [%d] %s\n", $mysql->errno, $mysql->error);
+
+	$stmt = $mysql->prepare("SELECT * FROM test");
+	if ($stmt) {
+
+		$stmt->execute();
+		$stmt->store_result();
+		for ($i = 0; $i < $col_num; $i++) {
+			$params[] = &$col_num;
+		}
+		call_user_func_array(array($stmt, "bind_result"), $params);
+		$stmt->fetch();
+
+		$stmt->close();
+	} else {
+		printf("[003] [%d] %s\n", $mysql->errno, $mysql->error);
+	}
+
 	$mysql->close();
-	echo "OK\n";
+
+	echo "done!";
 ?>
+--CLEAN--
+<?php require("clean_table.inc"); ?>
 --EXPECT--
-OK
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/bug36420.phpt
+++ b/ext/mysqli/tests/bug36420.phpt
@@ -1,12 +1,15 @@
 --TEST--
 Bug #36420 (segfault when access result->num_rows after calling result->close())
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
 
-include "connect.inc";
-$mysqli = mysqli_connect($host, $user, $passwd);
+require_once("connect.inc");
+$mysqli = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 $result = $mysqli->query('select 1');
 
@@ -18,7 +21,7 @@
 
 echo "Done\n";
 ?>
---EXPECTF--	
+--EXPECTF--
 Warning: main(): Couldn't fetch mysqli_result in %s on line %d
 
 Warning: main(): Couldn't fetch mysqli_result in %s on line %d
--- a/ext/mysqli/tests/bug36745.phpt
+++ b/ext/mysqli/tests/bug36745.phpt
@@ -1,13 +1,16 @@
 --TEST--
 Bug #36745 (LOAD DATA LOCAL INFILE doesn't return correct error message)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-	include ("connect.inc");
+	require_once("connect.inc");
 
 	/*** test mysqli_connect 127.0.0.1 ***/
-	$mysql = mysqli_connect($host, $user, $passwd, "test");
+	$mysql = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
 
 	$mysql->query("DROP TABLE IF EXISTS litest");
 	$mysql->query("CREATE TABLE litest (a VARCHAR(20))");
@@ -18,6 +21,17 @@
 	$mysql->close();
 	printf("Done");
 ?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS litest"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
 --EXPECTF--
-string(%d) "%s"
+%s(%d) "%s"
 Done
--- a/ext/mysqli/tests/bug36802.phpt
+++ b/ext/mysqli/tests/bug36802.phpt
@@ -1,19 +1,16 @@
 --TEST--
-Bug #36802 (crashes with mysql_init)
+Bug #36802 (crashes with with mysqli_set_charset())
 --SKIPIF--
 <?php require_once('skipif.inc'); ?>
 --FILE--
 <?php
-
-	class my_mysqli extends mysqli {
-		function __construct() 
+	class really_my_mysqli extends mysqli {
+		function __construct()
 		{
 		}
 	}
 
-	include "connect.inc";
-
-
+	require_once("connect.inc");
 	$mysql = mysqli_init();
 
 	/* following operations should not work */
@@ -24,12 +21,10 @@
 	}
 	$x[1] = @$mysql->query("SELECT 'foo' FROM DUAL");
 
-	/* following operations should work */ 
+	/* following operations should work */
 	$x[2] = ($mysql->client_version > 0);
 	$x[3] = $mysql->errno;
 	$mysql->close();
-	
-
 
 	var_dump($x);
 ?>
--- a/ext/mysqli/tests/bug36949.phpt
+++ b/ext/mysqli/tests/bug36949.phpt
@@ -1,18 +1,20 @@
 --TEST--
 Bug #36949 (invalid internal mysqli objects dtor)
 --SKIPIF--
-<?php require_once('skipif.inc'); ?>
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
 --FILE--
 <?php
-include "connect.inc";
-
+require_once("connect.inc");
 class A {
 
 	private $mysqli;
 
 	public function __construct() {
-		global $user, $host, $passwd;
-		$this->mysqli = new mysqli($host, $user, $passwd);
+		global $user, $host, $passwd, $db, $port, $socket;
+		$this->mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket);
 		$result = $this->mysqli->query("SELECT NOW() AS my_time FROM DUAL");
 		$row = $result->fetch_object();
 		echo $row->my_time."<br>\n";
@@ -29,8 +31,8 @@
 	private $mysqli;
 
 	public function __construct() {
-		global $user, $host, $passwd;
-		$this->mysqli = new mysqli($host, $user, $passwd);
+		global $user, $host, $passwd, $db, $port, $socket;
+		$this->mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket);
 		$result = $this->mysqli->query("SELECT NOW() AS my_time FROM DUAL");
 		$row = $result->fetch_object();
 		echo $row->my_time."<br>\n";
@@ -44,6 +46,17 @@
 
 $A = new A();
 $B = new B();
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS my_time"))
+	printf("[002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
 ?>
 --EXPECTF--
 %d%d%d%d-%d%d-%d%d %d%d:%d%d:%d%d<br>
--- a/ext/mysqli/tests/bug37090.phpt
+++ b/ext/mysqli/tests/bug37090.phpt
@@ -1,19 +1,24 @@
 --TEST--
 Bug #37090 (mysqli_set_charset return code)
 --SKIPIF--
-<?php require_once('skipif.inc'); 
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
 if (!function_exists('mysqli_set_charset')) {
 	die('skip mysqli_set_charset() not available');
 }
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1)) {
+	die("skip Functionality not available in unicode mode");
+}
 ?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
-	$mysql = new mysqli($host, $user, $passwd);
+	$mysql = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 
 	$cs = array();
-	$cs[] = $mysql->set_charset("latin5");
+	$cs[] = $mysql->set_charset("latin1");
 	$cs[] = $mysql->character_set_name();
 
 	$cs[] = $mysql->set_charset("utf8");
@@ -23,13 +28,14 @@
 	$cs[] = $mysql->character_set_name();
 
 	var_dump($cs);
+	print "done!";
 ?>
 --EXPECT--
 array(6) {
   [0]=>
   bool(true)
   [1]=>
-  string(6) "latin5"
+  string(6) "latin1"
   [2]=>
   bool(true)
   [3]=>
@@ -39,3 +45,4 @@
   [5]=>
   string(4) "utf8"
 }
+done!
--- a/ext/mysqli/tests/bug38710.phpt
+++ b/ext/mysqli/tests/bug38710.phpt
@@ -1,23 +1,24 @@
 --TEST--
 Bug #38710 (data leakage because of nonexisting boundary checking in statements)
 --SKIPIF--
-<?php 
-require_once('skipif.inc'); 
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
 ?>
 --FILE--
 <?php
-include "connect.inc";
+require_once("connect.inc");
 
-$db = new mysqli($host, $user, $passwd, "test");
+$db = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
 $qry=$db->stmt_init();
 $qry->prepare("SELECT REPEAT('a',100000)");
 $qry->execute();
 $qry->bind_result($text);
 $qry->fetch();
-if ($text !== str_repeat('a', mysqli_get_server_version($db) > 50110? 100000:(mysqli_get_server_version($db)>=50000? 8193:8191))) {
+if ($text !== str_repeat('a', ($IS_MYSQLND || mysqli_get_server_version($db) > 50110)? 100000:(mysqli_get_server_version($db)>=50000? 8193:8191))) {
 	var_dump(strlen($text));
 }
 echo "Done";
 ?>
---EXPECTF--	
-Done
+--EXPECTF--
+Done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug39457.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Bug #39457 (Multiple invoked OO connections never close)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$mysql = mysqli_init();
+	$mysql->connect($host, $user, $passwd, $db, $port, $socket);
+
+	$mysql->connect($host, $user, $passwd, $db, $port, $socket);
+
+	$mysql->close();
+	echo "OK\n";
+?>
+--EXPECT--
+OK
--- /dev/null
+++ b/ext/mysqli/tests/bug42378.phpt
@@ -0,0 +1,197 @@
+--TEST--
+Bug #42378 (bind_result memory exhaustion, SELECT column, FORMAT(...) AS _format)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+memory_limit=83886080
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	function create_table($link, $column, $min, $max, $engine, $offset) {
+
+		if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+			printf("[%03d] Cannot drop table test, [%d] %s\n",
+				$offset,
+				mysqli_errno($link), mysqli_error($link));
+			return array();
+		}
+		print "$column\n";
+
+		$sql = sprintf("CREATE TABLE test(id INT AUTO_INCREMENT PRIMARY KEY, col1 %s) ENGINE=%s",
+			$column, $engine);
+		if (!mysqli_query($link, $sql)) {
+			printf("[%03d] Cannot create table test, [%d] %s\n",
+				$offset + 1,
+				mysqli_errno($link), mysqli_error($link));
+			return array();
+		}
+
+		$values = array();
+		for ($i = 1; $i <= 100; $i++) {
+			$col1 = mt_rand($min, $max);
+			$values[$i] = $col1;
+			$sql = sprintf("INSERT INTO test(id, col1) VALUES (%d, %f)",
+				$i, $col1);
+			if (!mysqli_query($link, $sql)) {
+				printf("[%03d] Cannot insert data, [%d] %s\n",
+					$offset + 2,
+					mysqli_errno($link), mysqli_error($link));
+				return array();
+			}
+		}
+
+		return $values;
+	}
+
+	function test_format($link, $format, $from, $order_by, $expected, $offset) {
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%03d] Cannot create PS, [%d] %s\n",
+				$offset,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+		print "$format\n";
+
+		if ($order_by)
+			$sql = sprintf('SELECT %s AS _format FROM %s ORDER BY %s', $format, $from, $order_by);
+		else
+			$sql = sprintf('SELECT %s AS _format FROM %s', $format, $from);
+
+		if (!mysqli_stmt_prepare($stmt, $sql)) {
+			printf("[%03d] Cannot prepare PS, [%d] %s\n",
+				$offset + 1,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d] Cannot execute PS, [%d] %s\n",
+				$offset + 2,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_store_result($stmt)) {
+			printf("[%03d] Cannot store result set, [%d] %s\n",
+				$offset + 3,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!is_array($expected)) {
+
+			$result = null;
+			if (!mysqli_stmt_bind_result($stmt, $result)) {
+				printf("[%03d] Cannot bind result, [%d] %s\n",
+					$offset + 4,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			if (!mysqli_stmt_fetch($stmt)) {
+				printf("[%03d] Cannot fetch result,, [%d] %s\n",
+					$offset + 5,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			if ($result !== $expected) {
+				printf("[%03d] Expecting %s/%s got %s/%s with %s - %s.\n",
+					$offset + 6,
+					gettype($expected), $expected,
+					gettype($result), $result,
+					$format, $sql);
+			}
+
+		} else {
+
+			$order_by_col = $result = null;
+			if (!is_null($order_by)) {
+				if (!mysqli_stmt_bind_result($stmt, $order_by_col, $result)) {
+					printf("[%03d] Cannot bind result, [%d] %s\n",
+						$offset + 7,
+						mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+					return false;
+				}
+			} else {
+				if (!mysqli_stmt_bind_result($stmt, $result)) {
+					printf("[%03d] Cannot bind result, [%d] %s\n",
+						$offset + 7,
+						mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+					return false;
+				}
+			}
+
+			if (!empty($expected))
+				reset($expected);
+			while ((list($k, $v) = each($expected)) && mysqli_stmt_fetch($stmt)) {
+				if (!empty($expected)) {
+					if ($result !== $v) {
+						printf("[%03d] Row %d - expecting %s/%s got %s/%s [%s] with %s - %s.\n",
+							$offset + 8,
+							$k,
+							gettype($v), $v,
+							gettype($result), $result,
+							$order_by_col,
+							$format, $sql);
+					}
+				}
+			}
+
+		}
+
+		mysqli_stmt_free_result($stmt);
+		mysqli_stmt_close($stmt);
+
+		return true;
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect - [%d] %s\n",
+			mysqli_connect_errno(),
+			mysqli_connect_error());
+
+	/* create new table and select from it */
+	$expected = create_table($link, 'FLOAT', -10000, 10000, $engine, 90);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'FORMAT(col1, 0)', 'test', NULL, array(), 100);
+
+	$expected = create_table($link, 'FLOAT', -10000, 10000, $engine, 110);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 120);
+
+	$expected = create_table($link, 'FLOAT UNSIGNED', 0, 10000, $engine, 130);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 140);
+
+	$expected = create_table($link, 'DECIMAL(5,0)', -1000, 1000, $engine, 150);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 160);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+FLOAT
+FORMAT(col1, 0)
+FLOAT
+id AS order_by_col, FORMAT(col1, 0)
+FLOAT UNSIGNED
+id AS order_by_col, FORMAT(col1, 0)
+DECIMAL(5,0)
+id AS order_by_col, FORMAT(col1, 0)
+done!
--- a/ext/mysqli/tests/bug42548.phpt
+++ b/ext/mysqli/tests/bug42548.phpt
@@ -1,52 +1,66 @@
 --TEST--
 Bug #42548 PROCEDURE xxx can't return a result set in the given context (works in 5.2.3!!)
 --SKIPIF--
-<?php 
+<?php
 require_once('skipif.inc');
-
-if (mysqli_get_server_version($con) <= 50000) {
-	die(sprintf('skip Needs MySQL 5.0+, found version %d.', mysqli_get_server_version($con)));
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
 }
-
+if (mysqli_get_server_version($link) <= 50000) {
+	die(sprintf('skip Needs MySQL 5.0+, found version %d.', mysqli_get_server_version($link)));
+}
 ?>
 --FILE--
 <?php
-include "connect.inc";
+require_once('connect.inc');
 
 $mysqli = mysqli_init();
-$mysqli->real_connect($host, $user, $passwd, 'test');
+$mysqli->real_connect($host, $user, $passwd, $db, $port, $socket);
 if (mysqli_connect_errno()) {
-  printf("Connect failed: %s\n", mysqli_connect_error());
-  exit();
+	printf("Connect failed: %s\n", mysqli_connect_error());
+	exit();
 }
 
 $mysqli->query("DROP PROCEDURE IF EXISTS p1") or die($mysqli->error);
 $mysqli->query("CREATE PROCEDURE p1() BEGIN SELECT 23; SELECT 42; END") or die($mysqli->error);
 
 if ($mysqli->multi_query("CALL p1();"))
-{	
-  do	
-  {	
-    if ($objResult = $mysqli->store_result()) {
-      while ($row = $objResult->fetch_assoc()) {
-        print_r($row);
-      }
-      $objResult->close();
-      if ($mysqli->more_results()) {
-        print "----- next result -----------\n";
-      }
-    } else {
-      print "no results found";
-    }
-  } while ($mysqli->more_results() && $mysqli->next_result());
+{
+	do
+	{
+		if ($objResult = $mysqli->store_result()) {
+			while ($row = $objResult->fetch_assoc()) {
+				print_r($row);
+			}
+			$objResult->close();
+			if ($mysqli->more_results()) {
+				print "----- next result -----------\n";
+			}
+		} else {
+			print "no results found\n";
+		}
+	} while ($mysqli->more_results() && $mysqli->next_result());
 } else {
-  print $mysqli->error;
+	print $mysqli->error;
 }
 
 $mysqli->query("DROP PROCEDURE p1") or die($mysqli->error);
 $mysqli->close();
+print "done!";
 ?>
---EXPECT--	
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+mysqli_query($link, "DROP PROCEDURE IF EXISTS p1");
+
+mysqli_close($link);
+?>
+--EXPECT--
 Array
 (
     [23] => 23
@@ -58,3 +72,4 @@
 )
 ----- next result -----------
 no results found
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug44897.phpt
@@ -0,0 +1,89 @@
+--TEST--
+Bug #44879 (failed to prepare statement)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+
+if (!stristr(mysqli_get_client_info(), 'mysqlnd'))
+	die("skip: only available in mysqlnd");
+
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) <= 50000) {
+	die(sprintf('skip Needs MySQL 5.0+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--FILE--
+<?php
+	require_once("table.inc");
+
+	if (!$link->query('DROP PROCEDURE IF EXISTS p'))
+		printf("[001] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$link->query('CREATE PROCEDURE p(IN new_id INT, IN new_label CHAR(1)) BEGIN INSERT INTO test(id, label) VALUES (new_id, new_label); SELECT new_label; END;'))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	$new_id = 100;
+	$new_label = 'z';
+
+	if (!$stmt = $link->prepare('CALL p(?, ?)'))
+		printf("[003] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$stmt->bind_param('is', $new_id, $new_label) || !$stmt->execute())
+		printf("[004] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$out_new_label = null;
+	if (!$stmt->bind_result($out_new_label) || !$stmt->fetch())
+		printf("[005] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if ($out_new_label != $new_label)
+		printf("[006] IN value and returned value differ. Expecting %s/%s got %s/%s\n",
+			$new_label, gettype($new_label), $out_new_label, gettype($out_new_label));
+
+	$stmt->close();
+
+	$stmt2 = $link->prepare('SELECT label FROM test WHERE id = ?');
+	if (!is_object($stmt2)) {
+
+		printf("[007] Failed to create new statement object, [%d] %s\n",
+			$link->errno, $link->error);
+
+	} else {
+
+		if (!$stmt2->bind_param("i", $new_id) || !$stmt2->execute())
+			printf("[008] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+		$out_new_label = null;
+		if (!$stmt2->bind_result($out_new_label) || !$stmt2->fetch())
+			printf("[009] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+		if ($out_new_label != $new_label)
+			printf("[010] IN value and returned value differ. Expecting %s/%s got %s/%s\n",
+				$new_label, gettype($new_label), $out_new_label, gettype($out_new_label));
+
+	}
+
+	$link->close();
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_query($link, "DROP PROCEDURE IF EXISTS p");
+
+mysqli_close($link);
+?>
+
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug45019.phpt
@@ -0,0 +1,59 @@
+--TEST--
+Bug #45019 (Segmentation fault with SELECT ? and UNION)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	// Regular (non-prepared) queries
+	print "Using CAST('somestring' AS CHAR)...\n";
+	if (!($res = $link->query("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST('two' AS CHAR)")))
+		printf("[001] [%d] %s\n", $link->errno, $link->error);
+
+	$data = array();
+	while ($row = $res->fetch_assoc()) {
+		$data[] = $row['column1'];
+		var_dump($row['column1']);
+	}
+	$res->free();
+
+	// Prepared Statements
+	if (!($stmt = $link->prepare("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST('two' AS CHAR)")))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	$column1 = null;
+	if (!$stmt->bind_result($column1) || !$stmt->execute())
+		printf("[003] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$index = 0;
+	while ($stmt->fetch()) {
+		/* NOTE: libmysql - http://bugs.mysql.com/bug.php?id=47483 */
+		if ($data[$index] != $column1) {
+			if ($IS_MYSQLND || $index != 1) {
+				printf("[004] Row %d, expecting %s/%s got %s/%s\n",
+					$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+			} else {
+				if ($column1 != "thre")
+					printf("[005] Got '%s'. Please check if http://bugs.mysql.com/bug.php?id=47483 has been fixed and adapt tests bug45019.phpt/mysqli_ps_select_union.phpt", $column1);
+			}
+		}
+		$index++;
+	}
+	$stmt->close();
+
+	$link->close();
+
+	print "done!";
+?>
+--EXPECTF--
+Using CAST('somestring' AS CHAR)...
+%unicode|string%(3) "one"
+%unicode|string%(5) "three"
+%unicode|string%(3) "two"
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug45289.phpt
@@ -0,0 +1,40 @@
+--TEST--
+Bug #45289 (Bogus store_result on PS)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	$link->close();
+
+	$link = mysqli_init();
+	if (!($link->real_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	$id = 1;
+	if (!($stmt = $link->prepare('SELECT id, label FROM test WHERE id=? LIMIT 1')))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$stmt->bind_param('i', $id) || !$stmt->execute())
+		printf("[003] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if ($res = $link->store_result()) {
+		if ($IS_MYSQLND)
+			printf("[004] Can store result!\n");
+		else
+			printf("[004] [007] http://bugs.mysql.com/bug.php?id=47485\n");
+	} else {
+		printf("[004] [%d] %s\n", $link->errno, $link->error);
+	}
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[004] [%s
--- a/ext/mysqli/tests/bug45940.phpt
+++ /dev/null
@@ -1,18 +0,0 @@
---TEST--
-Bug #45940 MySQLI OO does not populate connect_error property on failed connect
---SKIPIF--
-<?php require_once('skipif.inc'); ?>
---FILE--
-<?php
-include "connect.inc";
-
-//a forced username/password mismatch
-$dbo = @new mysqli($host, 'hopenotexist', 'andifheexistshehasanotherpassword', 'my_db');
-
-var_dump($dbo->connect_error);
-var_dump(mysqli_connect_error());
-?>
---EXPECTF--
-string(71) "Access denied for user 'hopenotexist'@'localhost' (using password: YES)"
-string(71) "Access denied for user 'hopenotexist'@'localhost' (using password: YES)"
-
--- a/ext/mysqli/tests/bug46109.phpt
+++ b/ext/mysqli/tests/bug46109.phpt
@@ -1,17 +1,18 @@
 --TEST--
 Bug #46109 (MySQLi::init - Memory leaks)
 --SKIPIF--
-<?php 
-require_once('skipif.inc'); 
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
 ?>
 --FILE--
 <?php
-	include "connect.inc";
+	require_once("connect.inc");
 
 	$mysqli = new mysqli();
 	$mysqli->init();
 	$mysqli->init();
-	echo "done";	
+	echo "done";
 ?>
 --EXPECTF--
 done
--- /dev/null
+++ b/ext/mysqli/tests/bug46614.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Bug #46614 (Extended MySQLi class gives incorrect empty() result)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+if (!defined("MYSQLI_ASYNC")) {
+	die("skip mysqlnd only");
+}
+?>
+--FILE--
+<?php
+class MySQL_Ext extends mysqli{
+	protected $fooData = array();
+
+	public function isEmpty()
+	{
+		$this->extData[] = 'Bar';
+		return empty($this->extData);
+	}
+}
+
+include ("connect.inc");
+$MySQL_Ext = new MySQL_Ext($host, $user, $passwd, $db, $port, $socket);
+
+$isEmpty = $MySQL_Ext->isEmpty();
+var_dump($isEmpty);
+?>
+--EXPECT--
+bool(false)
--- /dev/null
+++ b/ext/mysqli/tests/bug47050.phpt
@@ -0,0 +1,34 @@
+--TEST--
+Bug #47050 (mysqli_poll() modifies improper variables)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+if (!defined("MYSQLI_ASYNC")) {
+	die("skip mysqlnd only");
+}
+?>
+--FILE--
+<?php
+	include ("connect.inc");
+
+	$link1 = my_mysqli_connect($host, $user, $passwd, null, $port, $socket);
+	mysqli_select_db($link1, $db);
+
+	$link1->query("SELECT 'test'", MYSQLI_ASYNC);
+	$all_links = array($link1);
+	$links = $errors = $reject = $all_links;
+	mysqli_poll($links, $errors, $reject, 1);
+
+	echo "links: ",     sizeof($links), "\n";
+	echo "errors: ",    sizeof($errors), "\n";
+	echo "reject: ",    sizeof($reject), "\n";
+	echo "all_links: ", sizeof($all_links), "\n";
+
+	$link1->close();
+?>
+--EXPECT--
+links: 1
+errors: 0
+reject: 0
+all_links: 1
--- /dev/null
+++ b/ext/mysqli/tests/bug48909.phpt
@@ -0,0 +1,46 @@
+--TEST--
+Bug #48909 (Segmentation fault in mysqli_stmt_execute)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!($link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$link->query("DROP TABLE IF EXISTS test") ||
+		!$link->query(sprintf("CREATE TABLE test(id INT, label varchar(255)) ENGINE = %s", $engine)))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$stmt = $link->prepare("INSERT INTO test(id, label) VALUES  (?, ?)"))
+		printf("[003] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$stmt->bind_param("bb",$bvar, $bvar))
+		printf("[004] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if (!$stmt->execute()) {
+		if ($stmt->errno != 1366) {
+			/*
+				$bvar is null, b is for BLOB - any error like this should be OK:
+				1366 -  Incorrect integer value: '' for column 'id' at row 1
+			*/
+			printf("[005] [%d] %s\n", $stmt->errno, $stmt->error);
+		}
+	}
+
+	$stmt->close();
+	$link->close();
+
+	echo "done";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug49027.phpt
@@ -0,0 +1,62 @@
+--TEST--
+Bug #49027 (mysqli_options() doesn't work when using mysqlnd)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	include ("connect.inc");
+
+	$link = mysqli_init();
+	if (!mysqli_options($link, MYSQLI_INIT_COMMAND, "SELECT 1")) {
+		printf("[001] Cannot set INIT_COMMAND\n");
+	}
+
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[002] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	var_dump($link->query("SELECT 42")->fetch_row());
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+		!mysqli_query($link, sprintf("CREATE TABLE test(id INT) ENGINE=%s", $engine))) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+
+	$link = mysqli_init();
+	if (!mysqli_options($link, MYSQLI_INIT_COMMAND, "INSERT INTO test(id) VALUES(1)")) {
+		printf("[004] Cannot set INIT_COMMAND\n");
+	}
+
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[005] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link, "SELECT id FROM test"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump(mysqli_fetch_assoc($res));
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  %unicode|string%(2) "42"
+}
+array(1) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+}
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug49442.phpt
@@ -0,0 +1,130 @@
+--TEST--
+Bug #49422 (mysqlnd: mysqli_real_connect() and LOAD DATA INFILE crash)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
+$link = mysqli_init();
+if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
+}
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+mysqli.allow_persistent=1
+mysqli.max_persistent=1
+--FILE--
+<?php
+	include ("connect.inc");
+
+	$link = mysqli_init();
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("[002] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=' . $engine)) {
+		printf("[003] Failed to create test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	include("local_infile_tools.inc");
+	$file = create_standard_csv(4);
+
+	if (!@mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s'
+			INTO TABLE test
+			FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\''
+			LINES TERMINATED BY '\n'",
+			mysqli_real_escape_string($link, $file)))) {
+			printf("[005] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id"))
+		printf("[006] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	$rows = array();
+	while ($row = mysqli_fetch_assoc($res)) {
+		var_dump($row);
+		$rows[] = $row;
+	}
+
+	mysqli_free_result($res);
+
+	mysqli_query($link, "DELETE FROM test");
+	mysqli_close($link);
+
+	if ($IS_MYSQLND) {
+		/*
+			mysqlnd makes a connection created through mysql_init()/mysqli_real_connect() always a 'persistent' one.
+			At this point 'persistent' is not to be confused with what a user calls a 'persistent' - in this case
+			'persistent' means that mysqlnd uses malloc() instead of emalloc(). nothing else. ext/mysqli will
+			not consider it as a 'persistent' connection in a user sense, ext/mysqli will not appy max_persistent etc.
+			Its only about malloc() vs. emalloc().
+
+			However, the bug is about malloc() and efree(). You can make make mysqlnd use malloc() by either using
+			pconnect or mysql_init() - so we should test pconnect as well..
+		*/
+		$host = 'p:' . $host;
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+			printf("[007] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		}
+
+		/* bug happened during query processing */
+		if (!@mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s'
+			INTO TABLE test
+			FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\''
+			LINES TERMINATED BY '\n'",
+			mysqli_real_escape_string($link, $file)))) {
+			printf("[008] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+		}
+
+		/* we survived? that's good enough... */
+
+		if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id"))
+			printf("[009] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+		$i = 0;
+		while ($row = mysqli_fetch_assoc($res)) {
+			if (($row['id'] != $rows[$i]['id']) || ($row['label'] != $rows[$i]['label'])) {
+				printf("[010] Wrong values, check manually!\n");
+			}
+			$i++;
+		}
+		mysqli_close($link);
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "97"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "x"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "98"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "y"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "99"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "z"
+}
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/bug50636.phpt
+++ /dev/null
@@ -1,35 +0,0 @@
---TEST--
-Bug #50636 (MySQLi_Result sets values before calling constructor)
---SKIPIF--
-<?php
-require_once('skipif.inc');
-require_once('skipifconnectfailure.inc');
-?>
---FILE--
-<?php
-	include ("connect.inc");
-
-    class Book {
-        private $title = 0;
-
-        function __construct() {
-            $this->title = 'foobar';
-        }
-
-        function __set($name, $value) {
-            $this->{$name}   = $value;
-        }
-    }
-
-    $link = new mysqli($host, $user, $passwd);
-    var_dump($link->query('SELECT "PHP" AS title, "Rasmus" AS author')->fetch_object('Book'));
-    echo "done!";
-?>
---EXPECTF--
-object(Book)#%d (2) {
-  ["title:private"]=>
-  string(3) "PHP"
-  ["author"]=>
-  string(6) "Rasmus"
-}
-done!
--- a/ext/mysqli/tests/bug50772.phpt
+++ b/ext/mysqli/tests/bug50772.phpt
@@ -12,7 +12,7 @@
 
 	// These calls fail
 	$db1->options(MYSQLI_OPT_CONNECT_TIMEOUT, 3);
-	$db1->real_connect($host, $user, $passwd);
+	my_mysqli_real_connect($db1, $host, $user, $passwd, $db, $port, $socket);
 	if(mysqli_connect_error()) {
 		echo "error 1\n";
 	} else {
@@ -22,7 +22,7 @@
 	$db2 = mysqli_init();
 
 	$db2->options(MYSQLI_OPT_CONNECT_TIMEOUT, 3);
-	$db2->real_connect($host, $user, $passwd);
+	my_mysqli_real_connect($db2, $host, $user, $passwd, $db, $port, $socket);
 	if(mysqli_connect_error()) {
 		echo "error 2\n";
 	} else {
--- /dev/null
+++ b/ext/mysqli/tests/bug51605.phpt
@@ -0,0 +1,44 @@
+--TEST--
+Bug #51605 Mysqli - zombie links
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.max_links = 1
+mysqli.allow_persistent = Off
+mysqli.max_persistent = 0
+mysqli.reconnect = Off
+--FILE--
+<?php
+	include ("connect.inc");
+
+	$link = mysqli_init();
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[002] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+	mysqli_close($link);
+	echo "closed once\n";
+
+	$link = mysqli_init();
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[002] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+	mysqli_close($link);
+	echo "closed twice\n";
+
+	$link = mysqli_init();
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+	mysqli_close($link);
+	echo "closed for third time\n";
+
+	print "done!";
+?>
+--EXPECTF--
+closed once
+closed twice
+closed for third time
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug51647.phpt
@@ -0,0 +1,81 @@
+--TEST--
+Bug #51647 (Certificate file without private key (pk in another file) doesn't work)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once("connect.inc");
+
+if ($IS_MYSQLND && !extension_loaded("openssl"))
+	die("skip PHP streams lack support for SSL. mysqli is compiled to use mysqlnd which uses PHP streams in turn.");
+
+if (!($link = @my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+	die(sprintf("skip Connect failed, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+$row = NULL;
+if ($res = $link->query('SHOW VARIABLES LIKE "have_ssl"')) {
+	$row = $res->fetch_row();
+} else {
+	if ($link->errno == 1064 && ($res = $link->query("SHOW VARIABLES"))) {
+		while ($row = $res->fetch_row())
+			if ($row[0] == 'have_ssl')
+				break;
+	} else {
+		die(sprintf("skip Failed to test for MySQL SSL support, [%d] %s", $link->errno, $link->error));
+	}
+}
+
+
+if (empty($row))
+	die(sprintf("skip Failed to test for MySQL SSL support, [%d] %s", $link->errno, $link->error));
+
+if (($row[1] == 'NO') || ($row[1] == 'DISABLED'))
+	die(sprintf("skip MySQL has no SSL support, [%d] %s", $link->errno, $link->error));
+
+$link->close();
+?>
+--FILE--
+<?php
+	include ("connect.inc");
+
+	if (!is_object($link = mysqli_init()))
+		printf("[001] Cannot create link\n");
+
+	$path_to_pems = !$IS_MYSQLND? "ext/mysqli/tests/" : "";
+	if (!$link->ssl_set("{$path_to_pems}client-key.pem", "{$path_to_pems}client-cert.pem", "{$path_to_pems}cacert.pem","",""))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = $link->query('SHOW STATUS like "Ssl_cipher"')) {
+		if (1064 == $link->errno) {
+			/* ERROR 1064 (42000): You have an error in your SQL syntax;  = sql strict mode */
+			if ($res = $link->query("SHOW STATUS")) {
+				while ($row = $res->fetch_assoc())
+					if ($row['Variable_name'] == 'Ssl_cipher')
+						break;
+			} else {
+				printf("[005] [%d] %s\n", $link->errno, $link->error);
+			}
+		} else {
+			printf("[004] [%d] %s\n", $link->errno, $link->error);
+		}
+	} else {
+		if (!$row = $res->fetch_assoc())
+			printf("[006] [%d] %s\n", $link->errno, $link->error);
+	}
+
+	var_dump($row);
+
+	print "done!";
+?>
+--EXPECTF--
+array(2) {
+  ["Variable_name"]=>
+  string(10) "Ssl_cipher"
+  ["Value"]=>
+  string(%d) "%S"
+}
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug52082.phpt
@@ -0,0 +1,50 @@
+--TEST--
+Bug #52082 (character_set_client & character_set_connection reset after mysqli_change_user)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	$link = mysqli_init();
+	$link->options(MYSQLI_SET_CHARSET_NAME, "latin2");
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		die("can't connect");
+	}
+	var_dump($link->query("show variables like 'character_set_client'")->fetch_row());
+	var_dump($link->query("show variables like 'character_set_connection'")->fetch_row());
+	$link->change_user($user, $passwd, $db);
+	var_dump($link->query("show variables like 'character_set_client'")->fetch_row());
+	var_dump($link->query("show variables like 'character_set_connection'")->fetch_row());
+
+	print "done!";
+?>
+--EXPECTF--
+array(2) {
+  [0]=>
+  string(20) "character_set_client"
+  [1]=>
+  string(6) "latin2"
+}
+array(2) {
+  [0]=>
+  string(24) "character_set_connection"
+  [1]=>
+  string(6) "latin2"
+}
+array(2) {
+  [0]=>
+  string(20) "character_set_client"
+  [1]=>
+  string(6) "latin2"
+}
+array(2) {
+  [0]=>
+  string(24) "character_set_connection"
+  [1]=>
+  string(6) "latin2"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug52891.phpt
@@ -0,0 +1,160 @@
+--TEST--
+Bug #52891 (Wrong data inserted with mysqli/mysqlnd when using bind_param,value > LONG_MAX)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+if (!$IS_MYSQLND) {
+	die("skip: test applies only to mysqlnd");
+}
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$link->query("DROP TABLE IF EXISTS tuint") ||
+		!$link->query("DROP TABLE IF EXISTS tsint")) {
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+	}
+
+	if (!$link->query("CREATE TABLE tuint(a BIGINT UNSIGNED) ENGINE=" . $engine) ||
+		!$link->query("CREATE TABLE tsint(a BIGINT) ENGINE=" . $engine)) {
+		printf("[003] [%d] %s\n", $link->errno, $link->error);
+	}
+
+
+	if (!$stmt1 = $link->prepare("INSERT INTO tuint VALUES(?)"))
+		printf("[004] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$stmt2 = $link->prepare("INSERT INTO tsint VALUES(?)"))
+		printf("[005] [%d] %s\n", $link->errno, $link->error);
+
+	$param = 42;
+
+	if (!$stmt1->bind_param("i", $param))
+		printf("[006] [%d] %s\n", $stmt1->errno, $stmt1->error);
+
+	if (!$stmt2->bind_param("i", $param))
+		printf("[007] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	/* first insert normal value to force initial send of types */
+	if (!$stmt1->execute())
+		printf("[008] [%d] %s\n", $stmt1->errno, $stmt1->error);
+
+	if	(!$stmt2->execute())
+		printf("[009] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	/* now try values that don't fit in long, on 32bit, new types should be sent or 0 will be inserted */
+	$param = -4294967297;
+	if (!$stmt2->execute())
+		printf("[010] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	/* again normal value */
+	$param = 43;
+
+	if (!$stmt1->execute())
+		printf("[011] [%d] %s\n", $stmt1->errno, $stmt1->error);
+
+	if	(!$stmt2->execute())
+		printf("[012] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	/* again conversion */
+	$param = -4294967295;
+	if (!$stmt2->execute())
+		printf("[013] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	$param = 4294967295;
+	if (!$stmt1->execute())
+		printf("[014] [%d] %s\n", $stmt1->errno, $stmt1->error);
+
+	if	(!$stmt2->execute())
+		printf("[015] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	$param = 4294967297;
+	if (!$stmt1->execute())
+		printf("[016] [%d] %s\n", $stmt1->errno, $stmt1->error);
+
+	if	(!$stmt2->execute())
+		printf("[017] [%d] %s\n", $stmt2->errno, $stmt2->error);
+
+	$result = $link->query("SELECT * FROM tsint ORDER BY a ASC");
+	$result2 = $link->query("SELECT * FROM tuint ORDER BY a ASC");
+
+	echo "tsint:\n";
+	while ($row = $result->fetch_assoc()) {
+		var_dump($row);
+	}
+	echo "tuint:\n";
+	while ($row = $result2->fetch_assoc()) {
+		var_dump($row);
+	}
+
+	echo "done";
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+}
+
+if (!mysqli_query($link, 'DROP TABLE IF EXISTS tuint')) {
+	printf("[clean] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+}
+
+if (!mysqli_query($link, 'DROP TABLE IF EXISTS tsint')) {
+	printf("[clean] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+}
+
+mysqli_close($link);
+?>
+--EXPECTF--
+tsint:
+array(1) {
+  ["a"]=>
+  string(11) "-4294967297"
+}
+array(1) {
+  ["a"]=>
+  string(11) "-4294967295"
+}
+array(1) {
+  ["a"]=>
+  string(2) "42"
+}
+array(1) {
+  ["a"]=>
+  string(2) "43"
+}
+array(1) {
+  ["a"]=>
+  string(10) "4294967295"
+}
+array(1) {
+  ["a"]=>
+  string(10) "4294967297"
+}
+tuint:
+array(1) {
+  ["a"]=>
+  string(2) "42"
+}
+array(1) {
+  ["a"]=>
+  string(2) "43"
+}
+array(1) {
+  ["a"]=>
+  string(10) "4294967295"
+}
+array(1) {
+  ["a"]=>
+  string(10) "4294967297"
+}
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug53503.phpt
@@ -0,0 +1,66 @@
+--TEST--
+Bug #53503 (mysqli::query returns false after successful LOAD DATA query)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$link->query("DROP TABLE IF EXISTS test")) {
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+	}
+
+	if (!$link->query("CREATE TABLE test (dump1 INT UNSIGNED NOT NULL PRIMARY KEY) ENGINE=" . $engine)) {
+		printf("[003] [%d] %s\n", $link->errno, $link->error);
+	}
+
+	if (FALSE == file_put_contents('bug53503.data', "1\n2\n3\n"))
+		printf("[004] Failed to create CVS file\n");
+
+	if (!$link->query("SELECT 1 FROM DUAL"))
+		printf("[005] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$link->query("LOAD DATA LOCAL INFILE 'bug53503.data' INTO TABLE test")) {
+		printf("[006] [%d] %s\n", $link->errno, $link->error);
+		echo "bug";
+	} else {
+		echo "done";
+	}
+	$link->close();
+?>
+--CLEAN--
+<?php
+require_once('connect.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+}
+
+if (!$link->query($link, 'DROP TABLE IF EXISTS test')) {
+	printf("[clean] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+}
+
+$link->close();
+
+unlink('bug53503.data');
+?>
+--EXPECT--
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug54221.phpt
@@ -0,0 +1,47 @@
+--TEST--
+Bug #54221 mysqli::get_warnings segfault when used in multi queries
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.max_links = 1
+mysqli.allow_persistent = Off
+mysqli.max_persistent = 0
+mysqli.reconnect = Off
+--FILE--
+<?php
+	include ("connect.inc");
+
+	$link = mysqli_init();
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[002] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	$create = "CREATE TEMPORARY TABLE IF NOT EXISTS t54221(a int)";
+
+	$query = "$create;$create;$create;";
+	if ($link->multi_query($query)) {
+		do {
+			$sth = $link->store_result();
+
+			if ($link->warning_count) {
+				$warnings = $link->get_warnings();
+				if ($warnings) {
+					do {
+						echo "Warning: ".$warnings->errno.": ".$warnings->message."\n"; 
+					} while ($warnings->next());
+				}
+			}
+		} while ($link->more_results() && $link->next_result());
+	}
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: : 
+Warning: 1050: Table 't54221' already exists
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug54674.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Bug #54674 mysqlnd valid_sjis_(head|tail) is using invalid operator and range.
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.max_links = 1
+mysqli.allow_persistent = Off
+mysqli.max_persistent = 0
+mysqli.reconnect = Off
+--FILE--
+<?php
+	include ("connect.inc");
+
+	$link = mysqli_init();
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+		printf("[002] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	$japanese_so = pack('H4', '835c');
+	$link->set_charset('sjis');
+	var_dump($link->real_escape_string($japanese_so) === $japanese_so);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug55283.phpt
@@ -0,0 +1,75 @@
+--TEST--
+Bug #55283 (SSL options set by mysqli_ssl_set ignored for MySQLi persistent connections)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once("connect.inc");
+
+if ($IS_MYSQLND && !extension_loaded("openssl"))
+	die("skip PHP streams lack support for SSL. mysqli is compiled to use mysqlnd which uses PHP streams in turn.");
+
+if (!($link = @my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+	die(sprintf("skip Connect failed, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+$row = NULL;
+if ($res = $link->query('SHOW VARIABLES LIKE "have_ssl"')) {
+	$row = $res->fetch_row();
+} else {
+	if ($link->errno == 1064 && ($res = $link->query("SHOW VARIABLES"))) {
+		while ($row = $res->fetch_row())
+			if ($row[0] == 'have_ssl')
+				break;
+	} else {
+		die(sprintf("skip Failed to test for MySQL SSL support, [%d] %s", $link->errno, $link->error));
+	}
+}
+
+
+if (empty($row))
+	die(sprintf("skip Failed to test for MySQL SSL support, [%d] %s", $link->errno, $link->error));
+
+if (($row[1] == 'NO') || ($row[1] == 'DISABLED'))
+	die(sprintf("skip MySQL has no SSL support, [%d] %s", $link->errno, $link->error));
+
+$link->close();
+?>
+--FILE--
+<?php
+	include "connect.inc";
+	$db1 = new mysqli();
+
+
+	$flags = MYSQLI_CLIENT_SSL;
+
+	$link = mysqli_init();
+	mysqli_ssl_set($link, null, null, null, null, "RC4-MD5");
+	if (my_mysqli_real_connect($link, 'p:' . $host, $user, $passwd, $db, $port, null, $flags)) {
+		$r = $link->query("SHOW STATUS LIKE 'Ssl_cipher'");
+		var_dump($r->fetch_row());
+	}
+
+	/* non-persistent connection */
+	$link2 = mysqli_init();
+	mysqli_ssl_set($link2, null, null, null, null, "RC4-MD5");
+	if (my_mysqli_real_connect($link2, $host, $user, $passwd, $db, $port, null, $flags)) {
+		$r2 = $link2->query("SHOW STATUS LIKE 'Ssl_cipher'");
+		var_dump($r2->fetch_row());
+	}
+
+	echo "done\n";
+?>
+--EXPECTF--
+array(2) {
+  [0]=>
+  string(10) "Ssl_cipher"
+  [1]=>
+  string(7) "RC4-MD5"
+}
+array(2) {
+  [0]=>
+  string(10) "Ssl_cipher"
+  [1]=>
+  string(7) "RC4-MD5"
+}
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug55582.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Bug #55582 mysqli_num_rows() returns always 0 for unbuffered, when mysqlnd is used
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once("connect.inc");
+?>
+--FILE--
+<?php
+	include "connect.inc";
+	if (!($link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))) {
+		printf("[001] Cannot connect to the server");
+	}
+	
+	var_dump($link->real_query("SELECT 1"));
+	$res = $link->use_result();
+	var_dump(mysqli_num_rows($res));
+	var_dump($res->fetch_assoc());
+	var_dump(mysqli_num_rows($res));
+	var_dump($res->fetch_assoc());
+	var_dump(mysqli_num_rows($res));
+
+	$link->close();
+	echo "done\n";
+?>
+--EXPECTF--
+bool(true)
+
+Warning: mysqli_num_rows(): Function cannot be used with MYSQL_USE_RESULT in %s on line %d
+int(0)
+array(1) {
+  [1]=>
+  string(1) "1"
+}
+
+Warning: mysqli_num_rows(): Function cannot be used with MYSQL_USE_RESULT in %s on line %d
+int(0)
+NULL
+int(1)
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug55653.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Bug #55653 	PS crash with libmysql when binding same variable as param and out
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	$in_and_out = "a";
+
+	if (!($stmt = $link->stmt_init()))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	if (!($stmt->prepare("SELECT ?")) ||
+		!($stmt->bind_param("s", $in_and_out)) ||
+		!($stmt->execute()) ||
+		!($stmt->bind_result($in_and_out)))
+		printf("[003] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if (!$stmt->fetch())
+		printf("[004] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if ("a" !== $in_and_out)
+		printf("[005] Wrong result: '%s'\n", $in_and_out);
+
+	echo "done!";
+?>
+--EXPECT--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug55859.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Bug #55859 mysqli->stat property access gives error
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+	var_dump(soundex(mysqli_stat($link)) === soundex($link->stat));
+	echo "done!";
+?>
+--EXPECT--
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/bug62046.phpt
@@ -0,0 +1,40 @@
+--TEST--
+Bug #62046 	mysqli@mysqlnd can't iterate over stored sets after call to mysqli_stmt_reset()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+	if (FALSE === ($stmt = $link->prepare('SELECT 42'))) {
+		printf("[002] Prepare failed, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (FALSE === $stmt->execute()) {
+		printf("[003] Execute failed, [%d] %s\n", $stmt->errorno, $stmt->error);	
+	}
+	if (FALSE === $stmt->store_result()) {
+		printf("[004] store_result failed, [%d] %s\n", $stmt->errorno, $stmt->error);	
+	}
+	$one = NULL;
+	if (FALSE === $stmt->bind_result($one)) {
+		printf("[005] bind_result failed, [%d] %s\n", $stmt->errorno, $stmt->error);	
+	}
+	if (FALSE === $stmt->reset()) {
+		printf("[006] bind_result failed, [%d] %s\n", $stmt->errorno, $stmt->error);
+	}
+	while ($stmt->fetch()) {
+		var_dump($one);
+	}
+	$stmt->close();
+	$link->close();
+	echo "done!";
+?>
+--EXPECT--
+int(42)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/bug62885.phpt
@@ -0,0 +1,26 @@
+--TEST--
+Bug #62885 (mysqli_poll - Segmentation fault)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once("connect.inc");
+if (!$IS_MYSQLND) {
+    die("skip mysqlnd only test");
+}
+?>
+--FILE--
+<?php
+error_reporting(E_ALL);
+$tablica = array();
+$test1 = mysqli_poll($test2, $test3, $tablica, null);
+
+$test2 = array();
+$test2 = array();
+$test1 = mysqli_poll($test2, $test3, $tablica, null);
+echo "okey";
+?>
+--EXPECTF--
+Warning: mysqli_poll(): No stream arrays were passed in %sbug62885.php on line %d
+
+Warning: mysqli_poll(): No stream arrays were passed in %sbug62885.php on line %d
+okey
--- /dev/null
+++ b/ext/mysqli/tests/bug63398.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Bug #63398 (Segfault when polling closed link)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once("connect.inc");
+if (!$IS_MYSQLND) {
+    die("skip mysqlnd only test");
+}
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require 'connect.inc';
+$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+
+mysqli_close($link);
+
+$read = $error = $reject = array();
+$read[] = $error[] = $reject[] = $link;
+
+mysqli_poll($read, $error, $reject, 1);
+
+echo "okey";
+?>
+--EXPECTF--
+Warning: mysqli_poll(): [1] Couldn't fetch mysqli in %sbug63398.php on line %d
+
+Warning: mysqli_poll(): [1] Couldn't fetch mysqli in %sbug63398.php on line %d
+
+Warning: mysqli_poll(): No stream arrays were passed in %sbug63398.php on line %d
+
+Warning: mysqli_poll(): [1] Couldn't fetch mysqli in %sbug63398.php on line %d
+
+Warning: mysqli_poll(): [1] Couldn't fetch mysqli in %sbug63398.php on line %d
+okey
--- /dev/null
+++ b/ext/mysqli/tests/bug64726.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Bug #63398 (Memleak when calling fetch_object on a use_result and DB pointer has closed)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once("connect.inc");
+if (!$IS_MYSQLND) {
+    die("skip mysqlnd only test");
+}
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require 'connect.inc';
+$db = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+
+$result = $db->query('SELECT 1', MYSQLI_USE_RESULT);
+$db->close();
+var_dump($result->fetch_object());
+?>
+--EXPECTF--
+Warning: mysqli_result::fetch_object(): Error while reading a row in %sbug64726.php on line %d
+bool(false)
--- /dev/null
+++ b/ext/mysqli/tests/bug_mysql_49406.phpt
@@ -0,0 +1,107 @@
+--TEST--
+MySQL Bug #49406 (Binding params doesn't work when selecting a date inside a CASE-WHEN, http://bugs.mysql.com/bug.php?id=49406)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!($link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	$query = "SELECT CASE  WHEN 0 THEN CAST('2009-12-03' AS DATE)  ELSE CAST('2009-12-03' AS DATE) END";
+
+	if (!$res = $link->query($query))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$row = $res->fetch_row())
+		printf("[003] No result, [%d] %s\n", $link->errno, $link->error);
+
+	$res->free();
+
+	if ($row[0] != '2009-12-03') {
+		printf("[004] Expecting '2009-12-03' got '%s'\n", $row[0]);
+	}
+
+	if (!$stmt = $link->prepare($query))
+		printf("[005] [%d] %s\n", $link->errno, $link->error);
+
+	if (!$stmt->execute() || !$stmt->store_result())
+		printf("[006] [%d] %s\n", $stmt->errno, $stmt->error);
+
+
+	$datatypes = array(
+		MYSQLI_TYPE_TINY => "TINY",
+		MYSQLI_TYPE_SHORT => "SHORT",
+		MYSQLI_TYPE_LONG => "LONG",
+		MYSQLI_TYPE_FLOAT => "FLOAT",
+		MYSQLI_TYPE_DOUBLE => "DOUBLE",
+		MYSQLI_TYPE_TIMESTAMP => "TIMESTAMP",
+		MYSQLI_TYPE_LONGLONG => "LONGLONG",
+		MYSQLI_TYPE_INT24 => "INT24",
+		MYSQLI_TYPE_DATE => "DATE",
+		MYSQLI_TYPE_TIME => "TIME",
+		MYSQLI_TYPE_DATETIME => "DATETIME",
+		MYSQLI_TYPE_YEAR => "YEAR",
+		MYSQLI_TYPE_ENUM => "ENUM",
+		MYSQLI_TYPE_SET	=> "SET",
+		MYSQLI_TYPE_TINY_BLOB => "TINYBLOB",
+		MYSQLI_TYPE_MEDIUM_BLOB => "MEDIUMBLOB",
+		MYSQLI_TYPE_LONG_BLOB => "LONGBLOB",
+		MYSQLI_TYPE_BLOB => "BLOB",
+		MYSQLI_TYPE_VAR_STRING => "VAR_STRING",
+		MYSQLI_TYPE_STRING => "STRING",
+		MYSQLI_TYPE_NULL => "NULL",
+		MYSQLI_TYPE_NEWDATE => "NEWDATE",
+		MYSQLI_TYPE_INTERVAL => "INTERVAL",
+		MYSQLI_TYPE_GEOMETRY => "GEOMETRY",
+	);
+
+	$meta_res = $stmt->result_metadata();
+	for ($field_idx = 0; $field_idx < $meta_res->field_count; $field_idx++) {
+		$field = $meta_res->fetch_field();
+		printf("Field        : %d\n", $field_idx);
+		printf("Name         : %s\n", $field->name);
+		printf("Orgname      : %s\n", $field->orgname);
+		printf("Table        : %s\n", $field->table);
+		printf("Orgtable     : %s\n", $field->orgtable);
+		printf("Maxlength    : %d\n", $field->max_length);
+		printf("Length       : %d\n", $field->length);
+		printf("Charsetnr    : %d\n", $field->charsetnr);
+		printf("Flags        : %d\n", $field->flags);
+		printf("Type         : %d (%s)\n", $field->type, (isset($datatypes[$field->type])) ? $datatypes[$field->type] : 'unknown');
+		printf("Decimals     : %d\n", $field->decimals);
+	}
+
+	$row_stmt = null;
+	if (!$stmt->bind_result($row_stmt) || !$stmt->fetch())
+		printf("[007] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if ($row[0] != $row_stmt) {
+		printf("[008] PS and non-PS results differ, dumping data\n");
+		var_dump($row[0]);
+		var_dump($row_stmt);
+	}
+
+	$stmt->close();
+	$link->close();
+
+	echo "done";
+?>
+--EXPECTF--
+Field        : %s
+Name         : %s
+Orgname      :%s
+Table        :%s
+Orgtable     :%s
+Maxlength    : %d
+Length       : %d
+Charsetnr    : %d
+Flags        : %d
+Type         : %d (%s)
+Decimals     : %d
+done
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/cacert.pem
@@ -0,0 +1,17 @@
+-----BEGIN CERTIFICATE-----
+MIICrTCCAhagAwIBAgIJAMI7xZKjhrDbMA0GCSqGSIb3DQEBBAUAMEQxCzAJBgNV
+BAYTAlNFMRAwDgYDVQQIEwdVcHBzYWxhMRAwDgYDVQQHEwdVcHBzYWxhMREwDwYD
+VQQKEwhNeVNRTCBBQjAeFw0xMDAxMjkxMTQ3MTBaFw0xNTAxMjgxMTQ3MTBaMEQx
+CzAJBgNVBAYTAlNFMRAwDgYDVQQIEwdVcHBzYWxhMRAwDgYDVQQHEwdVcHBzYWxh
+MREwDwYDVQQKEwhNeVNRTCBBQjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA
+wQYsOEfrN4ESP3FjsI8cghE+tZVuyK2gck61lwieVxjgFMtBd65mI5a1y9pmlOI1
+yM4SB2Ppqcuw7/e1CdV1y7lvHrGNt5yqEHbN4QX1gvsN8TQauP/2WILturk4R4Hq
+rKg0ZySu7f1Xhl0ed9a48LpaEHD17IcxWEGMMJwAxF0CAwEAAaOBpjCBozAMBgNV
+HRMEBTADAQH/MB0GA1UdDgQWBBSvktYQ0ahLnyxyVKqty+WpBbBrDTB0BgNVHSME
+bTBrgBSvktYQ0ahLnyxyVKqty+WpBbBrDaFIpEYwRDELMAkGA1UEBhMCU0UxEDAO
+BgNVBAgTB1VwcHNhbGExEDAOBgNVBAcTB1VwcHNhbGExETAPBgNVBAoTCE15U1FM
+IEFCggkAwjvFkqOGsNswDQYJKoZIhvcNAQEEBQADgYEAdKN1PjwMHAKG2Ww1145g
+JQGBnKxSFOUaoSvkBi/4ntTM+ysnViWh7WvxyWjR9zU9arfr7aqsDeQxm0XDOqzj
+AQ/cQIla2/Li8tXyfc06bisH/IHRaSc2zWqioTKbEwMdVOdrvq4a8V8ic3xYyIWn
+7F4WeS07J8LKardSvM0+hOA=
+-----END CERTIFICATE-----
--- /dev/null
+++ b/ext/mysqli/tests/clean_table.inc
@@ -0,0 +1,14 @@
+<?PHP
+require_once('connect.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("[clean] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+}
+
+if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+	printf("[clean] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+}
+
+mysqli_close($link);
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/client-cert.pem
@@ -0,0 +1,46 @@
+Certificate:
+    Data:
+        Version: 1 (0x0)
+        Serial Number: 1048577 (0x100001)
+        Signature Algorithm: md5WithRSAEncryption
+        Issuer: C=SE, ST=Uppsala, L=Uppsala, O=MySQL AB
+        Validity
+            Not Before: Jan 29 11:50:22 2010 GMT
+            Not After : Jan 28 11:50:22 2015 GMT
+        Subject: C=SE, ST=Uppsala, O=MySQL AB
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (1024 bit)
+                Modulus:
+                    00:cc:9a:37:49:13:66:dc:cf:e3:0b:13:a1:23:ed:
+                    78:db:4e:bd:11:f6:8c:0d:76:f9:a3:32:56:9a:f8:
+                    a1:21:6a:55:4e:4d:3f:e6:67:9d:26:99:b2:cd:a4:
+                    9a:d2:2b:59:5c:d7:8a:d3:60:68:f8:18:bd:c5:be:
+                    15:e1:2a:3c:a3:d4:61:cb:f5:11:94:17:81:81:f7:
+                    87:8c:f6:6a:d2:ee:d8:e6:77:f6:62:66:4d:2e:16:
+                    8d:08:81:4a:c9:c6:4b:31:e5:b9:c7:8a:84:96:48:
+                    a7:47:8c:0d:26:90:56:4e:e6:a5:6e:8c:b3:f2:9f:
+                    fc:3d:78:9b:49:6e:86:83:77
+                Exponent: 65537 (0x10001)
+    Signature Algorithm: md5WithRSAEncryption
+        5e:1f:a3:53:5f:24:13:1c:f8:28:32:b0:7f:69:69:f3:0e:c0:
+        34:87:10:03:7d:da:15:8b:bd:19:b8:1a:56:31:e7:85:49:81:
+        c9:7f:45:20:74:3e:89:c0:e0:26:84:51:cc:04:16:ce:69:99:
+        01:e1:26:99:b3:e3:f5:bd:ec:5f:a0:84:e4:38:da:75:78:7b:
+        89:9c:d2:cd:60:95:20:ba:8e:e3:7c:e6:df:76:3a:7c:89:77:
+        02:94:86:11:3a:c4:61:7d:6f:71:83:21:8a:17:fb:17:e2:ee:
+        02:6b:61:c1:b4:52:63:d7:d8:46:b2:c5:9c:6f:38:91:8a:35:
+        32:0b
+-----BEGIN CERTIFICATE-----
+MIIB5zCCAVACAxAAATANBgkqhkiG9w0BAQQFADBEMQswCQYDVQQGEwJTRTEQMA4G
+A1UECBMHVXBwc2FsYTEQMA4GA1UEBxMHVXBwc2FsYTERMA8GA1UEChMITXlTUUwg
+QUIwHhcNMTAwMTI5MTE1MDIyWhcNMTUwMTI4MTE1MDIyWjAyMQswCQYDVQQGEwJT
+RTEQMA4GA1UECBMHVXBwc2FsYTERMA8GA1UEChMITXlTUUwgQUIwgZ8wDQYJKoZI
+hvcNAQEBBQADgY0AMIGJAoGBAMyaN0kTZtzP4wsToSPteNtOvRH2jA12+aMyVpr4
+oSFqVU5NP+ZnnSaZss2kmtIrWVzXitNgaPgYvcW+FeEqPKPUYcv1EZQXgYH3h4z2
+atLu2OZ39mJmTS4WjQiBSsnGSzHluceKhJZIp0eMDSaQVk7mpW6Ms/Kf/D14m0lu
+hoN3AgMBAAEwDQYJKoZIhvcNAQEEBQADgYEAXh+jU18kExz4KDKwf2lp8w7ANIcQ
+A33aFYu9GbgaVjHnhUmByX9FIHQ+icDgJoRRzAQWzmmZAeEmmbPj9b3sX6CE5Dja
+dXh7iZzSzWCVILqO43zm33Y6fIl3ApSGETrEYX1vcYMhihf7F+LuAmthwbRSY9fY
+RrLFnG84kYo1Mgs=
+-----END CERTIFICATE-----
--- /dev/null
+++ b/ext/mysqli/tests/client-key.pem
@@ -0,0 +1,15 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICXQIBAAKBgQDMmjdJE2bcz+MLE6Ej7XjbTr0R9owNdvmjMlaa+KEhalVOTT/m
+Z50mmbLNpJrSK1lc14rTYGj4GL3FvhXhKjyj1GHL9RGUF4GB94eM9mrS7tjmd/Zi
+Zk0uFo0IgUrJxksx5bnHioSWSKdHjA0mkFZO5qVujLPyn/w9eJtJboaDdwIDAQAB
+AoGASqk/4We2En+93y3jkIO4pXafIe3w/3zZ7caRue1ehx4RUQh5d+95djuB9u7J
+HEZ7TpjM7QNyao5EueL6gvbxt0LXFvqAMni7yM9tt/HUYtHHPqYiRtUny9bKYFTm
+l8szCCMal/wD9GZU9ByHDNHm7tHUMyMhARNTYSgx+SERFmECQQD/6jJocC4SXf6f
+T3LqimWR02lbJ7qCoDgRglsUXh0zjrG+IIiAyE+QOCCx1GMe3Uw6bsIuYwdHT6as
+WcdPs04xAkEAzKulvEvLVvN5zfa/DTYRTV7jh6aDleOxjsD5oN/oJXoACnPzVuUL
+qQQMNtuAXm6Q1QItrRxpQsSKbY0UQka6JwJBAOSgoNoG5lIIYTKIMvzwGV+XBLeo
+HYsXgh+6Wo4uql3mLErUG78ZtWL9kc/tE4R+ZdyKGLaCR/1gXmH5bwN4B/ECQEBb
+uUH8k3REG4kojesZlVc+/00ojzgS4UKCa/yqa9VdB6ZBz8MDQydinnShkTwgiGpy
+xOoqhO753o2UT0qH8wECQQC99IEJWUnwvExVMkLaZH5NjAFJkb22sjkmuT11tAgU
+RQgOMoDOm6driojnOnDWOkx1r1Gy9NgMLooduja4v6cx
+-----END RSA PRIVATE KEY-----
--- a/ext/mysqli/tests/connect.inc
+++ b/ext/mysqli/tests/connect.inc
@@ -1,25 +1,273 @@
 <?php
+	/*
+	Default values are "localhost", "root",
+	database "stest" and empty password.
+	Change the MYSQL_TEST environment values
+	if you want to use another configuration
+	*/
 
-  /* default values are localhost, root and empty password 
-     Change the values if you use another configuration   */
-	$driver = new mysqli_driver;
+	$driver    = new mysqli_driver;
 
-	if (!$driver->embedded) {
-		$host = "localhost";
-		$user = "root";
-		$passwd = "root";
+	$host      = getenv("MYSQL_TEST_HOST")     ? getenv("MYSQL_TEST_HOST") : "localhost";
+	$port      = getenv("MYSQL_TEST_PORT")     ? getenv("MYSQL_TEST_PORT") : 3306;
+	$user      = getenv("MYSQL_TEST_USER")     ? getenv("MYSQL_TEST_USER") : "root";
+	$passwd    = getenv("MYSQL_TEST_PASSWD")   ? getenv("MYSQL_TEST_PASSWD") : "";
+	$db        = getenv("MYSQL_TEST_DB")       ? getenv("MYSQL_TEST_DB") : "test";
+	$engine    = getenv("MYSQL_TEST_ENGINE")   ? getenv("MYSQL_TEST_ENGINE") : "MyISAM";
+	$socket    = getenv("MYSQL_TEST_SOCKET")   ? getenv("MYSQL_TEST_SOCKET") : null;
+	$skip_on_connect_failure  = getenv("MYSQL_TEST_SKIP_CONNECT_FAILURE") ? getenv("MYSQL_TEST_SKIP_CONNECT_FAILURE") : true;
+	$connect_flags = getenv("MYSQL_TEST_CONNECT_FLAGS") ? (int)getenv("MYSQL_TEST_CONNECT_FLAGS") : 0;
+	if ($socket) {
+		ini_set('mysqli.default_socket', $socket);
+	}
+
+	/* Development setting: test experimal features and/or feature requests that never worked before? */
+	$TEST_EXPERIMENTAL = (in_array(getenv("MYSQL_TEST_EXPERIMENTAL"), array(0, 1))) ?
+				((1 == getenv("MYSQL_TEST_EXPERIMENTAL")) ? true : false) :
+				false;
+
+	$IS_MYSQLND = stristr(mysqli_get_client_info(), "mysqlnd");
+	if (!$IS_MYSQLND) {
+		$MYSQLND_VERSION = NULL;
 	} else {
-		$path =  dirname(__FILE__);
-		$host = ":embedded";
-		$user = $passwd = NULL;
-		$args = array(
-					"--datadir=$path", 
-					"--innodb_data_home_dir=$path",
-					"--innodb_data_file_path=ibdata1:10M:autoextend",
-					"--log-error=$path/testrun.log",
-                                        "--init-connect='CREATE DATABASE IF NOT EXISTS test;'"
-				);
-		$driver->embedded_server_start(TRUE, $args, NULL);
+		/*
+		The formatting of the version reported by mysqli_get_client_info()
+		has changed significantly in the past. To get tests working properly
+		with PHP 5.3.0 and up, we set everything that looks like prior to
+		PHP 5.3.0 to version 5.0.4 = 5 * 10000 + 0 * 100 + 4 = 50004.
+		PHP 5.3.0	reports mysqlnd 5.0.5 dev (= 5 * 10000 + 0 * 100 + 5 = 50005.
+		*/
+		if (preg_match('@Revision:\s+(\d+)\s*\$@ism', mysqli_get_client_info(), $matches)) {
+			/* something prior to PHP 5.3.0 */
+			$MYSQLND_VERSION = 50004;
+		} else if (preg_match('@^mysqlnd (\d+)\.(\d+)\.(\d+).*@ism', mysqli_get_client_info(), $matches)) {
+			/* formatting schema used by PHP 5.3.0 */
+			$MYSQLND_VERSION = (int)$matches[1] * 10000 + (int)$matches[2] * 100 + (int)$matches[3];
+		} else if (preg_match('@^mysqlnd/PHP 6.0.0-dev@ism', mysqli_get_client_info(), $matches)) {
+			/*
+				PHP 6.0 at the time of the first PHP 5.3.0 release.
+				HEAD and 5.3 have been in sync when 5.3.0 was released.
+				It is at least 5.0.5-dev.
+			*/
+			$MYSQLND_VERSION = 50005;
+		} else {
+			/* unknown */
+			$MYSQLND_VERSION = -1;
+		}
+
 	}
 
+	if (!function_exists('sys_get_temp_dir')) {
+		function sys_get_temp_dir() {
+
+			if (!empty($_ENV['TMP']))
+				return realpath( $_ENV['TMP'] );
+			if (!empty($_ENV['TMPDIR']))
+				return realpath( $_ENV['TMPDIR'] );
+			if (!empty($_ENV['TEMP']))
+				return realpath( $_ENV['TEMP'] );
+
+			$temp_file = tempnam(md5(uniqid(rand(), TRUE)), '');
+			if ($temp_file) {
+				$temp_dir = realpath(dirname($temp_file));
+				unlink($temp_file);
+				return $temp_dir;
+			}
+			return FALSE;
+		}
+	}
+
+	if (!function_exists('my_mysqli_connect')) {
+
+		/**
+		* Whenever possible, please use this wrapper to make testing ot MYSQLI_CLIENT_COMPRESS (and potentially SSL) possible
+		*
+		* @param enable_env_flags Enable setting of connection flags through 	env(MYSQL_TEST_CONNECT_FLAGS)?
+		*/
+		function my_mysqli_connect($host, $user, $passwd, $db, $port, $socket, $enable_env_flags = true) {
+			global $connect_flags;
+
+			$flags = ($enable_env_flags) ? $connect_flags : false;
+
+			if ($flags !== false) {
+				$link = mysqli_init();
+				if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, $flags))
+					$link = false;
+			} else {
+				$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+			}
+
+			return $link;
+		}
+
+		/**
+		* Whenever possible, please use this wrapper to make testing ot MYSQLI_CLIENT_COMPRESS (and potentially SSL) possible
+		*
+		* @param enable_env_flags Enable setting of connection flags through env(MYSQL_TEST_CONNECT_FLAGS)
+		*/
+		function my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, $flags = 0, $enable_env_flags = true) {
+			global $connect_flags;
+
+			if ($enable_env_flags)
+				$flags & $connect_flags;
+
+			return mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, $flags);
+		}
+
+		class my_mysqli extends mysqli {
+			public function __construct($host, $user, $passwd, $db, $port, $socket, $enable_env_flags = true) {
+				global $connect_flags;
+
+				$flags = ($enable_env_flags) ? $connect_flags : false;
+
+				if ($flags !== false) {
+					parent::init();
+					$this->real_connect($host, $user, $passwd, $db, $port, $socket, $flags);
+				} else {
+					parent::__construct($host, $user, $passwd, $db, $port, $socket);
+				}
+			}
+		}
+
+		function my_get_charsets($link) {
+
+			/* Those tree are set by SET NAMES */
+			$charsets = array(
+				'client' 		=> NULL,
+				'results'		=> NULL,
+				'connection'	=> NULL,
+			);
+
+			if (!($res = mysqli_query($link, "SHOW VARIABLES LIKE '%character%'"))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+
+			$names = array();
+			while ($row = mysqli_fetch_assoc($res)) {
+				$names[$row['Variable_name']] = $row['Value'];
+			}
+			mysqli_free_result($res);
+
+			if (!($res = mysqli_query($link, sprintf("SHOW CHARACTER SET LIKE '%s'", $names['character_set_client']))) ||
+				!($details = mysqli_fetch_assoc($res))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+			mysqli_free_result($res);
+
+			$charsets['client'] = array(
+				'charset' 	=> $details['Charset'],
+				'desc'		=> $details['Description'],
+				'collation'	=> $details['Default collation'],
+				'maxlen'	=> $details['Maxlen'],
+				'nr'		=> NULL,
+			);
+
+			if (!($res = mysqli_query($link, sprintf("SHOW COLLATION LIKE '%s'", $details['Default collation']))) ||
+				!($collation = mysqli_fetch_assoc($res))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+			mysqli_free_result($res);
+			$charsets['client']['nr'] = $collation['Id'];
+
+			if (!($res = mysqli_query($link, sprintf("SHOW CHARACTER SET LIKE '%s'", $names['character_set_results']))) ||
+				!($details = mysqli_fetch_assoc($res))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+			mysqli_free_result($res);
+
+			$charsets['results'] = array(
+				'charset' 	=> $details['Charset'],
+				'desc'		=> $details['Description'],
+				'collation'	=> $details['Default collation'],
+				'maxlen'	=> $details['Maxlen'],
+				'nr'		=> NULL,
+			);
+
+			if (!($res = mysqli_query($link, sprintf("SHOW COLLATION LIKE '%s'", $details['Default collation']))) ||
+				!($collation = mysqli_fetch_assoc($res))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+			mysqli_free_result($res);
+			$charsets['results']['nr'] = $collation['Id'];
+
+
+			if (!($res = mysqli_query($link, sprintf("SHOW CHARACTER SET LIKE '%s'", $names['character_set_connection']))) ||
+				!($details = mysqli_fetch_assoc($res))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+			mysqli_free_result($res);
+
+			$charsets['connection'] = array(
+				'charset' 	=> $details['Charset'],
+				'desc'		=> $details['Description'],
+				'collation'	=> $details['Default collation'],
+				'maxlen'	=> $details['Maxlen'],
+				'nr'		=> NULL,
+			);
+
+			if (!($res = mysqli_query($link, sprintf("SHOW COLLATION LIKE '%s'", $details['Default collation']))) ||
+				!($collation = mysqli_fetch_assoc($res))) {
+				printf("[%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				return $charsets;
+			}
+			mysqli_free_result($res);
+			$charsets['connection']['nr'] = $collation['Id'];
+
+			return $charsets;
+		}
+
+		function have_innodb($link) {
+		  if (($res = $link->query("SHOW VARIABLES LIKE 'have_innodb'")) &&
+				($row = $res->fetch_row()) &&
+				!empty($row)) {
+				if ($row[1] == "DISABLED" || $row[1] == "NO") {
+					return false;
+				}
+				return true;
+		  } else {
+				/* MySQL 5.6.1+ */
+				if ($res = $link->query("SHOW ENGINES")) {
+					while ($row = $res->fetch_assoc()) {
+						if (!isset($row['Engine']) || !isset($row['Support']))
+							return false;
+
+						if (('InnoDB' == $row['Engine']) &&
+							(('YES' == $row['Support']) || ('DEFAULT' == $row['Support']))
+							) {
+							return true;
+						}
+					}
+					return false;
+				} else {
+					return false;
+				}
+		  }
+		  return false;
+		}
+
+	} else {
+		printf("skip Eeeek/BUG/FIXME - connect.inc included twice! skipif bug?\n");
+	}
+
+	function handle_catchable_fatal($errno, $error, $file, $line) {
+		static $errcodes = array();
+		if (empty($errcodes)) {
+			$constants = get_defined_constants();
+			foreach ($constants as $name => $value) {
+				if (substr($name, 0, 2) == "E_")
+					$errcodes[$value] = $name;
+			}
+		}
+		printf("[%s] %s in %s on line %s\n",
+			(isset($errcodes[$errno])) ? $errcodes[$errno] : $errno,
+			 $error, $file, $line);
+
+		return true;
+	}
 ?>
--- /dev/null
+++ b/ext/mysqli/tests/local_infile_tools.inc
@@ -0,0 +1,156 @@
+<?php
+	/* Utility function for mysqli_set_local_infile*.phpt tests */
+	function shutdown_clean($file) {
+		if ($file) {
+			unlink($file);
+		}
+	}
+
+	function check_local_infile_support($link, $engine, $table_name = 'test') {
+
+		if (!$res = mysqli_query($link, 'SHOW VARIABLES LIKE "local_infile"'))
+			return "Cannot check if Server variable 'local_infile' is set to 'ON'";
+
+		$row = mysqli_fetch_assoc($res);
+		mysqli_free_result($res);
+		if ('ON' != $row['Value'])
+			return sprintf("Server variable 'local_infile' seems not set to 'ON', found '%s'", $row['Value']);
+
+		if (!mysqli_query($link, sprintf('DROP TABLE IF EXISTS %s', $table_name))) {
+			return "Failed to drop old test table";
+		}
+
+		if (!mysqli_query($link, $sql = sprintf('CREATE TABLE %s(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=%s',
+			$table_name, $engine)))
+			return "Failed to create test table: $sql";
+
+		$file = create_standard_csv(1, false);
+		if (!$file) {
+			mysqli_query($link, sprintf('DROP TABLE IF EXISTS %s', $table_name));
+			return "Cannot create CSV file";
+		}
+
+		if (!@mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s'
+			INTO TABLE %s
+			FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\''
+			LINES TERMINATED BY '\n'",
+			mysqli_real_escape_string($link, $file),
+			$table_name))) {
+			  if (1148 == mysqli_errno($link)) {
+				  mysqli_query($link, sprintf('DROP TABLE IF EXISTS %s', $table_name));
+				  return "Cannot test LOAD DATA LOCAL INFILE, [1148] The used command is not allowed with this MySQL version";
+			  } else if ($link->errno) {
+				  return $link->error;
+			  }
+		}
+		mysqli_query($link, sprintf('DROP TABLE IF EXISTS %s', $table_name));
+		return "";
+	}
+
+	function create_standard_csv($offset, $verbose = true) {
+		// create a CVS file
+		$file = tempnam(sys_get_temp_dir(), 'mysqli_test');
+		if (!$fp = fopen($file, 'w')) {
+			if ($verbose)
+				printf("[%03d + 1] Cannot create CVS file '%s'\n", $offset, $file);
+			return NULL;
+		} else {
+			/* Looks ugly? No, handy if you have crashes... */
+			register_shutdown_function("shutdown_clean", $file);
+		}
+
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1)) {
+			if (!fwrite($fp, (binary)"'97';'x';\n") ||
+				!fwrite($fp, (binary)"'98';'y';\n") ||
+				!fwrite($fp, (binary)"99;'z';\n")) {
+				if ($verbose)
+					printf("[%03d + 2] Cannot write CVS file '%s'\n", $offset, $file);
+				return NULL;
+			}
+		} else {
+			if (!fwrite($fp, "97;'x';\n") ||
+				!fwrite($fp, "98;'y';\n") ||
+				!fwrite($fp, "99;'z';\n")) {
+				if ($verbose)
+					printf("[%03d + 3] Cannot write CVS file '%s'\n", $offset, $file);
+				return NULL;
+			}
+		}
+
+		fclose($fp);
+
+		if (!chmod($file, 0644)) {
+			if ($verbose)
+				printf("[%03d + 4] Cannot change the file perms of '%s' from 0600 to 0644, MySQL might not be able to read it\n",
+					$offset, $file);
+			return NULL;
+		}
+		return $file;
+	}
+
+	function try_handler($offset, $link, $file, $handler, $expected = null) {
+
+		if ('default' == $handler) {
+			mysqli_set_local_infile_default($link);
+		} else if (!mysqli_set_local_infile_handler($link, $handler)) {
+			printf("[%03d] Cannot set infile handler to '%s'\n", $offset, $handler);
+			return false;
+		}
+		printf("Callback set to '%s'\n", $handler);
+
+		if (!mysqli_query($link, sprintf("DELETE FROM test"))) {
+			printf("[%03d] Cannot remove records, [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!@mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s'
+			INTO TABLE test
+			FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\''
+			LINES TERMINATED BY '\n'",
+			mysqli_real_escape_string($link, $file)))) {
+			printf("[%03d] LOAD DATA failed, [%d] %s\n",
+				$offset + 2,
+				mysqli_errno($link), mysqli_error($link));
+		}
+
+		if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id")) {
+			printf("[%03d] [%d] %s\n", $offset + 3, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!is_array($expected))
+			return true;
+
+		foreach ($expected as $k => $values) {
+			if (!$tmp = mysqli_fetch_assoc($res)) {
+				printf("[%03d/%d] [%d] '%s'\n", $offset + 4, $k, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+			if ($values['id'] != $tmp['id']) {
+				printf("[%03d/%d] Expecting %s got %s\n",
+					$offset + 5, $k,
+					$values['id'], $tmp['id']);
+					return false;
+			}
+			if ($values['label'] != $tmp['label']) {
+				printf("[%03d/%d] Expecting %s got %s\n",
+					$offset + 6, $k,
+					$values['label'], $tmp['label']);
+					return false;
+			}
+		}
+
+		if ($res && $tmp = mysqli_fetch_assoc($res)) {
+			printf("[%03d] More results than expected!\n", $offset + 7);
+			do {
+				var_dump($tmp);
+			} while ($tmp = mysqli_fetch_assoc($res));
+			return false;
+		}
+
+		if ($res)
+			mysqli_free_result($res);
+
+		return true;
+	}
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_affected_rows.phpt
@@ -0,0 +1,135 @@
+--TEST--
+mysqli_affected_rows()
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_affected_rows()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_affected_rows($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_affected_rows($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[004] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (0 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[005] Expecting int/0, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE = ' . $engine))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (1, 'a')"))
+		printf("[008] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (1 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[010] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	// ignore INSERT error, NOTE: command line returns 0, affected_rows returns -1 as documented
+	mysqli_query($link, "INSERT INTO test(id, label) VALUES (1, 'a')");
+	if (-1 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[011] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (1, 'a') ON DUPLICATE KEY UPDATE id = 4"))
+		printf("[012] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (2 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[013] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (2, 'b'), (3, 'c')"))
+		printf("[014] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (2 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[015] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "INSERT IGNORE INTO test(id, label) VALUES (1, 'a')")) {
+		printf("[016] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (1 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[017] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) SELECT id + 10, label FROM test"))
+		printf("[018] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (4 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[019] Expecting int/4, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "REPLACE INTO test(id, label) values (4, 'd')"))
+		printf("[020] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (2 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[021] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "REPLACE INTO test(id, label) values (5, 'e')"))
+		printf("[022] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (1 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[023] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "UPDATE test SET label = 'a' WHERE id = 2"))
+		printf("[024] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	if (1 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[025] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	$charsets = array('utf8');
+	foreach ($charsets as $k => $charset) {
+		if (!($res = mysqli_query($link, sprintf("SHOW CHARACTER SET LIKE '%s'", $charset))))
+			continue;
+		mysqli_free_result($res);
+		if (true !== ($tmp = mysqli_set_charset($link, $charset)))
+			printf("[026] Expecting boolean/true got %s/%s\n",
+				gettype($tmp), $tmp);
+		if (0 !== ($tmp = mysqli_affected_rows($link)))
+			printf("[027] Expecting int/0 got %s/%s\n", gettype($tmp), $tmp);
+	}
+
+	if (!mysqli_query($link, "UPDATE test SET label = 'a' WHERE id = 2")) {
+		printf("[028] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (0 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[029] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "UPDATE test SET label = 'a' WHERE id = 100")) {
+		printf("[030] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (0 !== ($tmp = mysqli_affected_rows($link)))
+		printf("[031] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[032] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = @mysqli_affected_rows($link)))
+		printf("[033] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_affected_rows_oo.phpt
@@ -0,0 +1,114 @@
+--TEST--
+mysqli->affected_rows
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$mysqli = new mysqli();
+	if (NULL !== ($tmp = @$mysqli->affected_rows))
+		printf("[000a] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (0 !== ($tmp = $mysqli->affected_rows))
+  	printf("[002] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[003] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE = ' . $engine))
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'a')"))
+		printf("[005] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (1 !== ($tmp = $mysqli->affected_rows))
+		printf("[006] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	// ignore INSERT error, NOTE: command line returns 0, affected_rows returns -1 as documented
+	$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'a')");
+	if (-1 !== ($tmp = $mysqli->affected_rows))
+		printf("[007] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'a') ON DUPLICATE KEY UPDATE id = 4"))
+		printf("[008] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (2 !== ($tmp = $mysqli->affected_rows))
+		printf("[009] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("INSERT INTO test(id, label) VALUES (2, 'b'), (3, 'c')"))
+		printf("[010] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (2 !== ($tmp = $mysqli->affected_rows))
+		printf("[011] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("INSERT IGNORE INTO test(id, label) VALUES (1, 'a')")) {
+		printf("[012] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+	}
+
+	if (1 !== ($tmp = $mysqli->affected_rows))
+		printf("[013] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("INSERT INTO test(id, label) SELECT id + 10, label FROM test"))
+		printf("[014] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (4 !== ($tmp = $mysqli->affected_rows))
+		printf("[015] Expecting int/4, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("REPLACE INTO test(id, label) values (4, 'd')"))
+		printf("[015] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (2 !== ($tmp = $mysqli->affected_rows))
+		printf("[016] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("REPLACE INTO test(id, label) values (5, 'e')"))
+		printf("[017] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (1 !== ($tmp = $mysqli->affected_rows))
+		printf("[018] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("UPDATE test SET label = 'a' WHERE id = 2"))
+		printf("[019] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+
+	if (1 !== ($tmp = $mysqli->affected_rows))
+		printf("[020] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("UPDATE test SET label = 'a' WHERE id = 2")) {
+		printf("[021] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+	}
+
+	if (0 !== ($tmp = $mysqli->affected_rows))
+		printf("[022] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query("UPDATE test SET label = 'a' WHERE id = 100")) {
+		printf("[023] [%d] %s\n",  $mysqli->errno, $mysqli->error);
+	}
+
+	if (0 !== ($tmp = $mysqli->affected_rows))
+		printf("[024] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[025] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	$mysqli->close();
+
+	if (NULL !== ($tmp = @$mysqli->affected_rows))
+		printf("[026] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_autocommit.phpt
@@ -0,0 +1,147 @@
+--TEST--
+mysqli_autocommit()
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('connect.inc');
+	require_once('skipifconnectfailure.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		die(sprintf("skip Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket));
+	}
+
+	if (!have_innodb($link))
+		die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_autocommit()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_autocommit($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_autocommit($link, $link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[004] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (!is_bool($tmp = mysqli_autocommit($link, true)))
+		printf("[005] Expecting boolean/any, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'SET AUTOCOMMIT = 0'))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT @@autocommit as auto_commit'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if ($tmp['auto_commit'])
+		printf("[008] Cannot turn off autocommit\n");
+
+	if (true !== ($tmp = mysqli_autocommit($link, true)))
+		printf("[009] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, 'SELECT @@autocommit as auto_commit'))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!$tmp['auto_commit'])
+		printf("[011] Cannot turn on autocommit\n");
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT) ENGINE = InnoDB')) {
+		printf("[013] Cannot create test table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'INSERT INTO test(id) VALUES (1)'))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'ROLLBACK'))
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS num FROM test'))
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ((!$tmp = mysqli_fetch_assoc($res)) || (1 != $tmp['num']))
+		printf("[17] Expecting 1 row in table test, found %d rows. [%d] %s\n",
+			$tmp['num'], mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[018] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'SET AUTOCOMMIT = 1'))
+		printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT @@autocommit as auto_commit'))
+		printf("[020] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!$tmp['auto_commit'])
+		printf("[021] Cannot turn on autocommit\n");
+
+	if (true !== ($tmp = mysqli_autocommit($link, false)))
+		printf("[022] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT) ENGINE = InnoDB')) {
+		printf("[023] Cannot create test table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'INSERT INTO test(id) VALUES (1)'))
+		printf("[024] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'ROLLBACK'))
+		printf("[025] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS num FROM test'))
+		printf("[026] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	if (0 != $tmp['num'])
+		printf("[27] Expecting 0 rows in table test, found %d rows\n", $tmp['num']);
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, 'INSERT INTO test(id) VALUES (1)'))
+		printf("[028] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'COMMIT'))
+		printf("[029] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS num FROM test'))
+		printf("[030] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ((!$tmp = mysqli_fetch_assoc($res)) || (1 != $tmp['num']))
+		printf("[31] Expecting 1 row in table test, found %d rows. [%d] %s\n",
+			$tmp['num'], mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[032] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = @mysqli_autocommit($link, false)))
+		printf("[033] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_autocommit_oo.phpt
@@ -0,0 +1,137 @@
+--TEST--
+mysqli->autocommit()
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+	require_once('connect.inc');
+
+	if (!$link = new my_mysqli($host, $user, $passwd, $db, $port, $socket)) {
+		printf("skip Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+
+	if (!have_innodb($link))
+		die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (!is_bool($tmp = $mysqli->autocommit(true)))
+		printf("[002] Expecting boolean/any, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('SET AUTOCOMMIT = 0'))
+		printf("[003] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT @@autocommit as auto_commit'))
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	if ($tmp['auto_commit'])
+		printf("[005] Cannot turn off autocommit\n");
+
+	if (true !== ($tmp = $mysqli->autocommit( true)))
+		printf("[006] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = $mysqli->query('SELECT @@autocommit as auto_commit'))
+		printf("[007] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	if (!$tmp['auto_commit'])
+		printf("[008] Cannot turn on autocommit\n");
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[009] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('CREATE TABLE test(id INT) ENGINE = InnoDB')) {
+		printf("[010] Cannot create test table, [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	if (!$mysqli->query('INSERT INTO test(id) VALUES (1)'))
+		printf("[011] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('ROLLBACK'))
+		printf("[012] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT COUNT(*) AS num FROM test'))
+		printf("[013] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if ((!$tmp = $res->fetch_assoc()) || (1 != $tmp['num']))
+		printf("[014] Expecting 1 row in table test, found %d rows. [%d] %s\n",
+			$tmp['num'], $mysqli->errno, $mysqli->error);
+
+	$res->free_result();
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[015] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('SET AUTOCOMMIT = 1'))
+		printf("[016] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT @@autocommit as auto_commit'))
+		printf("[017] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	if (!$tmp['auto_commit'])
+		printf("[018] Cannot turn on autocommit\n");
+
+	if (true !== ($tmp = $mysqli->autocommit( false)))
+		printf("[019] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('CREATE TABLE test(id INT) ENGINE = InnoDB')) {
+		printf("[020] Cannot create test table, [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	if (!$mysqli->query('INSERT INTO test(id) VALUES (1)'))
+		printf("[021] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('ROLLBACK'))
+		printf("[022] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT COUNT(*) AS num FROM test'))
+		printf("[023] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	if (0 != $tmp['num'])
+		printf("[24] Expecting 0 rows in table test, found %d rows\n", $tmp['num']);
+	$res->free_result();
+
+	if (!$mysqli->query('INSERT INTO test(id) VALUES (1)'))
+		printf("[025] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('COMMIT'))
+		printf("[025] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT COUNT(*) AS num FROM test'))
+		printf("[027] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if ((!$tmp = $res->fetch_assoc()) || (1 != $tmp['num']))
+		printf("[028] Expecting 1 row in table test, found %d rows. [%d] %s\n",
+			$tmp['num'], $mysqli->errno, $mysqli->error);
+	$res->free_result();
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[029] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	$mysqli->close();
+
+	if (NULL !== ($tmp = @$mysqli->autocommit( false)))
+		printf("[030] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user.phpt
@@ -0,0 +1,112 @@
+--TEST--
+mysqli_change_user()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+
+	if (!is_null($tmp = @mysqli_change_user()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_change_user($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_change_user($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_change_user($link, $link, $link)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_change_user($link, $link, $link, $link, $link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[006] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (false !== ($tmp = mysqli_change_user($link, $user . '_unknown_really', $passwd . 'non_empty', $db)))
+		printf("[007] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_change_user($link, $user, $passwd . '_unknown_really', $db)))
+		printf("[008] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_change_user($link, $user, $passwd, $db . '_unknown_really')))
+		printf("[009] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'SET @mysqli_change_user_test_var=1'))
+		printf("[010] Failed to set test variable: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT @mysqli_change_user_test_var AS test_var'))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (1 != $tmp['test_var'])
+		printf("[012] Cannot set test variable\n");
+
+	if (true !== ($tmp = mysqli_change_user($link, $user, $passwd, $db)))
+		printf("[013] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, 'SELECT database() AS dbname, user() AS user'))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+
+	if (substr($tmp['user'], 0, strlen($user)) !== $user)
+		printf("[015] Expecting user %s, got user() %s\n", $user, $tmp['user']);
+	if ($tmp['dbname'] != $db)
+		printf("[016] Expecting database %s, got database() %s\n", $db, $tmp['dbname']);
+
+	if (!$res = mysqli_query($link, 'SELECT @mysqli_change_user_test_var AS test_var'))
+		printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (NULL !== $tmp['test_var'])
+		printf("[019] Test variable is still set!\n");
+
+	mysqli_close($link);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[020] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (false !== ($tmp = mysqli_change_user($link, str_repeat('user', 16384), str_repeat('pass', 16384), str_repeat('dbase', 16384))))
+		printf("[021] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[022] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	/* silent protocol change if no db which requires workaround in mysqlnd/libmysql
+    (empty db = no db send with COM_CHANGE_USER) */
+	if (true !== ($tmp = mysqli_change_user($link, $user, $passwd, "")))
+		printf("[023] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, 'SELECT database() AS dbname, user() AS user'))
+		printf("[024] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+
+	if ($tmp['dbname'] != "")
+		printf("[025] Expecting database '', got database() '%s'\n", $tmp['dbname']);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = @mysqli_change_user($link, $user, $passwd, $db)))
+		printf("[026] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_get_lock.phpt
@@ -0,0 +1,106 @@
+--TEST--
+mysqli_change_user() - GET_LOCK()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+die("skip - is the server still buggy?");
+?>
+--INI--
+max_execution_time=240
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	// We need this little hack to be able to re-run the test
+	$lock = 'phptest_' . mt_rand(0, 100000);
+	$thread_id = mysqli_thread_id($link);
+
+	printf("Testing GET_LOCK()...\n");
+
+	if (!$res = mysqli_query($link, sprintf('SELECT GET_LOCK("%s", 2) AS _ok', $lock)))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_ok'] != 1)
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	else
+		printf("... lock '%s' acquired by thread %d\n", $lock, $thread_id);
+
+	mysqli_free_result($res);
+
+
+	// GET_LOCK("phptest") should be released
+	/* From the mysql_change_user documentation:
+This command resets the state as if one had done a new connect. (See Section 25.2.13, Controlling Automatic Reconnect Behavior.) It always performs a ROLLBACK of any active transactions, closes and drops all temporary tables, and unlocks all locked tables. Session system variables are reset to the values of the corresponding global system variables. Prepared statements are released and HANDLER variables are closed. Locks acquired with GET_LOCK() are released. These effects occur even if the user didn't change.
+	*/
+	mysqli_change_user($link, $user, $passwd, $db);
+sleep(5);
+	$new_thread_id = mysqli_thread_id($link);
+
+	printf("... calling IS_USED_LOCK() on '%s' using thread '%d'\n", $lock, $new_thread_id);
+	if (!$res = mysqli_query($link, 'SELECT IS_USED_LOCK("phptest") AS _ok'))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_ok'] != NULL)
+		printf("[006] Lock '%s' should have been released, [%d] %s\n",
+			$lock,
+			mysqli_errno($link), mysqli_error($link));
+
+	printf("... calling IS_FREE_LOCK() on '%s' using thread '%d'\n", $lock, $new_thread_id);
+	if (!$res = mysqli_query($link, 'SELECT IS_FREE_LOCK("phptest") AS _ok'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_ok'] != 1)
+		printf("[009] Lock '%s' should have been released, [%d] %s\n",
+			$lock,
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	/* Ok, let's try a NEW connection and a NEW lock! */
+	mysqli_close($link);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[010] Cannot open new connection, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	do {
+		$newlock = 'phptest_' . mt_rand(0, 100000);
+	} while ($lock == $newlock);
+
+	$new_thread_id = mysqli_thread_id($link);
+	printf("... calling IS_USED_LOCK() on '%s' using new connection with thread '%d'\n", $newlock, $new_thread_id);
+	if (!$res = mysqli_query($link, 'SELECT IS_USED_LOCK("phptest") AS _ok'))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_ok'] != NULL)
+		printf("[013] Lock '%s' should have been released, [%d] %s\n",
+			$lock,
+			mysqli_errno($link), mysqli_error($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Testing GET_LOCK()...
+... lock 'phptest_%d' acquired by thread %d
+... calling IS_USED_LOCK() on 'phptest_%d' using thread '%d'
+... calling IS_FREE_LOCK() on 'phptest_%d' using thread '%d'
+... calling IS_USED_LOCK() on 'phptest_%d' using new connection with thread '%d'
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_insert_id.phpt
@@ -0,0 +1,65 @@
+--TEST--
+mysqli_change_user() - LAST_INSERT_ID() - http://bugs.mysql.com/bug.php?id=45184?
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$IS_MYSQLND) {
+	die("skip Might hit known and open bugs http://bugs.mysql.com/bug.php?id=30472, http://bugs.mysql.com/bug.php?id=45184");
+}
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT AUTO_INCREMENT PRIMARY KEY, label CHAR(10))'))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, 'z')"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (($insert_id = mysqli_insert_id($link)) !== 100)
+		printf("[005] Expecting 100, got %d, [%d] %s\n",
+			$insert_id,
+			mysqli_errno($link), mysqli_error($link));
+
+	// LAST_INSERT_ID should be reset
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	if (($insert_id = mysqli_insert_id($link)) !== 0)
+			printf("[006] Expecting 0, got %d, [%d] %s\n",
+				$insert_id,
+				mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT LAST_INSERT_ID() as _insert_id'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if ($row['_insert_id'] != $insert_id)
+		printf("LAST_INSERT_ID() [%d] and mysqli_insert_id [%d] differ!\n",
+			$row['_insert_id'], $insert_id);
+
+	if ($row['_insert_id'] != 0)
+		printf("Expecting 0 got %d\n", $row['_insert_id']);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_locks_temporary.phpt
@@ -0,0 +1,107 @@
+--TEST--
+mysqli_change_user() - table locks, GET_LOCK(), temporary tables
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+die("skip - is the server still buggy?");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot create second connection handle, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!mysqli_query($link, 'LOCK TABLE test WRITE'))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	/*
+	if ($res = mysqli_query($link2, 'SELECT COUNT(*) AS _num FROM test')) {
+		printf("[003] Reading from test should not be possible due to a lock, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link2));
+		mysqli_free_result($res);
+	}
+	*/
+
+	// LOCKS should be removed
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	if (!$res = mysqli_query($link2, 'SELECT COUNT(*) AS _num FROM test'))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_num'] < 1)
+		printf("[005] There should be some rows in the table test\n");
+
+	mysqli_free_result($res);
+	mysqli_close($link2);
+
+	if (!mysqli_query($link, 'DROP TABLE test'))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'CREATE TEMPORARY TABLE test(id INT)'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'INSERT INTO test(id) VALUES (1), (2), (3)'))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS _num FROM test'))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_num'] != 3)
+		printf("[011] There should be three rows in the table test\n");
+
+	mysqli_free_result($res);
+
+	// Temporary tables should be dropped
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	if ($res = mysqli_query($link, 'SELECT COUNT(*) AS _num FROM test')) {
+		printf("[012] There should be no table test any more, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+		mysqli_free_result($res);
+	}
+
+	if (!$res = mysqli_query($link, 'SELECT GET_LOCK("phptest", 2) AS _ok'))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_ok'] != 1)
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	// GET_LOCK("phptest") should be released
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	if (!$res = mysqli_query($link, 'SELECT IS_FREE_LOCK("phptest") AS _ok'))
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_ok'] != 1)
+		printf("[018] Lock 'phptest' should have been released, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_oo.phpt
@@ -0,0 +1,84 @@
+--TEST--
+mysqli->change_user()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once('table.inc');
+if (!$IS_MYSQLND && (mysqli_get_server_version($link) < 50118 && mysqli_get_server_version($link) > 50100)) {
+	die("skip Your MySQL Server version has a known bug that will cause a crash");
+}
+?>
+--FILE--
+<?php
+	include_once("connect.inc");
+
+	$link	= NULL;
+	$tmp	= NULL;
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @$mysqli->change_user()))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$mysqli->change_user($link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$mysqli->change_user($link, $link)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$mysqli->change_user($link, $link, $link, $link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $mysqli->change_user($user . '_unknown_really', $passwd . 'non_empty', $db)))
+		printf("[006] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $mysqli->change_user($user, $passwd . '_unknown_really', $db)))
+		printf("[007] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $mysqli->change_user($user, $passwd, $db . '_unknown_really')))
+		printf("[008] Expecting false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('SET @mysqli_change_user_test_var=1'))
+		printf("[009] Failed to set test variable: [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT @mysqli_change_user_test_var AS test_var'))
+		printf("[010] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	if (1 != $tmp['test_var'])
+		printf("[011] Cannot set test variable\n");
+
+	if (true !== ($tmp = $mysqli->change_user($user, $passwd, $db)))
+		printf("[012] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = $mysqli->query('SELECT database() AS dbname, user() AS user'))
+		printf("[013] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+
+	if (substr($tmp['user'], 0, strlen($user)) !== $user)
+		printf("[014] Expecting user %s, got user() %s\n", $user, $tmp['user']);
+	if ($tmp['dbname'] != $db)
+		printf("[015] Expecting database %s, got database() %s\n", $db, $tmp['dbname']);
+
+	if (!$res = $mysqli->query('SELECT @mysqli_change_user_test_var AS test_var'))
+		printf("[016] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	if (NULL !== $tmp['test_var'])
+		printf("[017] Test variable is still set!\n");
+
+	$mysqli->close();
+
+	if (NULL !== ($tmp = @$mysqli->change_user($user, $passwd, $db)))
+		printf("[018] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_prepared_statements.phpt
@@ -0,0 +1,33 @@
+--TEST--
+mysqli_change_user() - Prepared Statement
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$stmt = mysqli_prepare($link, "SELECT 'prepared statements should be released'"))
+		printf("[002] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	$wrong = null;
+	if ($stmt->execute() && $stmt->bind_result($wrong) && $stmt->fetch()) {
+		printf("This is wrong, because after a mysqli_change_user() %s\n", $wrong);
+	} else {
+		if ($stmt->errno == 0)
+			printf("Error code 2013, 1243 or similar should have been set\n");
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_rollback.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysqli_change_user() - ROLLBACK
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (!have_innodb($link))
+	die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	if (!mysqli_query($link, 'ALTER TABLE test ENGINE=InnoDB'))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_autocommit($link, false);
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS _num FROM test'))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	$num = $row['_num'];
+	assert($num > 0);
+
+	if (!$res = mysqli_query($link, 'DELETE FROM test'))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS _num FROM test'))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if (0 != $row['_num'])
+		printf("[007] Rows should have been deleted in this transaction\n");
+
+	// DELETE should be rolled back
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS _num FROM test'))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['_num'] != $num)
+		printf("[010] Expecting %d rows in the table test, found %d rows\n",
+			$num, $row['_num']);
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_change_user_set_names.phpt
@@ -0,0 +1,165 @@
+--TEST--
+mysqli_change_user() - SET NAMES
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("skip [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (!$res = mysqli_query($link, 'SELECT version() AS server_version'))
+	die(sprintf("skip [%d] %s\n", mysqli_errno($link), mysqli_error($link)));
+
+$tmp = mysqli_fetch_assoc($res);
+mysqli_free_result($res);
+$version = explode('.', $tmp['server_version']);
+if (empty($version))
+	die(sprintf("skip Cannot determine server version, we need MySQL Server 4.1+ for the test!"));
+
+if ($version[0] <= 4 && $version[1] < 1)
+	die(sprintf("skip We need MySQL Server 4.1+ for the test!"));
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($link, "SHOW CHARACTER SET LIKE 'latin%'"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$charsets = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$charsets[$row['Charset']] = $row['Default collation'];
+
+	mysqli_free_result($res);
+	if (!mysqli_query($link, 'SET NAMES DEFAULT'))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT
+		@@character_set_client AS charset_client,
+		@@character_set_connection AS charset_connection,
+		@@character_set_results AS charset_results,
+		@@collation_connection AS collation_connection,
+		@@collation_database AS collation_database,
+		@@collation_server AS collation_server'))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$defaults = mysqli_fetch_assoc($res))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	$not_changed = $defaults;
+	foreach ($charsets as $charset => $collation) {
+
+		if (isset($not_changed['charset_client']) &&
+				$charset != $not_changed['charset_client'] &&
+				mysqli_query($link, sprintf("SET @@character_set_client = '%s'", $charset)))
+			unset($not_changed['charset_client']);
+
+		if (isset($not_changed['charset_connection']) &&
+				$charset != $not_changed['charset_connection'] &&
+				mysqli_query($link, sprintf("SET @@character_connection = '%s'", $charset)))
+			unset($not_changed['charset_connection']);
+
+		if (isset($not_changed['charset_results']) &&
+				$charset != $not_changed['charset_results'] &&
+				mysqli_query($link, sprintf("SET @@character_set_results = '%s'", $charset)))
+			unset($not_changed['charset_results']);
+
+		if (isset($not_changed['collation_connection']) &&
+				$collation != $not_changed['collation_connection'] &&
+				mysqli_query($link, sprintf("SET @@collation_connection = '%s'", $collation)))
+			unset($not_changed['collation_connection']);
+
+		if (isset($not_changed['collation_database']) &&
+				$collation != $not_changed['collation_database'] &&
+				mysqli_query($link, sprintf("SET @@collation_database = '%s'", $collation)))
+			unset($not_changed['collation_database']);
+
+		if (isset($not_changed['collation_server']) &&
+				$collation != $not_changed['collation_server'] &&
+				mysqli_query($link, sprintf("SET @@collation_server = '%s'", $collation)))
+			unset($not_changed['collation_server']);
+
+		if (empty($not_changed))
+			break;
+	}
+
+	if (!$res = mysqli_query($link, 'SELECT
+		@@character_set_client AS charset_client,
+		@@character_set_connection AS charset_connection,
+		@@character_set_results AS charset_results,
+		@@collation_connection AS collation_connection,
+		@@collation_database AS collation_database,
+		@@collation_server AS collation_server'))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$modified = mysqli_fetch_assoc($res))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if ($modified == $defaults)
+		printf("[008] Not all settings have been changed\n");
+
+	// LAST_INSERT_ID should be reset
+	mysqli_change_user($link, $user, $passwd, $db);
+
+	if (!$res = mysqli_query($link, 'SELECT
+		@@character_set_client AS charset_client,
+		@@character_set_connection AS charset_connection,
+		@@character_set_results AS charset_results,
+		@@collation_connection AS collation_connection,
+		@@collation_database AS collation_database,
+		@@collation_server AS collation_server'))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$new = mysqli_fetch_assoc($res))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if ($new == $modified) {
+		printf("[011] Charsets/collations have not been reset.\n");
+		printf("Got:\n");
+		var_dump($new);
+		printf("Expected:\n");
+		var_dump($defaults);
+	}
+
+	if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1)) {
+		// charsets cannot take any other value but utf8 in unicode mode
+		$defaults['charset_client'] = 'utf8';
+		$defaults['charset_connection'] = 'utf8';
+		$defaults['charset_results'] = 'utf8';
+		$defaults['collation_connection'] = 'utf8_general_ci';
+	}
+
+	if ($new != $defaults) {
+		printf("[012] Charsets/collations have not been reset to their defaults.\n");
+		printf("Got:\n");
+		var_dump($new);
+		printf("Expected:\n");
+		var_dump($defaults);
+	}
+
+	if (!is_object($charset = mysqli_get_charset($link)))
+		printf("[013] Expecting object/std_class, got %s/%s\n", gettype($charset), $charset);
+
+	if ($charset->charset != $defaults['charset_connection'])
+		printf("[014] Expecting connection charset to be %s got %s\n",
+			$defaults['charset_connection'],
+			$charset->charset);
+
+	if ($charset->collation != $defaults['collation_connection'])
+		printf("[015] Expecting collation to be %s got %s\n",
+			$defaults['collation_connection'],
+			$charset->collation);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_character_set.phpt
@@ -0,0 +1,111 @@
+--TEST--
+Fetching results from tables of different charsets.
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('skipifunicode.inc');
+require_once('skipifemb.inc');
+
+if (!function_exists('mysqli_set_charset')) {
+	die('skip mysqli_set_charset() not available');
+}
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip set character set not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
+}
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = mysqli_query($link, 'SELECT version() AS server_version'))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	$version = explode('.', $tmp['server_version']);
+	if (empty($version))
+		printf("[003] Cannot determine server version, need MySQL Server 4.1+ for the test!\n");
+
+	if ($version[0] <= 4 && $version[1] < 1)
+		printf("[004] Need MySQL Server 4.1+ for the test!\n");
+
+	if (!$res = mysqli_query($link, "SHOW CHARACTER SET"))
+		printf("[005] Cannot get list of available character sets, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	$charsets = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$charsets[] = $row;
+	mysqli_free_result($res);
+
+	foreach ($charsets as $charset) {
+		$k = $charset['Charset'];
+		/* The server currently 17.07.2007 can't handle data sent in ucs2 */
+		/* The server currently 16.08.2010 can't handle data sent in utf16 and utf32 */
+		/* The server currently 02.09.2011 can't handle data sent in utf16le */
+		if ($charset['Charset'] == 'ucs2' || $charset['Charset'] == 'utf16' || $charset['Charset'] == 'utf32' || 'utf16le' == $charset['Charset']) {
+			continue;
+		}
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+			printf("[006 + %s] [%d] %s\n", $k, mysqli_errno($link), mysqli_error($link));
+
+		$sql = sprintf("CREATE TABLE test(id INT, label CHAR(1)) CHARACTER SET '%s' ", $charset['Charset']);
+		if (!mysqli_query($link, $sql)) {
+			printf("[007 + %s] %s [%d] %s\n", $k, $sql, mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		if (!mysqli_set_charset($link, $charset['Charset'])) {
+			printf("[008 + %s] [%d] %s\n", $k, mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		for ($i = 1; $i <= 3; $i++) {
+			if (!mysqli_query($link, sprintf("INSERT INTO test (id, label) VALUES (%d, '%s')",
+								$i, mysqli_real_escape_string($link, chr(ord("a") + $i)))))
+			{
+				var_dump($charset['Charset']);
+				printf("[009 + %s] [%d] %s\n", $k, mysqli_errno($link), mysqli_error($link));
+				continue;
+			}
+		}
+
+		if (!$res = mysqli_query($link, "SELECT id, label FROM test"))
+			printf("[010 + %s] [%d] %s\n", $k, mysqli_errno($link), mysqli_error($link));
+
+		for ($i = 1; $i <= 3; $i++) {
+
+			if (!$tmp = mysqli_fetch_assoc($res))
+				printf("[011 + %s] [%d] %s\n", $k, mysqli_errno($link), mysqli_error($link));
+
+			if ($tmp['id'] != $i)
+				printf("[012 + %s] Expecting %d, got %s, [%d] %s\n", $k,
+						$i, $tmp['id'],
+						mysqli_errno($link), mysqli_error($link));
+
+			if ($tmp['label'] != chr(ord("a") + $i))
+				printf("[013 + %s] Expecting %d, got %s, [%d] %s\n", $k,
+					chr(ord("a") + $i), $tmp['label'],
+					mysqli_errno($link), mysqli_error($link));
+
+		}
+		mysqli_free_result($res);
+	}
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_character_set_name.phpt
@@ -0,0 +1,75 @@
+--TEST--
+mysqli_chararcter_set_name(), mysql_client_encoding() [alias]
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/* NOTE: http://bugs.mysql.com/bug.php?id=7923 makes this test fail very likely on all 4.1.x - 5.0.x! */
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_character_set_name()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_character_set_name($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_character_set_name($link, $link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[005] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = mysqli_query($link, 'SELECT version() AS server_version'))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	$version = explode('.', $tmp['server_version']);
+	if (empty($version))
+		printf("[006] Cannot determine server version, need MySQL Server 4.1+ for the test!\n");
+
+	if ($version[0] <= 4 && $version[1] < 1)
+		printf("[007] Need MySQL Server 4.1+ for the test!\n");
+
+	if (!$res = mysqli_query($link, 'SELECT @@character_set_connection AS charset, @@collation_connection AS collation'))
+			printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!$tmp['charset'])
+		printf("[009] Cannot determine current character set and collation\n");
+
+	$charset = mysqli_character_set_name($link);
+	if ($tmp['charset'] !== $charset) {
+		if ($tmp['collation'] === $charset) {
+			printf("[010] Could be known server bug http://bugs.mysql.com/bug.php?id=7923, collation %s instead of character set returned, expected string/%s, got %s/%s\n",
+			$tmp['collation'], $tmp['charset'], gettype($charset), $charset);
+		} else {
+			printf("[011] Expecting character set %s/%s, got %s/%s\n", gettype($tmp['charset']), $tmp['charset'], gettype($charset), $charset);
+		}
+	}
+
+	$charset2 = mysqli_character_set_name($link);
+	if ($charset2 !== $charset) {
+		printf("[012] Alias mysqli_character_set_name returned %s/%s, expected  %s/%s\n", gettype($charset2), $charset2, gettype($charset), $charset);
+	}
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = @mysqli_character_set_name($link)))
+		printf("[013] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	/* Make sure that the function alias exists */
+	if (!is_null($tmp = @mysqli_character_set_name()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_character_set_name_oo.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysqli_chararcter_set_name(), mysql_client_encoding() [alias]
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/* NOTE: http://bugs.mysql.com/bug.php?id=7923 makes this test fail very likely on all 4.1.x - 5.0.x! */
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @$mysqli->character_set_name($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = $mysqli->query('SELECT version() AS server_version'))
+		printf("[003] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	$version = explode('.', $tmp['server_version']);
+	if (empty($version))
+		printf("[006] Cannot determine server version, need MySQL Server 4.1+ for the test!\n");
+
+	if ($version[0] <= 4 && $version[1] < 1)
+		printf("[007] Need MySQL Server 4.1+ for the test!\n");
+
+	if (!$res = $mysqli->query('SELECT @@character_set_connection AS charset, @@collation_connection AS collation'))
+		printf("[008] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	$res->free_result();
+	if (!$tmp['charset'])
+		printf("[009] Cannot determine current character set and collation\n");
+
+	$charset = $mysqli->character_set_name();
+	if ($tmp['charset'] !== $charset) {
+		if ($tmp['collation'] === $charset) {
+			printf("[010] Could be known server bug http://bugs.mysql.com/bug.php?id=7923, collation %s instead of character set returned, expected string/%s, got %s/%s\n",
+				$tmp['collation'], $tmp['charset'], gettype($charset), $charset);
+		} else {
+			printf("[011] Expecting character set %s/%s, got %s/%s\n", gettype($tmp['charset']), $tmp['charset'], gettype($charset), $charset);
+		}
+	}
+
+	$charset2 = $mysqli->character_set_name();
+	if ($charset2 !== $charset) {
+		printf("[012] Alias mysqli_character_set_name returned %s/%s, expected  %s/%s\n",
+			gettype($charset2), $charset2, gettype($charset), $charset);
+	}
+
+	$mysqli->close();
+
+	if (NULL !== ($tmp = @$mysqli->character_set_name()))
+		printf("[013] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	/* Make sure that the function alias exists */
+	if (!is_null($tmp = @$mysqli->character_set_name()))
+		printf("[014] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_driver_interface.phpt
@@ -0,0 +1,128 @@
+--TEST--
+Interface of the class mysqli_driver
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	require('table.inc');
+
+	$driver = new mysqli_driver();
+
+	printf("Parent class:\n");
+	var_dump(get_parent_class($driver));
+
+	printf("\nMethods:\n");
+	$methods = get_class_methods($driver);
+	$expected_methods = array();
+
+	if (!$IS_MYSQLND && (isset($methods['embedded_server_start']))) {
+		/* libmysql only - needs extra compile flag, no way to check properly in the
+		PHP user land if its compiled in or not */
+		$expected_methods = array_merge($expected_methods, array(
+				'embedded_server_start'         => true,
+				'embedded_server_end'           => true,
+		));
+	}
+
+	foreach ($methods as $k => $method) {
+		if (isset($expected_methods[$method])) {
+			unset($expected_methods[$method]);
+			unset($methods[$k]);
+		}
+	}
+	if (!empty($expected_methods)) {
+		printf("Dumping list of missing methods.\n");
+		var_dump($expected_methods);
+	}
+	if (!empty($methods)) {
+		printf("Dumping list of unexpected methods.\n");
+		var_dump($methods);
+	}
+	if (empty($expected_methods) && empty($methods))
+		printf("ok\n");
+
+	printf("\nClass variables:\n");
+	$variables = array_keys(get_class_vars(get_class($driver)));
+	sort($variables);
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nObject variables:\n");
+	$variables = array_keys(get_object_vars($driver));
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nMagic, magic properties:\n");
+
+	assert(mysqli_get_client_info() === $driver->client_info);
+	printf("driver->client_info = '%s'\n", $driver->client_info);
+
+	assert(mysqli_get_client_version() === $driver->client_version);
+	printf("driver->client_version = '%s'\n", $driver->client_version);
+
+	assert($driver->driver_version > 0);
+	printf("driver->driver_version = '%s'\n", $driver->driver_version);
+
+	assert(in_array($driver->report_mode,
+				array(
+					MYSQLI_REPORT_ALL,
+					MYSQLI_REPORT_STRICT,
+					MYSQLI_REPORT_ERROR,
+					MYSQLI_REPORT_INDEX,
+					MYSQLI_REPORT_OFF
+				)
+	));
+
+	printf("driver->report_mode = '%s'\n", $driver->report_mode);
+	$driver->report_mode = MYSQLI_REPORT_STRICT;
+	assert($driver->report_mode === MYSQLI_REPORT_STRICT);
+
+	assert(is_bool($driver->embedded));
+	printf("driver->embedded = '%s'\n", $driver->embedded);
+
+	printf("driver->reconnect = '%s'\n", $driver->reconnect);
+
+	printf("\nAccess to undefined properties:\n");
+	printf("driver->unknown = '%s'\n", @$driver->unknown);
+
+	print "done!";
+?>
+--EXPECTF--
+Parent class:
+bool(false)
+
+Methods:
+ok
+
+Class variables:
+client_info
+client_version
+driver_version
+embedded
+reconnect
+report_mode
+
+Object variables:
+client_info
+client_version
+driver_version
+embedded
+reconnect
+report_mode
+
+Magic, magic properties:
+driver->client_info = '%s'
+driver->client_version = '%d'
+driver->driver_version = '%d'
+driver->report_mode = '%d'
+driver->embedded = ''
+driver->reconnect = ''
+
+Access to undefined properties:
+driver->unknown = ''
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_driver_reflection.phpt
@@ -0,0 +1,92 @@
+--TEST--
+Interface of the class mysqli_driver - Reflection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+if (($tmp = substr(PHP_VERSION, 0, strpos(PHP_VERSION, '.'))) && ($tmp < 5))
+	die("skip Reflection not available before PHP 5 (found PHP $tmp)");
+
+/*
+Let's not deal with cross-version issues in the EXPECTF/UEXPECTF.
+Most of the things which we test are covered by mysqli_class_*_interface.phpt.
+Those tests go into the details and are aimed to be a development tool, no more.
+*/
+if (!$IS_MYSQLND)
+	die("skip Test has been written for the latest version of mysqlnd only");
+?>
+--FILE--
+<?php
+	require_once('reflection_tools.inc');
+	$class = new ReflectionClass('mysqli_driver');
+	inspectClass($class);
+	print "done!";
+?>
+--EXPECTF--
+Inspecting class 'mysqli_driver'
+isInternal: yes
+isUserDefined: no
+isInstantiable: yes
+isInterface: no
+isAbstract: no
+isFinal: yes
+isIteratable: no
+Modifiers: '%d'
+Parent Class: ''
+Extension: 'mysqli'
+
+Inspecting property 'client_info'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'client_version'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'driver_version'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'embedded'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'reconnect'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'report_mode'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+Default property 'client_info'
+Default property 'client_version'
+Default property 'driver_version'
+Default property 'embedded'
+Default property 'reconnect'
+Default property 'report_mode'
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_interface.phpt
@@ -0,0 +1,319 @@
+--TEST--
+Interface of the class mysqli
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('connect.inc');
+
+	$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket);
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+
+	printf("Parent class:\n");
+	var_dump(get_parent_class($mysqli));
+
+	printf("\nMethods:\n");
+	$methods = get_class_methods($mysqli);
+	$expected_methods = array(
+		'autocommit'			=> true,
+		'change_user'			=> true,
+		'character_set_name'		=> true,
+		'close'				=> true,
+		'commit'	=> true,
+		'connect'			=> true,
+		'dump_debug_info'		=> true,
+		'escape_string'			=> true,
+		'get_charset'			=> true,
+		'get_client_info'		=> true,
+		'get_server_info'		=> true,
+		'get_warnings'			=> true,
+		'init'				=> true,
+		'kill'				=> true,
+		'more_results'			=> true,
+		'multi_query'			=> true,
+		'mysqli'			=> true,
+		'next_result'			=> true,
+		'options'			=> true,
+		'ping'				=> true,
+		'prepare'			=> true,
+		'query'				=> true,
+		'real_connect'			=> true,
+		'real_escape_string'		=> true,
+		'real_query'			=> true,
+		'refresh'			=> true,
+		'rollback'			=> true,
+		'select_db'			=> true,
+		'set_charset'			=> true,
+		'set_opt'			=> true,
+		'ssl_set'			=> true,
+		'stat'				=> true,
+		'stmt_init'			=> true,
+		'store_result'			=> true,
+		'thread_safe'			=> true,
+		'use_result'			=> true,
+	);
+
+	if (version_compare(PHP_VERSION, '5.3.99', '<=')) {
+		$expected_methods['client_encoding'] = true;
+	}
+
+	if ($IS_MYSQLND) {
+		// mysqlnd only
+		/* $expected_methods['get_client_stats']	= true; */
+		$expected_methods['get_connection_stats']	= true;
+		$expected_methods['reap_async_query']	= true;
+		$expected_methods['poll'] = true;
+	} else {
+		// libmysql only
+		if (function_exists('mysqli_ssl_set'))
+			$expected_methods['ssl_set'] = true;
+		$expected_methods['set_local_infile_default']	= true;
+		$expected_methods['set_local_infile_handler']	= true;
+	}
+
+	/* we should add ruled when to expect them */
+	if (function_exists('mysqli_debug'))
+		$expected_methods['debug']		= true;
+	if (function_exists('ssl_set'))
+		$expected_methods['ssl_set']		= true;
+
+	foreach ($methods as $k => $method) {
+		if (isset($expected_methods[$method])) {
+			unset($methods[$k]);
+			unset($expected_methods[$method]);
+		}
+	}
+	if (!empty($methods)) {
+		printf("Dumping list of unexpected methods.\n");
+		var_dump($methods);
+	}
+	if (!empty($expected_methods)) {
+		printf("Dumping list of missing methods.\n");
+		var_dump($expected_methods);
+	}
+	if (empty($methods) && empty($expected_methods))
+		printf("ok\n");
+
+	printf("\nClass variables:\n");
+
+	$expected_class_variables = $expected_object_variables = array(
+		"affected_rows" 	=> true,
+		"client_info"		=> true,
+		"client_version"	=> true,
+		"connect_errno"		=> true,
+		"connect_error"		=> true,
+		"errno"				=> true,
+		"error"				=> true,
+		"field_count"		=> true,
+		"host_info"			=> true,
+		"info"				=> true,
+		"insert_id"			=> true,
+		"protocol_version"	=> true,
+		"server_info"		=> true,
+		"server_version"	=> true,
+		"sqlstate"			=> true,
+		"stat"				=> true,
+		"thread_id"			=> true,
+		"warning_count"		=> true,
+	);
+
+	if (version_compare(PHP_VERSION, '5.3.99', '>')) {
+	  $expected_class_variables["error_list"] = true;
+	  $expected_object_variables["error_list"] = true;
+	}
+
+	$variables = get_class_vars(get_class($mysqli));
+	foreach ($variables as $var => $v) {
+		if (isset($expected_class_variables[$var])) {
+			unset($expected_class_variables[$var]);
+			unset($variables[$var]);
+		}
+	}
+
+	if (!empty($expected_class_variables)) {
+	  printf("Dumping list of missing class variables\n");
+	  var_dump($expected_class_variables);
+	}
+	if (!empty($variables)) {
+	  printf("Dumping list of unexpected class variables\n");
+	  var_dump($variables);
+	}
+	echo "ok\n";
+
+	printf("\nObject variables:\n");
+	$variables = get_object_vars($mysqli);
+	foreach ($variables as $var => $v) {
+		if (isset($expected_object_variables[$var])) {
+			unset($expected_object_variables[$var]);
+			unset($variables[$var]);
+		}
+	}
+
+	if (!empty($expected_object_variables)) {
+	  printf("Dumping list of missing object variables\n");
+	  var_dump($expected_object_variables);
+	}
+	if (!empty($variables)) {
+	  printf("Dumping list of unexpected object variables\n");
+	  var_dump($variables);
+	}
+	echo "ok\n";
+
+
+	printf("\nMagic, magic properties:\n");
+
+	assert(mysqli_affected_rows($link) === $mysqli->affected_rows);
+	printf("mysqli->affected_rows = '%s'/%s ('%s'/%s)\n",
+		$mysqli->affected_rows, gettype($mysqli->affected_rows),
+		mysqli_affected_rows($link), gettype(mysqli_affected_rows($link)));
+
+	assert(mysqli_get_client_info() === $mysqli->client_info);
+	printf("mysqli->client_info = '%s'/%s ('%s'/%s)\n",
+		$mysqli->client_info, gettype($mysqli->client_info),
+		mysqli_get_client_info(), gettype(mysqli_get_client_info()));
+
+	assert(mysqli_get_client_version() === $mysqli->client_version);
+	printf("mysqli->client_version =  '%s'/%s ('%s'/%s)\n",
+		$mysqli->client_version, gettype($mysqli->client_version),
+		mysqli_get_client_version(), gettype(mysqli_get_client_version()));
+
+	assert(mysqli_errno($link) === $mysqli->errno);
+	printf("mysqli->errno = '%s'/%s ('%s'/%s)\n",
+		$mysqli->errno, gettype($mysqli->errno),
+		mysqli_errno($link), gettype(mysqli_errno($link)));
+
+	assert(mysqli_error($link) === $mysqli->error);
+	printf("mysqli->error = '%s'/%s ('%s'/%s)\n",
+		$mysqli->error, gettype($mysqli->error),
+		mysqli_error($link), gettype(mysqli_error($link)));
+
+	if (version_compare(PHP_VERSION, '5.3.99', '>')) {
+		assert(mysqli_error_list($link) === $mysqli->error_list);
+		assert(is_array($mysqli->error_list));
+	}
+
+	assert(mysqli_field_count($link) === $mysqli->field_count);
+	printf("mysqli->field_count = '%s'/%s ('%s'/%s)\n",
+		$mysqli->field_count, gettype($mysqli->field_count),
+		mysqli_field_count($link), gettype(mysqli_field_count($link)));
+
+	assert(mysqli_insert_id($link) === $mysqli->insert_id);
+	printf("mysqli->insert_id = '%s'/%s ('%s'/%s)\n",
+		$mysqli->insert_id, gettype($mysqli->insert_id),
+		mysqli_insert_id($link), gettype(mysqli_insert_id($link)));
+
+	assert(mysqli_sqlstate($link) === $mysqli->sqlstate);
+	printf("mysqli->sqlstate = '%s'/%s ('%s'/%s)\n",
+		$mysqli->sqlstate, gettype($mysqli->sqlstate),
+		mysqli_sqlstate($link), gettype(mysqli_sqlstate($link)));
+
+	assert(soundex(mysqli_stat($link)) == soundex($mysqli->stat));
+	printf("mysqli->stat = '%s'/%s ('%s'/%s)\n",
+		$mysqli->stat, gettype($mysqli->stat),
+		mysqli_stat($link), gettype(mysqli_stat($link)));
+
+	assert(mysqli_get_host_info($link) === $mysqli->host_info);
+	printf("mysqli->host_info = '%s'/%s ('%s'/%s)\n",
+		$mysqli->host_info, gettype($mysqli->host_info),
+		mysqli_get_host_info($link), gettype(mysqli_get_host_info($link)));
+
+	/* note that the data types are different */
+	assert(mysqli_info($link) == $mysqli->info);
+	printf("mysqli->info = '%s'/%s ('%s'/%s)\n",
+		$mysqli->info, gettype($mysqli->info),
+		mysqli_info($link), gettype(mysqli_info($link)));
+
+	assert(mysqli_thread_id($link) > $mysqli->thread_id);
+	assert(gettype($mysqli->thread_id) == gettype(mysqli_thread_id($link)));
+	printf("mysqli->thread_id = '%s'/%s ('%s'/%s)\n",
+		$mysqli->thread_id, gettype($mysqli->thread_id),
+		mysqli_thread_id($link), gettype(mysqli_thread_id($link)));
+
+	assert(mysqli_get_proto_info($link) === $mysqli->protocol_version);
+	printf("mysqli->protocol_version = '%s'/%s ('%s'/%s)\n",
+		$mysqli->protocol_version, gettype($mysqli->protocol_version),
+		mysqli_get_proto_info($link), gettype(mysqli_get_proto_info($link)));
+
+	assert(mysqli_get_server_info($link) === $mysqli->server_info);
+	printf("mysqli->server_info = '%s'/%s ('%s'/%s)\n",
+		$mysqli->server_info, gettype($mysqli->server_info),
+		mysqli_get_server_info($link), gettype(mysqli_get_server_info($link)));
+
+	assert(mysqli_get_server_version($link) === $mysqli->server_version);
+	printf("mysqli->server_version = '%s'/%s ('%s'/%s)\n",
+		$mysqli->server_version, gettype($mysqli->server_version),
+		mysqli_get_server_version($link), gettype(mysqli_get_server_version($link)));
+
+	assert(mysqli_warning_count($link) === $mysqli->warning_count);
+	printf("mysqli->warning_count = '%s'/%s ('%s'/%s)\n",
+		$mysqli->warning_count, gettype($mysqli->warning_count),
+		mysqli_warning_count($link), gettype(mysqli_warning_count($link)));
+
+	printf("\nAccess to undefined properties:\n");
+	printf("mysqli->unknown = '%s'\n", @$mysqli->unknown);
+
+	@$mysqli->unknown = 13;
+	printf("setting mysqli->unknown, mysqli_unknown = '%s'\n", @$mysqli->unknown);
+
+	$unknown = 'friday';
+	@$mysqli->unknown = $unknown;
+	printf("setting mysqli->unknown, mysqli_unknown = '%s'\n", @$mysqli->unknown);
+
+	$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	printf("\nAccess hidden properties for MYSLQI_STATUS_INITIALIZED (TODO documentation):\n");
+	assert(mysqli_connect_error() === $mysqli->connect_error);
+	printf("mysqli->connect_error = '%s'/%s ('%s'/%s)\n",
+		$mysqli->connect_error, gettype($mysqli->connect_error),
+		mysqli_connect_error(), gettype(mysqli_connect_error()));
+
+	assert(mysqli_connect_errno() === $mysqli->connect_errno);
+	printf("mysqli->connect_errno = '%s'/%s ('%s'/%s)\n",
+		$mysqli->connect_errno, gettype($mysqli->connect_errno),
+		mysqli_connect_errno(), gettype(mysqli_connect_errno()));
+
+	print "done!";
+?>
+--EXPECTF--
+Parent class:
+bool(false)
+
+Methods:
+ok
+
+Class variables:
+ok
+
+Object variables:
+ok
+
+Magic, magic properties:
+mysqli->affected_rows = '%s'/integer ('%s'/integer)
+mysqli->client_info = '%s'/%unicode|string% ('%s'/%unicode|string%)
+mysqli->client_version =  '%d'/integer ('%d'/integer)
+mysqli->errno = '0'/integer ('0'/integer)
+mysqli->error = ''/%unicode|string% (''/%unicode|string%)
+mysqli->field_count = '0'/integer ('0'/integer)
+mysqli->insert_id = '0'/integer ('0'/integer)
+mysqli->sqlstate = '00000'/%unicode|string% ('00000'/%unicode|string%)
+mysqli->stat = 'Uptime: %d  Threads: %d  Questions: %d  Slow queries: %d  Opens: %d  Flush tables: %d  Open tables: %d  Queries per second avg: %d.%d'/string ('Uptime: %d  Threads: %d  Questions: %d  Slow queries: %d  Opens: %d  Flush tables: %d  Open tables: %d  Queries per second avg: %d.%d'/string)
+mysqli->host_info = '%s'/%unicode|string% ('%s'/%unicode|string%)
+mysqli->info = ''/NULL (''/%unicode|string%)
+mysqli->thread_id = '%d'/integer ('%d'/integer)
+mysqli->protocol_version = '%d'/integer ('%d'/integer)
+mysqli->server_info = '%s'/%unicode|string% ('%s'/%unicode|string%)
+mysqli->server_version = '%d'/integer ('%d'/integer)
+mysqli->warning_count = '0'/integer ('0'/integer)
+
+Access to undefined properties:
+mysqli->unknown = ''
+setting mysqli->unknown, mysqli_unknown = '13'
+setting mysqli->unknown, mysqli_unknown = 'friday'
+
+Access hidden properties for MYSLQI_STATUS_INITIALIZED (TODO documentation):
+mysqli->connect_error = ''/NULL (''/NULL)
+mysqli->connect_errno = '0'/integer ('0'/integer)
+done!
\ No newline at end of file
--- a/ext/mysqli/tests/mysqli_class_mysqli_properties_no_conn.phpt
+++ b/ext/mysqli/tests/mysqli_class_mysqli_properties_no_conn.phpt
@@ -4,10 +4,11 @@
 <?php
 require_once('skipif.inc');
 require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
 ?>
 --FILE--
 <?php
-	require('connect.inc');
+	require('table.inc');
 
 	function dump_properties($mysqli) {
 
@@ -67,6 +68,11 @@
 			@$mysqli->sqlstate, gettype(@$mysqli->sqlstate),
 			@mysqli_sqlstate($mysqli), gettype(@mysqli_sqlstate($mysqli)));
 
+		assert(@mysqli_stat($mysqli) === @$mysqli->sstat);
+		printf("mysqli->stat = '%s'/%s ('%s'/%s)\n",
+			@$mysqli->stat, gettype(@$mysqli->stat),
+			@mysqli_stat($mysqli), gettype(@mysqli_stat($mysqli)));
+
 		assert(@mysqli_get_host_info($mysqli) === @$mysqli->host_info);
 		printf("mysqli->host_info = '%s'/%s ('%s'/%s)\n",
 			@$mysqli->host_info, gettype(@$mysqli->host_info),
@@ -132,33 +138,72 @@
 
 	printf("With RS\n");
 	$mysqli = @new mysqli($host, $user, $passwd . "invalid", $db, $port, $socket);
-	$res = @$mysqli->query("SELECT 1 AS 'a'");
+	$res = @$mysqli->query("SELECT * FROM test");
 	dump_properties($mysqli);
 
 	print "done!";
 ?>
+--CLEAN--
+<?php require_once("clean_table.inc"); ?>
 --EXPECTF--
 Without RS
 
 Class variables:
+affected_rows = 'NULL'
+client_info = 'NULL'
+client_version = '%d'
+connect_errno = '%d'
+connect_error = '%s'
+errno = 'NULL'
+error = 'NULL'
+field_count = 'NULL'
+host_info = 'NULL'
+info = 'NULL'
+insert_id = 'NULL'
+protocol_version = 'NULL'
+server_info = 'NULL'
+server_version = 'NULL'
+sqlstate = 'NULL'
+stat = 'NULL'
+thread_id = 'NULL'
+warning_count = 'NULL'
 
 Object variables:
+affected_rows = 'NULL'
+client_info = 'NULL'
+client_version = '%d'
+connect_errno = '%d'
+connect_error = '%s'
+errno = 'NULL'
+error = 'NULL'
+field_count = 'NULL'
+host_info = 'NULL'
+info = 'NULL'
+insert_id = 'NULL'
+server_info = 'NULL'
+server_version = 'NULL'
+stat = 'NULL'
+sqlstate = 'NULL'
+protocol_version = 'NULL'
+thread_id = 'NULL'
+warning_count = 'NULL'
 
 Magic, magic properties:
 mysqli->affected_rows = ''/NULL (''/NULL)
 
 Warning: assert(): Assertion failed in %s on line %d
 mysqli->client_info = ''/NULL ('%s'/string)
-mysqli->client_version =  '%s'/integer ('%s'/integer)
+mysqli->client_version =  '%d'/integer ('%d'/integer)
 mysqli->errno = ''/NULL (''/NULL)
 mysqli->error = ''/NULL (''/NULL)
 mysqli->field_count = ''/NULL (''/NULL)
 mysqli->insert_id = ''/NULL (''/NULL)
 mysqli->sqlstate = ''/NULL (''/NULL)
+mysqli->stat = ''/NULL (''/NULL)
 mysqli->host_info = ''/NULL (''/NULL)
 mysqli->info = ''/NULL (''/NULL)
 
-Warning: assert(): Assertion failed in %s on line %d
+Warning: assert(): Assertion failed in %s on line 78
 mysqli->thread_id = ''/NULL (''/NULL)
 mysqli->protocol_version = ''/NULL (''/NULL)
 mysqli->server_info = ''/NULL (''/NULL)
@@ -176,20 +221,57 @@
 With RS
 
 Class variables:
+affected_rows = 'NULL'
+client_info = 'NULL'
+client_version = '%d'
+connect_errno = '%d'
+connect_error = '%s'
+errno = 'NULL'
+error = 'NULL'
+field_count = 'NULL'
+host_info = 'NULL'
+info = 'NULL'
+insert_id = 'NULL'
+protocol_version = 'NULL'
+server_info = 'NULL'
+server_version = 'NULL'
+sqlstate = 'NULL'
+stat = 'NULL'
+thread_id = 'NULL'
+warning_count = 'NULL'
 
 Object variables:
+affected_rows = 'NULL'
+client_info = 'NULL'
+client_version = '%d'
+connect_errno = '%d'
+connect_error = '%s'
+errno = 'NULL'
+error = 'NULL'
+field_count = 'NULL'
+host_info = 'NULL'
+info = 'NULL'
+insert_id = 'NULL'
+server_info = 'NULL'
+server_version = 'NULL'
+stat = 'NULL'
+sqlstate = 'NULL'
+protocol_version = 'NULL'
+thread_id = 'NULL'
+warning_count = 'NULL'
 
 Magic, magic properties:
 mysqli->affected_rows = ''/NULL (''/NULL)
 
-Warning: assert(): Assertion failed in %s on line %d
+Warning: assert(): Assertion failed in %s on line %s
 mysqli->client_info = ''/NULL ('%s'/string)
-mysqli->client_version =  '%s'/integer ('%s'/integer)
+mysqli->client_version =  '%d'/integer ('%d'/integer)
 mysqli->errno = ''/NULL (''/NULL)
 mysqli->error = ''/NULL (''/NULL)
 mysqli->field_count = ''/NULL (''/NULL)
 mysqli->insert_id = ''/NULL (''/NULL)
 mysqli->sqlstate = ''/NULL (''/NULL)
+mysqli->stat = ''/NULL (''/NULL)
 mysqli->host_info = ''/NULL (''/NULL)
 mysqli->info = ''/NULL (''/NULL)
 
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_reflection.phpt
@@ -0,0 +1,1253 @@
+--TEST--
+Interface of the class mysqli - Reflection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+
+if (($tmp = substr(PHP_VERSION, 0, strpos(PHP_VERSION, '.'))) && ($tmp < 5))
+	die("skip Reflection not available before PHP 5 (found PHP $tmp)");
+/*
+Let's not deal with cross-version issues in the EXPECTF/UEXPECTF.
+Most of the things which we test are covered by mysqli_class_*_interface.phpt.
+Those tests go into the details and are aimed to be a development tool, no more.
+*/
+if (!$IS_MYSQLND)
+	die("skip Test has been written for the latest version of mysqlnd only");
+if ($MYSQLND_VERSION < 50004)
+	die("skip Test requires mysqlnd Revision 5.0.4 or newer");
+
+?>
+--FILE--
+<?php
+	require_once('reflection_tools.inc');
+	$class = new ReflectionClass('mysqli');
+	inspectClass($class);
+	print "done!\n";
+?>
+--EXPECTF--
+Inspecting class 'mysqli'
+isInternal: yes
+isUserDefined: no
+isInstantiable: yes
+isInterface: no
+isAbstract: no
+isFinal: no
+isIteratable: no
+Modifiers: '0'
+Parent Class: ''
+Extension: 'mysqli'
+
+Inspecting method 'mysqli'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: yes
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 8448
+Number of Parameters: 6
+Number of Required Parameters: 0
+
+Inspecting parameter 'host' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'user' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'password' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'database' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'port' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'socket' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting method 'autocommit'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'mode' of method 'autocommit'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'change_user'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 3
+Number of Required Parameters: 3
+
+Inspecting parameter 'user' of method 'change_user'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'password' of method 'change_user'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'database' of method 'change_user'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'character_set_name'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'client_encoding'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'close'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'commit'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'connect'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 6
+Number of Required Parameters: 0
+
+Inspecting parameter 'host' of method 'connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'user' of method 'connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'password' of method 'connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'database' of method 'connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'port' of method 'connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'socket' of method 'connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting method 'debug'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'debug_options' of method 'debug'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'dump_debug_info'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'escape_string'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'string_to_escape' of method 'escape_string'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'get_charset'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'get_client_info'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'get_connection_stats'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'get_server_info'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'get_warnings'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'init'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'kill'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'connection_id' of method 'kill'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'more_results'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'multi_query'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'query' of method 'multi_query'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'mysqli'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: yes
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 8448
+Number of Parameters: 6
+Number of Required Parameters: 0
+
+Inspecting parameter 'host' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'user' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'password' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'database' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'port' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'socket' of method 'mysqli'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting method 'next_result'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'options'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 2
+Number of Required Parameters: 2
+
+Inspecting parameter 'option' of method 'options'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'value' of method 'options'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'ping'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'poll'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: yes
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 257
+Number of Parameters: 5
+Number of Required Parameters: 4
+
+Inspecting parameter 'read' of method 'poll'
+isArray: yes
+allowsNull: yes
+isPassedByReference: yes
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'write' of method 'poll'
+isArray: yes
+allowsNull: yes
+isPassedByReference: yes
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'error' of method 'poll'
+isArray: yes
+allowsNull: yes
+isPassedByReference: yes
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'sec' of method 'poll'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'usec' of method 'poll'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting method 'prepare'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'query' of method 'prepare'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'query'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'query' of method 'query'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'real_connect'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 7
+Number of Required Parameters: 0
+
+Inspecting parameter 'host' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'user' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'password' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'database' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'port' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'socket' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting parameter 'flags' of method 'real_connect'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting method 'real_escape_string'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'string_to_escape' of method 'real_escape_string'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'real_query'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'query' of method 'real_query'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'reap_async_query'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'refresh'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'options' of method 'refresh'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'rollback'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'select_db'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'database' of method 'select_db'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'set_charset'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'charset' of method 'set_charset'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'set_opt'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 2
+Number of Required Parameters: 2
+
+Inspecting parameter 'option' of method 'set_opt'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'value' of method 'set_opt'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'ssl_set'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 5
+Number of Required Parameters: 5
+
+Inspecting parameter 'key' of method 'ssl_set'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'cert' of method 'ssl_set'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'certificate_authority' of method 'ssl_set'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'certificate_authority_path' of method 'ssl_set'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting parameter 'cipher' of method 'ssl_set'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'stat'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'stmt_init'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'store_result'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'thread_safe'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'use_result'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting property 'affected_rows'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'client_info'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'client_version'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'connect_errno'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'connect_error'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'errno'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'error'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'field_count'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'host_info'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'info'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'insert_id'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'protocol_version'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'server_info'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'server_version'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'sqlstate'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'stat'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'thread_id'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'warning_count'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+Default property 'affected_rows'
+Default property 'client_info'
+Default property 'client_version'
+Default property 'connect_errno'
+Default property 'connect_error'
+Default property 'errno'
+Default property 'error'
+Default property 'field_count'
+Default property 'host_info'
+Default property 'info'
+Default property 'insert_id'
+Default property 'protocol_version'
+Default property 'server_info'
+Default property 'server_version'
+Default property 'sqlstate'
+Default property 'stat'
+Default property 'thread_id'
+Default property 'warning_count'
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_result_interface.phpt
@@ -0,0 +1,193 @@
+--TEST--
+Interface of the class mysqli_result
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	require('table.inc');
+
+	$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	$mysqli_result = $mysqli->query('SELECT * FROM test');
+	$row = $mysqli_result->fetch_row();
+
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+	$res = mysqli_query($link, 'SELECT * FROM test');
+	assert(mysqli_fetch_row($res) === $row);
+
+	printf("Parent class:\n");
+	var_dump(get_parent_class($mysqli_result));
+
+	printf("\nMethods:\n");
+	$methods = get_class_methods($mysqli_result);
+	$expected_methods = array(
+		'__construct'           => true,
+		'close'                 => true,
+		'data_seek'             => true,
+		'fetch_array'           => true,
+		'fetch_assoc'           => true,
+		'fetch_field'           => true,
+		'fetch_field_direct'    => true,
+		'fetch_fields'          => true,
+		'fetch_object'          => true,
+		'fetch_row'             => true,
+		'field_seek'            => true,
+		'free'                  => true,
+		'free_result'           => true,
+	);
+	if ($IS_MYSQLND)
+		$expected_methods['fetch_all'] = true;
+
+	foreach ($methods as $k => $method) {
+		if (isset($expected_methods[$method])) {
+			unset($expected_methods[$method]);
+			unset($methods[$k]);
+		}
+		if ($method == 'mysqli_result') {
+			// get_class_method reports different constructor names
+			unset($expected_methods['__construct']);
+			unset($methods[$k]);
+		}
+	}
+
+	if (!empty($expected_methods)) {
+		printf("Dumping list of missing methods.\n");
+		var_dump($expected_methods);
+	}
+	if (!empty($methods)) {
+		printf("Dumping list of unexpected methods.\n");
+		var_dump($methods);
+	}
+	if (empty($expected_methods) && empty($methods))
+		printf("ok\n");
+
+
+	printf("\nClass variables:\n");
+	$variables = array_keys(get_class_vars(get_class($mysqli_result)));
+	sort($variables);
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nObject variables:\n");
+	$variables = array_keys(get_object_vars($mysqli_result));
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nMagic, magic properties:\n");
+
+	assert(($tmp = mysqli_field_tell($res)) === $mysqli_result->current_field);
+	printf("mysqli_result->current_field = '%s'/%s ('%s'/%s)\n",
+		$mysqli_result->current_field, gettype($mysqli_result->current_field),
+		$tmp, gettype($tmp));
+
+	assert(($tmp = mysqli_field_count($link)) === $mysqli_result->field_count);
+	printf("mysqli_result->field_count = '%s'/%s ('%s'/%s)\n",
+		$mysqli_result->field_count, gettype($mysqli_result->field_count),
+		$tmp, gettype($tmp));
+
+	assert(($tmp = mysqli_fetch_lengths($res)) === $mysqli_result->lengths);
+	printf("mysqli_result->lengths -> '%s'/%s ('%s'/%s)\n",
+		((is_array($mysqli_result->lengths)) ? implode(' ', $mysqli_result->lengths) : 'n/a'),
+		gettype($mysqli_result->lengths),
+		((is_array($tmp)) ? implode(' ', $tmp) : 'n/a'),
+		gettype($tmp));
+
+	assert(($tmp = mysqli_num_rows($res)) === $mysqli_result->num_rows);
+	printf("mysqli_result->num_rows = '%s'/%s ('%s'/%s)\n",
+		$mysqli_result->num_rows, gettype($mysqli_result->num_rows),
+		$tmp, gettype($tmp));
+
+	assert(in_array($mysqli_result->type, array(MYSQLI_STORE_RESULT, MYSQLI_USE_RESULT)));
+	printf("mysqli_result->type = '%s'/%s\n",
+		((MYSQLI_STORE_RESULT == $mysqli_result->type) ? 'store' : 'use'),
+		gettype($mysqli_result->type));
+
+	printf("\nAccess to undefined properties:\n");
+	printf("mysqli_result->unknown = '%s'\n", @$mysqli_result->unknown);
+
+	printf("\nConstructor:\n");
+	if (!is_object($res = new mysqli_result($link)))
+		printf("[001] Expecting object/mysqli_result got %s/%s\n", gettye($res), $res);
+
+	if (null !== ($tmp = @$res->num_rows))
+		printf("[002] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "SELECT id FROM test ORDER BY id"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = new mysqli_result($link)))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = new mysqli_result($link, MYSQLI_STORE_RESULT)))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = new mysqli_result($link, MYSQLI_USE_RESULT)))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = new mysqli_result($link, 'invalid')))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$valid = array(MYSQLI_STORE_RESULT, MYSQLI_USE_RESULT);
+	do {
+		$mode = mt_rand(-1000, 1000);
+	} while (in_array($mode, $valid));
+
+	if ($TEST_EXPERIMENTAL) {
+		ob_start();
+		if (!is_object($res = new mysqli_result($link, $mode)))
+			printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		$content = ob_get_contents();
+		ob_end_clean();
+		if (!stristr($content, 'Invalid value for resultmode'))
+			printf("[009] Expecting warning because of invalid resultmode\n");
+	}
+
+	if (!is_object($res = new mysqli_result('foo')))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = @new mysqli_result($link, MYSQLI_STORE_RESULT, 1)))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	print "done!";
+?>
+--EXPECTF--
+Parent class:
+bool(false)
+
+Methods:
+ok
+
+Class variables:
+current_field
+field_count
+lengths
+num_rows
+type
+
+Object variables:
+current_field
+field_count
+lengths
+num_rows
+type
+
+Magic, magic properties:
+mysqli_result->current_field = '0'/integer ('0'/integer)
+mysqli_result->field_count = '2'/integer ('2'/integer)
+mysqli_result->lengths -> '1 1'/array ('1 1'/array)
+mysqli_result->num_rows = '6'/integer ('6'/integer)
+mysqli_result->type = 'store'/integer
+
+Access to undefined properties:
+mysqli_result->unknown = ''
+
+Constructor:
+
+Warning: mysqli_result::__construct() expects parameter 2 to be long, %unicode_string_optional% given in %s on line %d
+
+Warning: mysqli_result::__construct() expects parameter 1 to be mysqli, %unicode_string_optional% given in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_result_reflection.phpt
@@ -0,0 +1,355 @@
+--TEST--
+Interface of the class mysqli_result - Reflection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (($tmp = substr(PHP_VERSION, 0, strpos(PHP_VERSION, '.'))) && ($tmp < 5))
+	die("skip Reflection not available before PHP 5 (found PHP $tmp)");
+
+/*
+Let's not deal with cross-version issues in the EXPECTF/UEXPECTF.
+Most of the things which we test are covered by mysqli_class_*_interface.phpt.
+Those tests go into the details and are aimed to be a development tool, no more.
+*/
+if (!$IS_MYSQLND)
+	die("skip Test has been written for the latest version of mysqlnd only");
+if ($MYSQLND_VERSION < 50004)
+	die("skip Test requires mysqlnd Revision 5.0.4 or newer");
+?>
+--FILE--
+<?php
+	require_once('reflection_tools.inc');
+	$class = new ReflectionClass('mysqli_result');
+	inspectClass($class);
+	print "done!";
+?>
+--EXPECTF--
+Inspecting class 'mysqli_result'
+isInternal: yes
+isUserDefined: no
+isInstantiable: yes
+isInterface: no
+isAbstract: no
+isFinal: no
+isIteratable: no
+Modifiers: '0'
+Parent Class: ''
+Extension: 'mysqli'
+
+Inspecting method '__construct'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: yes
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 8448
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method '__construct'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: yes
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 8448
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'close'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'data_seek'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'offset' of method 'data_seek'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'fetch_all'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'fetch_array'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 0
+
+Inspecting parameter 'result_type' of method 'fetch_array'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: yes
+isDefaultValueAvailable: no
+
+Inspecting method 'fetch_assoc'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'fetch_field'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'fetch_field_direct'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'field_nr' of method 'fetch_field_direct'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'fetch_fields'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'fetch_object'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'fetch_row'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'field_seek'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 1
+Number of Required Parameters: 1
+
+Inspecting parameter 'field_nr' of method 'field_seek'
+isArray: no
+allowsNull: no
+isPassedByReference: no
+isOptional: no
+isDefaultValueAvailable: no
+
+Inspecting method 'free'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'free_result'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: 256
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting property 'current_field'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'field_count'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'lengths'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'num_rows'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'type'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+Default property 'current_field'
+Default property 'field_count'
+Default property 'lengths'
+Default property 'num_rows'
+Default property 'type'
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_stmt_interface.phpt
@@ -0,0 +1,190 @@
+--TEST--
+Interface of the class mysqli_stmt
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	require('table.inc');
+
+	$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+	$stmt = new mysqli_stmt($link);
+
+	printf("Parent class:\n");
+	var_dump(get_parent_class($stmt));
+
+	printf("\nMethods:\n");
+
+	$methods = get_class_methods($stmt);
+	$expected_methods = array(
+		'__construct'       => true,
+		'attr_get'          => true,
+		'attr_set'          => true,
+		'bind_param'        => true,
+		'bind_result'       => true,
+		'close'             => true,
+		'data_seek'         => true,
+		'execute'           => true,
+		'fetch'             => true,
+		'free_result'       => true,
+		'get_warnings'      => true,
+		'num_rows'          => true,
+		'prepare'           => true,
+		'reset'             => true,
+		'result_metadata'   => true,
+		'send_long_data'    => true,
+		'store_result'      => true,
+	);
+
+	if ($IS_MYSQLND) {
+		$expected_methods['get_result'] = true;
+		$expected_methods['more_results'] = true;
+		$expected_methods['next_result'] = true;
+	}
+
+	foreach ($methods as $k => $method) {
+	if (isset($expected_methods[$method])) {
+		unset($methods[$k]);
+		unset($expected_methods[$method]);
+	}
+		if ($method == 'mysqli_stmt') {
+			// get_class_method reports different constructor names
+			unset($expected_methods['__construct']);
+			unset($methods[$k]);
+		}
+	}
+	if (!empty($methods)) {
+		printf("More methods found than indicated. Dumping list of unexpected methods.\n");
+		var_dump($methods);
+	}
+	if (!empty($expected_methods)) {
+		printf("Some methods are missing. Dumping list of missing methods.\n");
+		var_dump($expected_methods);
+	}
+	if (empty($methods) && empty($expected_methods))
+		printf("ok\n");
+
+	printf("\nClass variables:\n");
+	$variables = array_keys(get_class_vars(get_class($stmt)));
+	sort($variables);
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nObject variables:\n");
+	$variables = array_keys(get_object_vars($stmt));
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+printf("\nMagic, magic properties:\n");
+
+assert(mysqli_stmt_affected_rows($stmt) === $stmt->affected_rows);
+printf("stmt->affected_rows = '%s'\n", $stmt->affected_rows);
+
+if (!$stmt->prepare("INSERT INTO test(id, label) VALUES (100, 'z')") ||
+!$stmt->execute())
+printf("[001] [%d] %s\n", $stmt->errno, $stmt->error);
+
+assert(mysqli_stmt_affected_rows($stmt) === $stmt->affected_rows);
+printf("stmt->affected_rows = '%s'\n", $stmt->affected_rows);
+
+assert(mysqli_stmt_errno($stmt) === $stmt->errno);
+printf("stmt->errno = '%s'\n", $stmt->errno);
+
+assert(mysqli_stmt_error($stmt) === $stmt->error);
+printf("stmt->error = '%s'\n", $stmt->error);
+
+assert(mysqli_stmt_field_count($stmt) === $stmt->field_count);
+printf("stmt->field_count = '%s'\n", $stmt->field_count);
+
+assert($stmt->id > 0);
+printf("stmt->id = '%s'\n", $stmt->id);
+
+assert(mysqli_stmt_insert_id($stmt) === $stmt->insert_id);
+printf("stmt->insert_id = '%s'\n", $stmt->insert_id);
+
+assert(mysqli_stmt_num_rows($stmt) === $stmt->num_rows);
+printf("stmt->num_rows = '%s'\n", $stmt->num_rows);
+
+assert(mysqli_stmt_param_count($stmt) === $stmt->param_count);
+printf("stmt->param_count = '%s'\n", $stmt->param_count);
+
+assert(mysqli_stmt_sqlstate($stmt) === $stmt->sqlstate);
+printf("stmt->sqlstate = '%s'\n", $stmt->sqlstate);
+
+printf("\nAccess to undefined properties:\n");
+printf("stmt->unknown = '%s'\n", @$stmt->unknown);
+@$stmt->unknown = 13;
+printf("stmt->unknown = '%s'\n", @$stmt->unknown);
+
+printf("\nPrepare using the constructor:\n");
+$stmt = new mysqli_stmt($link, 'SELECT id FROM test ORDER BY id');
+if (!$stmt->execute())
+printf("[002] [%d] %s\n", $stmt->errno, $stmt->error);
+$stmt->close();
+
+$obj = new stdClass();
+if (!is_object($stmt = new mysqli_stmt($link, $obj)))
+printf("[003] Expecting NULL got %s/%s\n", gettype($stmt), $stmt);
+
+print "done!";
+?>
+--EXPECTF--
+Parent class:
+bool(false)
+
+Methods:
+ok
+
+Class variables:
+affected_rows
+errno
+error
+field_count
+id
+insert_id
+num_rows
+param_count
+sqlstate
+
+Object variables:
+affected_rows
+insert_id
+num_rows
+param_count
+field_count
+errno
+error
+sqlstate
+id
+
+Magic, magic properties:
+
+Warning: mysqli_stmt_affected_rows(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: main(): Property access is not allowed yet in %s on line %d
+
+Warning: main(): Property access is not allowed yet in %s on line %d
+stmt->affected_rows = ''
+stmt->affected_rows = '1'
+stmt->errno = '0'
+stmt->error = ''
+stmt->field_count = '0'
+stmt->id = '%d'
+stmt->insert_id = '0'
+stmt->num_rows = '0'
+stmt->param_count = '0'
+stmt->sqlstate = '00000'
+
+Access to undefined properties:
+stmt->unknown = ''
+stmt->unknown = '13'
+
+Prepare using the constructor:
+
+Warning: mysqli_stmt::__construct() expects parameter 2 to be %binary_string_optional%, object given in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_warning.phpt
@@ -0,0 +1,132 @@
+--TEST--
+Interface of the class mysqli_warning - TODO
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+
+	$warning = new mysqli_warning();
+	$warning = new mysqli_warning(null);
+	$warning = new mysqli_warning(null, null);
+
+	$mysqli = new mysqli();
+	$warning = new mysqli_warning($mysqli);
+
+	$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	$stmt = new mysqli_stmt($mysqli);
+	$warning = new mysqli_warning($stmt);
+
+	$stmt = $mysqli->stmt_init();
+	$warning = new mysqli_warning($stmt);
+
+	$obj = new stdClass();
+	$warning = new mysqli_warning($obj);
+
+	include("table.inc");
+	$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+	$res = $mysqli->query('INSERT INTO test(id, label) VALUES (1, "zz")');
+	$warning = mysqli_get_warnings($mysqli);
+
+	printf("Parent class:\n");
+	var_dump(get_parent_class($warning));
+
+	printf("\nMethods:\n");
+	$methods = get_class_methods($warning);
+	$expected_methods = array(
+		'next'                      => true,
+	);
+
+	foreach ($methods as $k => $method) {
+		if (isset($expected_methods[$method])) {
+			unset($methods[$k]);
+			unset($expected_methods[$method]);
+		}
+	}
+	if (!empty($methods)) {
+		printf("Dumping list of unexpected methods.\n");
+		var_dump($methods);
+	}
+	if (!empty($expected_methods)) {
+		printf("Dumping list of missing methods.\n");
+		var_dump($expected_methods);
+	}
+	if (empty($methods) && empty($expected_methods))
+		printf("ok\n");
+
+	printf("\nClass variables:\n");
+	$variables = get_class_vars(get_class($mysqli));
+	sort($variables);
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nObject variables:\n");
+	$variables = get_object_vars($mysqli);
+	foreach ($variables as $k => $var)
+		printf("%s\n", $var);
+
+	printf("\nMagic, magic properties:\n");
+
+	assert('' === $warning->message);
+	printf("warning->message = '%s'\n", $warning->message);
+
+	assert('' === $warning->sqlstate);
+	printf("warning->sqlstate= '%s'\n", $warning->sqlstate);
+
+	assert(0 === $warning->errno);
+	printf("warning->errno = '%s'\n", $warning->errno);
+
+	printf("\nAccess to undefined properties:\n");
+	printf("warning->unknown = '%s'\n", @$warning->unknown);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: Wrong parameter count for mysqli_warning::mysqli_warning() in %s on line %d
+
+Warning: mysqli_warning::mysqli_warning() expects parameter 1 to be object, null given in %s on line %d
+
+Warning: Wrong parameter count for mysqli_warning::mysqli_warning() in %s on line %d
+
+Warning: mysqli_warning::mysqli_warning(): Couldn't fetch mysqli in %s on line %d
+
+Warning: mysqli_warning::mysqli_warning(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_warning::mysqli_warning(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_warning::mysqli_warning(): invalid class argument in /home/nixnutz/php6_mysqlnd/ext/mysqli/tests/mysqli_class_mysqli_warning.php on line 19
+
+Warning: mysqli_warning::mysqli_warning(): No warnings found in %s on line %d
+Parent class:
+bool(false)
+
+Methods:
+ok
+
+Class variables:
+
+Object variables:
+
+Magic, magic properties:
+warning->message = ''
+warning->sqlstate= ''
+warning->errno = ''
+
+Access to undefined properties:
+
+warning->unknown = ''
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_class_mysqli_warning_reflection.phpt
@@ -0,0 +1,116 @@
+--TEST--
+Interface of the class mysqli_stmt - Reflection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+
+if (($tmp = substr(PHP_VERSION, 0, strpos(PHP_VERSION, '.'))) && ($tmp < 5))
+	die("skip Reflection not available before PHP 5 (found PHP $tmp)");
+
+/*
+Let's not deal with cross-version issues in the EXPECTF/UEXPECTF.
+Most of the things which we test are covered by mysqli_class_*_interface.phpt.
+Those tests go into the details and are aimed to be a development tool, no more.
+*/
+if (!$IS_MYSQLND)
+	die("skip Test has been written for the latest version of mysqlnd only");
+if ($MYSQLND_VERSION < 50004)
+	die("skip Test requires mysqlnd Revision 5.0.4 or newer");
+?>
+--FILE--
+<?php
+	require_once('reflection_tools.inc');
+	$class = new ReflectionClass('mysqli_warning');
+	inspectClass($class);
+	print "done!\n";
+?>
+--EXPECTF--
+Inspecting class 'mysqli_warning'
+isInternal: yes
+isUserDefined: no
+isInstantiable: no
+isInterface: no
+isAbstract: no
+isFinal: yes
+isIteratable: no
+Modifiers: '%d'
+Parent Class: ''
+Extension: 'mysqli'
+
+Inspecting method '__construct'
+isFinal: no
+isAbstract: no
+isPublic: no
+isPrivate: no
+isProtected: yes
+isStatic: no
+isConstructor: yes
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: %d
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method '__construct'
+isFinal: no
+isAbstract: no
+isPublic: no
+isPrivate: no
+isProtected: yes
+isStatic: no
+isConstructor: yes
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: %d
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting method 'next'
+isFinal: no
+isAbstract: no
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isConstructor: no
+isDestructor: no
+isInternal: yes
+isUserDefined: no
+returnsReference: no
+Modifiers: %d
+Number of Parameters: 0
+Number of Required Parameters: 0
+
+Inspecting property 'errno'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'message'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+
+Inspecting property 'sqlstate'
+isPublic: yes
+isPrivate: no
+isProtected: no
+isStatic: no
+isDefault: yes
+Modifiers: 256
+Default property 'errno'
+Default property 'message'
+Default property 'sqlstate'
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_close.phpt
@@ -0,0 +1,40 @@
+--TEST--
+mysqli_close()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_close()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_close($link, $link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	$tmp = @mysqli_close(NULL);
+	if (NULL !== $tmp)
+		printf("[004] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$tmp = mysqli_close($link);
+	if (true !== $tmp)
+		printf("[005] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_query($link, "SELECT 1")))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_close_oo.phpt
@@ -0,0 +1,36 @@
+--TEST--
+mysqli_close()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @$mysqli->close($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$tmp = $mysqli->close();
+	if (true !== $tmp)
+		printf("[003] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$mysqli->close()))
+		printf("[004] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$mysqli->query("SELECT 1")))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_commit.phpt
@@ -0,0 +1,77 @@
+--TEST--
+mysqli_commit()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (!have_innodb($link))
+	die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_commit()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_commit($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_commit($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[004] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (true !== ($tmp = mysqli_autocommit($link, false)))
+		printf("[005] Cannot turn off autocommit, expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT) ENGINE = InnoDB'))
+		printf("[007] Cannot create test table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'INSERT INTO test(id) VALUES (1)'))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$tmp = mysqli_commit($link);
+	if ($tmp !== true)
+		printf("[009] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'ROLLBACK'))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS num FROM test'))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	if (1 != $tmp['num'])
+		printf("[12] Expecting 1 row in table test, found %d rows\n", $tmp['num']);
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = @mysqli_commit($link)))
+		printf("[014] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_commit_oo.phpt
@@ -0,0 +1,79 @@
+--TEST--
+mysqli_commit()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (!have_innodb($link))
+	die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$mysqli = new mysqli();
+	if (!is_null($tmp = @$mysqli->commit()))
+		printf("[013] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @$mysqli->commit($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, $mysqli->errno, $mysqli->error);
+
+	if (true !== ($tmp = $mysqli->commit()))
+		printf("[014] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = $mysqli->autocommit(false)))
+		printf("[003] Cannot turn off autocommit, expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('CREATE TABLE test(id INT) ENGINE = InnoDB'))
+		printf("[005] Cannot create test table, [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('INSERT INTO test(id) VALUES (1)'))
+		printf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	$tmp = $mysqli->commit();
+	if ($tmp !== true)
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli->query('ROLLBACK'))
+		printf("[008] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (!$res = $mysqli->query('SELECT COUNT(*) AS num FROM test'))
+		printf("[009] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	$tmp = $res->fetch_assoc();
+	if (1 != $tmp['num'])
+		printf("[010] Expecting 1 row in table test, found %d rows\n", $tmp['num']);
+	$res->free();
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test'))
+		printf("[011] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	$mysqli->close();
+
+	if (NULL !== ($tmp = @$mysqli->commit()))
+		printf("[012] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect.phpt
@@ -0,0 +1,175 @@
+--TEST--
+mysqli_connect()
+--SKIPIF--
+<?php 
+require_once('skipif.inc');
+require_once('skipifemb.inc'); 
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	/* we need to check, if the server allows anonymous login (empty user) */
+	$tmp = @mysqli_connect('localhost');
+	$anon_allow = (gettype($tmp) == "object");
+
+	$exptype = ($anon_allow) ? "mysqli_object" : "false";
+
+	$obj = new stdClass();
+	if (!is_null($tmp = @mysqli_connect($obj)))
+		printf("[001] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	$tmp = @mysqli_connect($link);
+	if (($anon_allow && gettype($tmp) != "object") || (!$anon_allow && $tmp != false)) {
+		printf("[002] Expecting %s, got %s/%s\n", $exptype, gettype($tmp), $tmp);
+	}
+
+	$tmp = @mysqli_connect($link, $link);
+	if (($anon_allow && gettype($tmp) != "object") || (!$anon_allow && $tmp != false)) {
+		printf("[003] Expecting %s, got %s/%s\n", $exptype, gettype($tmp), $tmp);
+	}
+
+	$tmp = @mysqli_connect($link, $link, $link);
+	if (($anon_allow && gettype($tmp) != "object") || (!$anon_allow && $tmp != false)) {
+		printf("[004] Expecting %s, got %s/%s\n", $exptype, gettype($tmp), $tmp);
+	}
+
+	$tmp = @mysqli_connect($link, $link, $link, $link);
+	if (($anon_allow && gettype($tmp) != "object") || (!$anon_allow && $tmp != false)) {
+		printf("[005] Expecting %s, got %s/%s\n", $exptype, gettype($tmp), $tmp);
+	}
+
+	$tmp = @mysqli_connect($link, $link, $link, $link, $link);
+	if (($anon_allow && gettype($tmp) != "object") || (!$anon_allow && $tmp != false)) {
+		printf("[006] Expecting %s, got %s/%s\n", $exptype, gettype($tmp), $tmp);
+	}
+
+	$tmp = @mysqli_connect($link, $link, $link, $link, $link, $link);
+	if (($anon_allow && gettype($tmp) != "object") || (!$anon_allow && $tmp != false)) {
+		printf("[007] Expecting %s, got %s/%s\n", $exptype, gettype($tmp), $tmp);
+	}
+
+	if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[008] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	mysqli_close($link);
+
+	if ($link = mysqli_connect($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+		printf("[009] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+			$host, $user . 'unknown_really', $db, $port, $socket);
+
+	if (false !== $link)
+		printf("[010] Expecting boolean/false, got %s/%s\n", gettype($link), $link);
+
+	// Run the following tests without an anoynmous MySQL user and use a password for the test user!
+	ini_set('mysqli.default_socket', $socket);
+	if (!is_object($link = mysqli_connect($host, $user, $passwd, $db, $port))) {
+		printf("[011] Usage of mysqli.default_socket failed\n") ;
+	} else {
+		if (!$res = mysqli_query($link, "SELECT 'mysqli.default_socket' AS 'testing'"))
+			printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	}
+
+	ini_set('mysqli.default_port', $port);
+	if (!is_object($link = mysqli_connect($host, $user, $passwd, $db))) {
+		printf("[013] Usage of mysqli.default_port failed\n") ;
+	} else {
+		if (!$res = mysqli_query($link, "SELECT 'mysqli.default_port' AS 'testing'"))
+			printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	}
+
+	ini_set('mysqli.default_pw', $passwd);
+	if (!is_object($link = mysqli_connect($host, $user))) {
+		printf("[015] Usage of mysqli.default_pw failed\n") ;
+	} else {
+		if (!$res = mysqli_query($link, "SELECT 'mysqli.default_pw' AS 'testing'"))
+			printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	}
+
+	ini_set('mysqli.default_user', $user);
+	if (!is_object($link = mysqli_connect($host))) {
+		printf("[017] Usage of mysqli.default_user failed\n") ;
+	} else {
+		if (!$res = mysqli_query($link, "SELECT 'mysqli.default_user' AS 'testing'"))
+			printf("[018] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_array($res, MYSQLI_BOTH));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	}
+
+	ini_set('mysqli.default_host', $host);
+	if (!is_object($link = mysqli_connect())) {
+		printf("[019] Usage of mysqli.default_host failed\n") ;
+	} else {
+		if (!$res = mysqli_query($link, "SELECT 'mysqli.default_host' AS 'testing'"))
+			printf("[020] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_array($res, MYSQLI_NUM));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	}
+
+	if ($IS_MYSQLND) {
+		ini_set('mysqli.default_host', 'p:' . $host);
+			if (!is_object($link = mysqli_connect())) {
+				printf("[021] Usage of mysqli.default_host (persistent) failed\n") ;
+		} else {
+			if (!$res = mysqli_query($link, "SELECT 'mysqli.default_host (persistent)' AS 'testing'"))
+				printf("[022] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			$tmp = mysqli_fetch_assoc($res);
+			if ($tmp['testing'] !== 'mysqli.default_host (persistent)') {
+				printf("[023] Result looks strange - check manually, [%d] %s\n",
+					mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+			mysqli_free_result($res);
+			mysqli_close($link);
+		}
+
+		ini_set('mysqli.default_host', 'p:');
+		if (is_object($link = @mysqli_connect())) {
+			printf("[024] Usage of mysqli.default_host=p: did not fail\n") ;
+			mysqli_close($link);
+		}
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_connect(): (%s/%d): Access denied for user '%s'@'%s' (using password: YES) in %s on line %d
+array(1) {
+  [%u|b%"testing"]=>
+  %unicode|string%(21) "mysqli.default_socket"
+}
+array(1) {
+  [%u|b%"testing"]=>
+  %unicode|string%(19) "mysqli.default_port"
+}
+array(1) {
+  [%u|b%"testing"]=>
+  %unicode|string%(17) "mysqli.default_pw"
+}
+array(2) {
+  [0]=>
+  %unicode|string%(19) "mysqli.default_user"
+  [%u|b%"testing"]=>
+  %unicode|string%(19) "mysqli.default_user"
+}
+array(1) {
+  [0]=>
+  %unicode|string%(19) "mysqli.default_host"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect_errno.phpt
@@ -0,0 +1,40 @@
+--TEST--
+mysqli_connect_errno()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// too many parameter
+	if (0 !== ($tmp = @mysqli_connect_errno($link)))
+		printf("[001] Expecting integer/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (0 !== ($tmp = mysqli_connect_errno()))
+		printf("[003] Expecting integer/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	$link = @my_mysqli_connect($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket);
+	if (false !== $link)
+		printf("[004] Connect to the server should fail using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s, expecting boolean/false, got %s/%s\n",
+			$host, $user . 'unknown_really', $db, $port, $socket, gettype($link), var_export($link, true));
+
+	if (0 === ($tmp = mysqli_connect_errno()))
+		printf("[005] Expecting integer/any non-zero, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect_error.phpt
@@ -0,0 +1,39 @@
+--TEST--
+mysqli_connect_error()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// too many parameter
+	if (!is_null($tmp = @mysqli_connect_error($link)))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (NULL !== ($tmp = mysqli_connect_error()))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if ($link = @my_mysqli_connect($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+		printf("[003] Connect to the server should fail using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+			$host, $user . 'unknown_really', $db, $port, $socket);
+
+	if ('' === ($tmp = mysqli_connect_error()))
+		printf("[004] Expecting string/'', got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect_oo.phpt
@@ -0,0 +1,153 @@
+--TEST--
+new mysqli()
+--SKIPIF--
+<?php 
+require_once('skipif.inc');
+require_once('skipifemb.inc'); 
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$obj = new stdClass();
+
+	if ($mysqli = new mysqli($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket) && !mysqli_connect_errno())
+		printf("[003] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+			$host, $user . 'unknown_really', $db, $port, $socket);
+
+	if (false !== $mysqli)
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($mysqli), $mysqli);
+
+	// Run the following tests without an anoynmous MySQL user and use a password for the test user!
+	ini_set('mysqli.default_socket', $socket);
+	if (!is_object($mysqli = new mysqli($host, $user, $passwd, $db, $port)) || (0 !== mysqli_connect_errno())) {
+		printf("[005] Usage of mysqli.default_socket failed\n") ;
+	} else {
+		$mysqli->close();
+	}
+
+	ini_set('mysqli.default_port', $port);
+	if (!is_object($mysqli = new mysqli($host, $user, $passwd, $db)) || (0 !== mysqli_connect_errno())) {
+		printf("[006] Usage of mysqli.default_port failed\n") ;
+	} else {
+		$mysqli->close();
+	}
+
+	ini_set('mysqli.default_pw', $passwd);
+	if (!is_object($mysqli = new mysqli($host, $user)) || (0 !== mysqli_connect_errno())) {
+		printf("[007] Usage of mysqli.default_pw failed\n") ;
+	} else {
+		$mysqli->close();
+	}
+
+	ini_set('mysqli.default_user', $user);
+	if (!is_object($mysqli = new mysqli($host)) || (0 !== mysqli_connect_errno())) {
+		printf("[008] Usage of mysqli.default_user failed\n") ;
+	} else {
+		$mysqli->close();
+	}
+
+	ini_set('mysqli.default_host', $host);
+	if (!is_object($mysqli = new mysqli()) || (0 !== mysqli_connect_errno())) {
+		printf("[012] Failed to create mysqli object\n");
+	} else {
+		// There shall be NO connection! Using new mysqli(void) shall not use defaults for a connection!
+			// We had long discussions on this and found that the ext/mysqli API as
+			// such is broken. As we can't fix it, we document how it has behaved from
+			// the first day on. And that's: no connection.
+			if (NULL !== ($tmp = @$mysqli->query('SELECT 1'))) {
+				printf("[013] There shall be no connection!\n");
+				$mysqli->close();
+			}
+	}
+
+	if ($IS_MYSQLND) {
+		ini_set('mysqli.default_host', 'p:' . $host);
+		if (!is_object($mysqli = new mysqli())) {
+			// Due to an API flaw this shall not connect
+			printf("[010] Failed to create mysqli object\n");
+		} else {
+			// There shall be NO connection! Using new mysqli(void) shall not use defaults for a connection!
+			// We had long discussions on this and found that the ext/mysqli API as
+			// such is broken. As we can't fix it, we document how it has behaved from
+			// the first day on. And that's: no connection.
+			if (NULL !== ($tmp = @$mysqli->query('SELECT 1'))) {
+				printf("[011] There shall be no connection!\n");
+				$mysqli->close();
+			}
+		}
+	}
+
+	print "... and now Exceptions\n";
+	mysqli_report(MYSQLI_REPORT_OFF);
+	mysqli_report(MYSQLI_REPORT_STRICT);
+
+	try {
+		$mysqli = new mysqli($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket);
+		printf("[016] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+			$host, $user . 'unknown_really', $db, $port, $socket);
+		$mysqli->close();
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+	}
+
+	ini_set('mysqli.default_socket', $socket);
+	try {
+		$mysqli = new mysqli($host, $user, $passwd, $db, $port);
+		$mysqli->close();
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[017] Usage of mysqli.default_socket failed\n") ;
+	}
+
+	ini_set('mysqli.default_port', $port);
+	try {
+		$mysqli = new mysqli($host, $user, $passwd, $db);
+		$mysqli->close();
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[018] Usage of mysqli.default_port failed\n") ;
+	}
+
+	ini_set('mysqli.default_pw', $passwd);
+	try {
+		$mysqli = new mysqli($host, $user);
+		$mysqli->close();
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[019] Usage of mysqli.default_pw failed\n");
+	}
+
+	ini_set('mysqli.default_user', $user);
+	try {
+		$mysqli = new mysqli($host);
+		$mysqli->close();
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[020] Usage of mysqli.default_user failed\n") ;
+	}
+
+	ini_set('mysqli.default_host', $host);
+	try {
+		/* NOTE that at this point one must use a different syntax! */
+		$mysqli = mysqli_init();
+		$mysqli->real_connect();
+		assert(0 === mysqli_connect_errno());
+		$mysqli->close();
+		assert(0 === mysqli_connect_errno());
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[021] Usage of mysqli.default_host failed\n");
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli::mysqli(): (%s/%d): Access denied for user '%sunknown%s'@'%s' (using password: %s) in %s on line %d
+... and now Exceptions
+Access denied for user '%s'@'%s' (using password: %s)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect_oo_defaults.phpt
@@ -0,0 +1,180 @@
+--TEST--
+new mysqli()
+--SKIPIF--
+<?php 
+require_once('skipif.inc');
+require_once('skipifemb.inc'); 
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if ($socket != "")
+		/* mysqli.default_socket requires non-empty string */
+		ini_set('mysqli.default_socket', 'socket');
+
+	ini_set('mysqli.default_port', 9999);
+	ini_set('mysqli.default_pw', 'password');
+	ini_set('mysqli.default_user', 'user');
+	ini_set('mysqli.default_host', 'host');
+
+	mysqli_report(MYSQLI_REPORT_OFF);
+	mysqli_report(MYSQLI_REPORT_STRICT);
+
+	if ($socket != "") {
+		ini_set('mysqli.default_socket', $socket);
+		try {
+			$mysqli = mysqli_init();
+			$mysqli->real_connect($host, $user, $passwd, $db, $port);
+
+			if (!$res = $mysqli->query("SELECT 'mysqli.default_socket' AS testing"))
+				printf("[001] [%d] %s\n", $mysqli->errno, $mysqli->error);
+			$tmp = $res->fetch_assoc();
+			$res->free_result();
+
+			if (!isset($tmp['testing']) || $tmp['testing'] != 'mysqli.default_socket') {
+				printf("[002] mysqli.default_socket not properly set?\n");
+				var_dump($tmp);
+			}
+
+			$mysqli->close();
+
+		} catch (mysqli_sql_exception $e) {
+			printf("%s\n", $e->getMessage());
+			printf("[002] Usage of mysqli.default_socket failed\n");
+		}
+	}
+
+	ini_set('mysqli.default_port', $port);
+	try {
+		$mysqli = mysqli_init();
+		$mysqli->real_connect($host, $user, $passwd, $db);
+
+		if (!$res = $mysqli->query("SELECT 'mysqli.default_port' AS testing"))
+			printf("[003] [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($res->fetch_assoc());
+		$res->free_result();
+
+		$mysqli->close();
+
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[004] Usage of mysqli.default_port failed\n");
+	}
+
+	ini_set('mysqli.default_pw', $passwd);
+	try {
+		$mysqli = mysqli_init();
+		$mysqli->real_connect($host, $user);
+		$mysqli->select_db($db);
+
+		if (!$res = $mysqli->query("SELECT 'mysqli.default_pw' AS testing"))
+			printf("[005] [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($res->fetch_assoc());
+		$res->free_result();
+
+		$mysqli->close();
+
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[006] Usage of mysqli.default_pw failed\n");
+	}
+
+	ini_set('mysqli.default_user', $user);
+	try {
+		$mysqli = mysqli_init();
+		$mysqli->real_connect($host);
+		$mysqli->select_db($db);
+
+		if (!$res = $mysqli->query("SELECT 'mysqli.default_user' AS testing"))
+			printf("[007] [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($res->fetch_assoc());
+		$res->free_result();
+
+		$mysqli->close();
+
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[008] Usage of mysqli.default_user failed\n");
+	}
+
+	ini_set('mysqli.default_host', $host);
+	try {
+		$mysqli = mysqli_init();
+		$mysqli->real_connect();
+		$mysqli->select_db($db);
+
+		if (!$res = $mysqli->query("SELECT 1"))
+			printf("[009] [%d] %s\n", $mysqli->errno, $mysqli->error);
+		$res->free_result();
+
+		if (!$res = $mysqli->query("SELECT SUBSTRING_INDEX(USER(),'@',1) AS username"))
+			printf("[010] [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+		$tmp = $res->fetch_assoc();
+		$res->free_result();
+		if ($tmp['username'] !== $user)
+			printf("[011] Expecting string/%s, got %s/%s\n", $user, gettype($tmp['username']), $tmp['username']);
+
+		$mysqli->close();
+
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[012] Usage of mysqli.default_host failed\n");
+	}
+
+	try {
+		$link = mysqli_connect($host, $user, $passwd, null, ini_get('mysqli.default_port'));
+		mysqli_select_db($link, $db);
+		if (!$res = mysqli_query($link, "SELECT 'have been set' AS all_defaults"))
+			printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[014] Usage of mysqli_connect() has failed\n");
+	}
+
+	try {
+		$link = mysqli_connect($host, $user, $passwd, null);
+		mysqli_select_db($link, $db);
+		if (!$res = mysqli_query($link, "SELECT 'have been set' AS all_defaults"))
+			printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+		mysqli_close($link);
+	} catch (mysqli_sql_exception $e) {
+		printf("%s\n", $e->getMessage());
+		printf("[016] Usage of mysqli_connect() has failed\n");
+	}
+
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"testing"]=>
+  %unicode|string%(19) "mysqli.default_port"
+}
+array(1) {
+  [%u|b%"testing"]=>
+  %unicode|string%(17) "mysqli.default_pw"
+}
+array(1) {
+  [%u|b%"testing"]=>
+  %unicode|string%(19) "mysqli.default_user"
+}
+array(1) {
+  [%u|b%"all_defaults"]=>
+  %unicode|string%(13) "have been set"
+}
+array(1) {
+  [%u|b%"all_defaults"]=>
+  %unicode|string%(13) "have been set"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect_oo_warnings.phpt
@@ -0,0 +1,57 @@
+--TEST--
+new mysqli()
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+	if (!get_current_user())
+		die('skip: get_current_user() not supported');
+	if (stristr(mysqli_get_client_info(), 'mysqlnd'))
+		die("skip: test for libmysql (different error output when using php streams");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$myhost = 'invalidhost';
+	$link   = NULL;
+
+	print "1) bail\n";
+	if (!is_object($mysqli = new mysqli($myhost)) || ('mysqli' !== get_class($mysqli)))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($mysqli), (is_object($mysqli)) ? var_export($mysqli, true) : $mysqli);
+
+	print "2) be quiet\n";
+	if (!is_object($mysqli = @new mysqli($myhost)) || ('mysqli' !== get_class($mysqli)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($mysqli), (is_object($mysqli)) ? var_export($mysqli, true) : $mysqli);
+	var_dump(mysqli_connect_error());
+	var_dump(mysqli_connect_errno());
+
+	print "3) bail\n";
+	if (false !== ($link = mysqli_connect($myhost))) {
+		printf("[003] Expecting boolean/false, got %s/%s\n", gettype($link), $link);
+	}
+
+	print "4) be quiet\n";
+	if (false !== ($link = @mysqli_connect($myhost))) {
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($link), $link);
+	}
+	var_dump(mysqli_connect_error());
+	var_dump(mysqli_connect_errno());
+
+	print "done!";
+?>
+--EXPECTF--
+1) bail
+
+Warning: mysqli::mysqli(): (HY000/200%d): %s
+2) be quiet
+%s(%d) "%s"
+int(200%d)
+3) bail
+
+Warning: mysqli_connect(): (HY000/200%d): %s
+4) be quiet
+%s(%d) "%s"
+int(200%d)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_connect_twice.phpt
@@ -0,0 +1,84 @@
+--TEST--
+Calling connect() on an open connection to create a new connection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$thread_id = mysqli_thread_id($link))
+		printf("[002] Cannot determine thread id, test will fail, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)))
+		printf("[003] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($new_thread_id = mysqli_thread_id($link)) || ($new_thread_id < 0))
+		printf("[004] Expecting int/any got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($thread_id == $new_thread_id)
+		printf("[005] Expecting new connection and new thread id. Old thread id %d, new thread id %d\n", $thread_id, $new_thread_id);
+
+	if (!($res = mysqli_query($link, "SELECT 'ok' AS it_works")) ||
+		!($row = mysqli_fetch_assoc($res)))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (!$link = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[007] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$thread_id = $link->thread_id)
+		printf("[008] Cannot determine thread id, test will fail, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = $link->real_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[009] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($new_thread_id = $link->thread_id) || ($new_thread_id < 0))
+		printf("[010] Expecting int/any got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($thread_id == $new_thread_id)
+		printf("[011] Expecting new connection and new thread id. Old thread id %d, new thread id %d\n", $thread_id, $new_thread_id);
+
+	if (!($res = $link->query("SELECT 'works also with oo' AS syntax")) ||
+			!($row = $res->fetch_assoc()))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = $link->connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[013] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[014] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (NULL !== ($tmp = $link->connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[015] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"it_works"]=>
+  %unicode|string%(2) "ok"
+}
+array(1) {
+  [%u|b%"syntax"]=>
+  %unicode|string%(18) "works also with oo"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_constants.phpt
@@ -0,0 +1,208 @@
+--TEST--
+Constants exported by ext/mysqli
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require("connect.inc");
+	require("table.inc");
+
+	$php_version = (int)str_replace('.', '', PHP_VERSION);
+	$constants = get_defined_constants(true);
+	sort($constants);
+
+	$expected_constants = array(
+		'MYSQLI_READ_DEFAULT_GROUP'			=> true,
+		'MYSQLI_READ_DEFAULT_FILE'			=> true,
+		'MYSQLI_OPT_CONNECT_TIMEOUT'		=> true,
+		'MYSQLI_OPT_LOCAL_INFILE'			=> true,
+		'MYSQLI_INIT_COMMAND'				=> true,
+		'MYSQLI_CLIENT_SSL'					=> true,
+		"MYSQLI_CLIENT_COMPRESS"			=> true,
+		"MYSQLI_CLIENT_INTERACTIVE"			=> true,
+		"MYSQLI_CLIENT_IGNORE_SPACE"		=> true,
+		"MYSQLI_CLIENT_NO_SCHEMA"			=> true,
+		"MYSQLI_CLIENT_FOUND_ROWS"			=> true,
+		"MYSQLI_STORE_RESULT"				=> true,
+		"MYSQLI_USE_RESULT"					=> true,
+		"MYSQLI_ASSOC"						=> true,
+		"MYSQLI_NUM"						=> true,
+		"MYSQLI_BOTH"						=> true,
+		"MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH"	=> true,
+		"MYSQLI_NOT_NULL_FLAG"				=> true,
+		"MYSQLI_PRI_KEY_FLAG"				=> true,
+		"MYSQLI_UNIQUE_KEY_FLAG"			=> true,
+		"MYSQLI_MULTIPLE_KEY_FLAG"			=> true,
+		"MYSQLI_BLOB_FLAG"					=> true,
+		"MYSQLI_UNSIGNED_FLAG"				=> true,
+		"MYSQLI_ZEROFILL_FLAG"				=> true,
+		"MYSQLI_AUTO_INCREMENT_FLAG"		=> true,
+		"MYSQLI_TIMESTAMP_FLAG"				=> true,
+		"MYSQLI_SET_FLAG"					=> true,
+		"MYSQLI_NUM_FLAG"					=> true,
+		"MYSQLI_ENUM_FLAG"					=> true,
+		"MYSQLI_BINARY_FLAG"				=> true,
+		"MYSQLI_PART_KEY_FLAG"				=> true,
+		"MYSQLI_GROUP_FLAG"					=> true,
+		"MYSQLI_SERVER_QUERY_NO_GOOD_INDEX_USED"=> true,
+		"MYSQLI_SERVER_QUERY_NO_INDEX_USED"	=> true,
+
+		"MYSQLI_TYPE_DECIMAL"				=> true,
+		"MYSQLI_TYPE_TINY"					=> true,
+		"MYSQLI_TYPE_SHORT"					=> true,
+		"MYSQLI_TYPE_LONG"					=> true,
+		"MYSQLI_TYPE_FLOAT"					=> true,
+		"MYSQLI_TYPE_DOUBLE"				=> true,
+		"MYSQLI_TYPE_NULL"					=> true,
+		"MYSQLI_TYPE_TIMESTAMP"				=> true,
+		"MYSQLI_TYPE_LONGLONG"				=> true,
+		"MYSQLI_TYPE_INT24"					=> true,
+		"MYSQLI_TYPE_DATE"					=> true,
+		"MYSQLI_TYPE_TIME"					=> true,
+		"MYSQLI_TYPE_DATETIME"				=> true,
+		"MYSQLI_TYPE_YEAR"					=> true,
+		"MYSQLI_TYPE_NEWDATE"				=> true,
+		"MYSQLI_TYPE_ENUM"					=> true,
+		"MYSQLI_TYPE_SET"					=> true,
+		"MYSQLI_TYPE_TINY_BLOB"				=> true,
+		"MYSQLI_TYPE_MEDIUM_BLOB"			=> true,
+		"MYSQLI_TYPE_LONG_BLOB"				=> true,
+		"MYSQLI_TYPE_BLOB"					=> true,
+		"MYSQLI_TYPE_VAR_STRING"			=> true,
+		"MYSQLI_TYPE_STRING"				=> true,
+		"MYSQLI_TYPE_CHAR"					=> true,
+		"MYSQLI_TYPE_INTERVAL"				=> true,
+		"MYSQLI_TYPE_GEOMETRY"				=> true,
+		"MYSQLI_NO_DATA"					=> true,
+		"MYSQLI_REPORT_INDEX"				=> true,
+		"MYSQLI_REPORT_STRICT"				=> true,
+		"MYSQLI_REPORT_ALL"					=> true,
+		"MYSQLI_REPORT_ERROR"				=> true,
+		"MYSQLI_REPORT_OFF"					=> true,
+		"MYSQLI_SET_CHARSET_NAME"			=> true,
+		"MYSQLI_SET_CHARSET_DIR"			=> true,
+		"MYSQLI_REFRESH_GRANT"				=> true,
+		"MYSQLI_REFRESH_LOG"					=> true,
+		"MYSQLI_REFRESH_TABLES"				=> true,
+		"MYSQLI_REFRESH_HOSTS"				=> true,
+		"MYSQLI_REFRESH_STATUS"				=> true,
+		"MYSQLI_REFRESH_THREADS"			=> true,
+		"MYSQLI_REFRESH_SLAVE"				=> true,
+		"MYSQLI_REFRESH_MASTER"				=> true,
+		"MYSQLI_DEBUG_TRACE_ENABLED"	=> true,
+	);
+
+	/* depends on the build - experimental */
+	if ($IS_MYSQLND && defined('MYSQLI_OPT_INT_AND_FLOAT_NATIVE')) {
+		$expected_constants['MYSQLI_OPT_INT_AND_FLOAT_NATIVE'] = true;
+	}
+
+	if ($IS_MYSQLND || defined('MYSQLI_REFRESH_BACKUP_LOG')) {
+		$expected_constants['MYSQLI_REFRESH_BACKUP_LOG'] = true;
+	}
+
+	if ($IS_MYSQLND) {
+		$version = 50007 + 1;
+		$expected_constants['MYSQLI_OPT_NET_CMD_BUFFER_SIZE'] = true;
+		$expected_constants['MYSQLI_OPT_NET_READ_BUFFER_SIZE'] = true;
+		$expected_constants['MYSQLI_ASYNC'] = true;
+
+		$expected_constants['MYSQLI_SERVER_PS_OUT_PARAMS'] = true;
+	} else {
+		$version = mysqli_get_client_version();
+	}
+
+	if (($version > 51122 && $version < 60000) || ($version > 60003) || $IS_MYSQLND) {
+		$expected_constants['MYSQLI_ON_UPDATE_NOW_FLAG'] = true;
+	}
+
+	/* First introduced in MySQL 6.0, backported to MySQL 5.5 */
+	if ($version >= 50500 || $IS_MYSQLND) {
+		$expected_constants['MYSQLI_SERVER_QUERY_WAS_SLOW'] = true;
+	}
+
+	if ($version > 50002) {
+		$expected_constants = array_merge($expected_constants, array(
+			"MYSQLI_TYPE_NEWDECIMAL"	=> true,
+			"MYSQLI_TYPE_BIT"			=> true,
+		));
+	}
+
+	if ($version > 50002 || $IS_MYSQLND) {
+		$expected_constants['MYSQLI_NO_DEFAULT_VALUE_FLAG'] = true;
+	}
+
+	if ($version > 50003) {
+		$expected_constants = array_merge($expected_constants, array(
+			"MYSQLI_STMT_ATTR_CURSOR_TYPE"		=> true,
+			"MYSQLI_CURSOR_TYPE_NO_CURSOR"		=> true,
+			"MYSQLI_CURSOR_TYPE_READ_ONLY"		=> true,
+			"MYSQLI_CURSOR_TYPE_FOR_UPDATE"		=> true,
+			"MYSQLI_CURSOR_TYPE_SCROLLABLE"		=> true,
+		));
+	}
+
+	if ($version > 50007) {
+		$expected_constants = array_merge($expected_constants, array(
+			"MYSQLI_STMT_ATTR_PREFETCH_ROWS"	=> true,
+		));
+	}
+
+	if ($version > 50110 || $IS_MYSQLND) {
+		$expected_constants['MYSQLI_OPT_SSL_VERIFY_SERVER_CERT'] = true;
+	}
+
+	/* pretty dump test, but that is the best way to mimic mysql.c */
+	if (defined('MYSQLI_DATA_TRUNCATED'))
+		$expected_constants["MYSQLI_DATA_TRUNCATED"] = true;
+
+	if (defined('MYSQLI_SERVER_PS_OUT_PARAMS'))
+		$expected_constants["MYSQLI_SERVER_PS_OUT_PARAMS"] = true;
+
+	if (!$IS_MYSQLND) {
+		/* libmysql only */
+
+		/* are they available in all versions of ext/mysqli ?
+		... no we must have removed them at some point - for BC, weakening the test
+		*/
+		if (defined("MYSQLI_RPL_MASTER")) {
+			$expected_constants["MYSQLI_RPL_MASTER"]	= true;
+			$expected_constants["MYSQLI_RPL_SLAVE"]		= true;
+			$expected_constants["MYSQLI_RPL_ADMIN"]		= true;
+		}
+	}
+
+
+	$unexpected_constants = array();
+
+	foreach ($constants as $group => $consts) {
+		foreach ($consts as $name => $value) {
+			if (stristr($name, 'mysqli')) {
+				$name = strtoupper($name);
+				if (isset($expected_constants[$name])) {
+					unset($expected_constants[$name]);
+				} else {
+					$unexpected_constants[$name] = $name;
+				}
+			}
+		}
+	}
+
+	if (!empty($unexpected_constants)) {
+		printf("Dumping list of unexpected constants\n");
+		var_dump($unexpected_constants);
+	}
+
+	if (!empty($expected_constants)) {
+		printf("Dumping list of missing constants\n");
+		var_dump($expected_constants);
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_constants_categories.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Constants exported by ext/mysqli - checking category - PHP bug not mysqli bug (check from time to time)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+?>
+--FILE--
+<?php
+	$constants = get_defined_constants(true);
+
+	foreach ($constants as $group => $consts) {
+		foreach ($consts as $name => $value) {
+			if (stristr($name, 'mysqli')) {
+				if ('mysqli' != $group)
+				printf("found constant '%s' in group '%s'. expecting group 'mysqli'\n", $name, $group);
+			}
+		}
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_data_seek.phpt
@@ -0,0 +1,74 @@
+--TEST--
+mysqli_data_seek()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_data_seek()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_data_seek($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_data_seek($link, $link)))
+		printf("[003] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, 'SELECT * FROM test ORDER BY id LIMIT 4', MYSQLI_STORE_RESULT))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = mysqli_data_seek($res, 3)))
+		printf("[005] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$row = mysqli_fetch_assoc($res);
+	if (4 != $row['id'])
+		printf("[006] Expecting record 4/d, got record %s/%s\n", $row['id'], $row['label']);
+
+	if (true !== ($tmp = mysqli_data_seek($res, 0)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$row = mysqli_fetch_assoc($res);
+	if (1 != $row['id'])
+		printf("[008] Expecting record 1/a, got record %s/%s\n", $row['id'], $row['label']);
+
+	if (false !== ($tmp = mysqli_data_seek($res, 4)))
+		printf("[009] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_data_seek($res, -1)))
+		printf("[010] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, 'SELECT * FROM test ORDER BY id', MYSQLI_USE_RESULT))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_data_seek($res, 3)))
+		printf("[012] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_free_result($res);
+
+	if (NULL !== ($tmp = mysqli_data_seek($res, 1)))
+		printf("[013] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_data_seek(): Function cannot be used with MYSQL_USE_RESULT in %s on line %d
+
+Warning: mysqli_data_seek(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_data_seek_oo.phpt
@@ -0,0 +1,83 @@
+--TEST--
+mysqli_result->data_seek()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	require('table.inc');
+
+	if (!$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket))
+	printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+
+	$res = new mysqli_result($mysqli);
+	if (NULL !== ($tmp = @$res->data_seek(0)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = $mysqli->query('SELECT * FROM test ORDER BY id LIMIT 4', MYSQLI_STORE_RESULT))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = @$res->data_seek()))
+		printf("[004] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @$res->data_seek($link)))
+		printf("[005] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @$res->data_seek($link, $link)))
+		printf("[006] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = $res->data_seek(3)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$row = $res->fetch_assoc();
+	if (4 != $row['id'])
+		printf("[008] Expecting record 4/d, got record %s/%s\n", $row['id'], $row['label']);
+
+	if (true !== ($tmp = $res->data_seek(0)))
+		printf("[009] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$row = $res->fetch_assoc();
+	if (1 != $row['id'])
+		printf("[010] Expecting record 1/a, got record %s/%s\n", $row['id'], $row['label']);
+
+	if (false !== ($tmp = $res->data_seek(4)))
+		printf("[011] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $res->data_seek(-1)))
+		printf("[012] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	$res->free_result();
+
+	if (!$res = $mysqli->query('SELECT * FROM test ORDER BY id', MYSQLI_USE_RESULT))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = $res->data_seek(3)))
+		printf("[014] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	$res->free_result();
+
+	if (NULL !== ($tmp = $res->data_seek(1)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$mysqli->close();
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_result::data_seek(): Function cannot be used with MYSQL_USE_RESULT in %s on line %d
+
+Warning: mysqli_result::data_seek(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_debug.phpt
@@ -0,0 +1,69 @@
+--TEST--
+mysqli_debug()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_debug'))
+ 	die("skip: mysqli_debug() not available");
+
+if (!defined('MYSQLI_DEBUG_TRACE_ENABLED'))
+	die("skip: can't say for sure if mysqli_debug works");
+
+if (defined('MYSQLI_DEBUG_TRACE_ENABLED') && !MYSQLI_DEBUG_TRACE_ENABLED)
+	die("skip: debug functionality not enabled");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');;
+
+	if (NULL !== ($tmp = @mysqli_debug()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	// NOTE: documentation is not clear on this: function always return NULL or TRUE
+	if (true !== ($tmp = mysqli_debug(sprintf('d:t:O,%s/mysqli_debug_phpt.trace', sys_get_temp_dir()))))
+		printf("[002] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($IS_MYSQLND) {
+		// let's make this mysqlnd only - for libmysql we need debug installation
+
+		// table.inc will create a database connection and run some SQL queries, therefore
+		// the debug file should have entries
+		require_once('table.inc');
+
+		clearstatcache();
+		$trace_file = sprintf('%s/mysqli_debug_phpt.trace', sys_get_temp_dir());
+		if (!file_exists($trace_file))
+			printf("[003] Trace file '%s' has not been created\n", $trace_file);
+		if (filesize($trace_file) < 50)
+			printf("[004] Trace file '%s' is very small. filesize() reports only %d bytes. Please check.\n",
+				$trace_file,
+				filesize($trace_file));
+
+		// will mysqli_debug() mind if the trace file gets removed?
+		unlink($trace_file);
+		clearstatcache();
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test'))
+				printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			else
+				mysqli_free_result($res);
+
+		mysqli_close($link);
+
+		clearstatcache();
+		if (!file_exists($trace_file))
+			printf("[006] Trace file '%s' does not exist\n", $trace_file);
+		unlink($trace_file);
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done%s
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_debug_append.phpt
@@ -0,0 +1,93 @@
+--TEST--
+mysqli_debug() - append to trace file
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_debug'))
+ 	die("skip: mysqli_debug() not available");
+
+if (!defined('MYSQLI_DEBUG_TRACE_ENABLED'))
+	die("skip: can't say for sure if mysqli_debug works");
+
+if (defined('MYSQLI_DEBUG_TRACE_ENABLED') && !MYSQLI_DEBUG_TRACE_ENABLED)
+	die("skip: debug functionality not enabled");
+
+if (!$IS_MYSQLND)
+	die("SKIP Libmysql feature not sufficiently spec'd in MySQL C API documentation");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');;
+
+	if (true !== ($tmp = mysqli_debug(sprintf('d:t:O,%s/mysqli_debug_phpt.trace', sys_get_temp_dir()))))
+		printf("[001] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	// table.inc will create a database connection and run some SQL queries, therefore
+	// the debug file should have entries
+	require_once('table.inc');
+
+	clearstatcache();
+	$trace_file = sprintf('%s/mysqli_debug_phpt.trace', sys_get_temp_dir());
+	if (!file_exists($trace_file))
+		printf("[002] Trace file '%s' has not been created\n", $trace_file);
+	if (filesize($trace_file) < 50)
+		printf("[003] Trace file '%s' is very small. filesize() reports only %d bytes. Please check.\n",
+			$trace_file,
+			filesize($trace_file));
+
+	// will mysqli_debug() mind if the trace file gets removed?
+	unlink($trace_file);
+	clearstatcache();
+
+	if (!$fp = fopen($trace_file, 'w')) {
+		printf("[004] Cannot create trace file to test append mode\n");
+	} else {
+
+		if (!fwrite($fp, (binary) 'mysqli_debug.phpt test line'))
+			printf("[005] Cannot write to trace file.\n");
+		fclose($fp);
+
+		if (true !== ($tmp = mysqli_debug(sprintf('d:a,%s', $trace_file))))
+			printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test'))
+			printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		else
+			mysqli_free_result($res);
+
+		$trace = file_get_contents($trace_file);
+		if (!strstr($trace, 'mysqli_debug.phpt test line'))
+			printf("[008] Cannot find original file content any more. Seems that the trace file got overwritten and not appended. Please check.");
+
+		if (true !== ($tmp = mysqli_debug(sprintf('d:A,%s', $trace_file))))
+			printf("[009] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test'))
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		else
+			mysqli_free_result($res);
+
+		if (!strstr(file_get_contents($trace_file), $trace))
+			printf("[011] Cannot find original file content any more. Seems that the trace file got overwritten and not appended. Please check.");
+	}
+
+	// what will happen if we create new trace entries...?
+	unlink($trace_file);
+	clearstatcache();
+	if (file_exists($trace_file))
+		printf("[012] Could not remove trace file '%s'.\n", $trace_file);
+
+	mysqli_close($link);
+	print "done";
+	if ($IS_MYSQLND)
+		print "libmysql/DBUG package prints some debug info here."
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done%s
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_debug_control_string.phpt
@@ -0,0 +1,77 @@
+--TEST--
+mysqli_debug() - invalid debug control strings
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_debug'))
+ 	die("skip: mysqli_debug() not available");
+
+if (!defined('MYSQLI_DEBUG_TRACE_ENABLED'))
+	die("skip: can't say for sure if mysqli_debug works");
+
+if (defined('MYSQLI_DEBUG_TRACE_ENABLED') && !MYSQLI_DEBUG_TRACE_ENABLED)
+	die("skip: debug functionality not enabled");
+
+if (!$IS_MYSQLND)
+	die("SKIP Libmysql feature not sufficiently spec'd in MySQL C API documentation");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	function try_control_string($link, $control_string, $trace_file, $offset) {
+
+		if (true !== ($tmp = mysqli_debug($control_string))) {
+			printf("[%03d][control string '%s'] Expecting boolean/true, got %s/%s.\n",
+				$offset + 1,
+				$control_string,
+				gettype($tmp),
+				$tmp);
+			return false;
+		}
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test')) {
+			printf("[%03d][control string '%s'] [%d] %s.\n",
+				$offset + 2,
+				$control_string,
+				mysqli_errno($link),
+				mysqli_error($link));
+			return false;
+		}
+
+		clearstatcache();
+		if (!file_exists($trace_file)) {
+			printf("[%03d][control string '%s'] Trace file has not been written.\n",
+				$offset + 3,
+				$control_string,
+				gettype($tmp),
+				$tmp);
+			return false;
+		}
+
+		unlink($trace_file);
+	}
+
+	$trace_file = sprintf('%s%s%s', sys_get_temp_dir(), DIRECTORY_SEPARATOR, 'mysqli_debug_phpt.trace');
+	try_control_string($link, 't:,,:o,' . $trace_file, $trace_file, 10);
+	try_control_string($link, ':' . chr(0) . 'A,' . $trace_file, $trace_file, 20);
+	try_control_string($link, 't:o,' . $trace_file . ':abc', $trace_file, 30);
+	try_control_string($link, 't:o,' . $trace_file . ':ABC,123:b', $trace_file, 40);
+	try_control_string($link, 't:ABC,123:b;:o,' . $trace_file, $trace_file, 50);
+	try_control_string($link, 't:A;BC,123:b;:o,' . $trace_file, $trace_file, 60);
+	try_control_string($link, 't:p:o,' . $trace_file, $trace_file, 70);
+	try_control_string($link, 't:p,1,,2:o,' . $trace_file, $trace_file, 80);
+	try_control_string($link, 't:z,1,,2:o,' . $trace_file, $trace_file, 90);#
+
+	mysqli_close($link);
+	print "done";
+	if ($IS_MYSQLND)
+		print "libmysql/DBUG package prints some debug info here."
+?>
+--EXPECTF--
+[023][control string '%s'] Trace file has not been written.
+done%s
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_debug_ini.phpt
@@ -0,0 +1,53 @@
+--TEST--
+mysqli_debug() - enabling trace with ini setting
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_debug'))
+ 	die("skip mysqli_debug() not available");
+
+if (!defined('MYSQLI_DEBUG_TRACE_ENABLED'))
+	die("skip: can't say for sure if mysqli_debug works");
+
+if (defined('MYSQLI_DEBUG_TRACE_ENABLED') && !MYSQLI_DEBUG_TRACE_ENABLED)
+	die("skip: debug functionality not enabled");
+
+require_once('connect.inc');
+if (!$IS_MYSQLND || ($MYSQLND_VERSION < 50004))
+	die("skip needs mysqlnd version/revision 5.0.4");
+
+if (!$fp = @fopen('/tmp/mysqli_debug_phpt.trace', 'w'))
+	die("skip PHP cannot create a file in /tmp/mysqli_debug_phpt");
+else
+	fclose($fp);
+@unlink("/tmp/mysqli_debug_phpt.trace");
+?>
+--INI--
+mysqlnd.debug="t:O,/tmp/mysqli_debug_phpt.trace"
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	var_dump(ini_get('mysqlnd.debug'));
+
+	$trace_file = '/tmp/mysqli_debug_phpt.trace';
+	clearstatcache();
+	if (!file_exists($trace_file))
+		printf("[003] Trace file '%s' has not been created\n", $trace_file);
+	if (filesize($trace_file) < 50)
+		printf("[004] Trace file '%s' is very small. filesize() reports only %d bytes. Please check.\n",
+			$trace_file,
+			filesize($trace_file));
+
+	mysqli_close($link);
+	unlink($trace_file);
+
+	print "done!";
+?>
+--EXPECTF--
+string(32) "t:O,/tmp/mysqli_debug_phpt.trace"
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_debug_mysqlnd_control_string.phpt
@@ -0,0 +1,230 @@
+--TEST--
+mysqli_debug() - all control string options supported by both mysqlnd and libmysql except oOaA
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_debug'))
+ 	die("skip: mysqli_debug() not available");
+
+if (!defined('MYSQLI_DEBUG_TRACE_ENABLED'))
+	die("skip: can't say for sure if mysqli_debug works");
+
+if (defined('MYSQLI_DEBUG_TRACE_ENABLED') && !MYSQLI_DEBUG_TRACE_ENABLED)
+	die("skip: debug functionality not enabled");
+
+if (!$IS_MYSQLND)
+	die("SKIP Libmysql feature not sufficiently spec'd in MySQL C API documentation");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');;
+	require_once('table.inc');
+
+	function try_control_string($link, $control_string, $trace_file, $offset) {
+
+		@unlink($trace_file);
+		if (true !== ($tmp = @mysqli_debug($control_string))) {
+			printf("[%03d][control string '%s'] Expecting boolean/true, got %s/%s.\n",
+				$offset + 1,
+				$control_string,
+				gettype($tmp),
+				$tmp);
+			return false;
+		}
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test')) {
+			printf("[%03d][control string '%s'] [%d] %s.\n",
+				$offset + 2,
+				$control_string,
+				mysqli_errno($link),
+				mysqli_error($link));
+			return false;
+		}
+		while ($row = mysqli_fetch_assoc($res))
+			;
+		mysqli_free_result($res);
+
+		clearstatcache();
+		if (!file_exists($trace_file)) {
+			printf("[%03d][control string '%s'] Trace file has not been written.\n",
+				$offset + 3,
+				$control_string,
+				gettype($tmp),
+				$tmp);
+			return false;
+		}
+
+		return trim(substr(file_get_contents($trace_file), 0, 100024));
+	}
+
+	$trace_file = sprintf('%s%s%s', sys_get_temp_dir(), DIRECTORY_SEPARATOR, 'mysqli_debug_phpt.trace');
+
+	$trace = try_control_string($link, 't:O,' . $trace_file, $trace_file, 10);
+	if (!strstr($trace, 'SELECT * FROM test') && !strstr($trace, 'mysql_real_query'))
+		printf("[015] SELECT query cannot be found in trace. Trace contents seems wrong.\n");
+
+	// T - gettimeofday() system call, system dependent format
+	// 16:57:03.350734 >mysql_real_query
+	$trace = try_control_string($link, 't:O,' . $trace_file . ':T', $trace_file, 20);
+	if (!preg_match('@^[012]{0,1}[0-9]{1}:[0-5]{0,1}[0-9]{1}:[0-5]{0,1}[0-9]{1}@ismU', $trace))
+		printf("[025] Timestamp not found. One reason could be that the test is borked and does not recognize the format of the gettimeofday() system call. Check manually (and fix the test, if needed :-)). First characters from trace are '%s'\n", substr($trace, 0, 80));
+
+	// i - add PID of the current process
+	// currently PHP is not multi-threaded, so it should be save to test for the PID of this PHP process
+	if (false === ($pid = getmypid()))
+		$pid = "[\d]+";
+
+	$trace = try_control_string($link, 't:O,' . $trace_file . ':i', $trace_file, 30);
+	if (!preg_match("@^" . $pid . "*@ismU", $trace))
+		printf("[035] Process ID has not been found, first characters from trace are '%s'\n", substr($trace, 0, 80));
+
+	// L - line numbers
+	$trace = try_control_string($link, 't:O,' . $trace_file . ':L', $trace_file, 40);
+	if (!preg_match("@^[\d]+@ismU", $trace))
+		printf("[045] Line numbers have not been found, first characters from trace are '%s'\n", substr($trace, 0, 80));
+
+	// F - file name
+	$trace = try_control_string($link, 't:O,' . $trace_file . ':F', $trace_file, 50);
+	// hopefully we'll never see a file name that's not covered by this regular expression...
+	if (!preg_match("@^\s*[/\w\\\\d\.\-]+\.[ch]@ismU", $trace))
+		printf("[055] File names seem to be missing, first characters from trace are '%s'\n", substr($trace, 0, 80));
+
+	// -n - print function nesting depth
+	$trace = try_control_string($link, 't:O,' . $trace_file . ':n', $trace_file, 60);
+	if (!preg_match("@^\d+:@ismU", $trace))
+		printf("[065] Nesting level seem to be missing, first characters from trace are '%s'\n", substr($trace, 0, 80));
+
+	// -t,[N] - maximum nesting level
+	$trace = try_control_string($link, 't,1:n:O,' . $trace_file, $trace_file, 70);
+	$lines = explode("\n", $trace);
+	foreach ($lines as $k => $line) {
+		$line = trim($line);
+		if (!preg_match("@^(\d+):+@ismU", $line, $matches)) {
+			printf("[075] Nesting level seem to be missing, first characters from trace are '%s'\n", substr($line, 0, 80));
+		} else {
+			if (!isset($matches[1]) || ((int)$matches[1] > 1)) {
+				printf("[076] Nesting level seem to be %d, should not be higher than 1, first characters from trace are '%s'\n",
+					$matches[1],
+					substr($line, 0, 80));
+			}
+		}
+	}
+
+	// omitting t
+	$trace = try_control_string($link, 'n:O,' . $trace_file, $trace_file, 80);
+	$lines = explode("\n", $trace);
+	foreach ($lines as $k => $line) {
+		$line = trim($line);
+		if (preg_match("@^[|\s]*>[\w]+@ism", $line, $matches)) {
+			printf("[085] Looks like a function call, but there should be none in the trace file, first characters from trace are '%s'\n",
+				substr($line, 0, 80));
+		}
+	}
+
+	// -f[,functions] - Limit debugger list to specified functions. Empty list -> all functions
+	$lines_all_funcs = explode("\n", try_control_string($link, 't:O,' . $trace_file, $trace_file, 90));
+	$functions_all_funcs = array();
+	foreach ($lines_all_funcs as $k => $line) {
+		$line = trim($line);
+		if (preg_match("@^[|\s]*>([\w:]+)@ism", $line, $matches)) {
+			$functions_all_funcs[$matches[1]] = $matches[1];
+		}
+	}
+
+	$lines_trace = explode("\n", try_control_string($link, 't:f:O,' . $trace_file, $trace_file, 100));
+	$functions_trace = array();
+	foreach ($lines_trace as $k => $line) {
+		$line = trim($line);
+		if (preg_match("@^[|\s]*>([\w:]+)@ism", $line, $matches)) {
+			$functions_trace[$matches[1]] = $matches[1];
+		}
+	}
+
+	$tmp = array_diff($functions_all_funcs, $functions_trace);
+	if (!empty($tmp)) {
+		printf("[105] Looks like not all functions are listed in the trace. Check manually, dumping diff.");
+		var_dump($tmp);
+	}
+
+	// get two or three function names to play with...
+	$test_functions = array('simple' => array(), 'doubledot' => array());
+
+	foreach ($functions_all_funcs as $func) {
+		if (count($test_functions['simple']) < 2 && !strstr($func, '::'))
+			$test_functions['simple'][$func] = $func;
+		else if (count($test_functions['doubledot']) < 2 && strstr($func, '::'))
+			$test_functions['doubledot'][$func] = $func;
+	}
+
+	$control_string = '';
+	if ($func = reset($test_functions['simple']))
+			$control_string .= sprintf('%s,', $func);
+	if ($func = reset($test_functions['doubledot']))
+			$control_string .= sprintf('%s,', $func);
+	if ($func = next($test_functions['simple']))
+			$control_string .= sprintf('%s,', $func);
+	if ($func = next($test_functions['doubledot']))
+			$control_string .= sprintf('%s,', $func);
+	$control_string = sprintf('t:f,%s:O,%s', $control_string, $trace_file);
+
+	$lines_trace = explode("\n", try_control_string($link, $control_string, $trace_file, 110));
+	$functions_trace = array();
+	foreach ($lines_trace as $k => $line) {
+		$line = trim($line);
+		if (preg_match("@^[|\s]*>([\w:]+)@ism", $line, $matches)) {
+			$functions_trace[$matches[1]] = $matches[1];
+		}
+	}
+
+	foreach ($test_functions['simple'] as $func)
+		if (isset($functions_trace[$func])) {
+			unset($functions_trace[$func]);
+			unset($test_functions['simple'][$func]);
+		}
+
+	foreach ($test_functions['doubledot'] as $func)
+		if (isset($functions_trace[$func])) {
+			unset($functions_trace[$func]);
+			unset($test_functions['doubledot'][$func]);
+		}
+
+	if (!empty($functions_trace)) {
+		printf("[115] Dumping list of unexpected functions which should have not been shown when using control string '%s'.\n",
+			$control_string);
+		var_dump($functions_trace);
+	}
+	$tmp = array_merge($test_functions['doubledot'], $test_functions['simple']);
+	if (!empty($tmp)) {
+		printf("[116] Dumping list of functions which should have been shown when using control string '%s'.\n",
+			$control_string);
+		var_dump($tmp);
+	}
+
+	if ($IS_MYSQLND) {
+		// mysqlnd only option
+		// m - trace memory allocations
+		$trace = try_control_string($link, 't:O,' . $trace_file . ':m', $trace_file, 120);
+		if (!preg_match("@^[|\s]*>\_mysqlnd_pefree@ismU", $trace, $matches) &&
+				!preg_match("@^[|\s]*>\_mysqlnd_pemalloc@ismU", $trace, $matches)) {
+			printf("[125] Memory dump does neither contain _mysqlnd_pefree nor _mysqlnd_pemalloc calls - check manually.\n");
+			var_dump($trace);
+		}
+
+	}
+
+	mysqli_close($link);
+	print "done";
+	if ($IS_MYSQLND)
+		print "libmysql/DBUG package prints some debug info here.";
+	@unlink($trace_file);
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[083][control string 'n:O,%smysqli_debug_phpt.trace'] Trace file has not been written.
+done%s
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_debug_mysqlnd_only.phpt
@@ -0,0 +1,128 @@
+--TEST--
+mysqli_debug() - mysqlnd only control strings
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!function_exists('mysqli_debug'))
+ 	die("skip mysqli_debug() not available");
+
+if (!defined('MYSQLI_DEBUG_TRACE_ENABLED'))
+	die("skip: can't say for sure if mysqli_debug works");
+
+if (defined('MYSQLI_DEBUG_TRACE_ENABLED') && !MYSQLI_DEBUG_TRACE_ENABLED)
+	die("skip: debug functionality not enabled");
+
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only test");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');;
+	require_once('table.inc');
+
+	function try_control_string($link, $control_string, $trace_file, $offset) {
+
+		@unlink($trace_file);
+		if (true !== ($tmp = @mysqli_debug($control_string))) {
+			printf("[%03d][control string '%s'] Expecting boolean/true, got %s/%s.\n",
+				$offset + 1,
+				$control_string,
+				gettype($tmp),
+				$tmp);
+			return false;
+		}
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test')) {
+			printf("[%03d][control string '%s'] [%d] %s.\n",
+				$offset + 2,
+				$control_string,
+				mysqli_errno($link),
+				mysqli_error($link));
+			return false;
+		}
+		while ($row = mysqli_fetch_assoc($res))
+			;
+		mysqli_free_result($res);
+
+		clearstatcache();
+		if (!file_exists($trace_file)) {
+			printf("[%03d][control string '%s'] Trace file has not been written.\n",
+				$offset + 3,
+				$control_string,
+				gettype($tmp),
+				$tmp);
+			return false;
+		}
+
+		return trim(substr(file_get_contents($trace_file), 0, 100024));
+	}
+
+	$memory_funcs = array(
+		'_mysqlnd_ecalloc',
+		'_mysqlnd_emalloc',
+		'_mysqlnd_palloc_free_thd_cache_reference',
+		'_mysqlnd_pecalloc',
+		'_mysqlnd_pefree',
+		'_mysqlnd_pemalloc',
+		'_mysqlnd_perealloc',
+	);
+	$trace_file = sprintf('%s%s%s', sys_get_temp_dir(), DIRECTORY_SEPARATOR, 'mysqli_debug_phpt.trace');
+
+	$trace = try_control_string($link, 't:m:O,' . $trace_file, $trace_file, 10);
+	if (!strstr($trace, 'SELECT * FROM test') && !strstr($trace, 'mysql_real_query'))
+		printf("[015] SELECT query cannot be found in trace. Trace contents seems wrong.\n");
+
+	$lines_trace = explode("\n", $trace);
+	$functions_trace = array();
+	foreach ($lines_trace as $k => $line) {
+		$line = trim($line);
+		if (preg_match("@^[|\s]*>([\w:]+)@ism", $line, $matches)) {
+			$functions_trace[$matches[1]] = $matches[1];
+		}
+	}
+
+	$found = 0;
+	foreach ($memory_funcs as $k => $name)
+		if (isset($functions_trace[$name]))
+			$found++;
+
+	if ($found < (count($memory_funcs) - 2))
+		printf("[016] Only %d memory functions have been found, expecting at least %d.\n",
+			$found, count($memory_funcs) - 2);
+
+	$trace = try_control_string($link, 't:O,' . $trace_file, $trace_file, 20);
+	if (!strstr($trace, 'SELECT * FROM test') && !strstr($trace, 'mysql_real_query'))
+		printf("[025] SELECT query cannot be found in trace. Trace contents seems wrong.\n");
+
+	$lines_trace = explode("\n", $trace);
+	$functions_trace = array();
+	foreach ($lines_trace as $k => $line) {
+		$line = trim($line);
+		if (preg_match("@^[|\s]*>([\w:]+)@ism", $line, $matches)) {
+			$functions_trace[$matches[1]] = $matches[1];
+		}
+	}
+
+	$found = 0;
+	foreach ($memory_funcs as $k => $name)
+		if (isset($functions_trace[$name]))
+			$found++;
+
+	if ($found > 2)
+		printf("[026] More than %d memory functions have been recorded, that's strange.\n",
+			$found);
+
+	mysqli_close($link);
+	@unlink($trace_file);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_disable_reads_from_master.phpt
@@ -0,0 +1,47 @@
+--TEST--
+mysqli_disable_reads_from_master()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_disable_reads_from_master')) {
+	die("skip mysqli_disable_reads_from_master() not available");
+}
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_disable_reads_from_master()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_disable_reads_from_master($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (!is_bool($tmp = mysqli_disable_reads_from_master($link)))
+		printf("[004] Expecting boolean/[true|false] value, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_disable_reads_from_master($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_disable_reads_from_master(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_driver.phpt
@@ -0,0 +1,114 @@
+--TEST--
+mysqli_driver class
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require("table.inc");
+
+	if (!is_object($driver = new mysqli_driver()))
+		printf("[001] Failed to create mysqli_driver object\n");
+
+	$client_info = mysqli_get_client_info();
+	if (($tmp = $driver->client_info) !== $client_info)
+		printf("[002] Expecting %s/%s, got %s/%s\n",
+			gettype($client_info), $client_info,
+			gettype($tmp), $tmp);
+
+	$client_version = mysqli_get_client_version();
+	if (($tmp = $driver->client_version) !== $client_version)
+		printf("[003] Expecting %s/%s, got %s/%s\n",
+		gettype($client_version), $client_version,
+		gettype($tmp), $tmp);
+
+	if (!is_int($tmp = $driver->driver_version) || (0 == $tmp))
+		printf("[004] Expecting int/any, got %s/%s\n",
+		gettype($tmp), $tmp);
+
+
+	$all_modes = array(MYSQLI_REPORT_INDEX, MYSQLI_REPORT_ERROR, MYSQLI_REPORT_STRICT,
+			MYSQLI_REPORT_ALL, MYSQLI_REPORT_OFF);
+	$report_mode = $driver->report_mode;
+	if (!is_int($report_mode))
+		printf("[005] Expecting int/any, got %s/%s\n",
+		gettype($report_mode), $report_mode);
+
+	if (!in_array($report_mode, $all_modes))
+		printf("[006] Illegal report mode returned? Got %s, expected %s\n",
+			$report_mode, implode(', ', $all_modes));
+
+	$driver->report_mode = MYSQLI_REPORT_STRICT;
+	$ok = false;
+	try {
+
+		if ($link = my_mysqli_connect($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+			printf("[007] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+			$host, $user . 'unknown_really', $db, $port, $socket);
+			mysqli_close($link);
+
+	} catch (mysqli_sql_exception $e) {
+		$ok = true;
+		if ('' == $e->getMessage())
+			printf("[008] getMessage() has returned an emptry string.\n");
+		if ('' == $e->getCode())
+			printf("[009] getCode() has returned an empty string.\n");
+		if ('' == $e->getFile())
+			printf("[010] getFile() has returned an empty string.\n");
+		if ('' == $e->getLine())
+			printf("[011] getLine() has returned an empty string.\n");
+		$tmp = $e->getTrace();
+		if (empty($tmp))
+			printf("[012] getTrace() has returned an empty array.\n");
+		if ('' == $e->getTraceAsString())
+			printf("[013] getTraceAsString() has returned an empty string.\n");
+		if ('' == $e->__toString())
+			printf("[014] __toString() has returned an empty string.\n");
+
+	}
+	if (!$ok)
+		printf("[015] Error reporting mode has not been switched to exceptions and or no exception thrown\n");
+
+
+	$driver->report_mode = MYSQLI_REPORT_OFF;
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[016] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	mysqli_query($link, "NO_SQL");
+	mysqli_close($link);
+
+	$driver->report_mode = MYSQLI_REPORT_ERROR;
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[017] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	mysqli_query($link, "NO_SQL");
+	mysqli_close($link);
+
+	if (MYSQLI_REPORT_ERROR !== $driver->report_mode)
+		printf("[018] Error mode should be different\n");
+
+	/* TODO - more report testing should go in here, but it's not really documented what behaviour is expected */
+
+	$driver->report_mode = $report_mode;
+
+	$reconnect = $driver->reconnect;
+	if (!is_bool($reconnect))
+	printf("[019] Expecting boolean/any, got %s/%s\n",
+		gettype($reconnect), $reconnect);
+
+	/* pointless, but I need more documentation */
+	$driver->reconnect = true;
+	$driver->reconnect = false;
+	$driver->reconnect = $reconnect;
+
+	if (!is_bool($embedded = $driver->embedded))
+		printf("[020] Expecting boolean/any, got %s/%s\n",
+			gettype($embedded), $embedded);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'NO_SQL' at line 1 in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_driver_unclonable.phpt
@@ -0,0 +1,13 @@
+--TEST--
+Trying to clone mysqli_driver object
+--SKIPIF--
+<?php require_once('skipif.inc'); ?>
+<?php require_once('skipifemb.inc'); ?>
+--FILE--
+<?php
+	$driver = new mysqli_driver;
+	$driver_clone = clone $driver;
+	print "done!";
+?>
+--EXPECTF--
+Fatal error: Trying to clone an uncloneable object of class mysqli_driver in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_dump_debug_info.phpt
@@ -0,0 +1,44 @@
+--TEST--
+mysqli_dump_debug_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+
+	if (NULL !== ($tmp = @mysqli_dump_debug_info()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_dump_debug_info($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+
+	if (!is_bool($tmp = mysqli_dump_debug_info($link)))
+		printf("[004] Expecting boolean/[true|false] value, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp,
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_dump_debug_info($link)))
+		printf("[005] Expecting NULL, got %s/%s\n",
+			gettype($tmp), $tmp,
+			mysqli_errno($link), mysqli_error($link));
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_dump_debug_info(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_dump_debug_info_oo.phpt
@@ -0,0 +1,38 @@
+--TEST--
+mysqli_dump_debug_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+
+	if (!$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n", $host, $user, $db, $port, $socket);
+
+	if (NULL !== ($tmp = @$mysqli->dump_debug_info($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_bool($tmp = $mysqli->dump_debug_info()))
+		printf("[003] Expecting boolean/[true|false] value, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp,
+			$mysqli->errno, $mysqli->error);
+
+	$mysqli->close();
+
+	if (NULL !== ($tmp = $mysqli->dump_debug_info()))
+		printf("[004] Expecting NULL, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp,
+			$mysqli->errno, $mysqli->error);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli::dump_debug_info(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_embedded_connect.phpt
@@ -0,0 +1,32 @@
+--TEST--
+mysqli_embedded_connect()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifnotemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_embedded_connect()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_embedded_connect($db)) {
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (!is_bool($tmp = mysqli_embedded_connect($db . '_unknown')))
+		printf("[003] Expecting boolean/[true|false] value, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_embedded_connect() expects parameter 1 to be mysqli, null given in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_enable_reads_from_master.phpt
@@ -0,0 +1,43 @@
+--TEST--
+mysqli_enable_reads_from_master()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_enable_reads_from_master')) {
+	die("skip function mysqli_enable_reads_from_master() not available\n");
+}
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_enable_reads_from_master()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_enable_reads_from_master($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (!is_bool($tmp = mysqli_enable_reads_from_master($link)))
+		printf("[004] Expecting boolean/[true|false] value, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_enable_reads_from_master($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_enable_reads_from_master(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_errno.phpt
@@ -0,0 +1,52 @@
+--TEST--
+mysqli_errno()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_errno()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_errno($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+}
+
+	var_dump(mysqli_errno($link));
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("[004] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_query($link, 'SELECT * FROM test');
+	var_dump(mysqli_errno($link));
+
+	@mysqli_query($link, 'No SQL');
+	if (($tmp = mysqli_errno($link)) == 0)
+		printf("[005] Expecting int/any non zero got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	var_dump(mysqli_errno($link));
+
+	print "done!";
+?>
+--EXPECTF--
+int(0)
+int(%d)
+
+Warning: mysqli_errno(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_errno_oo.phpt
@@ -0,0 +1,49 @@
+--TEST--
+$mysqli->errno
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$mysqli = new mysqli();
+	if (0 !== ($tmp = @$mysqli->errno))
+		printf("[001] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	var_dump($mysqli->errno);
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test')) {
+		printf("[003] Failed to drop old test table: [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	$mysqli->query('SELECT * FROM test');
+	var_dump($mysqli->errno);
+
+	@$mysqli->query('No SQL');
+	if (($tmp = $mysqli->errno) === 0)
+		printf("[004] Expecting int/any non zero got %s/%s\n", gettype($tmp), $tmp);
+
+	$mysqli->close();
+
+	var_dump($mysqli->errno);
+
+	print "done!";
+?>
+--EXPECTF--
+int(0)
+int(%d)
+
+Warning: main(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_error.phpt
@@ -0,0 +1,49 @@
+--TEST--
+mysqli_error()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_error()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_error($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	$tmp = mysqli_error($link);
+	if (!is_string($tmp) || ('' !== $tmp))
+		printf("[004] Expecting string/empty, got %s/%s. [%d] %s\n", gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("[005] Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_query($link, 'SELECT * FROM test');
+	$tmp = mysqli_error($link);
+	if (!is_string($tmp) || !preg_match("/Table '\w*\.test' doesn't exist/su", $tmp))
+		printf("[006] Expecting string/[Table... doesn't exit], got %s/%s. [%d] %s\n", gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	var_dump(mysqli_error($link));
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_error(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_error_oo.phpt
@@ -0,0 +1,46 @@
+--TEST--
+$mysqli->error
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$mysqli = new mysqli();
+	if ('' !== ($tmp = @$mysqli->error))
+		printf("[001] Expecting empty string, got %s/'%s'\n", gettype($tmp), $tmp);
+
+	if (!$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	$tmp = $mysqli->error;
+	if (!is_string($tmp) || ('' !== $tmp))
+		printf("[003] Expecting string/empty, got %s/%s. [%d] %s\n", gettype($tmp), $tmp, $mysqli->errno, $mysqli->error);
+
+	if (!$mysqli->query('DROP TABLE IF EXISTS test')) {
+		printf("[004] Failed to drop old test table: [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	$mysqli->query('SELECT * FROM test');
+	$tmp = $mysqli->error;
+	if (!is_string($tmp) || !preg_match("/Table '\w*\.test' doesn't exist/su", $tmp))
+		printf("[006] Expecting string/[Table... doesn't exit], got %s/%s. [%d] %s\n", gettype($tmp), $tmp, $mysqli->errno, $mysqli->error);
+
+	$mysqli->close();
+
+	var_dump($mysqli->error);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: main(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_error_unicode.phpt
@@ -0,0 +1,51 @@
+--TEST--
+mysqli_error()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+
+	if (!is_null($tmp = @mysqli_error()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_error($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	if (!(version_compare(PHP_VERSION, '5.9.9', '>') == 1)) {
+		mysqli_query($link, "set names utf8");
+	}
+
+	$tmp = mysqli_error($link);
+	if (!is_string($tmp) || ('' !== $tmp))
+		printf("[004] Expecting string/empty, got %s/%s. [%d] %s\n", gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+
+	mysqli_query($link, 'SELECT * FROM __');
+	$tmp = mysqli_error($link);
+	var_dump(str_replace($db.".", "", $tmp));
+
+	mysqli_close($link);
+
+	var_dump(mysqli_error($link));
+
+	print "done!";
+?>
+--EXPECTF--
+%unicode|string%(%d) "Table '__' doesn't exist"
+
+Warning: mysqli_error(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_explain_metadata.phpt
@@ -0,0 +1,162 @@
+--TEST--
+EXPLAIN - metadata
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once("connect.inc");
+if (!$IS_MYSQLND)
+  die("skip Open libmysql/MySQL issue http://bugs.mysql.com/?id=62350");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	if (!$res = mysqli_query($link, 'EXPLAIN SELECT t1.*, t2.* FROM test AS t1, test AS t2'))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$num_rows 	= 0;
+	$num_fields 	= 0;
+	$field_names	= array();
+	if (!$row = mysqli_fetch_assoc($res)) {
+		printf("[002] Expecting result but got no data [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+	} else {
+		$num_rows++;
+		$num_fields = count($row);
+		foreach ($row as $name => $value)
+			$field_names[$name] = gettype($value);
+	}
+
+	while ($row = mysqli_fetch_assoc($res))
+		$num_rows++;
+
+	if (($tmp = mysqli_num_rows($res)) !== $num_rows) {
+		printf("[003] Expecting int/%d got %s/%s\n",
+			$num_rows, gettype($tmp), $tmp);
+	}
+	if (($tmp = mysqli_field_count($link)) !== $num_fields) {
+		printf("[004] Expecting int/%d got %s/%s\n",
+			$num_fields, gettype($tmp), $tmp);
+	}
+	$fields = mysqli_fetch_fields($res);
+	if (($tmp = count($fields)) !== $num_fields) {
+		printf("[005] Expecting int/%d got %s/%s\n",
+			$num_fields, gettype($tmp), $tmp);
+	}
+
+	foreach ($fields as $k => $field) {
+		$field->max_length = 0;// change it or we will get diff error
+		if (isset($field_names[$field->name])) {
+			unset($field_names[$field->name]);
+		} else {
+			printf("[006] Unexpected field '%s', dumping info\n");
+			var_dump($field);
+		}
+	}
+	if (!empty($field_names)) {
+		printf("[007] Field descriptions missing for the following columns\n");
+		var_dump($field_names);
+	}
+
+	mysqli_free_result($res);
+
+	$stmt = mysqli_stmt_init($link);
+	/* Depending on your version, the MySQL server migit not support this */
+	if ($stmt->prepare('EXPLAIN SELECT t1.*, t2.* FROM test AS t1, test AS t2') && $stmt->execute()) {
+		if (!mysqli_stmt_store_result($stmt))
+			printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$res_meta = mysqli_stmt_result_metadata($stmt))
+			printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (($tmp = mysqli_stmt_num_rows($stmt)) !== $num_rows) {
+			printf("[010] Expecting int/%d got %s/%s\n",
+				$num_rows, gettype($tmp), $tmp);
+		}
+		if (($tmp = mysqli_stmt_field_count($stmt)) !== $num_fields) {
+			printf("[011] Expecting int/%d got %s/%s\n",
+				$num_fields, gettype($tmp), $tmp);
+		}
+		if (($tmp = mysqli_field_count($link)) !== $num_fields) {
+			printf("[013] Expecting int/%d got %s/%s\n",
+				$num_fields, gettype($tmp), $tmp);
+		}
+		if (($tmp = $res_meta->field_count) !== $num_fields) {
+			printf("[014] Expecting int/%d got %s/%s\n",
+				$num_fields, gettype($tmp), $tmp);
+		}
+		$fields_res_meta = mysqli_fetch_fields($res_meta);
+		if (($tmp = count($fields_res_meta)) !== $num_fields)
+			printf("[015] Expecting int/%d got %s/%s\n",
+				$num_fields, gettype($tmp), $tmp);
+
+		if ($fields_res_meta != $fields) {
+			printf("[016] Prepared Statement metadata differs from normal metadata, dumping\n");
+			var_dump($fields_res_meta);
+			var_dump($fields);
+		}
+
+		if (function_exists('mysqli_stmt_get_result') &&
+			$stmt->prepare('EXPLAIN SELECT t1.*, t2.* FROM test AS t1, test AS t2') &&
+			$stmt->execute()) {
+			if (!$res_stmt = mysqli_stmt_get_result($stmt)) {
+				printf("[017] Cannot fetch result from PS [%d] %s\n",
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			}
+			if (($tmp = mysqli_num_rows($res_stmt)) !== $num_rows) {
+				printf("[018] Expecting int/%d got %s/%s\n",
+					$num_rows, gettype($tmp), $tmp);
+			}
+			if ((mysqli_stmt_num_rows($stmt)) !== 0) {
+				printf("[019] Expecting int/0 got %s/%s\n", gettype($tmp), $tmp);
+			}
+			if (($tmp = mysqli_stmt_field_count($stmt)) !== $num_fields) {
+				printf("[020] Expecting int/%d got %s/%s\n",
+					$num_fields, gettype($tmp), $tmp);
+
+			}
+			if (($tmp = $res_stmt->field_count) !== $num_fields) {
+				printf("[021] Expecting int/%d got %s/%s\n",
+					$num_fields, gettype($tmp), $tmp);
+			}
+
+			$fields_stmt = mysqli_fetch_fields($res_stmt);
+			if (($tmp = count($fields_stmt)) !== $num_fields) {
+				printf("[022] Expecting int/%d got %s/%s\n",
+					$num_fields, gettype($tmp), $tmp);
+			}
+			reset($fields);
+			foreach ($fields_stmt as $fields_stmt_val) {
+				list(,$fields_val) = each($fields);
+				unset($fields_stmt_val->max_length);
+				unset($fields_val->max_length);
+				if ($fields_stmt_val != $fields_val) {
+					printf("[023] PS mysqli_stmt_get_result() metadata seems wrong, dumping\n");
+					var_dump($fields_stmt_val);
+					var_dump($fields_val);
+				}
+			}
+/*
+			if ($fields_stmt != $fields) {
+				printf("[023] PS mysqli_stmt_get_result() metadata seems wrong, dumping\n");
+				var_dump($fields_stmt);
+				var_dump($fields);
+			}
+*/
+			mysqli_free_result($res_stmt);
+		}
+	}
+	mysqli_stmt_close($stmt);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_all.phpt
@@ -0,0 +1,440 @@
+--TEST--
+mysqli_fetch_all()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_fetch_all'))
+	die("skip: function only available with mysqlnd");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_fetch_all()))
+			printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_all($link)))
+			printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 2")) {
+			printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[005]\n";
+	var_dump(mysqli_fetch_all($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 2")) {
+			printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[007]\n";
+	var_dump(mysqli_fetch_all($res, MYSQLI_NUM));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 2")) {
+			printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[008]\n";
+	var_dump(mysqli_fetch_all($res, MYSQLI_BOTH));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 2")) {
+			printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[010]\n";
+	var_dump(mysqli_fetch_all($res, MYSQLI_ASSOC));
+
+	print "[011]\n";
+	var_dump(mysqli_fetch_all($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 2")) {
+			printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[013]\n";
+	var_dump(mysqli_fetch_all($res, MYSQLI_ASSOC));
+
+	print "[016]\n";
+	var_dump(mysqli_fetch_all($res));
+
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e")) {
+			printf("[010] Cannot run query, [%d] %s\n", mysqli_errno($link), $mysqli_error($link));
+	}
+	print "[017]\n";
+	var_dump(mysqli_fetch_all($res, MYSQLI_BOTH));
+
+	mysqli_free_result($res);
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2 AS b, 3 AS c, 4 AS C")) {
+			printf("[018] Cannot run query, [%d] %s\n",
+					mysqli_errno($link), $mysqli_error($link));
+			exit(1);
+	}
+
+	do {
+			$illegal_mode = mt_rand(-10000, 10000);
+	} while (in_array($illegal_mode, array(MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH)));
+	// NOTE: for BC reasons with ext/mysql, ext/mysqli accepts invalid result modes.
+	$tmp = mysqli_fetch_all($res, $illegal_mode);
+	if (false !== $tmp)
+			printf("[019] Expecting boolean/false although, got %s/%s. [%d] %s\n",
+					gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	function func_mysqli_fetch_all($link, $engine, $sql_type, $sql_value, $php_value, $offset, $regexp_comparison = NULL) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+				printf("[%04d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+				return false;
+		}
+
+		if (!mysqli_query($link, $sql = sprintf("CREATE TABLE test(id INT NOT NULL, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+				// don't bail, engine might not support the datatype
+				return false;
+		}
+
+		if (is_null($php_value)) {
+			if (!mysqli_query($link, $sql = sprintf("INSERT INTO test(id, label) VALUES (1, NULL)"))) {
+				printf("[%04d] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+		} else {
+			if (is_string($sql_value)) {
+				if (!mysqli_query($link, $sql = "INSERT INTO test(id, label) VALUES (1, '" . $sql_value . "')")) {
+					printf("[%04ds] [%d] %s - %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link), $sql);
+					return false;
+				}
+			} else {
+				if (!mysqli_query($link, $sql = sprintf("INSERT INTO test(id, label) VALUES (1, '%d')", $sql_value))) {
+					printf("[%04di] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+					return false;
+				}
+			}
+		}
+
+		if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+				printf("[%04d] [%d] %s\n", $offset + 2, mysqli_errno($link), mysqli_error($link));
+				return false;
+		}
+
+		if (!$tmp = mysqli_fetch_all($res, MYSQLI_BOTH)) {
+				printf("[%04d] [%d] %s\n", $offset + 3, mysqli_errno($link), mysqli_error($link));
+				return false;
+		}
+		$row = $tmp[0];
+
+		$fields = mysqli_fetch_fields($res);
+
+		if (!(gettype($php_value)=="unicode" && ($fields[1]->flags & 128))) {
+
+		if ($regexp_comparison) {
+				if (!preg_match($regexp_comparison, (string)$row['label']) || !preg_match($regexp_comparison, (string)$row[1])) {
+						printf("[%04d] Expecting %s/%s [reg exp = %s], got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+							gettype($php_value), $php_value, $regexp_comparison,
+							gettype($row[1]), $row[1],
+							gettype($row['label']), $row['label'], mysqli_errno($link), mysqli_error($link));
+						return false;
+				}
+			} else {
+				if (($row['label'] !== $php_value) || ($row[1] != $php_value)) {
+						printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+							gettype($php_value), $php_value,
+							gettype($row[1]), $row[1],
+							gettype($row['label']), $row['label'], mysqli_errno($link), mysqli_error($link));
+						return false;
+				}
+			}
+		}
+
+		return true;
+	}
+
+	function func_mysqli_fetch_array_make_string($len) {
+
+			$ret = '';
+			for ($i = 0; $i < $len; $i++)
+					$ret .= chr(mt_rand(65, 90));
+
+			return $ret;
+	}
+
+	func_mysqli_fetch_all($link, $engine, "TINYINT", -11, "-11", 20);
+	func_mysqli_fetch_all($link, $engine, "TINYINT", NULL, NULL, 30);
+	func_mysqli_fetch_all($link, $engine, "TINYINT UNSIGNED", 1, "1", 40);
+	func_mysqli_fetch_all($link, $engine, "TINYINT UNSIGNED", NULL, NULL, 50);
+
+	func_mysqli_fetch_all($link, $engine, "BOOL", 1, "1", 60);
+	func_mysqli_fetch_all($link, $engine, "BOOL", NULL, NULL, 70);
+	func_mysqli_fetch_all($link, $engine, "BOOLEAN", 0, "0", 80);
+	func_mysqli_fetch_all($link, $engine, "BOOLEAN", NULL, NULL, 90);
+
+	func_mysqli_fetch_all($link, $engine, "SMALLINT", -32768, "-32768", 100);
+	func_mysqli_fetch_all($link, $engine, "SMALLINT", 32767, "32767", 110);
+	func_mysqli_fetch_all($link, $engine, "SMALLINT", NULL, NULL, 120);
+	func_mysqli_fetch_all($link, $engine, "SMALLINT UNSIGNED", 65535, "65535", 130);
+	func_mysqli_fetch_all($link, $engine, "SMALLINT UNSIGNED", NULL, NULL, 140);
+
+	func_mysqli_fetch_all($link, $engine, "MEDIUMINT", -8388608, "-8388608", 150);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMINT", 8388607, "8388607", 160);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMINT", NULL, NULL, 170);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMINT UNSIGNED", 16777215, "16777215", 180);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMINT UNSIGNED", NULL, NULL, 190);
+
+	func_mysqli_fetch_all($link, $engine, "INTEGER", -2147483648, "-2147483648", 200);
+	func_mysqli_fetch_all($link, $engine, "INTEGER", 2147483647, "2147483647", 210);
+	func_mysqli_fetch_all($link, $engine, "INTEGER", NULL, NULL, 220);
+	func_mysqli_fetch_all($link, $engine, "INTEGER UNSIGNED", "4294967295", "4294967295", 230);
+	func_mysqli_fetch_all($link, $engine, "INTEGER UNSIGNED", NULL, NULL, 240);
+
+	func_mysqli_fetch_all($link, $engine, "BIGINT", "-9223372036854775808", "-9223372036854775808", 250);
+
+	func_mysqli_fetch_all($link, $engine, "BIGINT", NULL, NULL, 260);
+	func_mysqli_fetch_all($link, $engine, "BIGINT UNSIGNED", "18446744073709551615", "18446744073709551615", 270);
+	func_mysqli_fetch_all($link, $engine, "BIGINT UNSIGNED", NULL, NULL, 280);
+
+	func_mysqli_fetch_all($link, $engine, "FLOAT", (string)(-9223372036854775808 - 1.1), "-9.22337e+18", 290, "/-9\.22337e\+?[0]?18/iu");
+	func_mysqli_fetch_all($link, $engine, "FLOAT", NULL, NULL, 300);
+	func_mysqli_fetch_all($link, $engine, "FLOAT UNSIGNED", (string)(18446744073709551615 + 1.1), "1.84467e+19", 310, "/1\.84467e\+?[0]?19/iu");
+	func_mysqli_fetch_all($link, $engine, "FLOAT UNSIGNED ", NULL, NULL, 320);
+
+	func_mysqli_fetch_all($link, $engine, "DOUBLE(10,2)", "-99999999.99", "-99999999.99", 330);
+	func_mysqli_fetch_all($link, $engine, "DOUBLE(10,2)", NULL, NULL, 340);
+	func_mysqli_fetch_all($link, $engine, "DOUBLE(10,2) UNSIGNED", "99999999.99", "99999999.99", 350);
+	func_mysqli_fetch_all($link, $engine, "DOUBLE(10,2) UNSIGNED", NULL, NULL, 360);
+
+	func_mysqli_fetch_all($link, $engine, "DECIMAL(10,2)", "-99999999.99", "-99999999.99", 370);
+	func_mysqli_fetch_all($link, $engine, "DECIMAL(10,2)", NULL, NULL, 380);
+	func_mysqli_fetch_all($link, $engine, "DECIMAL(10,2)", "99999999.99", "99999999.99", 390);
+	func_mysqli_fetch_all($link, $engine, "DECIMAL(10,2)", NULL, NULL, 400);
+
+	// don't care about date() strict TZ warnings...
+	func_mysqli_fetch_all($link, $engine, "DATE", @date('Y-m-d'), @date('Y-m-d'), 410);
+	func_mysqli_fetch_all($link, $engine, "DATE NOT NULL", @date('Y-m-d'), @date('Y-m-d'), 420);
+	func_mysqli_fetch_all($link, $engine, "DATE", NULL, NULL, 430);
+
+	func_mysqli_fetch_all($link, $engine, "DATETIME", @date('Y-m-d H:i:s'), @date('Y-m-d H:i:s'), 440);
+	func_mysqli_fetch_all($link, $engine, "DATETIME NOT NULL", @date('Y-m-d H:i:s'), @date('Y-m-d H:i:s'), 450);
+	func_mysqli_fetch_all($link, $engine, "DATETIME", NULL, NULL, 460);
+
+	func_mysqli_fetch_all($link, $engine, "TIMESTAMP", @date('Y-m-d H:i:s'), @date('Y-m-d H:i:s'), 470);
+
+	func_mysqli_fetch_all($link, $engine, "TIME", @date('H:i:s'), @date('H:i:s'), 480);
+	func_mysqli_fetch_all($link, $engine, "TIME NOT NULL", @date('H:i:s'), @date('H:i:s'), 490);
+	func_mysqli_fetch_all($link, $engine, "TIME", NULL, NULL, 500);
+
+	func_mysqli_fetch_all($link, $engine, "YEAR", @date('Y'), @date('Y'), 510);
+	func_mysqli_fetch_all($link, $engine, "YEAR NOT NULL", @date('Y'), @date('Y'), 520);
+	func_mysqli_fetch_all($link, $engine, "YEAR", NULL, NULL, 530);
+
+	$string255 = func_mysqli_fetch_array_make_string(255);
+	func_mysqli_fetch_all($link, $engine, "CHAR(1)", "a", "a", 540);
+	func_mysqli_fetch_all($link, $engine, "CHAR(255)", $string255,  $string255, 550);
+	func_mysqli_fetch_all($link, $engine, "CHAR(1) NOT NULL", "a", "a", 560);
+	func_mysqli_fetch_all($link, $engine, "CHAR(1)", NULL, NULL, 570);
+
+	$string65k = func_mysqli_fetch_array_make_string(65400);
+	func_mysqli_fetch_all($link, $engine, "VARCHAR(1)", "a", "a", 580);
+	func_mysqli_fetch_all($link, $engine, "VARCHAR(255)", $string255, $string255, 590);
+	func_mysqli_fetch_all($link, $engine, "VARCHAR(65400)", $string65k, $string65k, 600);
+	func_mysqli_fetch_all($link, $engine, "VARCHAR(1) NOT NULL", "a", "a", 610);
+	func_mysqli_fetch_all($link, $engine, "VARCHAR(1)", NULL, NULL, 620);
+
+	func_mysqli_fetch_all($link, $engine, "BINARY(1)", "a", "a", 630);
+	func_mysqli_fetch_all($link, $engine, "BINARY(2)", chr(0) . "a", chr(0) . "a", 640);
+	func_mysqli_fetch_all($link, $engine, "BINARY(1) NOT NULL", "b", "b", 650);
+	func_mysqli_fetch_all($link, $engine, "BINARY(1)", NULL, NULL, 660);
+
+	func_mysqli_fetch_all($link, $engine, "VARBINARY(1)", "a", "a", 670);
+	func_mysqli_fetch_all($link, $engine, "VARBINARY(2)", chr(0) . "a", chr(0) . "a", 680);
+	func_mysqli_fetch_all($link, $engine, "VARBINARY(1) NOT NULL", "b", "b", 690);
+	func_mysqli_fetch_all($link, $engine, "VARBINARY(1)", NULL, NULL, 700);
+
+	func_mysqli_fetch_all($link, $engine, "TINYBLOB", "a", "a", 710);
+	func_mysqli_fetch_all($link, $engine, "TINYBLOB", chr(0) . "a", chr(0) . "a", 720);
+	func_mysqli_fetch_all($link, $engine, "TINYBLOB NOT NULL", "b", "b", 730);
+	func_mysqli_fetch_all($link, $engine, "TINYBLOB", NULL, NULL, 740);
+
+	func_mysqli_fetch_all($link, $engine, "TINYTEXT", "a", "a", 750);
+	func_mysqli_fetch_all($link, $engine, "TINYTEXT NOT NULL", "a", "a", 760);
+	func_mysqli_fetch_all($link, $engine, "TINYTEXT", NULL, NULL, 770);
+
+	func_mysqli_fetch_all($link, $engine, "BLOB", "a", "a", 780);
+	func_mysqli_fetch_all($link, $engine, "BLOB", chr(0) . "a", chr(0) . "a", 780);
+	func_mysqli_fetch_all($link, $engine, "BLOB", NULL, NULL, 790);
+
+	func_mysqli_fetch_all($link, $engine, "TEXT", "a", "a", 800);
+	func_mysqli_fetch_all($link, $engine, "TEXT", chr(0) . "a", chr(0) . "a", 810);
+	func_mysqli_fetch_all($link, $engine, "TEXT", NULL, NULL, 820);
+
+	func_mysqli_fetch_all($link, $engine, "MEDIUMBLOB", "a", "a", 830);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMBLOB", chr(0) . "a", chr(0) . "a", 840);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMBLOB", NULL, NULL, 850);
+
+	func_mysqli_fetch_all($link, $engine, "MEDIUMTEXT", "a", "a", 860);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMTEXT", chr(0) . "a", chr(0) . "a", 870);
+	func_mysqli_fetch_all($link, $engine, "MEDIUMTEXT", NULL, NULL, 880);
+
+	func_mysqli_fetch_all($link, $engine, "LONGBLOB", "a", "a", 890);
+	func_mysqli_fetch_all($link, $engine, "LONGTEXT", chr(0) . "a", chr(0) . "a", 900);
+	func_mysqli_fetch_all($link, $engine, "LONGBLOB", NULL, NULL, 910);
+
+	func_mysqli_fetch_all($link, $engine, "ENUM('a', 'b')", "a", "a", 920);
+	func_mysqli_fetch_all($link, $engine, "ENUM('a', 'b')", NULL, NULL, 930);
+
+	func_mysqli_fetch_all($link, $engine, "SET('a', 'b')", "a", "a", 940);
+	func_mysqli_fetch_all($link, $engine, "SET('a', 'b')", NULL, NULL, 950);
+
+	mysqli_close($link);
+
+	if (null !== ($tmp = mysqli_fetch_array($res, MYSQLI_ASSOC)))
+			printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	// require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(2) {
+  [0]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "b"
+  }
+}
+[007]
+array(2) {
+  [0]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "b"
+  }
+}
+[008]
+array(2) {
+  [0]=>
+  array(4) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "a"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(4) {
+    [0]=>
+    %unicode|string%(1) "2"
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "b"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+}
+[010]
+array(2) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+}
+[011]
+array(0) {
+}
+[013]
+array(2) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+}
+[016]
+array(0) {
+}
+[017]
+array(1) {
+  [0]=>
+  array(11) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"a"]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "2"
+    [2]=>
+    %unicode|string%(1) "3"
+    [%u|b%"c"]=>
+    %unicode|string%(1) "3"
+    [3]=>
+    %unicode|string%(1) "4"
+    [%u|b%"C"]=>
+    %unicode|string%(1) "4"
+    [4]=>
+    NULL
+    [%u|b%"d"]=>
+    NULL
+    [5]=>
+    %unicode|string%(1) "1"
+    [%u|b%"e"]=>
+    %unicode|string%(1) "1"
+  }
+}
+
+Warning: mysqli_fetch_all(): Mode can be only MYSQLI_FETCH_NUM, MYSQLI_FETCH_ASSOC or MYSQLI_FETCH_BOTH in %s on line %d
+
+Warning: mysqli_fetch_array(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_all_oo.phpt
@@ -0,0 +1,440 @@
+--TEST--
+$mysqli->fetch_all() (introduced with mysqlnd)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_fetch_all'))
+	die("skip: function only available with mysqlnd");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$mysqli = new mysqli();
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	require('table.inc');
+	if (!$res = $mysqli->query("SELECT * FROM test ORDER BY id LIMIT 2")) {
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[005]\n";
+	var_dump($res->fetch_all());
+	$res->free_result();
+
+	if (!$res = $mysqli->query("SELECT * FROM test ORDER BY id LIMIT 2")) {
+		printf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[007]\n";
+	var_dump($res->fetch_all(MYSQLI_NUM));
+	$res->free_result();
+
+	if (!$res = $mysqli->query("SELECT * FROM test ORDER BY id LIMIT 2")) {
+		printf("[008] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[008]\n";
+	var_dump($res->fetch_all(MYSQLI_BOTH));
+	$res->free_result();
+
+	if (!$res = $mysqli->query("SELECT * FROM test ORDER BY id LIMIT 2")) {
+		printf("[009] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[010]\n";
+	var_dump($res->fetch_all(MYSQLI_ASSOC));
+
+	print "[011]\n";
+	var_dump($res->fetch_array());
+	$res->free_result();
+
+	if (!$res = $mysqli->query("SELECT * FROM test ORDER BY id LIMIT 2")) {
+		printf("[012] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[013]\n";
+	var_dump($res->fetch_all(MYSQLI_ASSOC));
+
+	print "[016]\n";
+	var_dump($res->fetch_array());
+
+	if (!$res = $mysqli->query("SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e")) {
+		printf("[010] Cannot run query, [%d] %s\n", $mysqli->errno, $$mysqli->error);
+	}
+	print "[017]\n";
+	var_dump($res->fetch_all(MYSQLI_BOTH));
+
+	$res->free_result();
+	if (!$res = $mysqli->query("SELECT 1 AS a, 2 AS b, 3 AS c, 4 AS C")) {
+		printf("[018] Cannot run query, [%d] %s\n",
+			$mysqli->errno, $$mysqli->error);
+		exit(1);
+	}
+
+	do {
+		$illegal_mode = mt_rand(-10000, 10000);
+	} while (in_array($illegal_mode, array(MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH)));
+	// NOTE: for BC reasons with ext/mysql, ext/mysqli accepts invalid result modes.
+	$tmp = $res->fetch_all($illegal_mode);
+	if (false !== $tmp)
+		printf("[019] Expecting boolean/false although, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, $mysqli->errno, $mysqli->error);
+
+	$res->free_result();
+
+	function func_mysqli_fetch_all_oo($link, $engine, $sql_type, $sql_value, $php_value, $offset, $regexp_comparison = NULL) {
+
+		if (!$link->query("DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, $link->errno, $link->error);
+			return false;
+		}
+
+		if (!$link->query($sql = sprintf("CREATE TABLE test(id INT NOT NULL, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+				// don't bail, engine might not support the datatype
+				return false;
+		}
+
+		if (is_null($php_value)) {
+			if (!$link->query($sql = sprintf("INSERT INTO test(id, label) VALUES (1, NULL)"))) {
+				printf("[%04d] [%d] %s\n", $offset + 1, $link->errno, $link->error);
+				return false;
+			}
+		} else {
+			if (is_string($sql_value)) {
+				if (!$link->query($sql = "INSERT INTO test(id, label) VALUES (1, '" . $sql_value . "')")) {
+					printf("[%04ds] [%d] %s - %s\n", $offset + 1, $link->errno, $link->error, $sql);
+					return false;
+				}
+			} else {
+				if (!$link->query($sql = sprintf("INSERT INTO test(id, label) VALUES (1, '%d')", $sql_value))) {
+					printf("[%04di] [%d] %s\n", $offset + 1, $link->errno, $link->error);
+					return false;
+				}
+			}
+		}
+
+		if (!$res = $link->query("SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 2, $link->errno, $link->error);
+			return false;
+		}
+
+		if (!$tmp = $res->fetch_all(MYSQLI_BOTH)) {
+			printf("[%04d] [%d] %s\n", $offset + 3, $link->errno, $link->error);
+			return false;
+		}
+		$row = $tmp[0];
+
+		$fields = mysqli_fetch_fields($res);
+
+		if (!(gettype($php_value)=="unicode" && ($fields[1]->flags & 128))) {
+			if ($regexp_comparison) {
+				if (!preg_match($regexp_comparison, (string)$row['label']) || !preg_match($regexp_comparison, (string)$row[1])) {
+					printf("[%04d] Expecting %s/%s [reg exp = %s], got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+						gettype($php_value), $php_value, $regexp_comparison,
+						gettype($row[1]), $row[1],
+						gettype($row['label']), $row['label'], $link->errno, $link->error);
+					return false;
+				}
+			} else {
+				if (($row['label'] !== $php_value) || ($row[1] != $php_value)) {
+					printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+						gettype($php_value), $php_value,
+						gettype($row[1]), $row[1],
+						gettype($row['label']), $row['label'], $link->errno, $link->error);
+					return false;
+				}
+			}
+		}
+
+		return true;
+	}
+
+	function func_mysqli_fetch_array_oo_make_string($len) {
+
+		$ret = '';
+		for ($i = 0; $i < $len; $i++)
+			$ret .= chr(mt_rand(65, 90));
+
+		return $ret;
+	}
+
+	func_mysqli_fetch_all_oo($link, $engine, "TINYINT", -11, "-11", 20);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYINT", NULL, NULL, 30);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYINT UNSIGNED", 1, "1", 40);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYINT UNSIGNED", NULL, NULL, 50);
+
+	func_mysqli_fetch_all_oo($link, $engine, "BOOL", 1, "1", 60);
+	func_mysqli_fetch_all_oo($link, $engine, "BOOL", NULL, NULL, 70);
+	func_mysqli_fetch_all_oo($link, $engine, "BOOLEAN", 0, "0", 80);
+	func_mysqli_fetch_all_oo($link, $engine, "BOOLEAN", NULL, NULL, 90);
+
+	func_mysqli_fetch_all_oo($link, $engine, "SMALLINT", -32768, "-32768", 100);
+	func_mysqli_fetch_all_oo($link, $engine, "SMALLINT", 32767, "32767", 110);
+	func_mysqli_fetch_all_oo($link, $engine, "SMALLINT", NULL, NULL, 120);
+	func_mysqli_fetch_all_oo($link, $engine, "SMALLINT UNSIGNED", 65400, "65400", 130);
+	func_mysqli_fetch_all_oo($link, $engine, "SMALLINT UNSIGNED", NULL, NULL, 140);
+
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMINT", -8388608, "-8388608", 150);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMINT", 8388607, "8388607", 160);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMINT", NULL, NULL, 170);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMINT UNSIGNED", 16777215, "16777215", 180);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMINT UNSIGNED", NULL, NULL, 190);
+
+	func_mysqli_fetch_all_oo($link, $engine, "INTEGER", -2147483648, "-2147483648", 200);
+	func_mysqli_fetch_all_oo($link, $engine, "INTEGER", 2147483647, "2147483647", 210);
+	func_mysqli_fetch_all_oo($link, $engine, "INTEGER", NULL, NULL, 220);
+	func_mysqli_fetch_all_oo($link, $engine, "INTEGER UNSIGNED", "4294967295", "4294967295", 230);
+	func_mysqli_fetch_all_oo($link, $engine, "INTEGER UNSIGNED", NULL, NULL, 240);
+
+	func_mysqli_fetch_all_oo($link, $engine, "BIGINT", "-9223372036854775808", "-9223372036854775808", 250);
+	func_mysqli_fetch_all_oo($link, $engine, "BIGINT", NULL, NULL, 260);
+	func_mysqli_fetch_all_oo($link, $engine, "BIGINT UNSIGNED", "18446744073709551615", "18446744073709551615", 270);
+	func_mysqli_fetch_all_oo($link, $engine, "BIGINT UNSIGNED", NULL, NULL, 280);
+
+	func_mysqli_fetch_all_oo($link, $engine, "FLOAT", (string)(-9223372036854775808 - 1.1), "-9.22337e+18", 290, "/-9\.22337e\+?[0]?18/iu");
+	func_mysqli_fetch_all_oo($link, $engine, "FLOAT", NULL, NULL, 300);
+	func_mysqli_fetch_all_oo($link, $engine, "FLOAT UNSIGNED", (string)(18446744073709551615 + 1.1), "1.84467e+?19", 310, "/1\.84467e\+?[0]?19/iu");
+	func_mysqli_fetch_all_oo($link, $engine, "FLOAT UNSIGNED ", NULL, NULL, 320);
+
+	func_mysqli_fetch_all_oo($link, $engine, "DOUBLE(10,2)", "-99999999.99", "-99999999.99", 330);
+	func_mysqli_fetch_all_oo($link, $engine, "DOUBLE(10,2)", NULL, NULL, 340);
+	func_mysqli_fetch_all_oo($link, $engine, "DOUBLE(10,2) UNSIGNED", "99999999.99", "99999999.99", 350);
+	func_mysqli_fetch_all_oo($link, $engine, "DOUBLE(10,2) UNSIGNED", NULL, NULL, 360);
+
+	func_mysqli_fetch_all_oo($link, $engine, "DECIMAL(10,2)", "-99999999.99", "-99999999.99", 370);
+	func_mysqli_fetch_all_oo($link, $engine, "DECIMAL(10,2)", NULL, NULL, 380);
+	func_mysqli_fetch_all_oo($link, $engine, "DECIMAL(10,2)", "99999999.99", "99999999.99", 390);
+	func_mysqli_fetch_all_oo($link, $engine, "DECIMAL(10,2)", NULL, NULL, 400);
+
+	// don't care about date() strict TZ warnings...
+	$date = @date('Y-m-d');
+	func_mysqli_fetch_all_oo($link, $engine, "DATE", $date, $date, 410);
+	func_mysqli_fetch_all_oo($link, $engine, "DATE NOT NULL", $date, $date, 420);
+	func_mysqli_fetch_all_oo($link, $engine, "DATE", NULL, NULL, 430);
+
+	$datetime = @date('Y-m-d H:i:s');
+	func_mysqli_fetch_all_oo($link, $engine, "DATETIME", $datetime, $datetime, 440);
+	func_mysqli_fetch_all_oo($link, $engine, "DATETIME NOT NULL", $datetime, $datetime, 450);
+	func_mysqli_fetch_all_oo($link, $engine, "DATETIME", NULL, NULL, 460);
+
+	func_mysqli_fetch_all_oo($link, $engine, "TIMESTAMP", $datetime, $datetime, 470);
+
+	$time = @date('H:i:s');
+	func_mysqli_fetch_all_oo($link, $engine, "TIME", $time, $time, 480);
+	func_mysqli_fetch_all_oo($link, $engine, "TIME NOT NULL", $time, $time, 490);
+	func_mysqli_fetch_all_oo($link, $engine, "TIME", NULL, NULL, 500);
+
+	func_mysqli_fetch_all_oo($link, $engine, "YEAR", @date('Y'), @date('Y'), 510);
+	func_mysqli_fetch_all_oo($link, $engine, "YEAR NOT NULL", @date('Y'), @date('Y'), 520);
+	func_mysqli_fetch_all_oo($link, $engine, "YEAR", NULL, NULL, 530);
+
+	$string255 = func_mysqli_fetch_array_oo_make_string(255);
+	func_mysqli_fetch_all_oo($link, $engine, "CHAR(1)", "a", "a", 540);
+	func_mysqli_fetch_all_oo($link, $engine, "CHAR(255)", $string255,  $string255, 550);
+	func_mysqli_fetch_all_oo($link, $engine, "CHAR(1) NOT NULL", "a", "a", 560);
+	func_mysqli_fetch_all_oo($link, $engine, "CHAR(1)", NULL, NULL, 570);
+
+	$string65k = func_mysqli_fetch_array_oo_make_string(65400);
+	func_mysqli_fetch_all_oo($link, $engine, "VARCHAR(1)", "a", "a", 580);
+	func_mysqli_fetch_all_oo($link, $engine, "VARCHAR(255)", $string255, $string255, 590);
+	func_mysqli_fetch_all_oo($link, $engine, "VARCHAR(65400)", $string65k, $string65k, 600);
+	func_mysqli_fetch_all_oo($link, $engine, "VARCHAR(1) NOT NULL", "a", "a", 610);
+	func_mysqli_fetch_all_oo($link, $engine, "VARCHAR(1)", NULL, NULL, 620);
+
+	func_mysqli_fetch_all_oo($link, $engine, "BINARY(1)", "a", "a", 630);
+	func_mysqli_fetch_all_oo($link, $engine, "BINARY(2)", chr(0) . "a", chr(0) . "a", 640);
+	func_mysqli_fetch_all_oo($link, $engine, "BINARY(1) NOT NULL", "b", "b", 650);
+	func_mysqli_fetch_all_oo($link, $engine, "BINARY(1)", NULL, NULL, 660);
+
+	func_mysqli_fetch_all_oo($link, $engine, "VARBINARY(1)", "a", "a", 670);
+	func_mysqli_fetch_all_oo($link, $engine, "VARBINARY(2)", chr(0) . "a", chr(0) . "a", 680);
+	func_mysqli_fetch_all_oo($link, $engine, "VARBINARY(1) NOT NULL", "b", "b", 690);
+	func_mysqli_fetch_all_oo($link, $engine, "VARBINARY(1)", NULL, NULL, 700);
+
+	func_mysqli_fetch_all_oo($link, $engine, "TINYBLOB", "a", "a", 710);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYBLOB", chr(0) . "a", chr(0) . "a", 720);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYBLOB NOT NULL", "b", "b", 730);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYBLOB", NULL, NULL, 740);
+
+	func_mysqli_fetch_all_oo($link, $engine, "TINYTEXT", "a", "a", 750);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYTEXT NOT NULL", "a", "a", 760);
+	func_mysqli_fetch_all_oo($link, $engine, "TINYTEXT", NULL, NULL, 770);
+
+	func_mysqli_fetch_all_oo($link, $engine, "BLOB", "a", "a", 780);
+	func_mysqli_fetch_all_oo($link, $engine, "BLOB", chr(0) . "a", chr(0) . "a", 780);
+	func_mysqli_fetch_all_oo($link, $engine, "BLOB", NULL, NULL, 790);
+
+	func_mysqli_fetch_all_oo($link, $engine, "TEXT", "a", "a", 800);
+	func_mysqli_fetch_all_oo($link, $engine, "TEXT", chr(0) . "a", chr(0) . "a", 810);
+	func_mysqli_fetch_all_oo($link, $engine, "TEXT", NULL, NULL, 820);
+
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMBLOB", "a", "a", 830);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMBLOB", chr(0) . "a", chr(0) . "a", 840);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMBLOB", NULL, NULL, 850);
+
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMTEXT", "a", "a", 860);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMTEXT", chr(0) . "a", chr(0) . "a", 870);
+	func_mysqli_fetch_all_oo($link, $engine, "MEDIUMTEXT", NULL, NULL, 880);
+
+	func_mysqli_fetch_all_oo($link, $engine, "LONGBLOB", "a", "a", 890);
+	func_mysqli_fetch_all_oo($link, $engine, "LONGTEXT", chr(0) . "a", chr(0) . "a", 900);
+	func_mysqli_fetch_all_oo($link, $engine, "LONGBLOB", NULL, NULL, 910);
+
+	func_mysqli_fetch_all_oo($link, $engine, "ENUM('a', 'b')", "a", "a", 920);
+	func_mysqli_fetch_all_oo($link, $engine, "ENUM('a', 'b')", NULL, NULL, 930);
+
+	func_mysqli_fetch_all_oo($link, $engine, "SET('a', 'b')", "a", "a", 940);
+	func_mysqli_fetch_all_oo($link, $engine, "SET('a', 'b')", NULL, NULL, 950);
+
+	mysqli_close($link);
+
+	if (null !== ($tmp = $res->fetch_array(MYSQLI_ASSOC)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(2) {
+  [0]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "b"
+  }
+}
+[007]
+array(2) {
+  [0]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [0]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "b"
+  }
+}
+[008]
+array(2) {
+  [0]=>
+  array(4) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "a"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(4) {
+    [0]=>
+    %unicode|string%(1) "2"
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "b"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+}
+[010]
+array(2) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+}
+[011]
+NULL
+[013]
+array(2) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+}
+[016]
+NULL
+[017]
+array(1) {
+  [0]=>
+  array(11) {
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"a"]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "2"
+    [2]=>
+    %unicode|string%(1) "3"
+    [%u|b%"c"]=>
+    %unicode|string%(1) "3"
+    [3]=>
+    %unicode|string%(1) "4"
+    [%u|b%"C"]=>
+    %unicode|string%(1) "4"
+    [4]=>
+    NULL
+    [%u|b%"d"]=>
+    NULL
+    [5]=>
+    %unicode|string%(1) "1"
+    [%u|b%"e"]=>
+    %unicode|string%(1) "1"
+  }
+}
+
+Warning: mysqli_result::fetch_all(): Mode can be only MYSQLI_FETCH_NUM, MYSQLI_FETCH_ASSOC or MYSQLI_FETCH_BOTH in %s on line %d
+
+Warning: mysqli_result::fetch_array(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_array.phpt
@@ -0,0 +1,374 @@
+--TEST--
+mysqli_fetch_array() - all datatypes but BIT
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_fetch_array()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_array($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 5")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[005]\n";
+	var_dump(mysqli_fetch_array($res));
+
+	print "[006]\n";
+	var_dump(mysqli_fetch_array($res, MYSQLI_NUM));
+
+	print "[007]\n";
+	var_dump(mysqli_fetch_array($res, MYSQLI_BOTH));
+
+	print "[008]\n";
+	var_dump(mysqli_fetch_array($res, MYSQLI_ASSOC));
+
+	print "[009]\n";
+	var_dump(mysqli_fetch_array($res));
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e")) {
+		printf("[010] Cannot run query, [%d] %s\n", mysqli_errno($link), $mysqli_error($link));
+	}
+	print "[011]\n";
+	var_dump(mysqli_fetch_array($res, MYSQLI_BOTH));
+
+	mysqli_free_result($res);
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2 AS b, 3 AS c, 4 AS C")) {
+		printf("[012] Cannot run query, [%d] %s\n",
+			mysqli_errno($link), $mysqli_error($link));
+		exit(1);
+	}
+
+	do {
+		$illegal_mode = mt_rand(-10000, 10000);
+	} while (in_array($illegal_mode, array(MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH)));
+	// NOTE: for BC reasons with ext/mysql, ext/mysqli accepts invalid result modes.
+	$tmp = mysqli_fetch_array($res, $illegal_mode);
+	if (false !== $tmp)
+			printf("[013] Expecting boolean/false although, got %s/%s. [%d] %s\n",
+				gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	$tmp = mysqli_fetch_array($res, $illegal_mode);
+	if (false !== $tmp)
+		printf("[014] Expecting boolean/false, got %s/%s. [%d] %s\n",
+				gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	function func_mysqli_fetch_array($link, $engine, $sql_type, $sql_value, $php_value, $offset, $regexp_comparison = NULL, $binary_type = false) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_query($link, $sql = sprintf("CREATE TABLE test(id INT NOT NULL, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+				// don't bail, engine might not support the datatype
+				return false;
+		}
+
+		if (is_null($php_value)) {
+			if (!mysqli_query($link, $sql = sprintf("INSERT INTO test(id, label) VALUES (1, NULL)"))) {
+				printf("[%04d] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+		} else {
+			if (is_string($sql_value)) {
+				if (!mysqli_query($link, $sql = "INSERT INTO test(id, label) VALUES (1, '" . $sql_value . "')")) {
+					printf("[%04ds] [%d] %s - %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link), $sql);
+					return false;
+				}
+			} else {
+				if (!mysqli_query($link, $sql = sprintf("INSERT INTO test(id, label) VALUES (1, '%d')", $sql_value))) {
+					printf("[%04di] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+					return false;
+				}
+			}
+		}
+		if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 2, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!$row = mysqli_fetch_array($res, MYSQLI_BOTH)) {
+			printf("[%04d] [%d] %s\n", $offset + 3, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if ($regexp_comparison) {
+			if (!preg_match($regexp_comparison, (string)$row['label']) || !preg_match($regexp_comparison, (string)$row[1])) {
+				printf("[%04d] Expecting %s/%s [reg exp = %s], got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+					gettype($php_value), $php_value, $regexp_comparison,
+					gettype($row[1]), $row[1],
+					gettype($row['label']), $row['label'], mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+		} else if ((gettype($php_value) == 'unicode') && $binary_type) {
+			// Unicode is on and we are told that the MySQL column type is a binary type.
+			// Don't expect a unicode value from the database, you'll get binary string
+			if (($row['label'] != $php_value) || ($row[1] != $php_value)) {
+				printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 5,
+					gettype($php_value), $php_value,
+					gettype($row[1]), $row[1],
+					gettype($row['label']), $row['label'], mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+			if (gettype($row['label']) == 'unicode') {
+				var_dump(mysqli_fetch_field_direct($res, 1), $row['label']);
+				printf("[%04d] SQL Type: '%s', binary columns are supposed to return binary string and not unicode\n",
+					$offset + 6, $sql_type);
+				return false;
+			}
+		} else {
+			if (($row['label'] !== $php_value) || ($row[1] != $php_value)) {
+				printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 7,
+					gettype($php_value), $php_value,
+					gettype($row[1]), $row[1],
+					gettype($row['label']), $row['label'], mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+		}
+		return true;
+	}
+
+	function func_mysqli_fetch_array_make_string($len) {
+
+		$ret = '';
+		for ($i = 0; $i < $len; $i++)
+				$ret .= chr(mt_rand(65, 90));
+
+		return $ret;
+	}
+
+	func_mysqli_fetch_array($link, $engine, "TINYINT", -11, "-11", 20);
+	func_mysqli_fetch_array($link, $engine, "TINYINT", NULL, NULL, 30);
+	func_mysqli_fetch_array($link, $engine, "TINYINT UNSIGNED", 1, "1", 40);
+	func_mysqli_fetch_array($link, $engine, "TINYINT UNSIGNED", NULL, NULL, 50);
+
+	func_mysqli_fetch_array($link, $engine, "BOOL", 1, "1", 60);
+	func_mysqli_fetch_array($link, $engine, "BOOL", NULL, NULL, 70);
+	func_mysqli_fetch_array($link, $engine, "BOOLEAN", 0, "0", 80);
+	func_mysqli_fetch_array($link, $engine, "BOOLEAN", NULL, NULL, 90);
+
+	func_mysqli_fetch_array($link, $engine, "SMALLINT", -32768, "-32768", 100);
+	func_mysqli_fetch_array($link, $engine, "SMALLINT", 32767, "32767", 110);
+	func_mysqli_fetch_array($link, $engine, "SMALLINT", NULL, NULL, 120);
+	func_mysqli_fetch_array($link, $engine, "SMALLINT UNSIGNED", 65535, "65535", 130);
+	func_mysqli_fetch_array($link, $engine, "SMALLINT UNSIGNED", NULL, NULL, 140);
+
+	func_mysqli_fetch_array($link, $engine, "MEDIUMINT", -8388608, "-8388608", 150);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMINT", 8388607, "8388607", 160);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMINT", NULL, NULL, 170);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMINT UNSIGNED", 16777215, "16777215", 180);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMINT UNSIGNED", NULL, NULL, 190);
+
+	func_mysqli_fetch_array($link, $engine, "INTEGER", -2147483648, "-2147483648", 200);
+	func_mysqli_fetch_array($link, $engine, "INTEGER", 2147483647, "2147483647", 210);
+	func_mysqli_fetch_array($link, $engine, "INTEGER", NULL, NULL, 220);
+	func_mysqli_fetch_array($link, $engine, "INTEGER UNSIGNED", "4294967295", "4294967295", 230);
+	func_mysqli_fetch_array($link, $engine, "INTEGER UNSIGNED", NULL, NULL, 240);
+
+	if ($IS_MYSQLND ||
+		((mysqli_get_server_version($link) >= 51000) &&
+		(mysqli_get_client_version($link) >= 51000))) {
+		func_mysqli_fetch_array($link, $engine, "BIGINT", "-9223372036854775808", "-9223372036854775808", 250);
+		func_mysqli_fetch_array($link, $engine, "BIGINT", NULL, NULL, 260);
+		func_mysqli_fetch_array($link, $engine, "BIGINT UNSIGNED", "18446744073709551615", "18446744073709551615", 260);
+		func_mysqli_fetch_array($link, $engine, "BIGINT UNSIGNED", NULL, NULL, 280);
+	}
+
+	func_mysqli_fetch_array($link, $engine, "FLOAT", (string)(-9223372036854775808 - 1.1), "-9.22337e+18", 290, "/-9\.22337e\+?[0]?18/iu");
+	func_mysqli_fetch_array($link, $engine, "FLOAT", NULL, NULL, 300);
+	func_mysqli_fetch_array($link, $engine, "FLOAT UNSIGNED", (string)(18446744073709551615 + 1.1), "1.84467e+?19", 310, "/1\.84467e\+?[0]?19/iu");
+	func_mysqli_fetch_array($link, $engine, "FLOAT UNSIGNED ", NULL, NULL, 320);
+
+	func_mysqli_fetch_array($link, $engine, "DOUBLE(10,2)", "-99999999.99", "-99999999.99", 330);
+	func_mysqli_fetch_array($link, $engine, "DOUBLE(10,2)", NULL, NULL, 340);
+	func_mysqli_fetch_array($link, $engine, "DOUBLE(10,2) UNSIGNED", "99999999.99", "99999999.99", 350);
+	func_mysqli_fetch_array($link, $engine, "DOUBLE(10,2) UNSIGNED", NULL, NULL, 360);
+
+	func_mysqli_fetch_array($link, $engine, "DECIMAL(10,2)", "-99999999.99", "-99999999.99", 370);
+	func_mysqli_fetch_array($link, $engine, "DECIMAL(10,2)", NULL, NULL, 380);
+	func_mysqli_fetch_array($link, $engine, "DECIMAL(10,2)", "99999999.99", "99999999.99", 390);
+	func_mysqli_fetch_array($link, $engine, "DECIMAL(10,2)", NULL, NULL, 400);
+
+		// don't care about date() strict TZ warnings...
+	$date = @date('Y-m-d');
+	func_mysqli_fetch_array($link, $engine, "DATE",$date, $date, 410);
+	func_mysqli_fetch_array($link, $engine, "DATE NOT NULL",$date, $date, 420);
+	func_mysqli_fetch_array($link, $engine, "DATE", NULL, NULL, 430);
+
+	$date = @date('Y-m-d H:i:s');
+	func_mysqli_fetch_array($link, $engine, "DATETIME", $date, $date, 440);
+	func_mysqli_fetch_array($link, $engine, "DATETIME NOT NULL", $date, $date, 450);
+	func_mysqli_fetch_array($link, $engine, "DATETIME", NULL, NULL, 460);
+	func_mysqli_fetch_array($link, $engine, "TIMESTAMP", $date, $date, 470);
+
+	$date = @date('H:i:s');
+	func_mysqli_fetch_array($link, $engine, "TIME", $date, $date, 480);
+	func_mysqli_fetch_array($link, $engine, "TIME NOT NULL", $date, $date, 490);
+	func_mysqli_fetch_array($link, $engine, "TIME", NULL, NULL, 500);
+
+	func_mysqli_fetch_array($link, $engine, "YEAR", @date('Y'), @date('Y'), 510);
+	func_mysqli_fetch_array($link, $engine, "YEAR NOT NULL", @date('Y'), @date('Y'), 520);
+	func_mysqli_fetch_array($link, $engine, "YEAR", NULL, NULL, 530);
+
+	$string255 = func_mysqli_fetch_array_make_string(255);
+	func_mysqli_fetch_array($link, $engine, "CHAR(1)", "a", "a", 540);
+	func_mysqli_fetch_array($link, $engine, "CHAR(255)", $string255,  $string255, 550);
+	func_mysqli_fetch_array($link, $engine, "CHAR(1) NOT NULL", "a", "a", 560);
+	func_mysqli_fetch_array($link, $engine, "CHAR(1)", NULL, NULL, 570);
+
+	$string65k = func_mysqli_fetch_array_make_string(65400);
+	func_mysqli_fetch_array($link, $engine, "VARCHAR(1)", "a", "a", 580);
+	func_mysqli_fetch_array($link, $engine, "VARCHAR(255)", $string255, $string255, 590);
+	func_mysqli_fetch_array($link, $engine, "VARCHAR(65400)", $string65k, $string65k, 600);
+	func_mysqli_fetch_array($link, $engine, "VARCHAR(1) NOT NULL", "a", "a", 610);
+	func_mysqli_fetch_array($link, $engine, "VARCHAR(1)", NULL, NULL, 620);
+
+	func_mysqli_fetch_array($link, $engine, "BINARY(1)", "a", "a", 630, null, true);
+	func_mysqli_fetch_array($link, $engine, "BINARY(2)", chr(0) . "a", chr(0) . "a", 640, null, true);
+	func_mysqli_fetch_array($link, $engine, "BINARY(1) NOT NULL", "b", "b", 650, null, true);
+	func_mysqli_fetch_array($link, $engine, "BINARY(1)", NULL, NULL, 660, null, true);
+
+	func_mysqli_fetch_array($link, $engine, "VARBINARY(1)", "a", "a", 670, null, true);
+	func_mysqli_fetch_array($link, $engine, "VARBINARY(2)", chr(0) . "a", chr(0) . "a", 680, null, true);
+	func_mysqli_fetch_array($link, $engine, "VARBINARY(1) NOT NULL", "b", "b", 690, null, true);
+	func_mysqli_fetch_array($link, $engine, "VARBINARY(1)", NULL, NULL, 700, null, true);
+
+	func_mysqli_fetch_array($link, $engine, "TINYBLOB", "a", "a", 710, null, true);
+	func_mysqli_fetch_array($link, $engine, "TINYBLOB", chr(0) . "a", chr(0) . "a", 720, null, true);
+	func_mysqli_fetch_array($link, $engine, "TINYBLOB NOT NULL", "b", "b", 730, null, true);
+	func_mysqli_fetch_array($link, $engine, "TINYBLOB", NULL, NULL, 740, null, true);
+
+	func_mysqli_fetch_array($link, $engine, "TINYTEXT", "a", "a", 750);
+	func_mysqli_fetch_array($link, $engine, "TINYTEXT NOT NULL", "a", "a", 760);
+	func_mysqli_fetch_array($link, $engine, "TINYTEXT", NULL, NULL, 770);
+
+	func_mysqli_fetch_array($link, $engine, "BLOB", "a", "a", 780, null, true);
+	func_mysqli_fetch_array($link, $engine, "BLOB", chr(0) . "a", chr(0) . "a", 780, null, true);
+	func_mysqli_fetch_array($link, $engine, "BLOB", NULL, NULL, 790, null, true);
+
+	func_mysqli_fetch_array($link, $engine, "TEXT", "a", "a", 800);
+	func_mysqli_fetch_array($link, $engine, "TEXT", chr(0) . "a", chr(0) . "a", 810);
+	func_mysqli_fetch_array($link, $engine, "TEXT", NULL, NULL, 820);
+
+	func_mysqli_fetch_array($link, $engine, "MEDIUMBLOB", "a", "a", 830, null, true);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMBLOB", chr(0) . "a", chr(0) . "a", 840, null, true);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMBLOB", NULL, NULL, 850, null, true);
+
+	func_mysqli_fetch_array($link, $engine, "MEDIUMTEXT", "a", "a", 860);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMTEXT", chr(0) . "a", chr(0) . "a", 870);
+	func_mysqli_fetch_array($link, $engine, "MEDIUMTEXT", NULL, NULL, 880);
+
+	func_mysqli_fetch_array($link, $engine, "LONGBLOB", "a", "a", 890, null, true);
+	func_mysqli_fetch_array($link, $engine, "LONGTEXT", chr(0) . "a", chr(0) . "a", 900);
+	func_mysqli_fetch_array($link, $engine, "LONGBLOB", NULL, NULL, 910, null, true);
+
+	func_mysqli_fetch_array($link, $engine, "ENUM('a', 'b')", "a", "a", 920);
+	func_mysqli_fetch_array($link, $engine, "ENUM('a', 'b')", NULL, NULL, 930);
+
+	func_mysqli_fetch_array($link, $engine, "SET('a', 'b')", "a", "a", 940);
+	func_mysqli_fetch_array($link, $engine, "SET('a', 'b')", NULL, NULL, 950);
+
+	mysqli_close($link);
+
+	if (null !== ($tmp = mysqli_fetch_array($res, MYSQLI_ASSOC)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+[005]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "a"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[006]
+array(2) {
+  [0]=>
+  %unicode|string%(1) "2"
+  [1]=>
+  %unicode|string%(1) "b"
+}
+[007]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "3"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "3"
+  [1]=>
+  %unicode|string%(1) "c"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "c"
+}
+[008]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "d"
+}
+[009]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "5"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "5"
+  [1]=>
+  %unicode|string%(1) "e"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "e"
+}
+[011]
+array(11) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [%u|b%"a"]=>
+  %unicode|string%(1) "2"
+  [1]=>
+  %unicode|string%(1) "2"
+  [2]=>
+  %unicode|string%(1) "3"
+  [%u|b%"c"]=>
+  %unicode|string%(1) "3"
+  [3]=>
+  %unicode|string%(1) "4"
+  [%u|b%"C"]=>
+  %unicode|string%(1) "4"
+  [4]=>
+  NULL
+  [%u|b%"d"]=>
+  NULL
+  [5]=>
+  %unicode|string%(1) "1"
+  [%u|b%"e"]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysqli_fetch_array(): The result type should be either MYSQLI_NUM, MYSQLI_ASSOC or MYSQLI_BOTH in %s on line %d
+
+Warning: mysqli_fetch_array(): The result type should be either MYSQLI_NUM, MYSQLI_ASSOC or MYSQLI_BOTH in %s on line %d
+
+Warning: mysqli_fetch_array(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_array_assoc.phpt
@@ -0,0 +1,49 @@
+--TEST--
+mysqli_fetch_array()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 5")) {
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[002]\n";
+	var_dump(mysqli_fetch_array($res, MYSQLI_ASSOC));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id LIMIT 5")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[004]\n";
+	var_dump(mysqli_fetch_array($res, MYSQLI_ASSOC));
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[002]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[004]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_array_large.phpt
@@ -0,0 +1,167 @@
+--TEST--
+mysqli_fetch_array() - large packages (to test compression)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	function mysqli_fetch_array_large($offset, $link, $package_size) {
+
+		/* we are aiming for maximum compression to test MYSQLI_CLIENT_COMPRESS */
+		$random_char = str_repeat('a', 255);
+		$sql = "INSERT INTO test(label) VALUES ";
+
+		while (strlen($sql) < ($package_size - 259))
+			$sql .= sprintf("('%s'), ", $random_char);
+
+		$sql = substr($sql, 0, -2);
+		$len = strlen($sql);
+		assert($len < $package_size);
+
+		if (!@mysqli_query($link, $sql)) {
+			if (1153 == mysqli_errno($link) || 2006 == mysqli_errno($link) || stristr(mysqli_error($link), 'max_allowed_packet'))
+				/*
+					myslqnd - [1153] Got a packet bigger than 'max_allowed_packet' bytes
+					libmysql -[2006] MySQL server has gone away
+				*/
+				return false;
+
+			printf("[%03d + 1] len = %d, [%d] %s\n", $offset, $len, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		/* buffered result set - let's hope we do not run into PHP memory limit... */
+		if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+			printf("[%03d + 2] len = %d, [%d] %s\n", $offset, $len, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		while ($row = mysqli_fetch_assoc($res)) {
+			if ($row['label'] != $random_char) {
+				printf("[%03d + 3] Wrong results - expecting '%s' got '%s', len = %d, [%d] %s\n",
+					$offset, $random_char, $row['label'], $len, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+		}
+		mysqli_free_result($res);
+
+		if (!$stmt = mysqli_prepare($link, "SELECT id, label FROM test")) {
+			printf("[%03d + 4] len = %d, [%d] %s\n", $offset, $len, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		/* unbuffered result set */
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d + 5] len = %d, [%d] %s, [%d] %s\n", $offset, $len, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		$id = $label = NULL;
+		if (!mysqli_stmt_bind_result($stmt, $id, $label)) {
+			printf("[%03d + 6] len = %d, [%d] %s, [%d] %s\n", $offset, $len, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		while (mysqli_stmt_fetch($stmt)) {
+			if ($label != $random_char) {
+				printf("[%03d + 7] Wrong results - expecting '%s' got '%s', len = %d, [%d] %s\n",
+					$offset, $random_char, $label, $len, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+		}
+
+		mysqli_stmt_free_result($stmt);
+		mysqli_stmt_close($stmt);
+
+		return true;
+	}
+
+	function parse_memory_limit($limit) {
+
+		$val = trim($limit);
+		$last = strtolower($val[strlen($val)-1]);
+
+		switch($last) {
+				// The 'G' modifier is available since PHP 5.1.0
+				case 'g':
+					$val *= 1024;
+				case 'm':
+					$val *= 1024;
+				case 'k':
+					$val *= 1024;
+				default:
+					break;
+    	}
+			return $val;
+	}
+
+
+	function test_fetch($host, $user, $passwd, $db, $port, $socket, $engine, $flags = null) {
+
+		$link = mysqli_init();
+		if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, $flags)) {
+			printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+			return false;
+		}
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+			!mysqli_query($link, sprintf("CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, label VARCHAR(255)) ENGINE = %s", $engine))) {
+			printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		$package_size = 524288;
+		$offset = 3;
+		$limit = (ini_get('memory_limit') > 0) ? parse_memory_limit(ini_get('memory_limit')) : pow(2, 32);
+
+		/* try to respect php.ini but make run time a soft limit */
+		$max_runtime = (ini_get('max_execution_time') > 0) ? ini_get('max_execution_time') : 30;
+		set_time_limit(0);
+
+		do {
+			if ($package_size > $limit) {
+				printf("stop: memory limit - %s vs. %s\n", $package_size, $limit);
+				break;
+			}
+
+			$start = microtime(true);
+			if (!mysqli_fetch_array_large($offset++, $link, $package_size)) {
+				printf("stop: packet size - %d\n", $package_size);
+				break;
+			}
+
+			$duration = microtime(true) - $start;
+			$max_runtime -= $duration;
+			if ($max_runtime < ($duration * 3)) {
+				/* likely the next iteration will not be within max_execution_time */
+				printf("stop: time limit - %2.2fs\n", $max_runtime);
+				break;
+			}
+
+			$package_size += $package_size;
+
+		} while (true);
+
+
+		mysqli_close($link);
+		return true;
+	}
+
+
+	test_fetch($host, $user, $passwd, $db, $port, $socket, $engine, null);
+	test_fetch($host, $user, $passwd, $db, $port, $socket, $engine, MYSQLI_CLIENT_COMPRESS);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+stop: %s
+stop: %s
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_array_many_rows.phpt
@@ -0,0 +1,115 @@
+--TEST--
+mysqli_fetch_array()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require("table.inc");
+
+	// do as much as we can do in 5 seconds
+	$start = microtime(true);
+	for ($id = 100, $start = microtime(true); (microtime(true) - $start) < 5; $id++) {
+		if (!mysqli_query($link, $sql = sprintf("INSERT INTO test(id, label) VALUES (%d, '%s')",
+			$id, mysqli_real_escape_string($link, chr(65 + ($id % 26)))))) {
+				printf("[001] %s failed: [%d] %s\n", $sql, mysqli_errno($link), mysqli_error($link));
+				break;
+		}
+	}
+
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test')) {
+		printf("[002] SELECT failed: [%d] %s\n", mysqli_errno($link), mysqli_errno($link));
+	}
+
+	while ($row = mysqli_fetch_array($res)) {
+		// overwrite results and check if the cache magic works
+		$row['label'] = NULL;
+	}
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test')) {
+		printf("[003] SELECT failed: [%d] %s\n", mysqli_errno($link), mysqli_errno($link));
+	}
+
+	$i = 0;
+	$results = array();
+	while ($row = mysqli_fetch_array($res, MYSQLI_BOTH)) {
+
+		// create copies and destroy later
+		$results[$i++] = &$row;
+		if ($i % 999) {
+			$results = array();
+		}
+
+		if ($row[0] < 0 || $row[0] > $id) {
+			printf("[004] Unexpected result row[0] = '%s' (range 0...%d), [%d] %s\n",
+				$row[0], $id, mysqli_errno($link), mysqli_error($link));
+			break;
+		}
+		if ($row[0] !== $row['id']) {
+			printf("[005] Unexpected result row[0] = '%s', row[id] = '%s', [%d] %s\n",
+				$row[0], $row[id], mysqli_errno($link), mysqli_error($link));
+			break;
+		}
+
+		$len = strlen($row[1]);
+		if (!is_string($row[1]) || $len == 0 || $len > 1) {
+			printf("[006] Unexpected result row[1] = '%s', [%d] %s\n",
+				$row[1], mysqli_errno($link), mysqli_error($link));
+			break;
+		}
+		if ($row[1] !== $row['label']) {
+			printf("[007] Unexpected result row[1] = '%s', row[label] = '%s', [%d] %s\n",
+				$row[1], $row['label'], mysqli_errno($link), mysqli_error($link));
+			break;
+		}
+
+	}
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test')) {
+		printf("[008] SELECT failed: [%d] %s\n", mysqli_errno($link), mysqli_errno($link));
+	}
+
+	while ($row = mysqli_fetch_array($res, MYSQLI_ASSOC)) {
+		// overwrite results and check if the cache magic works
+		$row['label'] = NULL;
+	}
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, 'SELECT count(*) AS num FROM test')) {
+		printf("[009] SELECT failed: [%d] %s\n", mysqli_errno($link), mysqli_errno($link));
+	}
+	$row = mysqli_fetch_assoc($res);
+	$num = $row['num'];
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test')) {
+		printf("[010] SELECT failed: [%d] %s\n", mysqli_errno($link), mysqli_errno($link));
+	}
+
+	$i = 0;
+	while ($row = mysqli_fetch_array($res, MYSQLI_NUM)) {
+		// overwrite results and check if the cache magic works
+		$row[0] = NULL;
+		$i++;
+	}
+	mysqli_free_result($res);
+
+	if ($i != $num)
+		printf("[011] Expecting %d results, got %d results, [%d] %s\n",
+			$num, $i, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_array_oo.phpt
@@ -0,0 +1,362 @@
+--TEST--
+mysqli->fetch_array()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	require('table.inc');
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = $mysqli->query("SELECT * FROM test ORDER BY id LIMIT 5")) {
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[005]\n";
+	var_dump($res->fetch_array());
+
+	print "[006]\n";
+	var_dump($res->fetch_array(MYSQLI_NUM));
+
+	print "[007]\n";
+	var_dump($res->fetch_array(MYSQLI_BOTH));
+
+	print "[008]\n";
+	var_dump($res->fetch_array(MYSQLI_ASSOC));
+
+	print "[009]\n";
+	var_dump($res->fetch_array());
+
+	$res->free_result();
+
+	if (!$res = $mysqli->query("SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e")) {
+		printf("[010] Cannot run query, [%d] %s\n", $mysqli->errno, $$mysqli->error);
+	}
+	print "[011]\n";
+	var_dump($res->fetch_array(MYSQLI_BOTH));
+
+	$res->free_result();
+	if (!$res = $mysqli->query("SELECT 1 AS a, 2 AS b, 3 AS c, 4 AS C")) {
+		printf("[012] Cannot run query, [%d] %s\n",
+			$mysqli->errno, $$mysqli->error);
+		exit(1);
+	}
+
+	do {
+		$illegal_mode = mt_rand(-10000, 10000);
+	} while (in_array($illegal_mode, array(MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH)));
+	// NOTE: for BC reasons with ext/mysql, ext/mysqli accepts invalid result modes.
+	$tmp = $res->fetch_array($illegal_mode);
+	if (false !== $tmp)
+		printf("[013] Expecting boolean/false although, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, $mysqli->errno, $mysqli->error);
+
+	$tmp = $res->fetch_array($illegal_mode);
+	if (false !== $tmp)
+		printf("[014] Expecting boolean/false, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, $mysqli->errno, $mysqli->error);
+
+	$res->free_result();
+
+	function func_mysqli_fetch_array($mysqli, $engine, $sql_type, $sql_value, $php_value, $offset, $regexp_comparison = NULL) {
+
+		if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, $mysqli->errno, $mysqli->error);
+			return false;
+		}
+
+		if (!$mysqli->query($sql = sprintf("CREATE TABLE test(id INT NOT NULL, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+				// don't bail, engine might not support the datatype
+				return false;
+		}
+
+		if (is_null($php_value)) {
+			if (!$mysqli->query($sql = sprintf("INSERT INTO test(id, label) VALUES (1, NULL)"))) {
+				printf("[%04d] [%d] %s\n", $offset + 1, $mysqli->errno, $mysqli->error);
+				return false;
+			}
+		} else {
+			if (is_string($sql_value)) {
+				if (!$mysqli->query($sql = "INSERT INTO test(id, label) VALUES (1, '" . $sql_value . "')")) {
+					printf("[%04ds] [%d] %s - %s\n", $offset + 1, $mysqli->errno, $mysqli->error, $sql);
+					return false;
+				}
+			} else {
+				if (!$mysqli->query($sql = sprintf("INSERT INTO test(id, label) VALUES (1, '%d')", $sql_value))) {
+					printf("[%04di] [%d] %s\n", $offset + 1, $mysqli->errno, $mysqli->error);
+					return false;
+				}
+			}
+		}
+
+		if (!$res = $mysqli->query("SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 2, $mysqli->errno, $mysqli->error);
+			return false;
+		}
+
+		if (!$row = $res->fetch_array(MYSQLI_BOTH)) {
+			printf("[%04d] [%d] %s\n", $offset + 3, $mysqli->errno, $mysqli->error);
+			return false;
+		}
+		$fields = mysqli_fetch_fields($res);
+
+		if (!(gettype($php_value)=="unicode" && ($fields[1]->flags & 128))) {
+			if ($regexp_comparison) {
+				if (!preg_match($regexp_comparison, (string)$row['label']) || !preg_match($regexp_comparison, (string)$row[1])) {
+					printf("[%04d] Expecting %s/%s [reg exp = %s], got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+						gettype($php_value), $php_value, $regexp_comparison,
+						gettype($row[1]), $row[1],
+						gettype($row['label']), $row['label'], $mysqli->errno, $mysqli->error);
+					return false;
+				}
+			} else {
+				if (($row['label'] !== $php_value) || ($row[1] != $php_value)) {
+					printf("[%04d] Expecting %s/%s, got %s/%s resp. %s/%s. [%d] %s\n", $offset + 4,
+						gettype($php_value), $php_value,
+						gettype($row[1]), $row[1],
+						gettype($row['label']), $row['label'], $mysqli->errno, $mysqli->error);
+						return false;
+				}
+			}
+		}
+		return true;
+	}
+
+	function func_mysqli_fetch_array_make_string($len) {
+
+		$ret = '';
+		for ($i = 0; $i < $len; $i++)
+			$ret .= chr(mt_rand(65, 90));
+
+		return $ret;
+	}
+
+	func_mysqli_fetch_array($mysqli, $engine, "TINYINT", -11, "-11", 20);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYINT", NULL, NULL, 30);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYINT UNSIGNED", 1, "1", 40);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYINT UNSIGNED", NULL, NULL, 50);
+
+	func_mysqli_fetch_array($mysqli, $engine, "BOOL", 1, "1", 60);
+	func_mysqli_fetch_array($mysqli, $engine, "BOOL", NULL, NULL, 70);
+	func_mysqli_fetch_array($mysqli, $engine, "BOOLEAN", 0, "0", 80);
+	func_mysqli_fetch_array($mysqli, $engine, "BOOLEAN", NULL, NULL, 90);
+
+	func_mysqli_fetch_array($mysqli, $engine, "SMALLINT", -32768, "-32768", 100);
+	func_mysqli_fetch_array($mysqli, $engine, "SMALLINT", 32767, "32767", 110);
+	func_mysqli_fetch_array($mysqli, $engine, "SMALLINT", NULL, NULL, 120);
+	func_mysqli_fetch_array($mysqli, $engine, "SMALLINT UNSIGNED", 65535, "65535", 130);
+	func_mysqli_fetch_array($mysqli, $engine, "SMALLINT UNSIGNED", NULL, NULL, 140);
+
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMINT", -8388608, "-8388608", 150);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMINT", 8388607, "8388607", 160);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMINT", NULL, NULL, 170);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMINT UNSIGNED", 16777215, "16777215", 180);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMINT UNSIGNED", NULL, NULL, 190);
+
+	func_mysqli_fetch_array($mysqli, $engine, "INTEGER", -2147483648, "-2147483648", 200);
+	func_mysqli_fetch_array($mysqli, $engine, "INTEGER", 2147483647, "2147483647", 210);
+	func_mysqli_fetch_array($mysqli, $engine, "INTEGER", NULL, NULL, 220);
+	func_mysqli_fetch_array($mysqli, $engine, "INTEGER UNSIGNED", "4294967295", "4294967295", 230);
+	func_mysqli_fetch_array($mysqli, $engine, "INTEGER UNSIGNED", NULL, NULL, 240);
+
+	if ($IS_MYSQLND ||
+		((mysqli_get_server_version($link) >= 51000) &&
+		 (mysqli_get_client_version($link) >= 51000))) {
+		func_mysqli_fetch_array($mysqli, $engine, "BIGINT", "-9223372036854775808", "-9223372036854775808", 250);
+		func_mysqli_fetch_array($mysqli, $engine, "BIGINT", NULL, NULL, 260);
+		func_mysqli_fetch_array($mysqli, $engine, "BIGINT UNSIGNED", "18446744073709551615", "18446744073709551615", 270);
+		func_mysqli_fetch_array($mysqli, $engine, "BIGINT UNSIGNED", NULL, NULL, 280);
+	}
+
+	func_mysqli_fetch_array($mysqli, $engine, "FLOAT", (string)(-9223372036854775808 - 1.1), "-9.22337e+18", 290, "/-9\.22337e\+?[0]?18/iu");
+	func_mysqli_fetch_array($mysqli, $engine, "FLOAT", NULL, NULL, 300);
+	func_mysqli_fetch_array($mysqli, $engine, "FLOAT UNSIGNED", (string)(18446744073709551615 + 1.1), "1.84467e+?19", 310, "/1\.84467e\+?[0]?19/iu");
+	func_mysqli_fetch_array($mysqli, $engine, "FLOAT UNSIGNED ", NULL, NULL, 320);
+
+	func_mysqli_fetch_array($mysqli, $engine, "DOUBLE(10,2)", "-99999999.99", "-99999999.99", 330);
+	func_mysqli_fetch_array($mysqli, $engine, "DOUBLE(10,2)", NULL, NULL, 340);
+	func_mysqli_fetch_array($mysqli, $engine, "DOUBLE(10,2) UNSIGNED", "99999999.99", "99999999.99", 350);
+	func_mysqli_fetch_array($mysqli, $engine, "DOUBLE(10,2) UNSIGNED", NULL, NULL, 360);
+	func_mysqli_fetch_array($mysqli, $engine, "DECIMAL(10,2)", "-99999999.99", "-99999999.99", 370);
+	func_mysqli_fetch_array($mysqli, $engine, "DECIMAL(10,2)", NULL, NULL, 380);
+	func_mysqli_fetch_array($mysqli, $engine, "DECIMAL(10,2)", "99999999.99", "99999999.99", 390);
+	func_mysqli_fetch_array($mysqli, $engine, "DECIMAL(10,2)", NULL, NULL, 400);
+
+	// don't care about date() strict TZ warnings...
+	$date = @date('Y-m-d');
+	func_mysqli_fetch_array($mysqli, $engine, "DATE",$date, $date, 410);
+	func_mysqli_fetch_array($mysqli, $engine, "DATE NOT NULL",$date, $date, 420);
+	func_mysqli_fetch_array($mysqli, $engine, "DATE", NULL, NULL, 430);
+
+	$date = @date('Y-m-d H:i:s');
+	func_mysqli_fetch_array($mysqli, $engine, "DATETIME", $date, $date, 440);
+	func_mysqli_fetch_array($mysqli, $engine, "DATETIME NOT NULL", $date, $date, 450);
+	func_mysqli_fetch_array($mysqli, $engine, "DATETIME", NULL, NULL, 460);
+	func_mysqli_fetch_array($mysqli, $engine, "TIMESTAMP", $date, $date, 470);
+	$date = @date('H:i:s');
+	func_mysqli_fetch_array($mysqli, $engine, "TIME", $date, $date, 480);
+	func_mysqli_fetch_array($mysqli, $engine, "TIME NOT NULL", $date, $date, 490);
+	func_mysqli_fetch_array($mysqli, $engine, "TIME", NULL, NULL, 500);
+	func_mysqli_fetch_array($mysqli, $engine, "YEAR", @date('Y'), @date('Y'), 510);
+	func_mysqli_fetch_array($mysqli, $engine, "YEAR NOT NULL", @date('Y'), @date('Y'), 520);
+	func_mysqli_fetch_array($mysqli, $engine, "YEAR", NULL, NULL, 530);
+
+	$string255 = func_mysqli_fetch_array_make_string(255);
+	func_mysqli_fetch_array($mysqli, $engine, "CHAR(1)", "a", "a", 540);
+	func_mysqli_fetch_array($mysqli, $engine, "CHAR(255)", $string255,  $string255, 550);
+	func_mysqli_fetch_array($mysqli, $engine, "CHAR(1) NOT NULL", "a", "a", 560);
+	func_mysqli_fetch_array($mysqli, $engine, "CHAR(1)", NULL, NULL, 570);
+
+	$string65k = func_mysqli_fetch_array_make_string(65400);
+	func_mysqli_fetch_array($mysqli, $engine, "VARCHAR(1)", "a", "a", 580);
+	func_mysqli_fetch_array($mysqli, $engine, "VARCHAR(255)", $string255, $string255, 590);
+	func_mysqli_fetch_array($mysqli, $engine, "VARCHAR(65400)", $string65k, $string65k, 600);
+	func_mysqli_fetch_array($mysqli, $engine, "VARCHAR(1) NOT NULL", "a", "a", 610);
+	func_mysqli_fetch_array($mysqli, $engine, "VARCHAR(1)", NULL, NULL, 620);
+
+	func_mysqli_fetch_array($mysqli, $engine, "BINARY(1)", "a", "a", 630);
+	func_mysqli_fetch_array($mysqli, $engine, "BINARY(2)", chr(0) . "a", chr(0) . "a", 640);
+	func_mysqli_fetch_array($mysqli, $engine, "BINARY(1) NOT NULL", "b", "b", 650);
+	func_mysqli_fetch_array($mysqli, $engine, "BINARY(1)", NULL, NULL, 660);
+
+	func_mysqli_fetch_array($mysqli, $engine, "VARBINARY(1)", "a", "a", 670);
+	func_mysqli_fetch_array($mysqli, $engine, "VARBINARY(2)", chr(0) . "a", chr(0) . "a", 680);
+	func_mysqli_fetch_array($mysqli, $engine, "VARBINARY(1) NOT NULL", "b", "b", 690);
+	func_mysqli_fetch_array($mysqli, $engine, "VARBINARY(1)", NULL, NULL, 700);
+
+	func_mysqli_fetch_array($mysqli, $engine, "TINYBLOB", "a", "a", 710);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYBLOB", chr(0) . "a", chr(0) . "a", 720);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYBLOB NOT NULL", "b", "b", 730);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYBLOB", NULL, NULL, 740);
+
+	func_mysqli_fetch_array($mysqli, $engine, "TINYTEXT", "a", "a", 750);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYTEXT NOT NULL", "a", "a", 760);
+	func_mysqli_fetch_array($mysqli, $engine, "TINYTEXT", NULL, NULL, 770);
+
+	func_mysqli_fetch_array($mysqli, $engine, "BLOB", "a", "a", 780);
+	func_mysqli_fetch_array($mysqli, $engine, "BLOB", chr(0) . "a", chr(0) . "a", 780);
+	func_mysqli_fetch_array($mysqli, $engine, "BLOB", NULL, NULL, 790);
+
+	func_mysqli_fetch_array($mysqli, $engine, "TEXT", "a", "a", 800);
+	func_mysqli_fetch_array($mysqli, $engine, "TEXT", chr(0) . "a", chr(0) . "a", 810);
+	func_mysqli_fetch_array($mysqli, $engine, "TEXT", NULL, NULL, 820);
+
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMBLOB", "a", "a", 830);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMBLOB", chr(0) . "a", chr(0) . "a", 840);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMBLOB", NULL, NULL, 850);
+
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMTEXT", "a", "a", 860);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMTEXT", chr(0) . "a", chr(0) . "a", 870);
+	func_mysqli_fetch_array($mysqli, $engine, "MEDIUMTEXT", NULL, NULL, 880);
+
+	func_mysqli_fetch_array($mysqli, $engine, "LONGBLOB", "a", "a", 890);
+	func_mysqli_fetch_array($mysqli, $engine, "LONGTEXT", chr(0) . "a", chr(0) . "a", 900);
+	func_mysqli_fetch_array($mysqli, $engine, "LONGBLOB", NULL, NULL, 910);
+
+	func_mysqli_fetch_array($mysqli, $engine, "ENUM('a', 'b')", "a", "a", 920);
+	func_mysqli_fetch_array($mysqli, $engine, "ENUM('a', 'b')", NULL, NULL, 930);
+
+	func_mysqli_fetch_array($mysqli, $engine, "SET('a', 'b')", "a", "a", 940);
+	func_mysqli_fetch_array($mysqli, $engine, "SET('a', 'b')", NULL, NULL, 950);
+
+	$mysqli->close();
+
+	if (null !== ($tmp = $res->fetch_array(MYSQLI_ASSOC)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "a"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[006]
+array(2) {
+  [0]=>
+  %unicode|string%(1) "2"
+  [1]=>
+  %unicode|string%(1) "b"
+}
+[007]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "3"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "3"
+  [1]=>
+  %unicode|string%(1) "c"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "c"
+}
+[008]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "d"
+}
+[009]
+array(4) {
+  [0]=>
+  %unicode|string%(1) "5"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "5"
+  [1]=>
+  %unicode|string%(1) "e"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "e"
+}
+[011]
+array(11) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [%u|b%"a"]=>
+  %unicode|string%(1) "2"
+  [1]=>
+  %unicode|string%(1) "2"
+  [2]=>
+  %unicode|string%(1) "3"
+  [%u|b%"c"]=>
+  %unicode|string%(1) "3"
+  [3]=>
+  %unicode|string%(1) "4"
+  [%u|b%"C"]=>
+  %unicode|string%(1) "4"
+  [4]=>
+  NULL
+  [%u|b%"d"]=>
+  NULL
+  [5]=>
+  %unicode|string%(1) "1"
+  [%u|b%"e"]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysqli_result::fetch_array(): The result type should be either MYSQLI_NUM, MYSQLI_ASSOC or MYSQLI_BOTH in %s on line %d
+
+Warning: mysqli_result::fetch_array(): The result type should be either MYSQLI_NUM, MYSQLI_ASSOC or MYSQLI_BOTH in %s on line %d
+
+Warning: mysqli_result::fetch_array(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_assoc.phpt
@@ -0,0 +1,119 @@
+--TEST--
+mysqli_fetch_assoc()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// Note: no SQL type tests, internally the same function gets used as for mysqli_fetch_array() which does a lot of SQL type test
+
+	if (!is_null($tmp = @mysqli_fetch_assoc()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_assoc($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[005]\n";
+	var_dump(mysqli_fetch_assoc($res));
+
+	print "[006]\n";
+	var_dump(mysqli_fetch_assoc($res));
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT
+		1 AS a,
+		2 AS a,
+		3 AS c,
+		4 AS C,
+		NULL AS d,
+		true AS e,
+		5 AS '-1',
+		6 AS '-10',
+		7 AS '-100',
+		8 AS '-1000',
+		9 AS '10000',
+		'a' AS '100000',
+		'b' AS '1000000',
+		'c' AS '9',
+		'd' AS '9',
+		'e' AS '01',
+		'f' AS '-02'
+	")) {
+		printf("[007] Cannot run query, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[008]\n";
+	var_dump(mysqli_fetch_assoc($res));
+
+	mysqli_free_result($res);
+
+	if (NULL !== ($tmp = mysqli_fetch_assoc($res)))
+		printf("[008] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[006]
+NULL
+[008]
+array(15) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "2"
+  [%u|b%"c"]=>
+  %unicode|string%(1) "3"
+  [%u|b%"C"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"d"]=>
+  NULL
+  [%u|b%"e"]=>
+  %unicode|string%(1) "1"
+  [-1]=>
+  %unicode|string%(1) "5"
+  [-10]=>
+  %unicode|string%(1) "6"
+  [-100]=>
+  %unicode|string%(1) "7"
+  [-1000]=>
+  %unicode|string%(1) "8"
+  [10000]=>
+  %unicode|string%(1) "9"
+  [100000]=>
+  %unicode|string%(1) "a"
+  [1000000]=>
+  %unicode|string%(1) "b"
+  [9]=>
+  %unicode|string%(1) "d"
+  [%u|b%"01"]=>
+  %unicode|string%(1) "e"
+  [%u|b%"-02"]=>
+  %unicode|string%(1) "f"
+}
+
+Warning: mysqli_fetch_assoc(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_assoc_bit.phpt
@@ -0,0 +1,117 @@
+--TEST--
+mysqli_fetch_assoc() - BIT
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	require_once('connect.inc');
+	require_once('table.inc');
+	if (mysqli_get_server_version($link) < 50003)
+		// b'001' syntax not supported before 5.0.3
+		die("skip Syntax used for test not supported with MySQL Server before 5.0.3");
+	if (!$IS_MYSQLND && (mysqli_get_client_version() < 50003))
+		// better don't trust libmysql before 5.0.3
+		die("skip Syntax used for test not supported with MySQL Server before 5.0.3");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+
+	function dec32bin($dec, $bits) {
+
+		$maxval = pow(2, $bits);
+		$bin = '';
+		for ($bitval = $maxval; $bitval >= 1; $bitval = $bitval / 2) {
+			if (($dec / $bitval) >= 1) {
+				$bin .= '1';
+				$dec -= $bitval;
+			} else {
+				$bin .= '0';
+			}
+		}
+		return $bin;
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	for ($bits = 1; $bits <= 46; $bits++) {
+		if (1 == $bits)
+			$max_value = 1;
+		else
+			$max_value = pow(2, $bits) - 1;
+		$tests = 0;
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+			!mysqli_query($link, $sql = sprintf('CREATE TABLE test(id BIGINT, bit_value BIT(%d) NOT NULL, bit_null BIT(%d) DEFAULT NULL) ENGINE="%s"', $bits, $bits, $engine)))
+			printf("[002 - %d] [%d] %s\n",$bits, mysqli_errno($link), mysqli_error($link));
+
+		$tests = 0;
+		$rand_max = mt_getrandmax();
+		while ($tests < 10) {
+
+			$tests++;
+			if (1 == $tests)
+				$value = 0;
+			else if (2 == $tests)
+				$value = $max_value;
+			else {
+				if ($max_value > $rand_max) {
+					$max_loops = floor($max_value/$rand_max);
+					$num_loops = mt_rand(1, $max_loops);
+					$value = 0;
+					for ($i = 0; $i < $num_loops; $i++)
+						$value += mt_rand(0, $rand_max);
+				} else {
+					$value = mt_rand(0, $max_value);
+				}
+			}
+
+			$bin = ($bits < 32) ? decbin($value) : dec32bin($value, $bits);
+			$sql = sprintf("INSERT INTO test(id, bit_value) VALUES (%s, b'%s')", $value, $bin);
+			for ($i = 0; ($i < strlen($bin)) && ($bin[$i] == '0'); $i++)
+				;
+			$bin2 = substr($bin, $i, strlen($bin));
+
+			if (!mysqli_query($link, $sql))
+				printf("[003 - %d] [%d] %s\n", $bits, mysqli_errno($link), mysqli_error($link));
+
+			$sql = sprintf("SELECT id, BIN(bit_value) AS _bin, bit_value + 0 AS _bit_value0, bit_value, bit_null FROM test WHERE id = %s", $value);
+			if (!$res = mysqli_query($link, $sql))
+				printf("[004 - %d] [%d] %s\n", $bits, mysqli_errno($link), mysqli_error($link));
+
+			if (!$row = mysqli_fetch_assoc($res))
+				printf("[005 - %d] [%d] %s\n", $bits, mysqli_errno($link), mysqli_error($link));
+
+			if (($value != $row['id']) || (($bin != $row['_bin']) && ($bin2 != $row['_bin']))) {
+				debug_zval_dump($row);
+				printf("[006 - %d] Insert of %s in BIT(%d) column might have failed. id = %s, bin = %s (%s/%s)\n",
+					$bits, $value, $bits, $row['id'], $row['_bin'], $bin, $bin2);
+				break;
+			}
+			if ($value != $row['bit_value']) {
+				debug_zval_dump($row);
+				printf("%10s %64s\n%10s %64s\n", '_bin', $row['_bin'], 'insert', $bin);
+				printf("[007 - %d] Expecting %s got %s\n", $bits, $value, $row['bit_value']);
+				break;
+			}
+
+			if (null !== $row['bit_null']) {
+				debug_zval_dump($row);
+				printf("[008 - %d] Expecting null got %s/%s\n", $bits, gettype($row['bit_value']), $row['bit_value']);
+				break;
+			}
+		}
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_assoc_no_alias.phpt
@@ -0,0 +1,142 @@
+--TEST--
+mysqli_fetch_assoc()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$res = mysqli_query($link, "SELECT 1, 2")) {
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[002]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[004]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2, 2 as '2'")) {
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[006]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT 1 AS a, 2 as '2', 2")) {
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[008]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	/* Now do it with unbuffered queries */
+	if (!$res = mysqli_real_query($link, "SELECT 1, 2")) {
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_use_result($link)) {
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[011]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_real_query($link, "SELECT 1 AS a, 2")) {
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_use_result($link)) {
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[014]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_real_query($link, "SELECT 1 AS a, 2, 2 as '2'")) {
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_use_result($link)) {
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[017]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_real_query($link, "SELECT 1 AS a, 2 as '2', 2")) {
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_use_result($link)) {
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[017]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+[002]
+array(2) {
+  [1]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+[004]
+array(2) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+[006]
+array(2) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+[008]
+array(2) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+[011]
+array(2) {
+  [1]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+[014]
+array(2) {
+  [%u|b%"a"]=>
+  %s(1) "1"
+  [2]=>
+  %s(1) "2"
+}
+[017]
+array(2) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+[017]
+array(2) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "2"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_assoc_no_alias_utf8.phpt
@@ -0,0 +1,164 @@
+--TEST--
+mysqli_fetch_assoc() - utf8
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+	require_once("connect.inc");
+
+	if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		die("skip Cannot connect to server to check charsets");
+
+	if (!$res = mysqli_query($link, "SHOW CHARACTER SET LIKE 'UTF8'"))
+		die("skip Cannot run SHOW CHARACTER SET to check charsets");
+
+	if (!$tmp = mysqli_fetch_assoc($res))
+		die("skip Looks like UTF8 is not available on the server");
+
+	if (strtolower($tmp['Charset']) !== 'utf8')
+		die("skip Not sure if UTF8 is available, cancelling the test");
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SHOW CHARACTER SET LIKE 'UCS2'"))
+		die("skip Cannot run SHOW CHARACTER SET to check charsets");
+
+	if (!$tmp = mysqli_fetch_assoc($res))
+		die("skip Looks like UCS2 is not available on the server");
+
+	if (strtolower($tmp['Charset']) !== 'ucs2')
+		die("skip Not sure if UCS2 is available, cancelling the test");
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	/* some cyrillic (utf8) comes here */
+	if (!$res = mysqli_query($link, "SET NAMES UTF8")) {
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!$res = mysqli_query($link, "SELECT 1 AS ' ', 2 AS ' ', 3 AS ' '")) {
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[003]\n";
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "CREATE TABLE __mysqlnd (id integer not null auto_increment primary key,  varchar(20) character set ucs2,  varchar(20) character set utf8)")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_query($link, "INSERT INTO __mysqlnd (, ) VALUES ('', ''), ('', ''), ('','')")) {
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_query($link, "INSERT INTO __mysqlnd (, ) VALUES ('Andrey', 'Hristov'), ('Georg', 'Richter'), ('Ulf','Wendel')")) {
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (!$res = mysqli_query($link, "INSERT INTO __mysqlnd (, ) VALUES ('', 'Hristov'), ('', 'Richter'), ('','Wendel')")) {
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!$res = mysqli_query($link, "SELECT id, ,  FROM __mysqlnd ORDER BY , ")) {
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "[009]\n";
+	while ($row = mysqli_fetch_assoc($res)) {
+		var_dump($row);
+	}
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "DROP TABLE __mysqlnd")) {
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+[003]
+array(3) {
+  [%u|b%" "]=>
+  %unicode|string%(%r[1|3]%r) "1"
+  [%u|b%" "]=>
+  %unicode|string%(1) "2"
+  [%u|b%" "]=>
+  %unicode|string%(1) "3"
+}
+[009]
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "4"
+  [%u|b%""]=>
+  %unicode|string%(6) "Andrey"
+  [%u|b%""]=>
+  %unicode|string%(7) "Hristov"
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "7"
+  [%u|b%""]=>
+  %unicode|string%(9) ""
+  [%u|b%""]=>
+  %unicode|string%(7) "Hristov"
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "5"
+  [%u|b%""]=>
+  %unicode|string%(5) "Georg"
+  [%u|b%""]=>
+  %unicode|string%(7) "Richter"
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "8"
+  [%u|b%""]=>
+  %unicode|string%(9) ""
+  [%u|b%""]=>
+  %unicode|string%(7) "Richter"
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "6"
+  [%u|b%""]=>
+  %unicode|string%(3) "Ulf"
+  [%u|b%""]=>
+  %unicode|string%(6) "Wendel"
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "9"
+  [%u|b%""]=>
+  %unicode|string%(9) ""
+  [%u|b%""]=>
+  %unicode|string%(6) "Wendel"
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "3"
+  [%u|b%""]=>
+  %unicode|string%(6) ""
+  [%u|b%""]=>
+  %unicode|string%(12) ""
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "2"
+  [%u|b%""]=>
+  %unicode|string%(10) ""
+  [%u|b%""]=>
+  %unicode|string%(12) ""
+}
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%""]=>
+  %unicode|string%(12) ""
+  [%u|b%""]=>
+  %unicode|string%(14) ""
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_assoc_oo.phpt
@@ -0,0 +1,86 @@
+--TEST--
+mysqli_fetch_assoc()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// Note: no SQL type tests, internally the same function gets used as for mysqli_fetch_array() which does a lot of SQL type test
+	$mysqli = new mysqli();
+	$res = @new mysqli_result($mysqli);
+	if (!is_null($tmp = @$res->fetch_assoc()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @$res->fetch_assoc($link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = $mysqli->query("SELECT id, label FROM test ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	print "[005]\n";
+	var_dump($res->fetch_assoc());
+
+	print "[006]\n";
+	var_dump($res->fetch_assoc());
+
+	$res->free_result();
+
+	if (!$res = $mysqli->query("SELECT 1 AS a, 2 AS a, 3 AS c, 4 AS C, NULL AS d, true AS e")) {
+		printf("[007] Cannot run query, [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+	print "[008]\n";
+	var_dump($res->fetch_assoc());
+
+	$res->free_result();
+
+	if (NULL !== ($tmp = $res->fetch_assoc()))
+		printf("[008] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[005]
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+[006]
+NULL
+[008]
+array(5) {
+  [%u|b%"a"]=>
+  %unicode|string%(1) "2"
+  [%u|b%"c"]=>
+  %unicode|string%(1) "3"
+  [%u|b%"C"]=>
+  %unicode|string%(1) "4"
+  [%u|b%"d"]=>
+  NULL
+  [%u|b%"e"]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysqli_result::fetch_assoc(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_assoc_zerofill.phpt
@@ -0,0 +1,78 @@
+--TEST--
+mysqli_fetch_assoc() - ZEROFILL
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	function zerofill($offset, $link, $datatype, $insert = 1) {
+
+		mysqli_query($link, 'ALTER TABLE test DROP zero');
+		$sql = sprintf('ALTER TABLE test ADD zero %s UNSIGNED ZEROFILL', $datatype);
+		if (!mysqli_query($link, $sql)) {
+			// no worries - server might not support it
+			return true;
+		}
+
+		if (!mysqli_query($link, sprintf('UPDATE test SET zero = %s', $insert))) {
+			printf("[%03d] UPDATE failed, [%d] %s\n",
+				$offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!($res = mysqli_query($link, 'SELECT zero FROM test LIMIT 1'))) {
+			printf("[%03d] SELECT failed, [%d] %s\n",
+				$offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		$row = mysqli_fetch_assoc($res);
+		$meta = mysqli_fetch_fields($res);
+		mysqli_free_result($res);
+		$meta = $meta[0];
+		$length = $meta->length;
+		if ($length > strlen($insert)) {
+
+			$expected = str_repeat('0', $length - strlen($insert));
+			$expected .= $insert;
+			if ($expected !== $row['zero']) {
+				printf("[%03d] Expecting '%s' got '%s'\n", $offset, $expected, $row['zero']);
+				return false;
+			}
+
+		} else if ($length <= 1) {
+			printf("[%03d] Length reported is too small to run test\n", $offset);
+			return false;
+		}
+
+		return true;
+	}
+
+	zerofill(2, $link, 'TINYINT');
+	zerofill(3, $link, 'SMALLINT');
+	zerofill(4, $link, 'MEDIUMINT');
+	zerofill(5, $link, 'INT');
+	zerofill(6, $link, 'INTEGER');
+	zerofill(7, $link, 'BIGINT');
+	zerofill(8, $link, 'FLOAT');
+	zerofill(9, $link, 'DOUBLE');
+	zerofill(10, $link, 'DOUBLE PRECISION');
+	zerofill(11, $link, 'DECIMAL');
+	zerofill(12, $link, 'DEC');
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_field.phpt
@@ -0,0 +1,177 @@
+--TEST--
+mysqli_fetch_field()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// Note: no SQL type tests, internally the same function gets used as for mysqli_fetch_array() which does a lot of SQL type test
+	if (!is_null($tmp = @mysqli_fetch_field()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_field($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$charsets = my_get_charsets($link);
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	/* ID column, binary charset */
+	$tmp = mysqli_fetch_field($res);
+	var_dump($tmp);
+
+	/* label column, result set charset */
+	$tmp = mysqli_fetch_field($res);
+	var_dump($tmp);
+	if ($tmp->charsetnr != $charsets['results']['nr']) {
+		printf("[004] Expecting charset %s/%d got %d\n",
+			$charsets['results']['charset'],
+			$charsets['results']['nr'], $tmp->charsetnr);
+	}
+	if ($tmp->length != (1 * $charsets['results']['maxlen'])) {
+		printf("[005] Expecting length %d got %d\n",
+			$charsets['results']['maxlen'],
+			$tmp->max_length);
+	}
+	if ($tmp->db != $db) {
+		printf("011] Expecting database '%s' got '%s'\n",
+		  $db, $tmp->db);
+	}
+
+	var_dump(mysqli_fetch_field($res));
+
+	mysqli_free_result($res);
+
+	// Read http://bugs.php.net/bug.php?id=42344 on defaults!
+	if (NULL !== ($tmp = mysqli_fetch_field($res)))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "CREATE TABLE test(id INT NOT NULL DEFAULT 1)"))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test(id) VALUES (2)"))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SELECT id as _default_test FROM test")) {
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	var_dump(mysqli_fetch_assoc($res));
+	/* binary */
+	var_dump(mysqli_fetch_field($res));
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "ID"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"orgname"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(0)
+  [%u|b%"type"]=>
+  int(254)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+bool(false)
+
+Warning: mysqli_fetch_field(): Couldn't fetch mysqli_result in %s on line %d
+array(1) {
+  [%u|b%"_default_test"]=>
+  %unicode|string%(1) "2"
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(13) "_default_test"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(32769)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_field_direct.phpt
@@ -0,0 +1,83 @@
+--TEST--
+mysqli_fetch_field_direct()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_fetch_field_direct()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_field_direct($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_field_direct($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	var_dump(mysqli_fetch_field_direct($res, -1));
+	var_dump(mysqli_fetch_field_direct($res, 0));
+	var_dump(mysqli_fetch_field_direct($res, 2));
+
+	mysqli_free_result($res);
+
+	if (NULL !== ($tmp = mysqli_fetch_field_direct($res, 0)))
+		printf("Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_fetch_field_direct(): Field offset is invalid for resultset in %s on line %d
+bool(false)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "ID"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(%d)
+  [%u|b%"type"]=>
+  int(%d)
+  [%u|b%"decimals"]=>
+  int(%d)
+}
+
+Warning: mysqli_fetch_field_direct(): Field offset is invalid for resultset in %s on line %d
+bool(false)
+
+Warning: mysqli_fetch_field_direct(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_field_direct_oo.phpt
@@ -0,0 +1,92 @@
+--TEST--
+$res->fetch_field_direct(s)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$mysqli = new mysqli();
+	$res = @new mysqli_result($mysqli);
+	if (!is_null($tmp = @$res->fetch_field_direct()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = $mysqli->query("SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!is_null($tmp = @$res->fetch_field_direct()))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$res->fetch_field_direct($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$res->fetch_field_direct($link, $link)))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	var_dump($res->fetch_field_direct(-1));
+	var_dump($res->fetch_field_direct(0));
+	var_dump($res->fetch_field_direct(2));
+
+	$res->free_result();
+
+	if (NULL !== ($tmp = $res->fetch_field_direct(0)))
+		printf("[007] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$mysqli->close();
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_result::fetch_field_direct(): Field offset is invalid for resultset in %s on line %d
+bool(false)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "ID"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(%d)
+  [%u|b%"type"]=>
+  int(%d)
+  [%u|b%"decimals"]=>
+  int(%d)
+}
+
+Warning: mysqli_result::fetch_field_direct(): Field offset is invalid for resultset in %s on line %d
+bool(false)
+
+Warning: mysqli_result::fetch_field_direct(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_field_flags.phpt
@@ -0,0 +1,243 @@
+--TEST--
+mysqli_fetch_field() - flags/field->flags
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		die(printf("skip: [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (mysqli_get_server_version($link) < 50041)
+	die("skip: Due to many MySQL Server differences, the test requires 5.0.41+");
+
+mysqli_close($link);
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+/* TODO: mysqli.c needs to export a few more constants - see all the defined() calls! */
+
+	$flags = array(
+		MYSQLI_NOT_NULL_FLAG => 'NOT_NULL',
+		MYSQLI_PRI_KEY_FLAG => 'PRI_KEY',
+		MYSQLI_UNIQUE_KEY_FLAG => 'UNIQUE_KEY',
+		MYSQLI_MULTIPLE_KEY_FLAG => 'MULTIPLE_KEY',
+		MYSQLI_BLOB_FLAG => 'BLOB',
+		MYSQLI_UNSIGNED_FLAG	=> 'UNSIGNED',
+		MYSQLI_ZEROFILL_FLAG => 'ZEROFILL',
+		MYSQLI_AUTO_INCREMENT_FLAG => 'AUTO_INCREMENT',
+		MYSQLI_TIMESTAMP_FLAG	=> 'TIMESTAMP',
+		MYSQLI_SET_FLAG	=> 'SET',
+		MYSQLI_NUM_FLAG => 'NUM',
+		MYSQLI_PART_KEY_FLAG => 'PART_KEY',
+		// MYSQLI_GROUP_FLAG => 'MYSQLI_GROUP_FLAG' - internal usage only
+		(defined('MYSQLI_NO_DEFAULT_VALUE_FLAG') ? MYSQLI_NO_DEFAULT_VALUE_FLAG : 4096) => 'NO_DEFAULT_VALUE',
+		(defined('MYSQLI_BINARY_FLAG') ? MYSQLI_BINARY_FLAG : 128) => 'BINARY',
+		(defined('MYSQLI_ENUM_FLAG') ? MYSQLI_ENUM_FLAG : 256) => 'ENUM',
+		// MYSQLI_BINCMP_FLAG
+	);
+
+	// 5.1.24 / 6.0.4+
+	if (defined('MYSQLI_ON_UPDATE_NOW'))
+		$flags[MYSQLI_ON_UPDATE_NOW] = 'ON_UPDATE_NOW';
+	else
+		$flags[8192] = 'ON_UPDATE_NOW';
+
+	krsort($flags);
+
+	$columns = array(
+		'INT DEFAULT NULL' => 'NUM',
+		'INT NOT NULL' => 'NOT_NULL NO_DEFAULT_VALUE NUM',
+		'INT NOT NULL DEFAULT 1' => 'NOT_NULL NUM',
+		'INT UNSIGNED DEFAULT NULL' => 'UNSIGNED NUM',
+		'INT UNSIGNED NOT NULL'	=> 'NOT_NULL UNSIGNED NO_DEFAULT_VALUE NUM',
+		'INT UNSIGNED NOT NULL DEFAULT 1' => 'NOT_NULL UNSIGNED NUM',
+		'INT UNSIGNED ZEROFILL DEFAULT NULL' => 'UNSIGNED ZEROFILL NUM',
+		'INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY' => 'NOT_NULL PRI_KEY UNSIGNED AUTO_INCREMENT NUM PART_KEY',
+		'CHAR(1) DEFAULT NULL'	=> '',
+		'CHAR(1) NOT NULL' => 'NOT_NULL NO_DEFAULT_VALUE',
+		'TIMESTAMP NOT NULL' => 'NOT_NULL UNSIGNED ZEROFILL BINARY TIMESTAMP',
+		'VARBINARY(127) DEFAULT NULL' => 'BINARY',
+		'BLOB'	=> 'BLOB BINARY',
+		'TINYBLOB'	=> 'BLOB BINARY',
+		'MEDIUMBLOB'	=> 'BLOB BINARY',
+		'LONGBLOB'	=> 'BLOB BINARY',
+		'TEXT'	=> 'BLOB',
+		'TINYTEXT'	=> 'BLOB',
+		'MEDIUMTEXT'	=> 'BLOB',
+		'LONGTEXT'	=> 'BLOB',
+		'SET("one", "two")'	=> 'SET',
+		'SET("one", "two") NOT NULL'	=> 'NOT_NULL SET NO_DEFAULT_VALUE',
+		'SET("one", "two") NOT NULL DEFAULT "one"'	=> 'NOT_NULL SET',
+		'ENUM("one", "two")'	=> 'ENUM',
+		'ENUM("one", "two") NOT NULL' => 'NOT_NULL ENUM NO_DEFAULT_VALUE',
+		'ENUM("one", "two") NOT NULL DEFAULT "one"' => 'NOT_NULL ENUM',
+		'TINYINT UNIQUE' => 'UNIQUE_KEY NUM PART_KEY',
+		'SMALLINT UNIQUE' => 'UNIQUE_KEY NUM PART_KEY',
+		'MEDIUMINT UNIQUE DEFAULT 1' => 'UNIQUE_KEY NUM PART_KEY',
+		'BIGINT UNSIGNED UNIQUE DEFAULT 100' => 'UNIQUE_KEY UNSIGNED NUM PART_KEY',
+		'BIT' => 'UNSIGNED',
+		'VARCHAR(2) NOT NULL PRIMARY KEY' => 'NOT_NULL PRI_KEY NO_DEFAULT_VALUE PART_KEY'
+	);
+
+
+
+	function checkFlags($reported_flags, $expected_flags, $flags) {
+		$found_flags = $unexpected_flags = '';
+		foreach ($flags as $code => $name) {
+			if ($reported_flags >= $code) {
+				$reported_flags -= $code;
+				$found_flags .= $name . ' ';
+				if (stristr($expected_flags, $name)) {
+					$expected_flags = trim(str_ireplace($name, '', $expected_flags));
+				} else {
+					$unexpected_flags .= $name . ' ';
+				}
+			}
+		}
+
+		return array($expected_flags, $unexpected_flags, $found_flags);
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (mysqli_get_server_version($link) > 50600) {
+		$columns['TIMESTAMP NOT NULL'] = 'ON_UPDATE_NOW TIMESTAMP BINARY NOT_NULL';
+	}
+
+	foreach ($columns as $column_def => $expected_flags) {
+		if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+			printf("[002] %s [%d] %s\n", $column_def,
+				mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		$create = sprintf('CREATE TABLE test(id INT, col1 %s)', $column_def);
+		if (!mysqli_query($link, $create)) {
+			// Server might not support it - skip
+			continue;
+		}
+
+		if (!$res = mysqli_query($link, 'SELECT * FROM test')) {
+			printf("[003] Can't select from table, %s [%d] %s\n", $column_def,
+				mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		$field = mysqli_fetch_field_direct($res, 1);
+		if (!is_object($field)) {
+			printf("[004] Fetching the meta data failed, %s [%d] %s\n", $column_def,
+				mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+		if ($field->name != 'col1') {
+			printf("[005] Field information seems wrong, %s [%d] %s\n", $column_def,
+				mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		/*
+		TODO
+		Unfortunately different server versions give you slightly different
+		results.The test does not yet fully reflect all server changes/bugs etc.
+		*/
+		switch ($column_def) {
+			case 'TIMESTAMP NOT NULL':
+				// http://bugs.mysql.com/bug.php?id=30081 - new flag introduced in 5.1.24/6.0.4
+				$version = mysqli_get_server_version($link);
+				if ((($version >  50122) && ($version < 60000) && ($version != 50200)) ||
+						($version >= 60004)) {
+					// new flag ON_UPDATE_NOW_FLAG (8192)
+					$expected_flags .= ' ON_UPDATE_NOW';
+				}
+				break;
+
+			case 'INT UNSIGNED NOT NULL':
+			case 'INT NOT NULL':
+			case 'CHAR(1) NOT NULL':
+			case 'SET("one", "two") NOT NULL':
+			case 'ENUM("one", "two") NOT NULL':
+				$version = mysqli_get_server_version($link);
+				if ($version < 50000) {
+					// TODO - check exact version!
+					$expected_flags = trim(str_replace('NO_DEFAULT_VALUE', '', $expected_flags));
+				}
+				break;
+
+			case 'BIT':
+				$version = mysqli_get_server_version($link);
+				if (($version <= 50114 && $version > 50100) || ($version == 50200)) {
+					// TODO - check exact version!
+					$expected_flags = trim(str_replace('UNSIGNED', '', $expected_flags));
+				}
+
+			default:
+				break;
+		}
+
+		list($missing_flags, $unexpected_flags, $flags_found) = checkFlags($field->flags, $expected_flags, $flags);
+		if ($unexpected_flags) {
+			printf("[006] Found unexpected flags '%s' for %s, found '%s' with MySQL %s'\n",
+				$unexpected_flags, $column_def, $flags_found, mysqli_get_server_version($link));
+		}
+		if ($missing_flags) {
+			printf("[007] The flags '%s' have not been reported for %s, found '%s'\n",
+				$missing_flags, $column_def, $flags_found);
+			var_dump($create);
+			var_dump(mysqli_get_server_version($link));
+			die($missing_flags);
+		}
+
+		mysqli_free_result($res);
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("[008] %s [%d] %s\n", $column_def,
+			mysqli_errno($link), mysqli_error($link));
+		continue;
+	}
+
+	$column_def = array('col1 CHAR(1)', 'col2 CHAR(2)','INDEX idx_col1_col2(col1, col2)');
+	$expected_flags = array('col1' => 'MULTIPLE_KEY PART_KEY', 'col2' => 'PART_KEY');
+	$create = 'CREATE TABLE test(id INT, ';
+	foreach ($column_def as $k => $v) {
+		$create .= sprintf('%s, ', $v);
+	}
+	$create = sprintf('%s)', substr($create, 0, -2));
+
+	if (mysqli_query($link, $create)) {
+		if (!$res = mysqli_query($link, 'SELECT * FROM test')) {
+			printf("[009] Cannot run SELECT, [%d] %s\n",
+				mysqli_errno($link), mysqli_error($link));
+		}
+		// id column - skip it
+		$field = mysqli_fetch_field($res);
+		while ($field = mysqli_fetch_field($res)) {
+			if (!isset($expected_flags[$field->name])) {
+				printf("[010] Found unexpected field '%s'\n", $field->name);
+				continue;
+			}
+			list($missing_flags, $unexpected_flags, $flags_found) = checkFlags($field->flags, $expected_flags[$field->name], $flags);
+			if ($unexpected_flags)
+				printf("[011] Found unexpected flags '%s' for %s, found '%s'\n",
+					$unexpected_flags, $field->name, $flags_found);
+			if ($missing_flags)
+				printf("[012] The flags '%s' have not been reported for %s, found '%s'\n",
+					$missing_flags, $field->name, $flags_found);
+		}
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_field_oo.phpt
@@ -0,0 +1,129 @@
+--TEST--
+mysqli_fetch_field()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// Note: no SQL type tests, internally the same function gets used as for mysqli_fetch_array() which does a lot of SQL type test
+	$mysqli = new mysqli();
+	$res = @new mysqli_result($mysqli);
+	if (!is_null($tmp = @$res->fetch_field()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @$res->fetch_field($link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$charsets = my_get_charsets($link);
+
+	if (!$res = $mysqli->query("SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	var_dump($res->fetch_field());
+
+	$tmp = $res->fetch_field();
+	var_dump($tmp);
+	if ($tmp->charsetnr != $charsets['results']['nr']) {
+		printf("[005] Expecting charset %s/%d got %d\n",
+			$charsets['results']['charset'],
+			$charsets['results']['nr'], $tmp->charsetnr);
+	}
+	if ($tmp->length != (1 * $charsets['results']['maxlen'])) {
+		printf("[006] Expecting length %d got %d\n",
+			$charsets['results']['maxlen'],
+			$tmp->max_length);
+	}
+	if ($tmp->db != $db) {
+		printf("008] Expecting database '%s' got '%s'\n",
+		  $db, $tmp->db);
+	}
+
+	var_dump($res->fetch_field());
+
+	$res->free_result();
+
+	if (NULL !== ($tmp = $res->fetch_field()))
+		printf("[007] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$mysqli->close();
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "ID"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"orgname"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(0)
+  [%u|b%"type"]=>
+  int(254)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+bool(false)
+
+Warning: mysqli_result::fetch_field(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_field_types.phpt
@@ -0,0 +1,126 @@
+--TEST--
+mysqli_fetch_field() - data types/field->type
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	function mysqli_field_datatypes($link, $sql_type, $php_value, $php_type, $datatypes, $default_charset="latin1") {
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[001] %s, [%d] %s\n", $sql_type,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		$create = sprintf("CREATE TABLE test(id %s) DEFAULT CHARSET %s", $sql_type, $default_charset);
+		if (!mysqli_query($link, $create)) {
+			printf("[002] '%s' - '%s', [%d] %s\n", $sql_type, $create,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (is_string($php_value))
+			$sql = sprintf("INSERT INTO test(id) VALUES ('%s')", $php_value);
+		else
+			$sql = sprintf("INSERT INTO test(id) VALUES (%s)", $php_value);
+
+		if (!mysqli_query($link, $sql)) {
+			printf("[003] '%s' - '%s' - '%s', [%d] %s\n", $sql_type, $create, $sql,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!$res = mysqli_query($link, 'SELECT id FROM test')) {
+			printf("[004] %s, [%d] %s\n", $sql_type,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!is_object($field = mysqli_fetch_field($res))) {
+			printf("[004] %s, expecting object got %s, [%d] %s\n", $sql_type,
+				gettype($field),
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if ($field->type != $php_type) {
+			$code_name = 'unknown';
+			foreach ($datatypes as $k => $v) {
+				if ($k == $field->type) {
+					$code_name = (is_array($v)) ? $v[0] : $v;
+					break;
+				}
+			}
+			printf("[006] Expecting %d for %s got code %d for %s\n",
+				$php_type, $sql_type, $field->type, $code_name);
+			return false;
+		}
+
+		return true;
+	}
+
+	$datatypes = array(
+		MYSQLI_TYPE_TINY => array('TINYINT', 5),
+		MYSQLI_TYPE_SHORT => array('SMALLINT', 10),
+		MYSQLI_TYPE_LONG => 'MYSQLI_TYPE_LONG - TODO add testing',
+		MYSQLI_TYPE_FLOAT => array('FLOAT', '1.3'),
+		MYSQLI_TYPE_DOUBLE => array('DOUBLE', '1.4'),
+		MYSQLI_TYPE_TIMESTAMP => array('TIMESTAMP', '2007-08-20 18:34:00'),
+		MYSQLI_TYPE_LONGLONG => array('BIGINT', 100),
+		MYSQLI_TYPE_INT24	=> array('MEDIUMINT', 10),
+		MYSQLI_TYPE_DATE => array('DATE', '2007-08-20'),
+		MYSQLI_TYPE_TIME => array('TIME', '18:41:38'),
+		MYSQLI_TYPE_DATETIME => array('DATETIME', '2007-08-20 18:42:01'),
+		MYSQLI_TYPE_YEAR => array('YEAR', '2007'),
+		MYSQLI_TYPE_ENUM => array('ENUM("everything", "is", "just", "wonderful")', 'is'),
+		// MYSQLI_TYPE_SET	=> array('SET("I", "smash", "the")', 'I,smash,the'), - string
+		// MYSQLI_TYPE_TINY_BLOB => array("TINYBLOB", "I got a tiny blog"), - blob
+		// MYSQLI_TYPE_MEDIUM_BLOB => array("MEDIUMBLOB", "No blob for masses"), - blob
+		// MYSQLI_TYPE_LONG_BLOB => array("LONGBLOB", "Small is beautiful?"), - blob
+		MYSQLI_TYPE_BLOB => array("LONGBLOB", 'MySQL does not report proper type. Use Length to distinct BLOB types'),
+		MYSQLI_TYPE_BLOB => array("MEDIUMBLOB", 'MySQL does not report proper type. Use Length to distinct BLOB types'),
+		MYSQLI_TYPE_BLOB => array("TINYBLOB", 'MySQL does not report proper type. Use Length to distinct BLOB types'),
+		MYSQLI_TYPE_BLOB => array("BLOB", 'silly'),
+		MYSQLI_TYPE_VAR_STRING => array("VARCHAR(32768)", 'varchar'),
+		MYSQLI_TYPE_STRING => 'MYSQLI_TYPE_STRING - TODO add testing',
+		MYSQLI_TYPE_STRING => array('CHAR(1)', 'a'),
+		MYSQLI_TYPE_STRING => array("SET('I', 'smash', 'the')", 'smash'),
+		MYSQLI_TYPE_NULL => 'MYSQLI_TYPE_NULL - TODO add testing',
+		MYSQLI_TYPE_NEWDATE => 'MYSQLI_TYPE_NEWDATE - TODO add testing',
+		MYSQLI_TYPE_INTERVAL => 'MYSQLI_TYPE_INTERVAL - TODO add testing',
+		MYSQLI_TYPE_GEOMETRY => 'MYSQLI_TYPE_GEOMETRY - TODO add testing',
+	);
+
+	if ($IS_MYSQLND) {
+		$version = 50007 + 1;
+	} else {
+		$version = mysqli_get_client_version();
+	}
+
+	if ($version > 50002) {
+		$datatypes[MYSQLI_TYPE_NEWDECIMAL] = array('DECIMAL', '1.1');
+		$datatypes[MYSQLI_TYPE_BIT] = array('BIT', 0);
+	} else {
+		$datatypes[MYSQLI_TYPE_DECIMAL] = array('DECIMAL', '1.1');
+	}
+
+	foreach ($datatypes as $php_type => $datatype) {
+		if (is_array($datatype))
+			mysqli_field_datatypes($link, $datatype[0], $datatype[1], $php_type, $datatypes);
+	}
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_fields.phpt
@@ -0,0 +1,121 @@
+--TEST--
+mysqli_fetch_fields()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	// Note: no SQL type tests, internally the same function gets used as for mysqli_fetch_array() which does a lot of SQL type test
+	if (!is_null($tmp = @mysqli_fetch_fields()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_fields($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	$charsets = my_get_charsets($link);
+
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 1")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	$fields = mysqli_fetch_fields($res);
+	foreach ($fields as $k => $field) {
+		var_dump($field);
+		switch ($k) {
+			case 1:
+				/* label column, result set charset */
+				if ($field->charsetnr != $charsets['results']['nr']) {
+					printf("[004] Expecting charset %s/%d got %d\n",
+						$charsets['results']['charset'],
+						$charsets['results']['nr'], $field->charsetnr);
+				}
+				if ($field->length != (1 * $charsets['results']['maxlen'])) {
+					printf("[005] Expecting length %d got %d\n",
+						$charsets['results']['maxlen'],
+						$field->max_length);
+				}
+				break;
+		}
+	}
+
+	mysqli_free_result($res);
+
+	if (NULL !== ($tmp = mysqli_fetch_fields($res)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "ID"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"orgname"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "TEST"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(1)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(0)
+  [%u|b%"type"]=>
+  int(254)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+
+Warning: mysqli_fetch_fields(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_lengths.phpt
@@ -0,0 +1,55 @@
+--TEST--
+mysqli_fetch_lengths()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$mysqli = new mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect\n");
+
+	if (!is_null($tmp = @mysqli_fetch_lengths()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_lengths($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id LIMIT 1")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	var_dump(mysqli_fetch_lengths($res));
+	while ($row = mysqli_fetch_assoc($res))
+		var_dump(mysqli_fetch_lengths($res));
+	var_dump(mysqli_fetch_lengths($res));
+
+	mysqli_free_result($res);
+
+	var_dump(mysqli_fetch_lengths($res));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(false)
+array(2) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(1)
+}
+bool(false)
+
+Warning: mysqli_fetch_lengths(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_lengths_oo.phpt
@@ -0,0 +1,50 @@
+--TEST--
+mysqli_result->lengths
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect\n");
+
+	require('table.inc');
+	if (!$res = $mysqli->query("SELECT id, label FROM test ORDER BY id LIMIT 1")) {
+		printf("[002] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	var_dump($res->lengths);
+	while ($row = $res->fetch_assoc())
+		var_dump($res->lengths);
+	var_dump($res->lengths);
+
+	$res->free_result();
+	var_dump($res->lengths);
+	$mysqli->close();
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+NULL
+array(2) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(1)
+}
+NULL
+
+Warning: main(): Property access is not allowed yet in %s on line %d
+NULL
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_object.phpt
@@ -0,0 +1,157 @@
+--TEST--
+mysqli_fetch_object()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	include_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_fetch_object()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_object($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	$obj = mysqli_fetch_object($res);
+	if (($obj->ID !== "1") || ($obj->label !== "a") || (get_class($obj) != 'stdClass')) {
+		printf("[004] Object seems wrong. [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump($obj);
+	}
+
+	class mysqli_fetch_object_test {
+
+		public $a = null;
+		public $b = null;
+
+		public function toString() {
+			var_dump($this);
+		}
+	}
+
+	$obj = mysqli_fetch_object($res, 'mysqli_fetch_object_test');
+	if (($obj->ID !== "2") || ($obj->label !== "b") || ($obj->a !== NULL) || ($obj->b !== NULL) || (get_class($obj) != 'mysqli_fetch_object_test')) {
+		printf("[005] Object seems wrong. [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump($obj);
+	}
+
+
+
+	class mysqli_fetch_object_construct extends mysqli_fetch_object_test {
+
+		public function __construct($a, $b) {
+			$this->a = $a;
+			$this->b = $b;
+		}
+
+	}
+
+	$obj = mysqli_fetch_object($res, 'mysqli_fetch_object_construct', null);
+
+	if (($obj->ID !== "3") || ($obj->label !== "c") || ($obj->a !== NULL) || ($obj->b !== NULL) || (get_class($obj) != 'mysqli_fetch_object_construct')) {
+		printf("[006] Object seems wrong. [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump($obj);
+	}
+
+	$obj = mysqli_fetch_object($res, 'mysqli_fetch_object_construct', array('a'));
+	if (($obj->ID !== "4") || ($obj->label !== "d") || ($obj->a !== 'a') || ($obj->b !== NULL) || (get_class($obj) != 'mysqli_fetch_object_construct')) {
+		printf("[007] Object seems wrong. [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump($obj);
+	}
+
+	$obj = mysqli_fetch_object($res, 'mysqli_fetch_object_construct', array('a', 'b'));
+	if (($obj->ID !== "5") || ($obj->label !== "e") || ($obj->a !== 'a') || ($obj->b !== 'b') || (get_class($obj) != 'mysqli_fetch_object_construct')) {
+		printf("[008] Object seems wrong. [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		var_dump($obj);
+	}
+
+	var_dump(mysqli_fetch_object($res, 'mysqli_fetch_object_construct', array('a', 'b', 'c')));
+	var_dump(mysqli_fetch_object($res));
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST")) {
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_free_result($res);
+	var_dump(mysqli_fetch_object($res));
+
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5"))
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	/*
+	TODO
+	I'm using the procedural interface, this should not throw an exception.
+	Also, I did not ask to get exceptions using the mysqli_options()
+	*/
+	try {
+		if (false !== ($obj = mysqli_fetch_object($res, 'mysqli_fetch_object_construct', 'a')))
+			printf("[011] Should have failed\n");
+	} catch (Exception $e) {
+		printf("%s\n", $e->getMessage());
+	}
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5"))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	class mysqli_fetch_object_private_constructor extends mysqli_fetch_object_test {
+
+		private function __construct($a, $b) {
+			$this->a = $a;
+			$this->b = $b;
+		}
+	}
+	/*
+	TODO
+	I think we should bail out here. The following line will give a Fatal error: Call to private ... from invalid context
+	var_dump($obj = new mysqli_fetch_object_private_constructor(1, 2));
+	This does not fail.
+	*/
+	$obj = mysqli_fetch_object($res, 'mysqli_fetch_object_private_constructor', array('a', 'b'));
+	mysqli_free_result($res);
+
+	// Fatal error, script execution will end
+	var_dump(mysqli_fetch_object($res, 'this_class_does_not_exist'));
+
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: Missing argument 1 for mysqli_fetch_object_construct::__construct() in %s on line %d
+
+Warning: Missing argument 2 for mysqli_fetch_object_construct::__construct() in %s on line %d
+
+Notice: Undefined variable: a in %s on line %d
+
+Notice: Undefined variable: b in %s on line %d
+
+Warning: Missing argument 2 for mysqli_fetch_object_construct::__construct() in %s on line %d
+
+Notice: Undefined variable: b in %s on line %d
+NULL
+NULL
+
+Warning: mysqli_fetch_object(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+Parameter ctor_params must be an array
+
+Fatal error: Class 'this_class_does_not_exist' not found in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_object_no_constructor.phpt
@@ -0,0 +1,65 @@
+--TEST--
+mysqli_fetch_object() - calling constructor on class wo constructor
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5")) {
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	class mysqli_fetch_object_test {
+
+		public $a = null;
+		public $b = null;
+
+		public function toString() {
+			var_dump($this);
+		}
+	}
+
+	printf("No exception with PHP:\n");
+	var_dump($obj = new mysqli_fetch_object_test(1, 2));
+
+	printf("\nException with mysqli. Note that at all other places we throws errors but no exceptions unless the error mode has been changed:\n");
+	try {
+		var_dump($obj = mysqli_fetch_object($res, 'mysqli_fetch_object_test', array(1, 2)));
+	} catch (Exception $e) {
+		printf("Exception: %s\n", $e->getMessage());
+	}
+
+	printf("\nFatal error with PHP (but no exception!):\n");
+	var_dump($obj->mysqli_fetch_object_test(1, 2));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+No exception with PHP:
+object(mysqli_fetch_object_test)#%d (%d) {
+  [%u|b%"a"]=>
+  NULL
+  [%u|b%"b"]=>
+  NULL
+}
+
+Exception with mysqli. Note that at all other places we throws errors but no exceptions unless the error mode has been changed:
+Exception: Class mysqli_fetch_object_test does not have a constructor hence you cannot use ctor_params
+
+Fatal error with PHP (but no exception!):
+
+Fatal error: Call to undefined method mysqli_fetch_object_test::mysqli_fetch_object_test() in %s on line %d
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_object_no_object.phpt
@@ -0,0 +1,27 @@
+--TEST--
+mysqli_fetch_object()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	$obj = mysqli_fetch_object($res);
+	var_dump(gettype($obj));
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+%s(6) "object"
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_object_oo.phpt
@@ -0,0 +1,130 @@
+--TEST--
+mysqli_fetch_object()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	$mysqli = new mysqli();
+	$res = @new mysqli_result($mysqli);
+	if (!is_null($tmp = @$res->fetch_object()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = $mysqli->query("SELECT id AS ID, label FROM test AS TEST ORDER BY id LIMIT 5")) {
+		printf("[003] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	if (!is_null($tmp = @$res->fetch_object($link)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$res->fetch_object($link, $link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @$res->fetch_object($link, $link, $link)))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$obj = mysqli_fetch_object($res);
+	if (($obj->ID !== "1") || ($obj->label !== "a") || (get_class($obj) != 'stdClass')) {
+		printf("[007] Object seems wrong. [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($obj);
+	}
+
+	class mysqli_fetch_object_test {
+
+		public $a = null;
+		public $b = null;
+
+		public function toString() {
+			var_dump($this);
+		}
+	}
+
+	$obj = $res->fetch_object('mysqli_fetch_object_test');
+	if (($obj->ID !== "2") || ($obj->label !== "b") || ($obj->a !== NULL) || ($obj->b !== NULL) || (get_class($obj) != 'mysqli_fetch_object_test')) {
+		printf("[008] Object seems wrong. [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($obj);
+	}
+
+	class mysqli_fetch_object_construct extends mysqli_fetch_object_test {
+
+		public function __construct($a, $b) {
+			$this->a = $a;
+			$this->b = $b;
+		}
+
+	}
+
+	$obj = $res->fetch_object('mysqli_fetch_object_construct', null);
+
+	if (($obj->ID !== "3") || ($obj->label !== "c") || ($obj->a !== NULL) || ($obj->b !== NULL) || (get_class($obj) != 'mysqli_fetch_object_construct')) {
+		printf("[009] Object seems wrong. [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($obj);
+	}
+
+	$obj = $res->fetch_object('mysqli_fetch_object_construct', array('a'));
+	if (($obj->ID !== "4") || ($obj->label !== "d") || ($obj->a !== 'a') || ($obj->b !== NULL) || (get_class($obj) != 'mysqli_fetch_object_construct')) {
+		printf("[010] Object seems wrong. [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($obj);
+	}
+
+	$obj = $res->fetch_object('mysqli_fetch_object_construct', array('a', 'b'));
+	if (($obj->ID !== "5") || ($obj->label !== "e") || ($obj->a !== 'a') || ($obj->b !== 'b') || (get_class($obj) != 'mysqli_fetch_object_construct')) {
+		printf("[011] Object seems wrong. [%d] %s\n", $mysqli->errno, $mysqli->error);
+		var_dump($obj);
+	}
+
+	var_dump($res->fetch_object('mysqli_fetch_object_construct', array('a', 'b', 'c')));
+	var_dump(mysqli_fetch_object($res));
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT id AS ID, label FROM test AS TEST")) {
+		printf("[012] [%d] %s\n", $mysqli->errno, $mysqli->error);
+	}
+
+	mysqli_free_result($res);
+
+	var_dump(mysqli_fetch_object($res));
+
+	// Fatal error, script execution will end
+	var_dump($res->fetch_object('this_class_does_not_exist'));
+
+	$mysqli->close();
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: Missing argument 1 for mysqli_fetch_object_construct::__construct() in %s on line %d
+
+Warning: Missing argument 2 for mysqli_fetch_object_construct::__construct() in %s on line %d
+
+Notice: Undefined variable: a in %s on line %d
+
+Notice: Undefined variable: b in %s on line %d
+
+Warning: Missing argument 2 for mysqli_fetch_object_construct::__construct() in %s on line %d
+
+Notice: Undefined variable: b in %s on line %d
+NULL
+NULL
+
+Warning: mysqli_fetch_object(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+
+Fatal error: Class 'this_class_does_not_exist' not found in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fetch_row.phpt
@@ -0,0 +1,59 @@
+--TEST--
+mysqli_fetch_row()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_fetch_row()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_fetch_row($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id, label, id AS _id FROM test ORDER BY id LIMIT 1")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "[004]\n";
+	var_dump(mysqli_fetch_row($res));
+
+	print "[005]\n";
+	var_dump(mysqli_fetch_row($res));
+
+	mysqli_free_result($res);
+
+	var_dump(mysqli_fetch_row($res));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[004]
+array(3) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "a"
+  [2]=>
+  %unicode|string%(1) "1"
+}
+[005]
+NULL
+
+Warning: mysqli_fetch_row(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_field_count.phpt
@@ -0,0 +1,63 @@
+--TEST--
+mysqli_field_count()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_field_count()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_field_count($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	var_dump(mysqli_field_count($link));
+
+	if (!$res = mysqli_query($link, "SELECT * FROM test ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	var_dump(mysqli_field_count($link));
+
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, 'x')"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	var_dump($link->field_count);
+	var_dump(mysqli_field_count($link));
+
+	if (!$res = mysqli_query($link, "SELECT NULL as _null, '' AS '', 'three' AS 'drei'"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	var_dump(mysqli_field_count($link));
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	var_dump(mysqli_field_count($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+int(0)
+int(2)
+int(0)
+int(0)
+int(3)
+
+Warning: mysqli_field_count(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_field_seek.phpt
@@ -0,0 +1,251 @@
+--TEST--
+mysqli_field_seek()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	function mysqli_field_seek_flags($flags) {
+
+		$ret = '';
+
+		if ($flags & MYSQLI_NOT_NULL_FLAG)
+			$ret .= 'MYSQLI_NOT_NULL_FLAG ';
+
+		if ($flags & MYSQLI_PRI_KEY_FLAG)
+			$ret .= 'MYSQLI_PRI_KEY_FLAG ';
+
+		if ($flags & MYSQLI_UNIQUE_KEY_FLAG)
+			$ret .= 'MYSQLI_UNIQUE_KEY_FLAG ';
+
+		if ($flags & MYSQLI_MULTIPLE_KEY_FLAG)
+			$ret .= 'MYSQLI_MULTIPLE_KEY_FLAG ';
+
+		if ($flags & MYSQLI_BLOB_FLAG)
+			$ret .= 'MYSQLI_BLOB_FLAG ';
+
+		if ($flags & MYSQLI_UNSIGNED_FLAG)
+			$ret .= 'MYSQLI_UNSIGNED_FLAG ';
+
+		if ($flags & MYSQLI_ZEROFILL_FLAG)
+			$ret .= 'MYSQLI_ZEROFILL_FLAG ';
+
+		if ($flags & MYSQLI_AUTO_INCREMENT_FLAG)
+			$ret .= 'MYSQLI_AUTO_INCREMENT_FLAG ';
+
+		if ($flags & MYSQLI_TIMESTAMP_FLAG)
+			$ret .= 'MYSQLI_TIMESTAMP_FLAG ';
+
+		if ($flags & MYSQLI_SET_FLAG)
+			$ret .= 'MYSQLI_SET_FLAG ';
+
+		if ($flags & MYSQLI_NUM_FLAG)
+			$ret .= 'MYSQLI_NUM_FLAG ';
+
+		if ($flags & MYSQLI_PART_KEY_FLAG)
+			$ret .= 'MYSQLI_PART_KEY_FLAG ';
+
+		if ($flags & MYSQLI_GROUP_FLAG)
+			$ret .= 'MYSQLI_GROUP_FLAG ';
+
+		return $ret;
+	}
+
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_field_seek()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_field_seek($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	$charsets = my_get_charsets($link);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id LIMIT 1", MYSQLI_USE_RESULT)) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	var_dump(mysqli_field_seek($res, -1));
+	var_dump(mysqli_fetch_field($res));
+	var_dump(mysqli_field_seek($res, 0));
+	var_dump(mysqli_fetch_field($res));
+	var_dump(mysqli_field_seek($res, 1));
+
+	$field = mysqli_fetch_field($res);
+	var_dump($field);
+	/* label column, result set charset */
+	if ($field->charsetnr != $charsets['results']['nr']) {
+		printf("[004] Expecting charset %s/%d got %d\n",
+			$charsets['results']['charset'],
+			$charsets['results']['nr'], $field->charsetnr);
+	}
+	if ($field->length != (1 * $charsets['results']['maxlen'])) {
+		printf("[005] Expecting length %d got %d\n",
+			$charsets['results']['maxlen'],
+			$field->max_length);
+	}
+
+	var_dump(mysqli_field_tell($res));
+	var_dump(mysqli_field_seek($res, 2));
+	var_dump(mysqli_fetch_field($res));
+	var_dump(mysqli_field_seek($res, PHP_INT_MAX + 1));
+
+	if (!is_null($tmp = @mysqli_field_seek($res, 0, "too many")))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT NULL as _null", MYSQLI_STORE_RESULT)) {
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	var_dump(mysqli_field_seek($res, 0));
+	var_dump(mysqli_fetch_field($res));
+
+	mysqli_free_result($res);
+
+	var_dump(mysqli_field_seek($res, 0));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_field_seek(): Invalid field offset in %s on line %d
+bool(false)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+bool(true)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+bool(true)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"orgname"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(0)
+  [%u|b%"type"]=>
+  int(254)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+int(2)
+
+Warning: mysqli_field_seek(): Invalid field offset in %s on line %d
+bool(false)
+bool(false)
+
+Warning: mysqli_field_seek(): Invalid field offset in %s on line %d
+bool(false)
+bool(true)
+object(stdClass)#3 (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "_null"
+  [%u|b%"orgname"]=>
+  %unicode|string%(0) ""
+  [%u|b%"table"]=>
+  %unicode|string%(0) ""
+  [%u|b%"orgtable"]=>
+  %unicode|string%(0) ""
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(0) ""
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(0)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(32896)
+  [%u|b%"type"]=>
+  int(6)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+
+Warning: mysqli_field_seek(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_field_tell.phpt
@@ -0,0 +1,110 @@
+--TEST--
+mysqli_field_tell()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_field_tell()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_field_tell($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id FROM test ORDER BY id LIMIT 1", MYSQLI_USE_RESULT)) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	var_dump(mysqli_field_tell($res));
+	var_dump(mysqli_field_seek(1));
+	var_dump(mysqli_field_tell($res));
+	var_dump(mysqli_fetch_field($res));
+	var_dump(mysqli_fetch_field($res));
+	var_dump(mysqli_field_tell($res));
+
+	if (!is_null($tmp = @mysqli_field_tell($res, 'too many arguments')))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+
+	var_dump(mysqli_field_seek($res, 2));
+	var_dump(mysqli_field_tell($res));
+
+	var_dump(mysqli_field_seek($res, -1));
+	var_dump(mysqli_field_tell($res));
+
+	var_dump(mysqli_field_seek($res, 0));
+	var_dump(mysqli_field_tell($res));
+
+
+
+	mysqli_free_result($res);
+
+	var_dump(mysqli_field_tell($res));
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+int(0)
+
+Warning: mysqli_field_seek() expects exactly 2 parameters, 1 given in %s on line %d
+NULL
+int(0)
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+bool(false)
+int(1)
+
+Warning: mysqli_field_seek(): Invalid field offset in %s on line %d
+bool(false)
+int(1)
+
+Warning: mysqli_field_seek(): Invalid field offset in %s on line %d
+bool(false)
+int(1)
+bool(true)
+int(0)
+
+Warning: mysqli_field_tell(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_fork.phpt
@@ -0,0 +1,252 @@
+--TEST--
+Forking a child and using the same connection.
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('pcntl_fork'))
+	die("skip Process Control Functions not available");
+
+if (!function_exists('posix_getpid'))
+	die("skip POSIX functions not available");
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (!have_innodb($link))
+	die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once("table.inc");
+
+	$res = mysqli_query($link, "SELECT 'dumped by the parent' AS message");
+	$pid = pcntl_fork();
+	switch ($pid) {
+		case -1:
+			printf("[001] Cannot fork child");
+			break;
+
+		case 0:
+			/* child */
+			exit(0);
+			break;
+
+		default:
+			/* parent */
+			$status = null;
+			$wait_id = pcntl_waitpid($pid, $status);
+			if (pcntl_wifexited($status) && (0 != ($tmp = pcntl_wexitstatus($status)))) {
+				printf("Exit code: %s\n", (pcntl_wifexited($status)) ? pcntl_wexitstatus($status) : 'n/a');
+				printf("Signal: %s\n", (pcntl_wifsignaled($status)) ? pcntl_wtermsig($status) : 'n/a');
+				printf("Stopped: %d\n", (pcntl_wifstopped($status)) ? pcntl_wstopsig($status) : 'n/a');
+			}
+			var_dump(mysqli_fetch_assoc($res));
+			mysqli_free_result($res);
+			break;
+	}
+
+	if (@mysqli_query($link, "SELECT id FROM test WHERE id = 1"))
+		printf("[003] Expecting error and closed connection, child exit should have closed connection\n");
+	else if ((($errno = mysqli_errno($link)) == 0) || ('' == ($error = mysqli_error($link))))
+		printf("[004] Expecting error string and error code from MySQL, got errno = %s/%s, error = %s/%s\n",
+			gettype($errno), $errno, gettype($error), $error);
+
+	mysqli_close($link);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[005] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	/* non trivial tests require a message list for parent-child communication */
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS messages"))
+		printf("[006] [%d] %s\n", mysqli_error($link), mysqli_errno($link));
+
+	if (!mysqli_query($link, "CREATE TABLE messages(
+		msg_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
+		msg_time TIMESTAMP,
+		pid INT NOT NULL,
+		sender ENUM('child', 'parent') NOT NULL,
+		msg TEXT) ENGINE = InnoDB"))
+		printf("[007] [%d] %s\n", mysqli_error($link), mysqli_errno($link));
+
+	mysqli_autocommit($link, false);
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id ASC LIMIT 3", MYSQLI_USE_RESULT))
+		printf("[008] [%d] %s\n", mysqli_error($link), mysqli_errno($link));
+
+	$pid = pcntl_fork();
+
+	switch ($pid) {
+		case -1:
+			printf("[009] Cannot fork child");
+			break;
+
+		case 0:
+			/* child */
+			if (!($plink = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) || !mysqli_autocommit($plink, true))
+				exit(mysqli_errno($plink));
+
+			$sql = sprintf("INSERT INTO messages(pid, sender, msg) VALUES (%d, 'child', '%%s')", posix_getpid());
+			if (!mysqli_query($plink, sprintf($sql, 'start')))
+				exit(mysqli_errno($plink));
+
+			$parent_sql = sprintf("SELECT msg_id, msg_time, msg FROM messages WHERE pid = %d  AND sender = 'parent' ORDER BY msg_id DESC LIMIT 1", posix_getppid());
+			$msg_id = 0;
+			while ($row = mysqli_fetch_assoc($res)) {
+				/* send row to parent */
+				ob_start();
+				var_dump($row);
+				$tmp = ob_get_contents();
+				ob_end_clean();
+				if (!mysqli_query($plink, sprintf($sql, $tmp)))
+					exit(mysqli_errno($plink));
+
+				/* let the parent reply... */
+				$start = time();
+				do {
+					usleep(100);
+					if (!$pres = mysqli_query($plink, $parent_sql))
+						continue;
+					$tmp = mysqli_fetch_assoc($pres);
+					mysqli_free_result($pres);
+					if ($tmp['msg_id'] == $msg_id)
+						/* no new message */
+						continue;
+					if ($tmp['msg'] == 'stop')
+						break 2;
+					$msg_id = $tmp['msg_id'];
+					break;
+				} while ((time() - $start) < 5);
+
+			}
+
+			if (!mysqli_query($plink, sprintf($sql, 'stop')) || !mysqli_commit($link))
+				exit(mysqli_errno($plink));
+			exit(0);
+			break;
+
+		default:
+			/* parent */
+			if (!$plink = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+					printf("[010] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+					$host, $user, $db, $port, $socket);
+
+			$status = null;
+			$start = time();
+			$sql = sprintf("SELECT msg_id, msg_time, msg FROM messages WHERE pid = %d AND sender = 'child' ORDER BY msg_id DESC LIMIT 1", $pid);
+			$parent_sql = sprintf("INSERT INTO messages (pid, sender, msg) VALUES (%d, 'parent', '%%s')", posix_getpid());
+			$last_msg_id = 0;
+			$num_rows = 0;
+			do {
+				$wait_id = pcntl_waitpid($pid, $status, WNOHANG);
+				if ($pres = mysqli_query($plink, $sql)) {
+					$row = mysqli_fetch_assoc($pres);
+					if ($row['msg_id'] != $last_msg_id) {
+						$last_msg_id = $row['msg_id'];
+						switch ($row['msg']) {
+							case 'start':
+								break;
+							case 'stop':
+								break 2;
+							default:
+								/* client has started fetching rows */
+								$client_row = $row['msg'];
+
+								$num_rows++;
+								if ($num_rows > 3) {
+									printf("[011] Child has fetched more than three rows!\n");
+									var_dump($client_row);
+									if (!mysqli_query($plink, sprintf($parent_sql, 'stop'))) {
+										printf("[012] Parent cannot inform child\n", mysqli_errno($plink), mysqli_error($plink));
+									}
+									break 2;
+								}
+
+								if (!$parent_row = mysqli_fetch_assoc($res)) {
+									printf("[013] Parent cannot fetch row %d\n", $num_rows, mysqli_errno($link), mysqli_error($link));
+									if (!mysqli_query($plink, sprintf($parent_sql, 'stop'))) {
+										printf("[014] Parent cannot inform child\n", mysqli_errno($plink), mysqli_error($plink));
+									}
+									break 2;
+								}
+
+								ob_start();
+								var_dump($parent_row);
+								$parent_row = ob_get_contents();
+								ob_end_clean();
+
+								if ($parent_row != $client_row) {
+									printf("[015] Child indicates different results than parent.\n");
+									var_dump($child_row);
+									var_dump($parent_row);
+									if (!mysqli_query($plink, sprintf($parent_sql, 'stop'))) {
+										printf("[016] Parent cannot inform child\n", mysqli_errno($plink), mysqli_error($plink));
+									}
+									break 2;
+								}
+
+								if (!mysqli_query($plink, sprintf($parent_sql, 'continue'))) {
+									printf("[017] Parent cannot inform child to continue.\n", mysqli_errno($plink), mysqli_error($plink));
+								}
+								break;
+						}
+					}
+					mysqli_free_result($pres);
+				}
+				usleep(100);
+			} while (((time() - $start) < 5) && ($num_rows < 3));
+			mysqli_close($plink);
+			$wait_id = pcntl_waitpid($pid, $status);
+			if (pcntl_wifexited($status) && (0 != ($tmp = pcntl_wexitstatus($status)))) {
+				printf("Exit code: %s\n", (pcntl_wifexited($status)) ? pcntl_wexitstatus($status) : 'n/a');
+				printf("Signal: %s\n", (pcntl_wifsignaled($status)) ? pcntl_wtermsig($status) : 'n/a');
+				printf("Stopped: %d\n", (pcntl_wifstopped($status)) ? pcntl_wstopsig($status) : 'n/a');
+			}
+			break;
+	}
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[018] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = mysqli_query($link, "SELECT sender, msg FROM messages ORDER BY msg_id ASC"))
+		printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	while ($row = mysqli_fetch_assoc($res))
+		printf("%10s %s\n", $row['sender'], substr($row['msg'], 0, 5));
+	mysqli_free_result($res);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS messages"))
+	printf("[c003] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(1) {
+  ["message"]=>
+  string(20) "dumped by the parent"
+}
+     child start
+     child array
+    parent conti
+     child array
+    parent conti
+     child array
+    parent conti
+     child stop
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_free_result.phpt
@@ -0,0 +1,79 @@
+--TEST--
+mysqli_free_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$db = 'test';
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_free_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_free_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id FROM test ORDER BY id LIMIT 1")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "a\n";
+	var_dump(mysqli_free_result($res));
+	print "b\n";
+	var_dump(mysqli_free_result($res));
+
+	if (!$res = mysqli_query($link, "SELECT id FROM test ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "c\n";
+	var_dump($res = mysqli_store_result($link));
+	var_dump(mysqli_error($link));
+	print "[005]\n";
+	var_dump(mysqli_free_result($res));
+
+	if (!$res = mysqli_query($link, "SELECT id FROM test ORDER BY id LIMIT 1")) {
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	print "d\n";
+	var_dump($res = mysqli_use_result($link));
+	var_dump(mysqli_error($link));
+	print "[007]\n";
+	var_dump(mysqli_free_result($res));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+a
+NULL
+b
+
+Warning: mysqli_free_result(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+c
+bool(false)
+%s(0) ""
+[005]
+
+Warning: mysqli_free_result() expects parameter 1 to be mysqli_result, boolean given in %s on line %d
+NULL
+d
+bool(false)
+%s(0) ""
+[007]
+
+Warning: mysqli_free_result() expects parameter 1 to be mysqli_result, boolean given in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_cache_stats_off.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysqli_get_cache_stats() - disabled via php.ini
+--INI--
+mysqlnd.collect_statistics="0"
+mysqlnd.collect_memory_statistics="0"
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_cache_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--FILE--
+<?php
+	$before = mysqli_get_cache_stats();
+	/*
+	NOTE: the function belongs to the mysqnd zval cache. The
+	mysqlnd zval cache was part of PHP from PHP 5.3.0(-dev) to
+	PHP 5.3.0RC3 or something. And it was turned off by default.
+	The function never returned anything meaningful in any released version of PHP.
+	*/
+	if (!is_array($before)) {
+		printf("[001] Expecting array, got %s.\n", gettype($before));
+		var_dump($before);
+	}
+
+	require_once('table.inc');
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	while ($row = mysqli_fetch_assoc($res))
+		;
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	while ($row = mysqli_fetch_assoc($res))
+		;
+
+	$after = mysqli_get_cache_stats();
+        if ($before !== $after) {
+		printf("[002] Statistics have changed\n");
+		var_dump($before);
+		var_dump($after);
+	}
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_charset.phpt
@@ -0,0 +1,115 @@
+--TEST--
+mysqli_get_charset()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_charset'))
+	die("skip: function not available");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_get_charset()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_charset($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_charset($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$res = mysqli_query($link, 'SELECT version() AS server_version'))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	$version = explode('.', $tmp['server_version']);
+	if (empty($version))
+		printf("[005] Cannot determine server version, need MySQL Server 4.1+ for the test!\n");
+
+	if ($version[0] <= 4 && $version[1] < 1)
+		printf("[006] Need MySQL Server 4.1+ for the test!\n");
+
+	if (!$res = mysqli_query($link, 'SELECT @@character_set_connection AS charset, @@collation_connection AS collation'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!($character_set_connection = $tmp['charset']) || !($collation_connection = $tmp['collation']))
+		printf("[008] Cannot determine current character set and collation\n");
+
+	if (!$res = mysqli_query($link, $sql = sprintf("SHOW CHARACTER SET LIKE '%s'", $character_set_connection)))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	if (empty($tmp))
+		printf("[010] Cannot fetch Maxlen and/or Comment, test will fail: $sql\n");
+
+	$maxlen = (isset($tmp['Maxlen'])) ? $tmp['Maxlen'] : '';
+	$comment = (isset($tmp['Description'])) ? $tmp['Description'] : '';
+
+	if (!$res = mysqli_query($link, sprintf("SHOW COLLATION LIKE '%s'", $collation_connection)))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!($id = $tmp['Id']))
+		printf("[012] Cannot fetch Id/Number, test will fail\n");
+
+	if (!$res = mysqli_query($link, sprintf("SHOW VARIABLES LIKE 'character_sets_dir'")))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!($character_sets_dir = $tmp['Value']))
+		printf("[014] Cannot fetch character_sets_dir, test will fail\n");
+
+	if (!is_object($charset = mysqli_get_charset($link)))
+		printf("[015] Expecting object/std_class, got %s/%s\n", gettype($charset), $charset);
+
+	if (!isset($charset->charset) ||
+		!in_array(gettype($charset->charset), array("string", "unicode")) ||
+		($character_set_connection !== $charset->charset))
+		printf("[016] Expecting string/%s, got %s/%s\n", $character_set_connection, gettype($charset->charset), $charset->charset);
+	if (!isset($charset->collation) ||
+		!in_array(gettype($charset->collation), array("string", "unicode")) ||
+		($collation_connection !== $charset->collation))
+		printf("[017] Expecting string/%s, got %s/%s\n", $collation_connection, gettype($charset->collation), $charset->collation);
+
+	if (!isset($charset->dir) ||
+		!is_string($charset->dir))
+		printf("[019] Expecting string - ideally %s*, got %s/%s\n", $character_sets_dir, gettype($charset->dir), $charset->dir);
+
+	if (!isset($charset->min_length) ||
+		!(is_int($charset->min_length)) ||
+		($charset->min_length < 0) ||
+		($charset->min_length > $charset->max_length))
+		printf("[020] Expecting int between 0 ... %d, got %s/%s\n", $charset->max_length,
+			gettype($charset->min_length), $charset->min_length);
+
+	if (!isset($charset->number) ||
+		!is_int($charset->number) ||
+		($charset->number !== (int)$id))
+		printf("[021] Expecting int/%d, got %s/%s\n", $id, gettype($charset->number), $charset->number);
+
+	if (!isset($charset->state) ||
+		!is_int($charset->state))
+		printf("[022] Expecting int/any, got %s/%s\n", gettype($charset->state), $charset->state);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_get_charset($link)))
+		printf("[023] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_get_charset(): Couldn't fetch mysqli in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_info.phpt
@@ -0,0 +1,18 @@
+--TEST--
+mysqli_get_client_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	if (!is_string($info = mysqli_get_client_info()) || ('' === $info))
+		printf("[001] Expecting string/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_stats.phpt
@@ -0,0 +1,1294 @@
+--TEST--
+mysqli_get_client_stats()
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_client_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--INI--
+mysqlnd.collect_statistics=1
+mysqlnd.collect_memory_statistics=1
+--FILE--
+<?php
+	/*
+	TODO
+	no_index_used - difficult to simulate because server/engine dependent
+	bad_index_used - difficult to simulate because server/engine dependent
+	flushed_normal_sets
+	flushed_ps_sets
+	explicit_close
+	implicit_close
+	disconnect_close
+	in_middle_of_command_close
+	explicit_free_result
+	implicit_free_result
+	explicit_stmt_close
+	implicit_stmt_close
+	*/
+
+	function mysqli_get_client_stats_assert_eq($field, $current, $expected, &$test_counter, $desc = "") {
+
+		$test_counter++;
+		if (is_array($current) && is_array($expected)) {
+			if ($current[$field] !== $expected[$field]) {
+				printf("[%03d] %s Expecting %s = %s/%s, got %s/%s\n",
+					$test_counter, $desc,
+					$field, $expected[$field], gettype($expected[$field]),
+					$current[$field], gettype($current[$field]));
+			}
+		} else if (is_array($current)) {
+			if ($current[$field] !== $expected) {
+				printf("[%03d] %s Expecting %s = %s/%s, got %s/%s\n",
+					$test_counter, $desc,
+					$field, $expected, gettype($expected),
+					$current[$field], gettype($current[$field]));
+			}
+		} else {
+			if ($current !== $expected) {
+				printf("[%03d] %s Expecting %s = %s/%s, got %s/%s\n",
+					$test_counter, $desc,
+					$field, $expected, gettype($expected),
+					$current, gettype($current));
+			}
+		}
+
+	}
+
+	function mysqli_get_client_stats_assert_gt($field, $current, $expected, &$test_counter, $desc = "") {
+
+		$test_counter++;
+		if (is_array($current) && is_array($expected)) {
+			if ($current[$field] <= $expected[$field]) {
+				printf("[%03d] %s Expecting %s > %s/%s, got %s/%s\n",
+					$test_counter, $desc,
+					$field, $expected[$field], gettype($expected[$field]),
+					$current[$field], gettype($current[$field]));
+				}
+		} else {
+			if ($current <= $expected) {
+				printf("[%03d] %s Expecting %s > %s/%s, got %s/%s\n",
+					$test_counter, $desc, $field,
+					$expected, gettype($expected),
+					$current, gettype($current));
+			}
+		}
+
+	}
+
+
+	$tmp = $link = null;
+	if (!is_null($tmp = @mysqli_get_client_stats($link)))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require_once("connect.inc");
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[002] Expecting array/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	var_dump($info);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[004] Expecting array/any_non_empty, got %s/%s\n", gettype($new_info), $new_info);
+
+	if (count($info) != count($new_info)) {
+		printf("[005] Expecting the same number of entries in the arrays\n");
+		var_dump($info);
+		var_dump($new_info);
+	}
+
+	$test_counter = 6;
+
+	mysqli_get_client_stats_assert_gt('bytes_sent', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_gt('bytes_received', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_gt('packets_sent', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_gt('packets_received', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_gt('protocol_overhead_in', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_gt('protocol_overhead_out', $new_info, $info, $test_counter);
+
+	// we assume the above as tested and in the following we check only those
+	mysqli_get_client_stats_assert_eq('result_set_queries', $new_info, $info, $test_counter);
+
+	/* we need to skip this test in unicode - we send set names utf8 during mysql_connect */
+	if (!(version_compare(PHP_VERSION, '5.9.9', '>') == 1))
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('buffered_sets', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('unbuffered_sets', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_buffered_sets', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_unbuffered_sets', $new_info, $info, $test_counter);
+
+	mysqli_get_client_stats_assert_eq('rows_skipped_ps', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('copy_on_write_saved', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('copy_on_write_performed', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('command_buffer_too_small', $new_info, $info, $test_counter);
+	// This is not a mistake that I use %unicode|string%(1) "1" here! Andrey did not go for int to avoid any
+	// issues for very large numbers and 32 vs. 64bit systems
+	mysqli_get_client_stats_assert_eq('connect_success', $new_info, "1", $test_counter);
+	mysqli_get_client_stats_assert_eq('connect_failure', $new_info, $info, $test_counter);
+	mysqli_get_client_stats_assert_eq('connection_reused', $new_info, $info, $test_counter);
+
+	// No data fetched so far
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $new_info, "0", $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $new_info, "0", $test_counter);
+
+	require('table.inc');
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	// fetch stats
+	$expected = $info;
+
+	// buffered normal
+	print "Testing buffered normal...\n";
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS _num FROM test', MYSQLI_STORE_RESULT))
+		printf("[%03d] SELECT COUNT() FROM test failed, [%d] %s\n",
+			++$test_counter, mysqli_errno($link), mysqli_error($link));
+
+	$expected['rows_fetched_from_server_normal'] = (string)($expected['rows_fetched_from_server_normal'] + 1);
+	$expected['buffered_sets'] = (string)($expected['buffered_sets'] + 1);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+	$expected['rows_buffered_from_client_normal'] = (string)($expected['rows_buffered_from_client_normal'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_gt('bytes_sent', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_gt('bytes_received', $info, $expected, $test_counter);
+
+	// real_data_* get incremeneted after mysqli_*fetch*()
+    mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, "0", $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, "0", $test_counter);
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_buffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('buffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_normal', $info, $expected, $test_counter);
+
+	/* no change to rows_fetched_from_client_normal_buffered! */
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[%03d] fetch_assoc - SELECT COUNT() FROM test failed, [%d] %s\n",
+			++$test_counter, mysqli_errno($link), mysqli_error($link));
+
+	$expected['rows_fetched_from_client_normal_buffered'] = (string)($expected['rows_fetched_from_client_normal_buffered'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	// fetch will increment
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_normal'] = $info['bytes_received_real_data_normal'];
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, "0", $test_counter);
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_buffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_normal', $info, $expected, $test_counter);
+
+	$num_rows = $row['_num'];
+	mysqli_free_result($res);
+
+	print "Testing buffered normal... - SELECT id, label FROM test\n";
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test', MYSQLI_STORE_RESULT))
+		printf("[%03d] SELECT id, label FROM test failed, [%d] %s\n",
+			++$test_counter, mysqli_errno($link), mysqli_error($link));
+
+
+	assert(mysqli_num_rows($res) == $num_rows);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+
+	$expected['rows_fetched_from_server_normal'] = (string)($expected['rows_fetched_from_server_normal'] + $num_rows);
+	$expected['rows_buffered_from_client_normal'] = (string)($expected['rows_buffered_from_client_normal'] + $num_rows);
+	$expected['buffered_sets'] = (string)($expected['buffered_sets'] + 1);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_buffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('buffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_normal', $info, $expected, $test_counter);
+
+	/* fetching none, but stats should not be affected - current implementation */
+	mysqli_free_result($res);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_buffered', $info, $expected, $test_counter);
+
+	print "Testing unbuffered normal...\n";
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test', MYSQLI_USE_RESULT))
+		printf("[%03d] SELECT id, label FROM test failed, [%d] %s\n",
+			++$test_counter, mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_unbuffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+
+	while ($row = mysqli_fetch_assoc($res))
+		;
+	mysqli_free_result($res);
+
+	$expected['rows_fetched_from_server_normal'] = (string)($expected['rows_fetched_from_server_normal'] + $num_rows);
+	$expected['rows_fetched_from_client_normal_unbuffered'] = (string)($expected['rows_fetched_from_client_normal_unbuffered'] + $num_rows);
+	$expected['unbuffered_sets'] = (string)($expected['unbuffered_sets'] + 1);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_normal'] = $info['bytes_received_real_data_normal'];
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_unbuffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('unbuffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+
+	print "Testing unbuffered normal... - SELECT id, label FROM test, not all fetched\n";
+	if (!$res = mysqli_query($link, 'SELECT id, label FROM test', MYSQLI_USE_RESULT))
+		printf("[%03d] SELECT id, label FROM test failed, [%d] %s\n",
+			++$test_counter, mysqli_errno($link), mysqli_error($link));
+
+	for ($i = 0; $i < $num_rows - 1; $i++)
+		$row = mysqli_fetch_assoc($res);
+
+	$expected['rows_fetched_from_server_normal'] = (string)($expected['rows_fetched_from_server_normal'] + $num_rows - 1);
+	$expected['rows_fetched_from_client_normal_unbuffered'] = (string)($expected['rows_fetched_from_client_normal_unbuffered'] + $num_rows - 1);
+	$expected['unbuffered_sets'] = (string)($expected['unbuffered_sets'] + 1);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_normal'] = $info['bytes_received_real_data_normal'];
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_unbuffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('unbuffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+
+	print "Testing if implicit fetching and cleaning happens...\n";
+	mysqli_free_result($res);
+
+	/* last row has been implicitly cleaned from the wire by freeing the result set */
+	$expected['rows_fetched_from_server_normal'] = (string)($expected['rows_fetched_from_server_normal'] + 1);
+	$expected['rows_fetched_from_client_normal_unbuffered'] = (string)($expected['rows_fetched_from_client_normal_unbuffered'] + 1);
+	$expected['rows_skipped_normal'] = (string)($info['rows_skipped_normal'] + 1);
+	$expected['flushed_normal_sets'] = (string)($expected['flushed_normal_sets'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_normal_unbuffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_skipped_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('flushed_normal_sets', $info, $expected, $test_counter);
+
+	print "Testing buffered Prepared Statements...\n";
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[%03d] stmt_init() failed, [%d] %s\n",
+			++$test_counter, mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test') ||
+			!mysqli_stmt_execute($stmt))
+		printf("[%03d] prepare/execute failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	/* by default PS is unbuffered - no change */
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_ps_buffered', $info, $expected, $test_counter);
+
+	if (!mysqli_stmt_store_result($stmt))
+		printf("[%03d] store_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	mysqli_stmt_free_result($stmt);
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, "0", $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+
+	$expected['rows_fetched_from_server_ps'] = (string)($expected['rows_fetched_from_server_ps'] + $num_rows);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+	$expected['ps_buffered_sets'] = (string)($expected['ps_buffered_sets'] + 1);
+	$expected['rows_buffered_from_client_ps'] = (string)($expected['rows_buffered_from_client_ps'] + $num_rows);
+
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_ps_buffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_buffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_ps', $info, $expected, $test_counter);
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, "0", $test_counter);
+
+	print "Testing buffered Prepared Statements... - fetching all\n";
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test') ||
+			!mysqli_stmt_execute($stmt))
+		printf("[%03d] prepare/execute failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[%03d] bind_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_store_result($stmt))
+		printf("[%03d] store_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	while (mysqli_stmt_fetch($stmt))
+		;
+
+	$expected['rows_fetched_from_server_ps'] = (string)($expected['rows_fetched_from_server_ps'] + $num_rows);
+	$expected['rows_fetched_from_client_ps_buffered'] = (string)($expected['rows_fetched_from_client_ps_buffered'] + $num_rows);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+	$expected['ps_buffered_sets'] = (string)($expected['ps_buffered_sets'] + 1);
+	$expected['rows_buffered_from_client_ps'] = (string)($expected['rows_buffered_from_client_ps'] + $num_rows);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_ps', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_ps'] = $info['bytes_received_real_data_ps'];
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_ps_buffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_buffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_ps', $info, $expected, $test_counter);
+
+	mysqli_stmt_free_result($stmt);
+
+	print "Testing buffered Prepared Statements... - fetching all but one\n";
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test') ||
+			!mysqli_stmt_execute($stmt))
+		printf("[%03d] prepare/execute failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[%03d] bind_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_store_result($stmt))
+		printf("[%03d] store_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	for ($i = 0; $i < $num_rows - 1; $i++)
+		mysqli_stmt_fetch($stmt);
+
+	$expected['rows_fetched_from_server_ps'] = (string)($expected['rows_fetched_from_server_ps'] + $num_rows);
+	$expected['rows_fetched_from_client_ps_buffered'] = (string)($expected['rows_fetched_from_client_ps_buffered'] + $num_rows - 1);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+	$expected['ps_buffered_sets'] = (string)($expected['ps_buffered_sets'] + 1);
+	$expected['rows_buffered_from_client_ps'] = (string)($expected['rows_buffered_from_client_ps'] + $num_rows);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_ps', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_ps'] = $info['bytes_received_real_data_ps'];
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_ps_buffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_buffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_ps', $info, $expected, $test_counter);
+
+	$expected['rows_skipped_ps'] = $info['rows_skipped_ps'];
+	mysqli_stmt_free_result($stmt);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	/* buffered result set - no skipping possible! */
+	mysqli_get_client_stats_assert_eq('rows_skipped_ps', $info, $expected, $test_counter);
+
+	print "Testing unbuffered Prepared Statements... - fetching all\n";
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test') ||
+			!mysqli_stmt_execute($stmt))
+		printf("[%03d] prepare/execute failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[%03d] bind_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$i = 0;
+	while (mysqli_stmt_fetch($stmt))
+		$i++;
+	assert($num_rows = $i);
+
+	$expected['rows_fetched_from_server_ps'] = (string)($expected['rows_fetched_from_server_ps'] + $num_rows);
+	$expected['rows_fetched_from_client_ps_unbuffered'] = (string)($expected['rows_fetched_from_client_ps_unbuffered'] + $num_rows);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+	$expected['ps_unbuffered_sets'] = (string)($expected['ps_unbuffered_sets'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_ps', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_ps'] = $info['bytes_received_real_data_ps'];
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_ps_unbuffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_unbuffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_ps', $info, $expected, $test_counter);
+
+	mysqli_stmt_free_result($stmt);
+
+	print "Testing unbuffered Prepared Statements... - fetching all but one\n";
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test') ||
+			!mysqli_stmt_execute($stmt))
+		printf("[%03d] prepare/execute failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[%03d] bind_result failed, [%d] %s\n",
+			++$test_counter, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	for ($i = 0; $i < $num_rows - 1; $i++)
+		mysqli_stmt_fetch($stmt);
+
+	$expected['rows_fetched_from_server_ps'] = (string)($expected['rows_fetched_from_server_ps'] + $num_rows - 1);
+	$expected['rows_fetched_from_client_ps_unbuffered'] = (string)($expected['rows_fetched_from_client_ps_unbuffered'] + $num_rows - 1);
+	$expected['result_set_queries'] = (string)($expected['result_set_queries'] + 1);
+	$expected['ps_unbuffered_sets'] = (string)($expected['ps_unbuffered_sets'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_ps', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_ps'] = $info['bytes_received_real_data_ps'];
+
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_client_ps_unbuffered', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('result_set_queries', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('ps_unbuffered_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_buffered_from_client_ps', $info, $expected, $test_counter);
+
+	mysqli_stmt_free_result($stmt);
+	$expected['rows_skipped_ps'] = (string)($expected['rows_skipped_ps'] + 1);
+	$expected['flushed_ps_sets'] = (string)($expected['flushed_ps_sets'] + 1);
+	$expected['rows_fetched_from_server_ps'] = (string)($expected['rows_fetched_from_server_ps'] + 1);
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, $expected, $test_counter);
+
+	mysqli_get_client_stats_assert_eq('rows_skipped_ps', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('flushed_ps_sets', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('rows_fetched_from_server_ps', $info, $expected, $test_counter);
+
+	/*
+	print "Checking for normal buffered side effects...\n";
+	foreach ($info as $k => $v)
+		if ($info[$k] != $expected[$k])
+			printf("$k - $v != %s\n", $expected[$k]);
+	*/
+	print "... done with fetch statistics\n";
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, $expected, $test_counter);
+
+	//
+	// result_set_queries statistics
+	//
+
+	if (!is_array($info = mysqli_get_client_stats()) || empty($info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($info), $info);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test"))
+		printf("[%03d] SELECT failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	$rows = 0;
+	while ($row = mysqli_fetch_assoc($res))
+		$rows++;
+
+	if (0 == $rows)
+		printf("[%03d] Expecting at least one result, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+
+	mysqli_get_client_stats_assert_eq('result_set_queries', $new_info, (string)($info['result_set_queries'] + 1), $test_counter);
+	$info = $new_info;
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_normal'] = $info['bytes_received_real_data_normal'];
+
+	//
+	// non_result_set_queries - DDL
+	//
+
+	// CREATE TABLE, DROP TABLE
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS non_result_set_queries_test"))
+		printf("[%03d] DROP TABLE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "CREATE TABLE non_result_set_queries_test(id INT) ENGINE = " . $engine)) {
+		printf("[%03d] CREATE TABLE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+	} else {
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 2), $test_counter, 'CREATE/DROP TABLE');
+	}
+	$info = $new_info;
+
+	// ALERT TABLE
+	if (!mysqli_query($link, "ALTER TABLE non_result_set_queries_test ADD label CHAR(1)")) {
+		printf("[%03d] ALTER TABLE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+	} else {
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'ALTER TABLE');
+	}
+	$info = $new_info;
+
+	// CREATE INDEX, DROP INDEX
+	if (!mysqli_query($link, "CREATE INDEX idx_1 ON non_result_set_queries_test(id)")) {
+		printf("[%03d] CREATE INDEX failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+	} else {
+
+		if (!mysqli_query($link, "DROP INDEX idx_1 ON non_result_set_queries_test"))
+			printf("[%03d] DROP INDEX failed, [%d] %s\n", ++$test_counter,
+				mysqli_errno($link), mysqli_error($link));
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 2), $test_counter, 'DROP INDEX');
+	}
+	$info = $new_info;
+
+	// RENAME TABLE
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS client_stats_test"))
+		printf("[%03d] Cleanup, DROP TABLE client_stats_test failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	$info = $new_info;
+
+	if (!mysqli_query($link, "RENAME TABLE non_result_set_queries_test TO client_stats_test")) {
+		printf("[%03d] RENAME TABLE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	} else {
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'RENAME TABLE');
+
+	}
+	$info = $new_info;
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS non_result_set_queries_test"))
+		printf("[%03d] Cleanup, DROP TABLE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS client_stats_test"))
+		printf("[%03d] Cleanup, DROP TABLE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	// Let's see if we have privileges for CREATE DATABASE
+	mysqli_query($link, "DROP DATABASE IF EXISTS mysqli_get_client_stats");
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	$info = $new_info;
+
+
+	// CREATE, ALTER, RENAME, DROP DATABASE
+	if (mysqli_query($link, "CREATE DATABASE mysqli_get_client_stats")) {
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'CREATE DATABASE');
+		$info = $new_info;
+
+		if (!mysqli_query($link, "ALTER DATABASE DEFAULT CHARACTER SET latin1"))
+			printf("[%03d] ALTER DATABASE failed, [%d] %s\n", ++$test_counter,
+				mysqli_errno($link), mysqli_error($link));
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'CREATE DATABASE');
+		$info = $new_info;
+
+		if (mysqli_get_server_version($link) > 51700) {
+			if (!mysqli_query($link, "RENAME DATABASE mysqli_get_client_stats TO mysqli_get_client_stats_"))
+				printf("[%03d] RENAME DATABASE failed, [%d] %s\n", ++$test_counter,
+					mysqli_errno($link), mysqli_error($link));
+
+			if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+				printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+					++$test_counter, gettype($new_info), $new_info);
+			mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'CREATE DATABASE');
+			$info = $new_info;
+		} else {
+			if (!mysqli_query($link, "CREATE DATABASE mysqli_get_client_stats_"))
+				printf("[%03d] CREATE DATABASE failed, [%d] %s\n", ++$test_counter,
+					mysqli_errno($link), mysqli_error($link));
+			if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+				printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+					++$test_counter, gettype($new_info), $new_info);
+			$info = $new_info;
+		}
+
+		if (!mysqli_query($link, "DROP DATABASE mysqli_get_client_stats_"))
+			printf("[%03d] DROP DATABASE failed, [%d] %s\n", ++$test_counter,
+				mysqli_errno($link), mysqli_error($link));
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'DROP DATABASE');
+		$info = $new_info;
+	}
+
+	// CREATE SERVER, ALTER SERVER, DROP SERVER
+	// We don't really try to use federated, we just want to see if the syntax works
+	mysqli_query($link, "DROP SERVER IF EXISTS myself");
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	$info = $new_info;
+
+	$sql = sprintf("CREATE SERVER myself FOREIGN DATA WRAPPER mysql OPTIONS (user '%s', password '%s', database '%s')",
+		$user, $passwd, $db);
+	if (mysqli_query($link, $sql)) {
+		// server knows about it
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'CREATE SERVER');
+		$info = $new_info;
+
+		if (!mysqli_query($link, sprintf("ALTER SERVER myself OPTIONS(user '%s_')", $user)))
+			printf("[%03d] ALTER SERVER failed, [%d] %s\n", ++$test_counter,
+				mysqli_errno($link), mysqli_error($link));
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'ALTER SERVER');
+		$info = $new_info;
+
+		if (!mysqli_query($link, "DROP SERVER myself"))
+			printf("[%03d] DROP SERVER failed, [%d] %s\n", ++$test_counter,
+				mysqli_errno($link), mysqli_error($link));
+
+		if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+			printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+		mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'DROP SERVER');
+		$info = $new_info;
+	}
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, $expected, $test_counter);
+
+	/*
+	We don't test the NDB ones.
+	13.1. Data Definition Statements
+	13.1.3. ALTER LOGFILE GROUP Syntax
+	13.1.4. ALTER TABLESPACE Syntax
+	13.1.9. CREATE LOGFILE GROUP Syntax
+	13.1.10. CREATE TABLESPACE Syntax
+	13.1.15. DROP LOGFILE GROUP Syntax
+	13.1.16. DROP TABLESPACE Syntax
+	*/
+
+	//
+	// DML
+	//
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+				++$test_counter, gettype($new_info), $new_info);
+	$info = $new_info;
+
+	if (!mysqli_query($link, "INSERT INTO test(id) VALUES (100)"))
+		printf("[%03d] INSERT failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'INSERT');
+	$info = $new_info;
+
+	if (!mysqli_query($link, "UPDATE test SET label ='z' WHERE id = 100"))
+		printf("[%03d] UPDATE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'UPDATE');
+	$info = $new_info;
+
+	if (!mysqli_query($link, "REPLACE INTO test(id, label) VALUES (100, 'b')"))
+		printf("[%03d] INSERT failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'REPLACE');
+	$info = $new_info;
+
+	// NOTE: this will NOT update dbl_ddls counter
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test WHERE id = 100"))
+		printf("[%03d] SELECT@dml failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, $info, $test_counter, 'SELECT@dml');
+	$info = $new_info;
+
+	if (!mysqli_query($link, "DELETE FROM test WHERE id = 100"))
+		printf("[%03d] DELETE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'DELETE');
+	$info = $new_info;
+
+	if (!$res = mysqli_query($link, "TRUNCATE TABLE test"))
+		printf("[%03d] TRUNCATE failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'TRUNCATE');
+	$info = $new_info;
+
+
+	$file = tempnam(sys_get_temp_dir(), 'mysqli_test');
+	if ($fp = fopen($file, 'w')) {
+		@fwrite($fp, '1;"a"');
+		fclose($fp);
+		chmod($file, 0644);
+		$sql = sprintf('LOAD DATA LOCAL INFILE "%s" INTO TABLE test', mysqli_real_escape_string($link, $file));
+		if (mysqli_query($link, $sql)) {
+			if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+				printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+					++$test_counter, gettype($new_info), $new_info);
+			mysqli_get_client_stats_assert_eq('non_result_set_queries', $new_info, (string)($info['non_result_set_queries'] + 1), $test_counter, 'LOAD DATA LOCAL');
+			$info = $new_info;
+		}
+		unlink($file);
+	}
+
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, $expected, $test_counter);
+
+	/*
+	We skip those:
+	13.2. Data Manipulation Statements
+	13.2.2. DO Syntax
+	13.2.3. HANDLER Syntax
+	13.2.5. LOAD DATA INFILE Syntax
+	*/
+	mysqli_query($link, "DELETE FROM test");
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (1, 'a'), (2, 'b')"))
+		printf("[%03d] Cannot insert new records, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[%03d] Cannot SELECT with mysqli_real_query(), [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = mysqli_use_result($link)))
+		printf("[%03d] mysqli_use_result() failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	while ($row = mysqli_fetch_assoc($res))
+		;
+	mysqli_free_result($res);
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('unbuffered_sets', $new_info, (string)($info['unbuffered_sets'] + 1), $test_counter, 'mysqli_use_result()');
+	$info = $new_info;
+
+	if (!$res = mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[%03d] Cannot SELECT with mysqli_real_query() II, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = mysqli_store_result($link)))
+		printf("[%03d] mysqli_use_result() failed, [%d] %s\n", ++$test_counter,
+			mysqli_errno($link), mysqli_error($link));
+
+	while ($row = mysqli_fetch_assoc($res))
+		;
+	mysqli_free_result($res);
+	if (!is_array($new_info = mysqli_get_client_stats()) || empty($new_info))
+		printf("[%03d] Expecting array/any_non_empty, got %s/%s\n",
+			++$test_counter, gettype($new_info), $new_info);
+	mysqli_get_client_stats_assert_eq('buffered_sets', $new_info, (string)($info['buffered_sets'] + 1), $test_counter, 'mysqli_use_result()');
+	$info = $new_info;
+
+	mysqli_close($link);
+
+	mysqli_get_client_stats_assert_gt('bytes_received_real_data_normal', $info, $expected, $test_counter);
+	$expected['bytes_received_real_data_normal'] = $info['bytes_received_real_data_normal'];
+	mysqli_get_client_stats_assert_eq('bytes_received_real_data_ps', $info, $expected, $test_counter);
+
+	/*
+	no_index_used
+	bad_index_used
+	flushed_normal_sets
+	flushed_ps_sets
+	explicit_close
+	implicit_close
+	disconnect_close
+	in_middle_of_command_close
+	explicit_free_result
+	implicit_free_result
+	explicit_stmt_close
+	implicit_stmt_close
+	*/
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS non_result_set_queries_test"))
+	printf("[c003] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS client_stats_test"))
+	printf("[c004] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP DATABASE IF EXISTS mysqli_get_client_stats_"))
+	printf("[c005] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP DATABASE IF EXISTS mysqli_get_client_stats"))
+	printf("[c006] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP SERVER IF EXISTS myself"))
+	printf("[c007] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(160) {
+  [%u|b%"bytes_sent"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_sent"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"protocol_overhead_in"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"protocol_overhead_out"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_ok_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_eof_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_rset_header_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_rset_field_meta_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_rset_row_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_prepare_response_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_change_user_packet"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_sent_command"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_ok"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_eof"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_rset_header"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_rset_field_meta"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_rset_row"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_prepare_response"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"packets_received_change_user"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"result_set_queries"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"non_result_set_queries"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"no_index_used"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bad_index_used"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"slow_queries"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"buffered_sets"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"unbuffered_sets"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"ps_buffered_sets"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"ps_unbuffered_sets"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"flushed_normal_sets"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"flushed_ps_sets"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"ps_prepared_never_executed"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"ps_prepared_once_executed"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_server_normal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_server_ps"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_buffered_from_client_normal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_buffered_from_client_ps"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_client_normal_buffered"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_client_normal_unbuffered"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_client_ps_buffered"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_client_ps_unbuffered"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_fetched_from_client_ps_cursor"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_affected_normal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_affected_ps"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_skipped_normal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"rows_skipped_ps"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"copy_on_write_saved"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"copy_on_write_performed"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"command_buffer_too_small"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"connect_success"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"connect_failure"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"connection_reused"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"reconnect"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"pconnect_success"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"active_connections"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"active_persistent_connections"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"explicit_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"implicit_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"disconnect_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"in_middle_of_command_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"explicit_free_result"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"implicit_free_result"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"explicit_stmt_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"implicit_stmt_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_emalloc_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_emalloc_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_ecalloc_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_ecalloc_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_erealloc_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_erealloc_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_efree_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_efree_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_malloc_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_malloc_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_calloc_count"]=>
+  %unicode|string%(%d) "%d"
+  [%u|b%"mem_calloc_amount"]=>
+  %unicode|string%(%d) "%d"
+  [%u|b%"mem_realloc_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_realloc_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_free_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_free_amount"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_estrndup_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_strndup_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_estndup_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"mem_strdup_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_null"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_bit"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_tinyint"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_short"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_int24"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_int"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_bigint"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_decimal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_float"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_double"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_date"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_year"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_time"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_datetime"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_timestamp"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_string"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_blob"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_enum"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_set"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_geometry"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_text_fetched_other"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_null"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_bit"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_tinyint"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_short"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_int24"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_int"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_bigint"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_decimal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_float"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_double"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_date"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_year"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_time"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_datetime"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_timestamp"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_string"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_blob"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_enum"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_set"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_geometry"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"proto_binary_fetched_other"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"init_command_executed_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"init_command_failed_count"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_quit"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_init_db"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_query"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_field_list"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_create_db"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_drop_db"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_refresh"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_shutdown"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_statistics"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_process_info"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_connect"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_process_kill"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_debug"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_ping"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_time"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_delayed_insert"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_change_user"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_binlog_dump"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_table_dump"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_connect_out"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_register_slave"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_prepare"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_execute"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_send_long_data"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_close"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_reset"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_set_option"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_stmt_fetch"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"com_deamon"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_real_data_normal"]=>
+  %unicode|string%(1) "0"
+  [%u|b%"bytes_received_real_data_ps"]=>
+  %unicode|string%(1) "0"
+}
+Testing buffered normal...
+Testing buffered normal... - SELECT id, label FROM test
+Testing unbuffered normal...
+Testing unbuffered normal... - SELECT id, label FROM test, not all fetched
+Testing if implicit fetching and cleaning happens...
+Testing buffered Prepared Statements...
+Testing buffered Prepared Statements... - fetching all
+Testing buffered Prepared Statements... - fetching all but one
+Testing unbuffered Prepared Statements... - fetching all
+Testing unbuffered Prepared Statements... - fetching all but one
+... done with fetch statistics
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_stats_implicit_free.phpt
@@ -0,0 +1,46 @@
+--TEST--
+mysqli_get_client_stats() - implicit_free_result
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_client_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--INI--
+mysqlnd.collect_statistics=1
+mysqlnd.collect_memory_statistics=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	$stats = mysqli_get_client_stats();
+	printf("BEGINNING: implicit_free_result = %d\n",	$stats['implicit_free_result']);
+
+	if (!$res = mysqli_query($link, 'SELECT id FROM test'))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	$after = mysqli_get_client_stats();
+	if ($after['implicit_free_result'] != $stats['implicit_free_result'])
+		printf("[002] Where is the missing mysqli_free_result() call? implicit_free_result has changed by %d.\n",
+			$after['implicit_free_result'] - $stats['implicit_free_result']);
+
+	$stats = $after;
+	printf("END: implicit_free_result = %d\n",	$stats['implicit_free_result']);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+BEGINNING: implicit_free_result = %d
+END: implicit_free_result = %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_stats_off.phpt
@@ -0,0 +1,48 @@
+--TEST--
+mysqli_get_client_stats() - php_ini setting
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_client_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--INI--
+mysqlnd.collect_statistics=0
+mysqlnd.collect_memory_statistics=0
+--FILE--
+<?php
+	$before = mysqli_get_client_stats();
+	if (!is_array($before) || empty($before)) {
+		printf("[001] Expecting non-empty array, got %s.\n", gettype($before));
+		var_dump($before);
+	}
+
+	// connect and table inc connect to mysql and create tables
+	require_once('connect.inc');
+	require_once('table.inc');
+	$after = mysqli_get_client_stats();
+
+	if ($before !== $after) {
+		printf("[002] Statistics have changed\n");
+		var_dump($before);
+		var_dump($after);
+	}
+
+	foreach ($after as $k => $v)
+		if ($v != 0) {
+			printf("[003] Field %s should not have any other value but 0, got %s.\n",
+				$k, $v);
+		}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_stats_ps.phpt
@@ -0,0 +1,106 @@
+--TEST--
+mysqli_get_client_stats() - PS
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_client_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--INI--
+mysqlnd.collect_statistics=1
+mysqlnd.collect_memory_statistics=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	$stats = mysqli_get_client_stats();
+	printf("BEGINNING: rows_fetched_from_client_ps_unbuffered = %d\n",	$stats['rows_fetched_from_client_ps_unbuffered']);
+	printf("BEGINNING: rows_fetched_from_client_ps_buffered = %d\n",	$stats['rows_fetched_from_client_ps_buffered']);
+	printf("BEGINNING: rows_fetched_from_client_ps_cursor = %d\n",	$stats['rows_fetched_from_client_ps_cursor']);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$id = null;
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id FROM test') ||
+			!mysqli_stmt_execute($stmt) ||
+			!mysqli_stmt_store_result($stmt) ||
+			!mysqli_stmt_bind_result($stmt, $id))
+		printf("[002] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$num_rows = 0;
+	while (mysqli_stmt_fetch($stmt))
+		$num_rows++;
+
+	mysqli_stmt_free_result($stmt);
+
+	$after = mysqli_get_client_stats();
+
+	if ($after['rows_fetched_from_client_ps_unbuffered'] != $stats['rows_fetched_from_client_ps_unbuffered'])
+		printf("[003] Unbuffered rows got increased after buffered PS, expecting %d got %d.\n",
+			$stats['rows_fetched_from_client_ps_unbuffered'],
+			$after['rows_fetched_from_client_ps_unbuffered']);
+
+	$stats['rows_fetched_from_client_ps_buffered'] += $num_rows;
+	if ($after['rows_fetched_from_client_ps_buffered'] != $stats['rows_fetched_from_client_ps_buffered'] )
+		printf("[005] Buffered rows should be %d got %d.\n",
+			$stats['rows_fetched_from_client_ps_buffered'],
+			$after['rows_fetched_from_client_ps_buffered']);
+
+	$stats = $after;
+	printf("BUFFERED: rows_fetched_from_client_ps_unbuffered = %d\n",	$stats['rows_fetched_from_client_ps_unbuffered']);
+	printf("BUFFERED: rows_fetched_from_client_ps_buffered = %d\n",	$stats['rows_fetched_from_client_ps_buffered']);
+	printf("BUFFERED: rows_fetched_from_client_ps_cursor = %d\n",	$stats['rows_fetched_from_client_ps_cursor']);
+
+	$id = null;
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id FROM test') ||
+			!mysqli_stmt_execute($stmt) ||
+			!mysqli_stmt_bind_result($stmt, $id))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$num_rows = 0;
+	while (mysqli_stmt_fetch($stmt))
+		$num_rows++;
+
+	$after = mysqli_get_client_stats();
+	$stats['rows_fetched_from_client_ps_unbuffered'] += $num_rows;
+	if ($after['rows_fetched_from_client_ps_unbuffered'] != $stats['rows_fetched_from_client_ps_unbuffered'])
+		printf("[007] Unbuffered rows should be %d got %d.\n",
+			$stats['rows_fetched_from_client_ps_unbuffered'],
+			$after['rows_fetched_from_client_ps_unbuffered']);
+
+	if ($after['rows_fetched_from_client_ps_buffered'] != $stats['rows_fetched_from_client_ps_buffered'] )
+		printf("[005] Buffered rows should be unchanged, expecting %d got %d.\n",
+			$stats['rows_fetched_from_client_ps_buffered'],
+			$after['rows_fetched_from_client_ps_buffered']);
+
+	mysqli_stmt_free_result($stmt);
+	mysqli_stmt_close($stmt);
+
+	$stats = $after;
+	printf("UNBUFFERED: rows_fetched_from_client_ps_unbuffered = %d\n",	$stats['rows_fetched_from_client_ps_unbuffered']);
+	printf("UNBUFFERED: rows_fetched_from_client_ps_buffered = %d\n",	$stats['rows_fetched_from_client_ps_buffered']);
+	printf("UNBUFFERED: rows_fetched_from_client_ps_cursor = %d\n",	$stats['rows_fetched_from_client_ps_cursor']);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+BEGINNING: rows_fetched_from_client_ps_unbuffered = %d
+BEGINNING: rows_fetched_from_client_ps_buffered = %d
+BEGINNING: rows_fetched_from_client_ps_cursor = 0
+BUFFERED: rows_fetched_from_client_ps_unbuffered = %d
+BUFFERED: rows_fetched_from_client_ps_buffered = %d
+BUFFERED: rows_fetched_from_client_ps_cursor = 0
+UNBUFFERED: rows_fetched_from_client_ps_unbuffered = %d
+UNBUFFERED: rows_fetched_from_client_ps_buffered = %d
+UNBUFFERED: rows_fetched_from_client_ps_cursor = 0
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_stats_skipped.phpt
@@ -0,0 +1,52 @@
+--TEST--
+mysqli_get_client_stats() - skipped rows
+--INI--
+mysqlnd.collect_statistics="1"
+mysqlnd.collect_memory_statistics="1"
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_client_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	if (!$res = mysqli_query($link, 'SELECT id FROM test', MYSQLI_STORE_RESULT))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$num_rows = mysqli_num_rows($res);
+	assert($num_rows > 2);
+	mysqli_free_result($res);
+
+	$before = mysqli_get_client_stats();
+	printf("BEFORE: rows_skipped_normal = %d\n", $before['rows_skipped_normal']);
+
+	if (!$res = mysqli_query($link, 'SELECT id FROM test', MYSQLI_USE_RESULT))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	/* fetch all rows but the last one */
+	for ($i = 0; $i < $num_rows - 1; $i++)
+		$row = mysqli_fetch_assoc($res);
+
+	/* enforce implicit cleaning of the wire and skipping the last row */
+	mysqli_free_result($res);
+	$after = mysqli_get_client_stats();
+	printf("AFTER: rows_skipped_normal = %d\n", $after['rows_skipped_normal']);
+
+	if ($after['rows_skipped_normal'] != $before['rows_skipped_normal'] + 1)
+		printf("Statistics should show an increase of 1 for rows_skipped_normal, ".
+				"but before=%d after=%d\n", $before['rows_skipped_normal'], $after['rows_skipped_normal']);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+BEFORE: rows_skipped_normal = %d
+AFTER: rows_skipped_normal = %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_client_version.phpt
@@ -0,0 +1,14 @@
+--TEST--
+mysqli_get_client_version()
+--SKIPIF--
+<?php require_once('skipif.inc'); ?>
+<?php require_once('skipifemb.inc'); ?>
+--FILE--
+<?php	
+	if (!is_int($info = mysqli_get_client_version()) || ($info < 100))
+		printf("[001] Expecting int/any_non_empty, got %s/%s\n", gettype($info), $info);
+		
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_connection_stats.phpt
@@ -0,0 +1,87 @@
+--TEST--
+mysqli_get_connection_stats()
+--INI--
+mysqlnd.collect_statistics="1"
+mysqlnd.collect_memory_statistics="1"
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_connection_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--FILE--
+<?php
+	$tmp = $link = null;
+	if (!is_null($tmp = @mysqli_get_connection_stats()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_connection_stats($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require("table.inc");
+
+	if (!is_array($info = mysqli_get_connection_stats($link)) || empty($info))
+		printf("[003] Expecting array/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	if (!is_array($info2 = mysqli_get_client_stats()) || empty($info2))
+		printf("[004] Expecting array/any_non_empty, got %s/%s\n", gettype($info2), $info2);
+
+	foreach ($info as $k => &$v) {
+		if (strpos($k, "mem_") === 0) {
+			$v = 0;
+		}
+	}
+	foreach ($info2 as $k => &$v) {
+		if (strpos($k, "mem_") === 0) {
+			$v = 0;
+		}
+	}
+
+	if ($info !== $info2) {
+		printf("[005] The hashes should be identical except of the memory related fields\n");
+		var_dump($info);
+		var_dump($info2);
+	}
+
+	if (!is_array($info = $link->get_connection_stats()) || empty($info))
+		printf("[006] Expecting array/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	foreach ($info as $k => &$v) {
+		if (strpos($k, "mem_") === 0) {
+			$v = 0;
+		}
+	}
+
+	if ($info !== $info2) {
+		printf("[007] The hashes should be identical except of the memory related fields\n");
+		var_dump($info);
+		var_dump($info2);
+	}
+
+	mysqli_close($link);
+	require("table.inc");
+
+	if (!is_array($info = mysqli_get_connection_stats($link)) || empty($info))
+		printf("[008] Expecting array/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	if (!is_array($info2 = mysqli_get_client_stats()) || empty($info2))
+		printf("[009] Expecting array/any_non_empty, got %s/%s\n", gettype($info2), $info2);
+
+	// assuming the test is run in a plain-vanilla CLI environment
+	if ($info === $info2) {
+		printf("[010] The hashes should not be identical\n");
+		var_dump($info);
+		var_dump($info2);
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_connection_stats_off.phpt
@@ -0,0 +1,53 @@
+--TEST--
+mysqli_get_connection_stats() - disable via php.ini
+--INI--
+mysqlnd.collect_statistics="0"
+mysqlnd.collect_memory_statistics="0"
+--SKIPIF--
+<?PHP
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_get_connection_stats')) {
+	die("skip only available with mysqlnd");
+}
+?>
+--FILE--
+<?php
+	// connect and table inc connect to mysql and create tables
+	require_once('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+	$before = mysqli_get_connection_stats($link);
+	if (!is_array($before) || empty($before)) {
+		printf("[002] Expecting non-empty array, got %s.\n", gettype($before));
+		var_dump($before);
+	}
+
+	mysqli_close($link);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+	$after = mysqli_get_connection_stats($link);
+
+	if ($before !== $after) {
+		printf("[004] Statistics differ!");
+		var_dump($before);
+		var_dump($after);
+	}
+
+	foreach ($after as $k => $v)
+		if ($v != 0) {
+			printf("[004] Field %s should not have any other value but 0, got %s.\n",
+				$k, $v);
+		}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_host_info.phpt
@@ -0,0 +1,35 @@
+--TEST--
+mysqli_get_host_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!is_null($tmp = @mysqli_get_host_info()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_host_info(NULL)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require "table.inc";
+	if (!is_string($info = mysqli_get_host_info($link)) || ('' === $info))
+		printf("[003] Expecting string/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	if ($IS_MYSQLND && $host != 'localhost' && $host != '127.0.0.1' && $port != '' && $host != "" && strtoupper(substr(PHP_OS, 0, 3)) != 'WIN') {
+		/* this should be a TCP/IP connection and not a Unix Socket (or SHM or Named Pipe) */
+		if (!stristr($info, "TCP/IP"))
+			printf("[004] Should be a TCP/IP connection but mysqlnd says '%s'\n", $info);	
+	}
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_proto_info.phpt
@@ -0,0 +1,29 @@
+--TEST--
+mysqli_get_proto_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!is_null($tmp = @mysqli_get_proto_info()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_proto_info(NULL)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require "table.inc";
+	if (!is_int($info = mysqli_get_proto_info($link)) || ($info < 1))
+		printf("[003] Expecting int/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	if (!is_null($tmp = @mysqli_get_proto_info('too many', 'arguments')))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_server_info.phpt
@@ -0,0 +1,33 @@
+--TEST--
+mysqli_get_server_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!is_null($tmp = @mysqli_get_server_info()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_server_info(NULL)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require "table.inc";
+	if (!is_string($info = mysqli_get_server_info($link)) || ('' === $info))
+		printf("[003] Expecting string/any_non_empty, got %s/%s\n", gettype($info), $info);
+
+	if (!is_null($tmp = @mysqli_get_server_info('too', 'many arguments')))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_server_version.phpt
@@ -0,0 +1,28 @@
+--TEST--
+mysqli_get_server_version()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!is_null($tmp = @mysqli_get_server_version()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_server_version(NULL)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require "table.inc";
+	/* 5.1.5 -> 50105 -- major_version*10000 + minor_version *100 + sub_version */
+	/* < 30000 = pre 3.2.3, very unlikely! */
+	if (!is_int($info = mysqli_get_server_version($link)) || ($info < (3 * 10000)))
+		printf("[003] Expecting int/any >= 30000, got %s/%s\n", gettype($info), $info);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_get_warnings.phpt
@@ -0,0 +1,160 @@
+--TEST--
+mysqli_get_warnings() - TODO
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_get_warnings()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_warnings($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_get_warnings('')))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (false !== ($tmp = mysqli_get_warnings($link))) {
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	}
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "CREATE TABLE test (id SMALLINT)"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test (id) VALUES (1000000)"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($warning = mysqli_get_warnings($link)) || 'mysqli_warning' != get_class($warning)) {
+		printf("[008] Expecting object/mysqli_warning, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	}
+
+	if (!method_exists($warning, 'next'))
+		printf("[009] Borked object, method next is missing\n");
+
+	$properties = array_merge(get_object_vars($warning), get_class_vars(get_class($warning)));
+	if (!empty($properties))
+		printf("[010] Properties have always been magic, hidden things - why are they visible now, a BC break...\n");
+
+	if ((!is_string($warning->message)) || ('' == $warning->message)) /* NULL or not there at all */
+		printf("[011] Expecting string/not empty, got %s/%s\n", gettype($warning->message), $warning->message);
+
+	if ((!is_string($warning->sqlstate)) || ('' == $warning->sqlstate)) /* NULL or not there at all */
+		printf("[012] Expecting string/not empty, got %s/%s\n", gettype($warning->sqlstate), $warning->sqlstate);
+
+	if ((!is_int($warning->errno)) || (0 == $warning->errno)) /* NULL or not there at all */
+		printf("[013] Expecting int/not 0, got %s/%s\n", gettype($warning->errno), $warning->errno);
+
+	if (false !== ($tmp = $warning->next()))
+		printf("[014] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "INSERT INTO test (id) VALUES (1000000), (1000001)"))
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (($tmp = mysqli_warning_count($link)) !== 2)
+		printf("[016] Expecting 2 warnings, got %d warnings", $tmp);
+
+	if (!is_object($warning = mysqli_get_warnings($link)) || 'mysqli_warning' != get_class($warning)) {
+		printf("[017] Expecting object/mysqli_warning, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	}
+
+	if (true !== ($tmp = $warning->next()))
+		printf("[018] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $warning->next()))
+		printf("[020] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[021] Cannot create mysqli object: [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$mysqli->query("DROP TABLE IF EXISTS t1"))
+		printf("[022] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$mysqli->query("CREATE TABLE t1 (a smallint)"))
+		printf("[023] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($warning = new mysqli_warning($mysqli)))
+		printf("[024] Expecting object/mysqli_warning, got %s/%s", gettype($warning), $warning);
+
+	if (!is_string($warning->message) || ('' == $warning->message))
+		printf("[025] Expecting string, got %s/%s", gettype($warning->message), $warning->message);
+
+	if (!$mysqli->query("DROP TABLE t1"))
+		printf("[026] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	/* Yes, I really want to check if the object property is empty */
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[027] Cannot create mysqli object: [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	$warning = new mysqli_warning($mysqli);
+	if (false !== ($tmp = $warning->next()))
+		printf("[028] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ('' != ($tmp = $warning->message))
+		printf("[029] Expecting string/empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[030] Cannot create mysqli object: [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$mysqli->query("DROP TABLE IF EXISTS t1"))
+		printf("[031] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$mysqli->query("CREATE TABLE t1 (a smallint)"))
+		printf("[032] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	/* out of range, three warnings */
+	if (!$mysqli->query("INSERT IGNORE INTO t1(a) VALUES (65536), (65536), (65536)"))
+		printf("[033] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$warning = new mysqli_warning($mysqli);
+		$i = 1;
+	while ($warning->next() && ('' != ($tmp = $warning->message))) {
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp))
+			printf("[033a] Warning should have been a unicode string, got %s/%s", gettype($tmp), $tmp);
+		$i++;
+	}
+	if (3 != $i)
+		printf("[034] Expecting three warnings, got %d warnings\n", $i);
+
+	$stmt = mysqli_stmt_init();
+	$warning = new mysqli_warning($stmt);
+	if (false !== ($tmp = $warning->next()))
+		printf("[035] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS t1"))
+	printf("[c003] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_info.phpt
@@ -0,0 +1,101 @@
+--TEST--
+mysqli_info()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!is_null($tmp = @mysqli_info()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_info(NULL)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require "table.inc";
+	if (!$res = mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, 'a')"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// NOTE: empty string, no multiple insert syntax
+	if (!is_string($tmp = mysqli_info($link)) || ('' != $tmp))
+		printf("[004] Expecting string/empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "INSERT INTO test(id, label) VALUES (101, 'a'), (102, 'b')"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_string($tmp = mysqli_info($link)) || ('' == $tmp))
+		printf("[006] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1) && !is_unicode($tmp))
+		printf("[007] Expecting unicode, because unicode mode it on. Got binary string\n");
+
+	if (!$res = mysqli_query($link, 'INSERT INTO test(id, label) SELECT id + 200, label FROM test'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_string($tmp = mysqli_info($link)) || ('' == $tmp))
+		printf("[008] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, 'ALTER TABLE test MODIFY label CHAR(2)'))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_string($tmp = mysqli_info($link)) || ('' == $tmp))
+		printf("[010] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "UPDATE test SET label = 'b' WHERE id >= 100"))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_string($tmp = mysqli_info($link)) || ('' == $tmp))
+		printf("[012] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "SELECT 1"))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_string($tmp = mysqli_info($link)) || ('' != $tmp))
+		printf("[014] Expecting string/empty, got %s/%s\n", gettype($tmp), $tmp);
+	mysqli_free_result($res);
+
+	// NOTE: no LOAD DATA INFILE test
+	if ($dir = sys_get_temp_dir()) {
+		do {
+			$file = $dir . '/' . 'mysqli_info_phpt.cvs';
+			if (!$fp = fopen($file, 'w'))
+				/* ignore this error */
+				break;
+
+			if (!fwrite($fp, b"100;'a';\n") ||
+				!fwrite($fp, b"101;'b';\n") ||
+				!fwrite($fp, b"102;'c';\n")) {
+				@unlink($file);
+				break;
+			}
+			fclose($fp);
+			if (!mysqli_query($link, "DELETE FROM test")) {
+				printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+
+			if (!@mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE test FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\'' LINES TERMINATED BY '\n'", $file))) {
+				/* ok, because we might not be allowed to do this */
+				@unlink($file);
+				break;
+			}
+
+			if (!is_string($tmp = mysqli_info($link)) || ('' == $tmp))
+				printf("[016] Expecting string/any_non_empty, got %s/%s\n", gettype($tmp), $tmp);
+
+			unlink($file);
+		} while (false);
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_init.phpt
@@ -0,0 +1,25 @@
+--TEST--
+mysqli_init()
+--SKIPIF--
+<?php 
+require_once('skipif.inc');
+require_once('skipifemb.inc'); 
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	$link = mysqli_init();
+
+	if (!is_object($link) && false !== $link)
+		printf("[001] Expecting object/mysqli_link or boolean/false, got %s/%s\n", gettype($link), $link);
+
+	if (is_object($link) && 'mysqli' != get_class($link))
+		printf("[002] Expecting object of type mysqli got object of type %s\n", get_class($link));
+
+	if ($link)
+		mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_insert_id.phpt
@@ -0,0 +1,140 @@
+--TEST--
+mysqli_insert_id()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_insert_id()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_insert_id($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (0 !== ($tmp = mysqli_insert_id($link)))
+		printf("[003] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id LIMIT 1")) {
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (0 !== ($tmp = mysqli_insert_id($link)))
+		printf("[005] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+	mysqli_free_result($res);
+
+	// no auto_increment column
+	if (!$res = mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, 'a')")) {
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (0 !== ($tmp = mysqli_insert_id($link)))
+		printf("[007] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "ALTER TABLE test MODIFY id INT NOT NULL AUTO_INCREMENT")) {
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!$res = mysqli_query($link, "INSERT INTO test(label) VALUES ('a')")) {
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (($last_id = mysqli_insert_id($link)) <= 0)
+		printf("[010] Expecting int/any >0, got %s/%s\n", gettype($last_id), $last_id);
+
+	if (mysqli_query($link, "LOCK TABLE test WRITE")) {
+		/* we need exclusive access for a moment */
+		/* let's hope nobody changes auto_increment_increment while this code executes */
+		do {
+			if (mysqli_get_server_version($link) >= 50000) {
+				if (!$res = mysqli_query($link, 'SELECT @@auto_increment_increment AS inc')) {
+					printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+					break;
+				}
+				if (!$row = mysqli_fetch_assoc($res)) {
+					printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+					break;
+				}
+				mysqli_free_result($res);
+				$inc = $row['inc'];
+			} else {
+				$inc = 1;
+			}
+
+			if (!mysqli_query($link, "INSERT INTO test(label) VALUES ('b')")) {
+				printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+			if (($next_id = mysqli_insert_id($link)) <= $last_id)
+				/*
+				very likely a bug, but someone could have done something on the server
+				between the second last insert and the lock, therefore don't stop just bail
+				*/
+				printf("[014] Expecting int/any > %d, got %s/%s\n", $last_id, gettype($next_id), $next_id);
+
+			$last_id = $next_id;
+			if (!mysqli_query($link, "INSERT INTO test(label) VALUES ('c'), ('d'), ('e')")) {
+				printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+			/*
+			Note: For a multiple-row insert, LAST_INSERT_ID() and mysql_insert_id() actually
+			return the AUTO_INCREMENT key from the first of the inserted rows. This allows
+			multiple-row inserts to be reproduced correctly on other servers in a replication setup.
+			*/
+			if (($next_id = mysqli_insert_id($link)) != $last_id + $inc) {
+				printf("[016] Expecting int/%d, got %s/%s\n", $last_id + 1, gettype($next_id), $next_id);
+				break;
+			}
+
+			if (!$res = mysqli_query($link, "SELECT LAST_INSERT_ID() AS last_id")) {
+				printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+			if (!$row = mysqli_fetch_assoc($res)) {
+				printf("[018] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+			mysqli_free_result($res);
+
+			if ($next_id != $row['last_id']) {
+				printf("[019] Something is wrong, check manually. Expecting %s got %s.\n",
+					$next_id, $row['last_id']);
+				break;
+			}
+		} while (false);
+		mysqli_query($link, "UNLOCK TABLE test");
+	}
+
+	if (!$res = mysqli_query($link, "INSERT INTO test(id, label) VALUES (1000, 'a')")) {
+		printf("[020] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (1000 !== ($tmp = mysqli_insert_id($link)))
+		printf("[021] Expecting int/1000, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "INSERT INTO test(label) VALUES ('b'), ('c')")) {
+		printf("[022] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	if (1000 >= ($tmp = mysqli_insert_id($link)))
+		printf("[023] Expecting int/>1000, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	var_dump(mysqli_insert_id($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_insert_id(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_insert_id_variation.phpt
@@ -0,0 +1,103 @@
+--TEST--
+Checking last_insert_id after different operations
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require_once("connect.inc");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+    printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+                        $host, $user, $db, $port, $socket);
+
+$link->query("DROP TABLE IF EXISTS test_insert_id_var");
+$link->query("CREATE TABLE test_insert_id_var (id INT auto_increment, PRIMARY KEY (id))");
+$link->query("INSERT INTO test_insert_id_var VALUES (null)");
+$i = $link->insert_id;
+
+if (!$i) {
+    printf("[001] Got no valid insert id: %s", var_export($i, true));
+    die();
+}
+
+
+$link->options(MYSQLI_OPT_LOCAL_INFILE, false);
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[002] mysqli_option changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+
+/*
+$link->dump_debug_info();
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[003] mysqli_debug_info changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+*/
+
+$link->stat();
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[004] mysqli_stat changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+
+/*$link->kill($link->thread_id);
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[005] mysqli_kill changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}*/
+
+$link->ping();
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[006] mysqli_ping changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+
+/*
+mysqlnd resets the IDE to 0
+libmysql doesn't
+
+$link->change_user ($user, $passwd, $db);
+if (0 != $link->insert_id || 0 != mysqli_insert_id($link)) {
+    printf("[007] mysqli_change_user changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+*/
+
+$stmt = $link->prepare("SELECT 1");
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[008a] mysqli_prepare changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+echo mysqli_error($link);
+if (0 != $stmt->insert_id || 0 != mysqli_stmt_insert_id($stmt)) {
+    printf("[008b] mysqli_stmt doesn't initialise insert_id: %s", var_export($stmt->insert_id, true));
+    die();
+}
+
+unset($stmt);
+if ($i != $link->insert_id || $i != mysqli_insert_id($link)) {
+    printf("[009] stmt free changes insert_id: %s", var_export($link->insert_id, true));
+    die();
+}
+
+$link->query("DROP TABLE IF EXISTS test_insert_id_var");
+
+echo "DONE";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_insert_id_var"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+DONE
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_insert_packet_overflow.phpt
@@ -0,0 +1,116 @@
+--TEST--
+INSERT and packet overflow
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("SKIP [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
+
+$max_len = pow(2, 24);
+if (!$res = mysqli_query($link, "SHOW GLOBAL VARIABLES LIKE 'max_allowed_packet'"))
+	die(sprintf("SKIP [%d] %s\n", mysqli_errno($link), mysqli_error($link)));
+
+if (!mysqli_query($link, "SET NAMES 'latin1'"))
+	die(sprintf("SKIP [%d] %s\n", mysqli_errno($link), mysqli_error($link)));
+
+mysqli_close($link);
+?>
+--INI--
+memory_limit=256M
+--FILE--
+<?php
+	require('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($link, "SHOW GLOBAL VARIABLES LIKE 'max_allowed_packet'"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (0 === ($org_max_allowed_packet = (int)$row['Value']))
+		printf("[004] Cannot determine max_allowed_packet size and/or bogus max_allowed_packet setting used.\n");
+
+	$max_len = pow(2, 24);
+	if ($org_max_allowed_packet < $max_len) {
+		if (!mysqli_query($link, "SET GLOBAL max_allowed_packet = " . ($max_len + 100))) {
+			if (1227 == mysqli_errno($link)) {
+				/* [1227] Access denied; you need the SUPER privilege for this operation */
+				print "done!";
+				exit(0);
+			} else {
+				printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			}
+		}
+	}
+	mysqli_close($link);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[006] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!mysqli_query($link, "SET NAMES 'latin1'"))
+		printf("[007] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($link, "SHOW GLOBAL VARIABLES LIKE 'max_allowed_packet'"))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (0 === ($max_allowed_packet = (int)$row['Value']))
+		printf("[010] Cannot determine max_allowed_packet size and/or bogus max_allowed_packet setting used.\n");
+
+	$max_len = pow(2, 24);
+	if ($max_allowed_packet < $max_len) {
+		printf("[011] Failed to change max_allowed_packet");
+	}
+
+	if (!mysqli_query($link, "CREATE TABLE test(col_blob LONGBLOB) ENGINE=" . $engine))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$query_prefix = "INSERT INTO test(col_blob) VALUES ('";
+	$query_postfix = "')";
+	$query_len = strlen($query_prefix) + strlen($query_postfix);
+	$com_query_len = 2;
+
+
+	$blob = str_repeat('a', $max_len - $com_query_len - $query_len);
+	$query = sprintf("%s%s%s", $query_prefix, $blob, $query_postfix);
+
+	if (!mysqli_query($link, $query))
+		printf("[013] max_allowed_packet = %d, strlen(query) = %d, [%d] %s\n", $max_allowed_packet, strlen($query), mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SELECT col_blob FROM test"))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res)) {
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	} else {
+		if ($row['col_blob'] != $blob) {
+			printf("[016] Blob seems wrong, dumping data\n");
+			var_dump(strlen($row['col_blob']));
+			var_dump(strlen($blob));
+		}
+		mysqli_free_result($res);
+	}
+
+	if (!mysqli_query($link, "SET GLOBAL max_allowed_packet = " . $org_max_allowed_packet))
+		if (1227 != mysqli_errno($link))
+			printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_kill.phpt
@@ -0,0 +1,133 @@
+--TEST--
+mysqli_kill()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_kill()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_kill($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	// Zend will cast the NULL to 0
+	if (!is_bool($tmp = mysqli_kill($link, null)))
+		printf("[003] Expecting boolean/any, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$thread_id = mysqli_thread_id($link))
+		printf("[004] Cannot determine thread id, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$tmp = mysqli_kill($link, $thread_id);
+	if (!is_bool($tmp))
+		printf("[005] Expecting boolean/any, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($res = mysqli_query($link, "SELECT id FROM test LIMIT 1"))
+		pintf("[006] Expecting boolean/false, got %s/%s\n", gettype($res), $res);
+
+	var_dump($error = mysqli_error($link));
+	if (!is_string($error) || ('' === $error))
+		printf("[007] Expecting string/any non empty, got %s/%s\n", gettype($error), $error);
+	var_dump($res);
+	var_dump($link);
+	if ($IS_MYSQLND) {
+		if ($link->info != 'Records: 6  Duplicates: 0  Warnings: 0') {
+			printf("[008] mysqlnd used to be more verbose and used to support SELECT");
+		}
+		if ($link->stat != NULL) {
+			printf("[009] NULL expected because of error.\n");
+		}
+	} else {
+		if ($link->info != NULL) {
+			printf("[010] Time for wonders - libmysql has started to support SELECT, change test");
+		}
+	}
+
+	mysqli_close($link);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[011] Cannot connect, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	mysqli_kill($link, -1);
+	if ((!$res = mysqli_query($link, "SELECT id FROM test LIMIT 1")) ||
+		(!$tmp = mysqli_fetch_assoc($res))) {
+		printf("[012] Connection should not be gone, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	var_dump($tmp);
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[013] Cannot connect, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	mysqli_change_user($link, "This might work if you accept anonymous users in your setup", "password", $db);      mysqli_kill($link, -1);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+%unicode|string%(%d) "%s"
+bool(false)
+object(mysqli)#%d (%d) {
+  [%u|b%"affected_rows"]=>
+  int(-1)
+  [%u|b%"client_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"client_version"]=>
+  int(%d)
+  [%u|b%"connect_errno"]=>
+  int(0)
+  [%u|b%"connect_error"]=>
+  NULL
+  [%u|b%"errno"]=>
+  int(2006)
+  [%u|b%"error"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"field_count"]=>
+  int(0)
+  [%u|b%"host_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"info"]=>
+  %s
+  [%u|b%"insert_id"]=>
+  int(0)
+  [%u|b%"server_info"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"server_version"]=>
+  int(%d)
+  ["stat"]=>
+  %s
+  [%u|b%"sqlstate"]=>
+  %unicode|string%(5) "HY000"
+  [%u|b%"protocol_version"]=>
+  int(10)
+  [%u|b%"thread_id"]=>
+  int(%d)
+  [%u|b%"warning_count"]=>
+  int(0)
+}
+
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+array(1) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_last_insert_id.phpt
@@ -0,0 +1,194 @@
+--TEST--
+API vs. SQL LAST_INSERT_ID()
+--SKIPIF--
+<?php
+  require_once('skipif.inc');
+  require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/*
+	CAUTION: the insert_id() API call is not supposed to return
+	the same value as a call to the LAST_INSERT_ID() SQL function.
+	It is not necessarily a bug if API and SQL function return different
+	values. Check the MySQL C API reference manual for details.
+	*/
+	require_once("connect.inc");
+
+	function get_sql_id($link) {
+		if (!($res = $link->query("SELECT LAST_INSERT_ID() AS _id"))) {
+			printf("[003] [%d] %s\n", $link->errno, $link->error);
+			return NULL;
+		}
+		$row = $res->fetch_assoc();
+		$res->close();
+
+		return $row['_id'];
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$link->query("DROP TABLE IF EXISTS test") ||
+		!$link->query("CREATE TABLE test (id INT auto_increment, label varchar(10) not null, PRIMARY KEY (id)) ENGINE=MyISAM") ||
+		!$link->query("INSERT INTO test (id, label) VALUES (null, 'a')")) {
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+	}
+
+	$api_id = $link->insert_id;
+	$sql_id = get_sql_id($link);
+	printf("API: %d, SQL: %d\n", $api_id, $sql_id);
+
+	if ($api_id < 1)
+		printf("[004] Expecting id > 0 got %d, [%d] %s\n", $api_id, $link->errno, $link->error)	;
+	if ($api_id != $sql_id)
+		printf("[005] SQL id %d should be equal to API id %d\n", $sql_id, $api_id);
+
+	// Not an INSERT, API value must become 0
+	if (!($res = $link->query("SELECT 1 FROM DUAL")))
+		printf("[006] [%d] %s\n", $link->errno, $link->error);
+	else
+		$res->close();
+
+	$api_id = $link->insert_id;
+	$new_sql_id = get_sql_id($link);
+	if (0 !== $api_id) {
+		printf("[007] API id should have been reset to 0 because previous query was SELECT, got API %d, SQL %d\n",
+		  $api_id, $new_sql_id);
+	}
+	if ($new_sql_id != $sql_id) {
+		printf("[008] The servers LAST_INSERT_ID() changed unexpectedly from %d to %d\n", $sql_id, $new_sql_id);
+	}
+
+	// Insert fails, LAST_INSERT_ID shall not change, API shall return 0
+	if ($link->query("INSERT INTO test (id, label) VALUES (null, null)")) {
+		printf("[009] The INSERT did not fail as planned, [%d] %s\n", $link->errno, $link->error);
+	}
+	$api_id = $link->insert_id;
+	$new_sql_id = get_sql_id($link);
+
+	if (0 !== $api_id) {
+		printf("[010] API id should have been reset to 0 because previous query was SELECT, got API %d, SQL %d\n",
+		  $api_id, $new_sql_id);
+	}
+	if ($new_sql_id != $sql_id) {
+		printf("[011] The servers LAST_INSERT_ID() changed unexpectedly from %d to %d\n", $sql_id, $new_sql_id);
+	}
+
+	// Sequence counter pattern...
+	if (!$link->query("UPDATE test SET id=LAST_INSERT_ID(id+1)"))
+	  printf("[012] [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$new_sql_id = get_sql_id($link);
+	if ($api_id < 1)
+		printf("[013] Expecting id > 0 got %d, [%d] %s\n", $api_id, $link->errno, $link->error)	;
+	if ($api_id != $new_sql_id)
+		printf("[014] SQL id %d should be equal to API id %d\n", $new_sql_id, $api_id);
+	if ($sql_id == $new_sql_id)
+		printf("[015] SQL id %d should have had changed, got %d\n", $sql_id, $new_sql_id);
+
+	$sql_id = $new_sql_id;
+
+	// Not an INSERT (after UPDATE), API value must become 0
+	if (!$link->query("SET @myvar=1"))
+		printf("[016] [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$new_sql_id = get_sql_id($link);
+	if (0 !== $api_id) {
+		printf("[017] API id should have been reset to 0 because previous query was SET, got API %d, SQL %d\n",
+		  $api_id, $new_sql_id);
+	}
+	if ($new_sql_id != $sql_id) {
+		printf("[018] The servers LAST_INSERT_ID() changed unexpectedly from %d to %d\n", $sql_id, $new_sql_id);
+	}
+
+	if (!$link->query("INSERT INTO test(id, label) VALUES (LAST_INSERT_ID(id + 1), 'b')"))
+		printf("[019] [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$sql_id = get_sql_id($link);
+	if ($api_id != $sql_id)
+		printf("[020] SQL id %d should be equal to API id %d\n", $sql_id, $api_id);
+
+	if (!$link->query("INSERT INTO test(label) VALUES ('c')"))
+		printf("[021] [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$sql_id = get_sql_id($link);
+	if ($api_id != $sql_id)
+		printf("[022] SQL id %d should be equal to API id %d\n", $sql_id, $api_id);
+
+	if (!($res = $link->query("SELECT id, label FROM test ORDER BY id ASC")))
+		printf("[023] [%d] %s\n", $link->errno, $link->error);
+
+	printf("Dumping table contents before INSERT...SELECT experiments...\n");
+	while ($row = $res->fetch_assoc()) {
+		printf("id = %d, label = '%s'\n", $row['id'], $row['label']);
+	}
+	$res->close();
+
+	if (!$link->query("INSERT INTO test(label) SELECT CONCAT(label, id) FROM test ORDER BY id ASC"))
+	  printf("[024] [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$sql_id = get_sql_id($link);
+	if ($api_id != $sql_id)
+		printf("[025] SQL id %d should be equal to API id %d\n", $sql_id, $api_id);
+
+	if ($link->query("INSERT INTO test(id, label) SELECT id, CONCAT(label, id) FROM test ORDER BY id ASC"))
+	  printf("[026] INSERT should have failed because of duplicate PK value, [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$new_sql_id = get_sql_id($link);
+	if (0 !== $api_id) {
+		printf("[027] API id should have been reset to 0 because previous query failed, got API %d, SQL %d\n",
+		  $api_id, $new_sql_id);
+	}
+	if ($new_sql_id != $sql_id) {
+		printf("[028] The servers LAST_INSERT_ID() changed unexpectedly from %d to %d\n", $sql_id, $new_sql_id);
+	}
+
+	/* API insert id will be 101 because of UPDATE, SQL unchanged */
+	if (!$link->query(sprintf("INSERT INTO test(id, label) VALUES (%d, 'z') ON DUPLICATE KEY UPDATE id = 101", $sql_id)	))
+	  printf("[029] [%d] %s\n", $link->errno, $link->error);
+
+	$api_id = $link->insert_id;
+	$new_sql_id = get_sql_id($link);
+	if ($api_id != 101)
+		printf("[030] API id should be %d got %d\n", $sql_id, $api_id);
+	if ($new_sql_id != $sql_id) {
+		printf("[031] The servers LAST_INSERT_ID() changed unexpectedly from %d to %d\n", $sql_id, $new_sql_id);
+	}
+
+	if (!($res = $link->query("SELECT id, label FROM test ORDER BY id ASC")))
+		printf("[032] [%d] %s\n", $link->errno, $link->error);
+
+	printf("Dumping table contents after INSERT...SELECT...\n");
+	while ($row = $res->fetch_assoc()) {
+		printf("id = %d, label = '%s'\n", $row['id'], $row['label']);
+	}
+	$res->close();
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+API: %d, SQL: %d
+Dumping table contents before INSERT...SELECT experiments...
+id = %d, label = 'b'
+id = %d, label = 'a'
+id = %d, label = 'c'
+Dumping table contents after INSERT...SELECT...
+id = %d, label = 'b'
+id = %d, label = 'a'
+id = %d, label = 'c'
+id = %d, label = 'a%d'
+id = %d, label = 'c%d'
+id = 101, label = 'b%d'
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_magic_quotes.phpt
@@ -0,0 +1,128 @@
+--TEST--
+magic_quotes_runtime (DEPRECATED)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (version_compare(PHP_VERSION, '5.3.98') >= 0) {
+	die("skip: PHP 5.3 test");
+}
+?>
+--INI--
+magic_quotes_runtime=1
+--FILE--
+<?php
+	require('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	$query = sprintf("SELECT '%s', '%s', '%s', '%s' FROM DUAL",
+				mysqli_real_escape_string($link, "'"),
+				mysqli_real_escape_string($link, '"'),
+				mysqli_real_escape_string($link, '\0'),
+				mysqli_real_escape_string($link, '\\'));
+
+	if (!$res = mysqli_query($link, $query)) {
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	while ($row = $res->fetch_assoc()) {
+		var_dump($row);
+	}
+
+	$res->free();
+
+	$expected = array(
+		"'" 	=> "\\'",
+		'"' 	=> "\\\"",
+		"\\0" 	=> "\\\\0",
+		"\\"	=> "\\\\",
+	);
+	$expectedBoth = array(
+		0		=> "\\'",
+		"'" 	=> "\\'",
+		1	 	=> "\\\"",
+		'"' 	=> "\\\"",
+		2	 	=> "\\\\0",
+		"\\0" 	=> "\\\\0",
+		3		=> "\\\\",
+		"\\"	=> "\\\\",
+	);
+
+	if (!$res = mysqli_query($link, $query)) {
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	$row = mysqli_fetch_row($res);
+	echo "Equal:";var_dump($row === array_values($expected));
+	if ($row !== array_values($expected)) {
+		var_dump($row, array_values($expected));
+	}
+	$res->free();
+
+	if (!$res = mysqli_query($link, $query)) {
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	$row = mysqli_fetch_array($res, MYSQLI_BOTH);
+	echo "Equal:";var_dump($row === $expectedBoth);
+	if ($row !== $expectedBoth) {
+		var_dump($row, $expectedBoth);
+	}
+	$res->free();
+
+	class fetch_object {
+		public function __set($key, $value) {
+			printf(">%s< => >%s<\n", $key, $value);
+		}
+	}
+
+	if (!$res = mysqli_query($link, $query)) {
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+	$obj = mysqli_fetch_object($res, "fetch_object");
+	$res->free();
+
+	if (false && $IS_MYSQLND) {
+			if (!$res = mysqli_query($link, $query)) {
+				printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			}
+			$row = @mysqli_fetch_all($res, MYSQLI_ASSOC);
+			if ($row[0] !== $expected) {
+				printf("[015] Wrong data, dumping\n");
+				var_dump($row);
+			}
+	}
+
+	$link->close();
+
+	print "done!";
+?>
+--EXPECTF--
+Deprecated: Directive 'magic_quotes_runtime' is deprecated in PHP 5.3 and greater in Unknown on line %d
+
+Warning: mysqli_result::fetch_assoc(): magic_quotes_runtime are deprecated since PHP 5.3 in %s on line %d
+array(4) {
+  ["'"]=>
+  string(2) "\'"
+  ["""]=>
+  string(2) "\""
+  ["\0"]=>
+  string(3) "\\0"
+  ["\"]=>
+  string(2) "\\"
+}
+
+Warning: mysqli_fetch_row(): magic_quotes_runtime are deprecated since PHP 5.3 in %s on line %d
+Equal:bool(true)
+
+Warning: mysqli_fetch_array(): magic_quotes_runtime are deprecated since PHP 5.3 in %s on line %d
+Equal:bool(true)
+
+Warning: mysqli_fetch_object(): magic_quotes_runtime are deprecated since PHP 5.3 in %s on line %d
+>'< => >\'<
+>"< => >\"<
+>\0< => >\\0<
+>\< => >\\<
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_max_links.phpt
@@ -0,0 +1,76 @@
+--TEST--
+Testing mysqli.max_links
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.max_links=1
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	// to make sure we have at least one working connection...
+	var_dump(mysqli_ping($link));
+	// to make sure that max_links is really set to one
+	var_dump((int)ini_get('mysqli.max_links'));
+
+	$links = array();
+	for ($i = 1; $i <= 5; $i++)
+		if ($links[$i] = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[%03d] One link is already open, it should not be possible to open more, [%d] %s, [%d] %s\n",
+				$i, mysqli_connect_errno(), mysqli_connect_error(),
+				mysqli_errno($links[$i]), mysqli_error($links[$i]));
+
+	for ($i = 1; $i <= 5; $i++) {
+		if ($res = mysqli_query($links[$i], 'SELECT id FROM test LIMIT 1')) {
+			printf("[%03d] Can run query on link %d\n", 5 + $i, $i);
+			mysqli_free_result($res);
+		}
+		mysqli_close($links[$i]);
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+int(1)
+
+Warning: mysqli_%sonnect(): Too many open links (1) in %s on line %d
+
+Warning: mysqli_%sonnect(): Too many open links (1) in %s on line %d
+
+Warning: mysqli_%sonnect(): Too many open links (1) in %s on line %d
+
+Warning: mysqli_%sonnect(): Too many open links (1) in %s on line %d
+
+Warning: mysqli_%sonnect(): Too many open links (1) in %s on line %d
+
+Warning: mysqli_query() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_close() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_query() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_close() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_query() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_close() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_query() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_close() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_query() expects parameter 1 to be mysqli, boolean given in %s on line %d
+
+Warning: mysqli_close() expects parameter 1 to be mysqli, boolean given in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_more_results.phpt
@@ -0,0 +1,114 @@
+--TEST--
+mysqli_more_results()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$strict_on = false;
+	if (defined('E_STRICT')) {
+		error_reporting(((int)ini_get('error_reporting')) | E_STRICT );
+		$strict_on = true;
+	}
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_more_results()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_more_results($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	print "[004]\n";
+	var_dump(mysqli_more_results($link));
+
+	if (!mysqli_multi_query($link, "SELECT 1 AS a; SELECT 1 AS a, 2 AS b; SELECT id FROM test ORDER BY id LIMIT 3"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	print "[006]\n";
+	$i = 1;
+
+	if ($strict_on)
+		ob_start();
+
+	if (mysqli_get_server_version($link) > 41000 && !($ret = mysqli_more_results($link)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($ret), $ret);
+	do {
+		$res = mysqli_store_result($link);
+		mysqli_free_result($res);
+		if (mysqli_more_results($link))
+			printf("%d\n", $i++);
+	} while (mysqli_next_result($link));
+
+	if ($strict_on) {
+		$tmp = ob_get_contents();
+		ob_end_clean();
+		if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+			printf("[008] Strict Standards warning missing\n");
+		} else {
+			$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+		}
+			print trim($tmp) . "\n";
+	}
+
+	if (!mysqli_multi_query($link, "SELECT 1 AS a; SELECT 1 AS a, 2 AS b; SELECT id FROM test ORDER BY id LIMIT 3"))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	print "[010]\n";
+	$i = 1;
+	if (mysqli_get_server_version($link) > 41000 && !($ret = mysqli_more_results($link)))
+		printf("[011] Expecting boolean/true, got %s/%s\n", gettype($ret), $ret);
+
+	if ($strict_on)
+		ob_start();
+	do {
+		$res = mysqli_use_result($link);
+		// NOTE: if you use mysqli_use_result() with mysqli_more_results() or any other info function,
+		// you must fetch all rows before you can loop to the next result set!
+		// See also the MySQL Reference Manual: mysql_use_result()
+		while ($row = mysqli_fetch_array($res))
+			;
+		mysqli_free_result($res);
+		if (mysqli_more_results($link))
+			printf("%d\n", $i++);
+	} while (mysqli_next_result($link));
+
+	if ($strict_on) {
+		$tmp = ob_get_contents();
+		ob_end_clean();
+		if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+			printf("[008] Strict Standards warning missing\n");
+		} else {
+			$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+		}
+		print trim($tmp) . "\n";
+	}
+	mysqli_close($link);
+
+	var_dump(mysqli_more_results($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[004]
+bool(false)
+[006]
+1
+2
+[010]
+1
+2
+
+Warning: mysqli_more_results(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_multi_query.phpt
@@ -0,0 +1,162 @@
+--TEST--
+mysqli_multi_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$strict_on = false;
+	if (defined('E_STRICT')) {
+		error_reporting(((int)ini_get('error_reporting')) | E_STRICT );
+		$strict_on = true;
+	}
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_multi_query()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_multi_query($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (false !== ($tmp = mysqli_multi_query($link, "")))
+		printf("[003] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_multi_query($link, "SELECT 1 AS a; SELECT 1 AS a, 2 AS b; SELECT id FROM test ORDER BY id LIMIT 3"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($strict_on)
+		ob_start();
+
+	$i = 0;
+	do {
+		$res = mysqli_store_result($link);
+		while ($row = mysqli_fetch_array($res))
+			;
+		mysqli_free_result($res);
+		$i++;
+	} while (mysqli_next_result($link));
+
+	if ($strict_on) {
+		$tmp = ob_get_contents();
+		ob_end_clean();
+		if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+			printf("[005a] Strict Standards warning missing\n");
+		} else {
+			$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+		}
+		print trim($tmp) . "\n";
+	}
+
+	printf("[006] %d\n", $i);
+
+	if (!mysqli_multi_query($link, "ALTER TABLE test MODIFY id INT AUTO_INCREMENT; INSERT INTO test(label) VALUES ('a'); SELECT id, label FROM test ORDER BY id"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$i = 0;
+	while (mysqli_next_result($link) && ($res = mysqli_store_result($link))) {
+
+		while ($row = mysqli_fetch_array($res))
+			;
+		mysqli_free_result($res);
+		printf("%d/%d\n", $i, mysqli_insert_id($link));
+		$i++;
+	}
+	printf("[008] %d\n", $i);
+
+	if (!mysqli_multi_query($link, "SELECT id, label FROM test"))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($strict_on)
+		ob_start();
+	$i = 0;
+	while (mysqli_next_result($link) && ($res = mysqli_store_result($link))) {
+		while ($row = mysqli_fetch_array($res))
+			$i++;
+		mysqli_free_result($res);
+	}
+	if ($strict_on) {
+		$tmp = ob_get_contents();
+		ob_end_clean();
+		if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+			printf("[009a] Strict Standards warning missing\n");
+		} else {
+			$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+		}
+		print trim($tmp) . "\n";
+	}
+	printf("[010] %d\n", $i);
+
+	if (!mysqli_multi_query($link, "SELECT 1 AS num, 'a' AS somechar; SELECT 2 AS num, 'a' AS somechar; SELECT 3 AS num, 'a' AS somechar"))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$res_num = 1;
+	do {
+		if (!$res = mysqli_store_result($link)) {
+			printf("[012 - %d] [%d] %s\n", $res_num, mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		$num_rows = 0;
+		while ($row = mysqli_fetch_array($res)) {
+
+			$num_rows++;
+			if ($row['num'] != $res_num)
+				printf("[013 - %d] Expecting %s got %s\n", $res_num, $res_num, $row['num']);
+			if ($row['somechar'] != "a")
+				printf("[014 - %d] Expecting a got %s\n", $res_num, $row['somechar']);
+
+			if (1 == $num_rows) {
+				/* simple metadata check */
+				if (!($lengths = mysqli_fetch_lengths($res)))
+					printf("[015 - %d] [%d] %s\n", $res_num, mysqli_errno($link), mysqli_error($link));
+
+				if (count($lengths) != 2)
+					printf("[016 - %d] Expecting 2 column lengths got %d [%d] %s\n", $res_num, count($lengths));
+
+				foreach ($lengths as $k => $length)
+					if ($length <= 0)
+						printf("[017 - %d] Strange column lengths for column %d, got %d expecting any > 0\n",
+							$res_num, $k, $length);
+				}
+		}
+
+		if ($num_rows != 1)
+			printf("[018 - %d] Expecting 1 row, got %d rows\n", $num_rows);
+
+		$res_num++;
+
+		mysqli_free_result($res);
+
+	} while (@mysqli_next_result($link));
+
+	if ($res_num != 4)
+		printf("[015] Expecting 3 result sets got %d result set[s]\n", $res_num);
+
+	mysqli_close($link);
+
+	var_dump(mysqli_multi_query($link, "SELECT id, label FROM test"));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[006] 3
+[008] 0
+[009] [2014] Commands out of sync; you can't run this command now
+
+[010] 7
+
+Warning: mysqli_multi_query(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_mysqli_result_invalid_mode.phpt
@@ -0,0 +1,30 @@
+--TEST--
+mysqli_result(), invalid mode
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	require('table.inc');
+
+	$valid = array(MYSQLI_STORE_RESULT, MYSQLI_USE_RESULT);
+	do {
+		$mode = mt_rand(-1000, 1000);
+	} while (in_array($mode, $valid));
+
+	if (!is_object($res = new mysqli_result($link, $mode)))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_result::__construct(): Invalid value for resultmode in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_mysqlnd_read_timeout.phpt
@@ -0,0 +1,36 @@
+--TEST--
+mysqlnd.net_read_timeout limit check
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$IS_MYSQLND)
+	/* The libmysql read_timeout limit default is 365 * 24 * 3600 seconds. It cannot be altered through PHP API calls */
+	die("skip mysqlnd only test");
+?>
+--INI--
+default_socket_timeout=60
+max_execution_time=60
+mysqlnd.net_read_timeout=1
+--FILE--
+<?php
+	include ("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link, "SELECT SLEEP(5)"))
+		printf("[002] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_query(): MySQL server has gone away in %s on line %d
+
+Warning: mysqli_query(): Error reading result set's header in %s on line %d
+[002] [%d] %s
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_mysqlnd_read_timeout_long.phpt
@@ -0,0 +1,48 @@
+--TEST--
+mysqlnd.net_read_timeout > default_socket_timeout
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$IS_MYSQLND) {
+	die("skip: test applies only to mysqlnd");
+}
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) <= 50011) {
+	die(sprintf('skip Needs MySQL 5.0.12+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--INI--
+default_socket_timeout=1
+mysqlnd.net_read_timeout=12
+max_execution_time=12
+--FILE--
+<?php
+	set_time_limit(12);
+	include ("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link, "SELECT SLEEP(6)"))
+		printf("[002] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	var_dump($res->fetch_assoc());
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"SLEEP(6)"]=>
+  %unicode|string%(1) "0"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_mysqlnd_read_timeout_zero.phpt
@@ -0,0 +1,47 @@
+--TEST--
+mysqlnd.net_read_timeout = 0
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$IS_MYSQLND) {
+	die("skip: test applies only to mysqlnd");
+}
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) <= 50011) {
+	die(sprintf('skip Needs MySQL 5.0.12+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--INI--
+default_socket_timeout=10
+max_execution_time=10
+mysqlnd.net_read_timeout=0
+--FILE--
+<?php
+	include ("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link, "SELECT SLEEP(2)"))
+		printf("[002] [%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+
+	var_dump($res->fetch_assoc());
+
+	mysqli_free_result($res);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"SLEEP(2)"]=>
+  %unicode|string%(1) "0"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_next_result.phpt
@@ -0,0 +1,124 @@
+--TEST--
+mysqli_next_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$strict_on = false;
+	if (defined('E_STRICT')) {
+		error_reporting(((int)ini_get('error_reporting')) | E_STRICT );
+		$strict_on = true;
+	}
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_next_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_next_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if ($strict_on)
+		ob_start();
+
+	if (false !== ($tmp = mysqli_next_result($link)))
+		printf("[003] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($strict_on) {
+		$tmp = ob_get_contents();
+		ob_end_clean();
+		if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+			printf("[003a] Strict Standards warning missing\n");
+		} else {
+			$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+		}
+		print trim($tmp) . "\n";
+		ob_start();
+	}
+
+	$res = mysqli_query($link, "SELECT 1 AS res");
+	if (false !== ($tmp = mysqli_next_result($link)))
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($strict_on) {
+		$tmp = ob_get_contents();
+		ob_end_clean();
+		if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+			printf("[004a] Strict Standards warning missing\n");
+		} else {
+			$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+		}
+		print trim($tmp) . "\n";
+	}
+
+	mysqli_free_result($res);
+
+	function func_test_mysqli_next_result($link, $query, $offset, $num_results, $strict_on) {
+
+		if (!mysqli_multi_query($link, $query))
+			printf("[%03d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+
+		$i = 0;
+		if ($strict_on)
+			ob_start();
+
+		do {
+			if ($res = mysqli_store_result($link)) {
+				mysqli_free_result($res);
+				$i++;
+			}
+		} while (true === mysqli_next_result($link));
+
+		if ($strict_on) {
+			$tmp = ob_get_contents();
+			ob_end_clean();
+			if (!preg_match('@Strict Standards: mysqli_next_result\(\): There is no next result set@ismU', $tmp)) {
+				printf("[%03d] Strict Standards warning missing\n", $offset + 1);
+			} else {
+				$tmp = trim(preg_replace('@Strict Standards: mysqli_next_result\(\).*on line \d+@ism', '', $tmp));
+			}
+			print trim($tmp) . "\n";
+		}
+
+		if ($i !== $num_results) {
+			printf("[%03d] Expecting %d result(s), got %d result(s)\n", $offset + 2, $num_results, $i);
+		}
+
+		if (mysqli_more_results($link))
+			printf("[%03d] mysqli_more_results() indicates more results than expected\n", $offset + 3);
+
+		if (!($res = mysqli_query($link, "SELECT 1 AS b"))) {
+			printf("[%03d] [%d] %s\n", $offset + 4, mysqli_errno($link), mysqli_error($link));
+		} else {
+			mysqli_free_result($res);
+		}
+
+	}
+
+	func_test_mysqli_next_result($link, "SELECT 1 AS a; SELECT 1 AS a, 2 AS b; SELECT id FROM test ORDER BY id LIMIT 3", 5, 3, $strict_on);
+	func_test_mysqli_next_result($link, "SELECT 1 AS a; INSERT INTO test(id, label) VALUES (100, 'y'); SELECT 1 AS a, 2 AS b", 8, 2, $strict_on);
+	func_test_mysqli_next_result($link, "DELETE FROM test WHERE id >= 100; SELECT 1 AS a; ", 11, 1, $strict_on);
+
+	mysqli_close($link);
+
+	var_dump(mysqli_next_result($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_next_result(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_no_reconnect.phpt
@@ -0,0 +1,127 @@
+--TEST--
+Trying implicit reconnect after wait_timeout and KILL using mysqli_ping()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.reconnect=0
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot create second database connection, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	$thread_id_timeout = mysqli_thread_id($link);
+	$thread_id_control = mysqli_thread_id($link2);
+
+	if (!$res = mysqli_query($link2, "SHOW FULL PROCESSLIST"))
+		printf("[002] Cannot get full processlist, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (!isset($running_threads[$thread_id_timeout]) ||
+			!isset($running_threads[$thread_id_control]))
+		printf("[003] Processlist is borked, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	if (!mysqli_query($link, "SET SESSION wait_timeout = 2"))
+		printf("[004] Cannot set wait_timeout, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SHOW VARIABLES LIKE 'wait_timeout'"))
+		printf("[005] Cannot check if wait_timeout has been set, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[006] Cannot get wait_timeout, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if ($row['Value'] != 2)
+		printf("[007] Failed setting the wait_timeout, test will not work, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	// after 2+ seconds the server should kill the connection
+	sleep(3);
+
+	if (!$res = mysqli_query($link2, "SHOW FULL PROCESSLIST"))
+		printf("[008] Cannot get full processlist, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (isset($running_threads[$thread_id_timeout]))
+		printf("[009] Server should have killed the timeout connection, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	if (false !== @mysqli_ping($link))
+		printf("[010] Reconnect should not have happened");
+
+	if ($res = @mysqli_query($link, "SELECT DATABASE() as _dbname"))
+		printf("[011] Executing a query should not be possible, connection should be closed, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!$link = @my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[012] Cannot create database connection, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	$thread_id_timeout = mysqli_thread_id($link);
+	/*
+	  Don't test for the mysqli_query() return value here.
+	  It is undefined if the server replies to the query and how.
+	  For example, it seems that on Linux when connecting to MySQL 5.1,
+	  the server always manages to send a full a reply. Whereas MySQl 5.5
+	  may not. The behaviour is undefined. Any return value is fine.
+	*/
+	if ($IS_MYSQLND) {
+		/*
+		mysqlnd is a bit more verbose than libmysql. mysqlnd should print:
+		Warning: mysqli_query(): MySQL server has gone away in %s on line %d
+
+		Warning: mysqli_query(): Error reading result set's header in %d on line %d
+		*/
+		@mysqli_query($link, sprintf('KILL %d', $thread_id_timeout));
+	} else {
+		mysqli_query($link, sprintf('KILL %d', $thread_id_timeout));
+	}
+	// Give the server a second to really kill the other thread...
+	sleep(1);
+
+	if (!$res = mysqli_query($link2, "SHOW FULL PROCESSLIST"))
+		printf("[014] Cannot get full processlist, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (isset($running_threads[$thread_id_timeout]) ||
+			!isset($running_threads[$thread_id_control]))
+		printf("[015] Processlist is borked, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	if (false !== ($tmp = @mysqli_ping($link)))
+		printf("[016] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($res = @mysqli_query($link, "SELECT DATABASE() as _dbname"))
+		printf("[017] Running a query should not be possible, connection should be gone, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link2);
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_num_fields.phpt
@@ -0,0 +1,57 @@
+--TEST--
+mysqli_num_fields()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_num_fields()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_num_fields($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	function func_test_mysqli_num_fields($link, $query, $expected, $offset, $test_free = false) {
+
+		if (!($res = mysqli_query($link, $query))) {
+			printf("[%03d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return;
+		}
+
+		if ($expected !== ($tmp = mysqli_num_fields($res)))
+			printf("[%03d] Expecting %s/%d, got %s/%d\n", $offset + 1,
+				gettype($expected), $expected,
+				gettype($tmp), $tmp);
+
+		mysqli_free_result($res);
+
+		if ($test_free && (NULL !== ($tmp = mysqli_num_fields($res))))
+			printf("[%03d] Expecting NULL, got %s/%s\n", $offset + 2, gettype($tmp), $tmp);
+	}
+
+	func_test_mysqli_num_fields($link, "SELECT 1 AS a", 1, 5);
+	func_test_mysqli_num_fields($link, "SELECT id, label FROM test", 2, 10);
+	func_test_mysqli_num_fields($link, "SELECT 1 AS a, NULL AS b, 'foo' AS c", 3, 15);
+	func_test_mysqli_num_fields($link, "SELECT id FROM test", 1, 20, true);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_num_fields(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_num_rows.phpt
@@ -0,0 +1,89 @@
+--TEST--
+mysqli_num_rows()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_num_rows()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_num_rows($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	function func_test_mysqli_num_rows($link, $query, $expected, $offset, $test_free = false) {
+
+		if (!$res = mysqli_query($link, $query, MYSQLI_STORE_RESULT)) {
+			printf("[%03d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return;
+		}
+
+		if ($expected !== ($tmp = mysqli_num_rows($res)))
+			printf("[%03d] Expecting %s/%d, got %s/%d\n", $offset + 1,
+				gettype($expected), $expected,
+				gettype($tmp), $tmp);
+
+		mysqli_free_result($res);
+
+		if ($test_free && (NULL !== ($tmp = mysqli_num_rows($res))))
+			printf("[%03d] Expecting NULL, got %s/%s\n", $offset + 2, gettype($tmp), $tmp);
+
+	}
+
+	func_test_mysqli_num_rows($link, "SELECT 1 AS a", 1, 5);
+	func_test_mysqli_num_rows($link, "SHOW VARIABLES LIKE '%nixnutz%'", 0, 10);
+	func_test_mysqli_num_rows($link, "INSERT INTO test(id, label) VALUES (100, 'z')", NULL, 15);
+	func_test_mysqli_num_rows($link, "SELECT id FROM test LIMIT 2", 2, 20, true);
+
+	if ($res = mysqli_query($link, 'SELECT COUNT(id) AS num FROM test')) {
+
+		$row = mysqli_fetch_assoc($res);
+		mysqli_free_result($res);
+
+		func_test_mysqli_num_rows($link, "SELECT id, label FROM test", (int)$row['num'], 25);
+
+	} else {
+		printf("[030] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "run_tests.php don't fool me with your 'ungreedy' expression '.+?'!\n";
+
+	if ($res = mysqli_query($link, 'SELECT id FROM test', MYSQLI_USE_RESULT)) {
+
+		$row = mysqli_fetch_row($res);
+		if (0 !== ($tmp = mysqli_num_rows($res)))
+			printf("[031] Expecting int/0, got %s/%d\n", gettype($tmp), $tmp);
+
+		mysqli_free_result($res);
+
+	} else {
+		printf("[032] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_num_rows() expects parameter 1 to be mysqli_result, boolean given in %s on line %d
+
+Warning: mysqli_free_result() expects parameter 1 to be mysqli_result, boolean given in %s on line %d
+
+Warning: mysqli_num_rows(): Couldn't fetch mysqli_result in %s on line %d
+run_tests.php don't fool me with your 'ungreedy' expression '.+?'!
+
+Warning: mysqli_num_rows(): Function cannot be used with MYSQL_USE_RESULT in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_options.phpt
@@ -0,0 +1,143 @@
+--TEST--
+mysqli_options()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$valid_options = array(
+		MYSQLI_READ_DEFAULT_GROUP 			=> "MYSQLI_READ_DEFAULT_GROUP",
+		MYSQLI_READ_DEFAULT_FILE 			=> "MYSQLI_READ_DEFAUTL_FILE",
+		MYSQLI_OPT_CONNECT_TIMEOUT			=> "MYSQLI_OPT_CONNECT_TIMEOUT",
+		MYSQLI_OPT_LOCAL_INFILE				=> "MYSQLI_OPT_LOCAL_INFILE",
+		MYSQLI_INIT_COMMAND					=> "MYSQLI_INIT_COMMAND",
+		MYSQLI_SET_CHARSET_NAME				=> "MYSQLI_SET_CHARSET_NAME",
+		MYSQLI_OPT_SSL_VERIFY_SERVER_CERT 	=> "MYSQLI_OPT_SSL_VERIFY_SERVER_CERT",
+	);
+
+	if ($IS_MYSQLND && defined('MYSQLI_OPT_NET_CMD_BUFFER_SIZE'))
+		$valid_options[] = constant('MYSQLI_OPT_NET_CMD_BUFFER_SIZE');
+	if ($IS_MYSQLND && defined('MYSQLI_OPT_NET_READ_BUFFER_SIZE'))
+		$valid_options[] = constant('MYSQLI_OPT_NET_READ_BUFFER_SIZE');
+	if ($IS_MYSQLND && defined('MYSQLI_OPT_INT_AND_FLOAT_NATIVE'))
+		$valid_options[] = constant('MYSQLI_OPT_INT_AND_FLOAT_NATIVE');
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_options()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_options($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$link = mysqli_init();
+
+	/* set it twice, checking if memory for the previous one is correctly freed */
+	mysqli_options($link, MYSQLI_SET_CHARSET_NAME, "utf8");
+	mysqli_options($link, MYSQLI_SET_CHARSET_NAME, "latin1");
+
+	if (!is_null($tmp = @mysqli_options($link, MYSQLI_OPT_CONNECT_TIMEOUT)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_options($link, "s", 'extra_my.cnf')))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_options($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=0', 'foo')))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	// print "run_tests.php don't fool me with your 'ungreedy' expression '.+?'!\n";
+	var_dump("MYSQLI_READ_DEFAULT_GROUP",	mysqli_options($link, MYSQLI_READ_DEFAULT_GROUP, 'extra_my.cnf'));
+	var_dump("MYSQLI_READ_DEFAULT_FILE",	mysqli_options($link, MYSQLI_READ_DEFAULT_FILE, 'extra_my.cnf'));
+	var_dump("MYSQLI_OPT_CONNECT_TIMEOUT",	mysqli_options($link, MYSQLI_OPT_CONNECT_TIMEOUT, 10));
+	var_dump("MYSQLI_OPT_LOCAL_INFILE",		mysqli_options($link, MYSQLI_OPT_LOCAL_INFILE, 1));
+	var_dump("MYSQLI_INIT_COMMAND",			mysqli_options($link, MYSQLI_INIT_COMMAND, array('SET AUTOCOMMIT=0', 'SET AUTOCOMMIT=1')));
+
+	
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[006] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = mysqli_query($link2, 'SELECT version() AS server_version'))
+		printf("[007] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	$version = explode('.', $tmp['server_version']);
+	if (empty($version))
+		printf("[008] Cannot determine server version, need MySQL Server 4.1+ for the test!\n");
+
+	if ($version[0] <= 4 && $version[1] < 1)
+		printf("[009] Need MySQL Server 4.1+ for the test!\n");
+
+	if (!$res = mysqli_query($link2, "SHOW CHARACTER SET"))
+		printf("[010] Cannot get list of available character sets, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link2));
+
+	$charsets = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$charsets[] = $row;
+	mysqli_free_result($res);
+	mysqli_close($link2);
+
+	foreach ($charsets as $charset) {
+		$k = $charset['Charset'];
+		/* The server currently 17.07.2007 can't handle data sent in ucs2 */
+		/* The server currently 16.08.2010 can't handle data sent in utf16 and utf32 */
+		if ($charset['Charset'] == 'ucs2' || $charset['Charset'] == 'utf16' || $charset['Charset'] == 'utf32') {
+			continue;
+		}
+		if (true !== mysqli_options($link, MYSQLI_SET_CHARSET_NAME, $charset['Charset'])) {
+			printf("[009] Setting charset name '%s' has failed\n", $charset['Charset']);
+		}
+	}
+
+	var_dump("MYSQLI_READ_DEFAULT_GROUP",	mysqli_options($link, MYSQLI_READ_DEFAULT_GROUP, 'extra_my.cnf'));
+	var_dump("MYSQLI_READ_DEFAULT_FILE",	mysqli_options($link, MYSQLI_READ_DEFAULT_FILE, 'extra_my.cnf'));
+	var_dump("MYSQLI_OPT_CONNECT_TIMEOUT",	mysqli_options($link, MYSQLI_OPT_CONNECT_TIMEOUT, 10));
+	var_dump("MYSQLI_OPT_LOCAL_INFILE",		mysqli_options($link, MYSQLI_OPT_LOCAL_INFILE, 1));
+	var_dump("MYSQLI_INIT_COMMAND",			mysqli_options($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=0'));
+
+	/* mysqli_real_connect() */
+	var_dump("MYSQLI_CLIENT_SSL",			mysqli_options($link, MYSQLI_CLIENT_SSL, 'not a mysqli_option'));
+	
+	mysqli_close($link);
+
+	echo "Link closed";
+	var_dump("MYSQLI_INIT_COMMAND", mysqli_options($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=1'));
+	print "done!";
+?>
+--EXPECTF--
+%s(25) "MYSQLI_READ_DEFAULT_GROUP"
+bool(true)
+%s(24) "MYSQLI_READ_DEFAULT_FILE"
+bool(true)
+%s(26) "MYSQLI_OPT_CONNECT_TIMEOUT"
+bool(true)
+%s(23) "MYSQLI_OPT_LOCAL_INFILE"
+bool(true)
+
+Notice: Array to string conversion in %s on line %d
+%s(19) "MYSQLI_INIT_COMMAND"
+bool(true)
+%s(25) "MYSQLI_READ_DEFAULT_GROUP"
+bool(true)
+%s(24) "MYSQLI_READ_DEFAULT_FILE"
+bool(true)
+%s(26) "MYSQLI_OPT_CONNECT_TIMEOUT"
+bool(true)
+%s(23) "MYSQLI_OPT_LOCAL_INFILE"
+bool(true)
+%s(19) "MYSQLI_INIT_COMMAND"
+bool(true)
+%s(17) "MYSQLI_CLIENT_SSL"
+bool(false)
+Link closed
+Warning: mysqli_options(): Couldn't fetch mysqli in %s line %d
+%s(19) "MYSQLI_INIT_COMMAND"
+NULL
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_options_init_command.phpt
@@ -0,0 +1,78 @@
+--TEST--
+mysqli_options()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+<?php require_once('skipifemb.inc'); ?>
+--FILE--
+<?php
+	/* see mysqli.c for details */
+	require_once("connect.inc");
+
+	if (!($link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	/* TODO: test more options */
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+		!mysqli_query($link, sprintf("CREATE TABLE test(id INT) ENGINE = %s\n", $engine)) ||
+		!mysqli_query($link, "INSERT INTO test(id) VALUES (1)"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SELECT COUNT(id) AS _num_rows FROM test"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+
+	if ($row['_num_rows'] != 1)
+		printf("[003] Expecting 1 got %s\n", $row['_num_rows']);
+
+	mysqli_close($link);
+
+	$link = mysqli_init();
+	if (true !== mysqli_options($link, MYSQLI_INIT_COMMAND, "INSERT INTO test(id) VALUES (2)"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
+		printf("[005] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$res = mysqli_query($link, "SELECT COUNT(id) AS _num_rows FROM test"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+
+	if ($row['_num_rows'] != 2)
+		printf("[007] Expecting 1 got %s\n", $row['_num_rows']);
+
+	mysqli_close($link);
+
+	$link = mysqli_init();
+	if (true !== mysqli_options($link, MYSQLI_INIT_COMMAND, "INSERT INTO test(i_do_no_exist) VALUES (2)"))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	$link = mysqli_init();
+	if (true !== mysqli_options($link, MYSQLI_INIT_COMMAND, "INSERT INTO test(i_do_no_exist) VALUES (2)"))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
+		printf("[010] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_real_connect(): (%s/%d): %s in %s on line %d
+[010] Cannot connect to the server using %s
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_options_int_and_float_native.phpt
@@ -0,0 +1,109 @@
+--TEST--
+mysqli_options() - MYSQLI_OPT_INT_AND_FLOAT_NATIVE
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once('connect.inc');
+if (!$IS_MYSQLND)	
+	die("skip mysqlnd only test");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+
+	$types = array(
+		'BIT' 			=> array('BIT(8)', 0),
+		'TINYINT'		=> array('TINYINT', 120),
+		'BOOL'			=> array('BOOL', 0),
+		'BOOLEAN'		=> array('BOOLEAN', 1),
+		'SMALLINT'		=> array('SMALLINT', 32000),
+		'MEDIUMINT'		=> array('MEDIUMINT', 999),
+		'INT'			=> array('INT', 999),
+		'BIGINT'		=> array('BIGINT', 999),
+		'FLOAT'			=> array('FLOAT', 1.3),
+		'DOUBLE'		=> array('DOUBLE', -1.3),
+	);
+
+	foreach ($types as $name => $data) {
+		$link = mysqli_init();
+		if (!mysqli_options($link, MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1)) {
+			printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+			printf("[002] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+			continue;
+		}
+
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+		
+		if (!mysqli_query($link, sprintf("CREATE TABLE test (id %s)", $data[0]))) {
+			printf("[004] TODO [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+		
+		if (!mysqli_query($link, sprintf("INSERT INTO test(id) VALUES (%f)", $data[1]))) {
+			printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		if (!$res = mysqli_query($link, "SELECT id FROM test")) {
+			printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		$row = mysqli_fetch_assoc($res);
+		mysqli_free_result($res);
+
+		if ($row['id'] !== $data[1]) {
+			printf("[007] Expecting %s - %s/%s got %s/%s\n", 
+				$name,
+				$data[1], gettype($data[1]), $row['id'], gettype($row['id']));
+		}
+		mysqli_close($link);
+
+		$link = mysqli_init();
+		if (!mysqli_options($link, MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 0)) {
+			printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {
+			printf("[009] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+			continue;
+		}
+		
+		if (!$res = mysqli_query($link, "SELECT id FROM test")) {
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		$row = mysqli_fetch_assoc($res);
+		mysqli_free_result($res);
+
+		if (!is_string($row['id']) || ($row['id'] != $data[1])) {
+			printf("[011] Expecting %s - %s/string got %s/%s\n", 
+				$name,
+				$data[1], $row['id'], gettype($row['id']));
+		}		
+		mysqli_close($link);		
+
+	}
+	
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_options_openbasedir.phpt
@@ -0,0 +1,24 @@
+--TEST--
+mysqli_options() - MYSQLI_OPT_LOCAL_INFILE and open_basedir
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+open_basedir="."
+--FILE--
+<?php
+	require_once('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (false !== mysqli_options($link, MYSQLI_OPT_LOCAL_INFILE, 1))
+		printf("[002] Can set MYSQLI_OPT_LOCAL_INFILE although open_basedir is set!\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_conn_multiple.phpt
@@ -0,0 +1,161 @@
+--TEST--
+Calling connect() on an open persistent connection to create a new persistent connection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=-1
+mysqli.max_links=-1
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$phost = 'p:' . $host;
+
+	if (!$link = my_mysqli_connect($phost, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$phost, $user, $db, $port, $socket);
+
+	if (!$thread_id = $link->thread_id)
+		printf("[002] Cannot determine thread id, test will fail, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)))
+		printf("[003] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($new_thread_id = mysqli_thread_id($link)) || ($new_thread_id < 0))
+		printf("[004] Expecting int/any got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($thread_id == $new_thread_id)
+		printf("[005] Expecting new connection and new thread id. Old thread id %d, new thread id %d\n", $thread_id, $new_thread_id);
+
+	if (!($res = mysqli_query($link, "SELECT 'ok' AS it_works")) ||
+		!($row = mysqli_fetch_assoc($res)))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (!$link = new my_mysqli($phost, $user, $passwd, $db, $port, $socket))
+		printf("[007] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$phost, $user, $db, $port, $socket);
+
+	if (!$thread_id = $link->thread_id)
+		printf("[008] Cannot determine thread id, test will fail, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = $link->real_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[009] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($new_thread_id = $link->thread_id) || ($new_thread_id < 0))
+		printf("[010] Expecting int/any got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($thread_id == $new_thread_id)
+		printf("[011] Expecting new connection and new thread id. Old thread id %d, new thread id %d\n", $thread_id, $new_thread_id);
+
+	if (!($res = $link->query("SELECT 'works also with oo' AS syntax")) ||
+			!($row = $res->fetch_assoc()))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = $link->connect($phost, $user, $passwd, $db, $port, $socket)))
+		printf("[013] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_connect($phost, $user, $passwd, $db, $port, $socket))
+		printf("[014] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$phost, $user, $db, $port, $socket);
+
+	if (NULL !== ($tmp = $link->connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[015] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	printf("Flipping phost/host order\n");
+
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[016] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$thread_id = mysqli_thread_id($link))
+		printf("[017] Cannot determine thread id, test will fail, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = my_mysqli_real_connect($link, $phost, $user, $passwd, $db, $port, $socket)))
+		printf("[018] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($new_thread_id = mysqli_thread_id($link)) || ($new_thread_id < 0))
+		printf("[019] Expecting int/any got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($thread_id == $new_thread_id)
+		printf("[020] Expecting new connection and new thread id. Old thread id %d, new thread id %d\n", $thread_id, $new_thread_id);
+
+	if (!($res = mysqli_query($link, "SELECT 'ok' AS it_works")) ||
+		!($row = mysqli_fetch_assoc($res)))
+		printf("[021] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (!$link = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[022] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$thread_id = $link->thread_id)
+		printf("[023] Cannot determine thread id, test will fail, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = $link->real_connect($phost, $user, $passwd, $db, $port, $socket)))
+		printf("[024] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($new_thread_id = $link->thread_id) || ($new_thread_id < 0))
+		printf("[025] Expecting int/any got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($thread_id == $new_thread_id)
+		printf("[026] Expecting new connection and new thread id. Old thread id %d, new thread id %d\n", $thread_id, $new_thread_id);
+
+	if (!($res = $link->query("SELECT 'works also with oo' AS syntax")) ||
+			!($row = $res->fetch_assoc()))
+		printf("[027] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = $link->connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[028] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[029] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (NULL !== ($tmp = $link->connect($phost, $user, $passwd, $db, $port, $socket)))
+		printf("[030] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"it_works"]=>
+  %unicode|string%(2) "ok"
+}
+array(1) {
+  [%u|b%"syntax"]=>
+  %unicode|string%(18) "works also with oo"
+}
+Flipping phost/host order
+array(1) {
+  [%u|b%"it_works"]=>
+  %unicode|string%(2) "ok"
+}
+array(1) {
+  [%u|b%"syntax"]=>
+  %unicode|string%(18) "works also with oo"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_disabled.phpt
@@ -0,0 +1,62 @@
+--TEST--
+mysqli_pconnect() - mysqli.allow_persistent = 0
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+die("skip TODO - we need to add a user level way to check if CHANGE_USER gets called by pconnect");
+?>
+--INI--
+mysqli.allow_persistent=0
+mysqli.max_persistent=2
+mysqli.max_links=2
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$host = 'p:' . $host;
+	if (!$link1 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		// automatic downgrade to normal connections has failed
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+	if (!mysqli_query($link1, "SET @pcondisabled = 'Connection 1'"))
+		printf("[002] Cannot set user variable to check if we got the same persistent connection, [%d] %s\n",
+			mysqli_errno($link1), mysqli_error($link1));
+
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		// automatic downgrade to normal connections has failed
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link1, 'SELECT @pcondisabled AS _test'))
+		printf("[004] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	printf("Connecction 1 - SELECT @pcondisabled -> '%s'\n", $row['_test']);
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link2, 'SELECT @pcondisabled AS _test'))
+		printf("[005] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	printf("Connecction 2 - SELECT @pcondisabled -> '%s'\n", $row['_test']);
+	mysqli_free_result($res);
+
+	if ($link1 === $link2)
+		printf("[006] Links should not be identical\n");
+
+	mysqli_close($link1);
+	mysqli_close($link2);
+	print "done!";
+?>
+--EXPECTF--
+Warning: my_mysqli_connect(): Persistent connections are disabled. Downgrading to normal in %s on line %d
+
+Warning: my_mysqli_connect(): Persistent connections are disabled. Downgrading to normal in %s on line %d
+Connecction 1 - SELECT @pcondisabled -> 'Connection 1'
+Connecction 2 - SELECT @pcondisabled -> ''
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_kill.phpt
@@ -0,0 +1,95 @@
+--TEST--
+Killing a persistent connection.
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once("connect.inc");
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=2
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	$host = 'p:' . $host;
+	if (!$plink = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	// get the thread ids of the two connections...
+	$thread_id = mysqli_thread_id($link);
+	$pthread_id = mysqli_thread_id($plink);
+
+	if (!$res = mysqli_query($link, 'SHOW FULL PROCESSLIST'))
+		printf("[002] Cannot get processlist, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (count($running_threads) < 2)
+		printf("[003] Processlist is too short, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!isset($running_threads[$thread_id]))
+		printf("[004] Cannot find thread id of the regular link, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!isset($running_threads[$pthread_id]))
+		printf("[005] Cannot find thread id of the persistent link, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// Kill the persistent connection - don't use mysqli_kill, mysqlnd will catch that...
+	if (!mysqli_query($link, sprintf('KILL %d', $pthread_id)))
+		printf("[006] Cannot kill persistent connection, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_close($plink);
+	// Give the server think-time to kill the pthread
+	sleep(1);
+
+	if (!$res = mysqli_query($link, 'SHOW FULL PROCESSLIST'))
+		printf("[007] Cannot get processlist, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$running_threads2 = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads2[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (isset($running_threads2[$pthread_id]))
+		printf("[008] Thread of the persistent connection should have been gone, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	if (!isset($running_threads2[$thread_id]))
+		printf("[009] Thread of the regular connection should be still there, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// On PHP side this should do nothing. PHP should not try to close the connection or something.
+	@mysqli_close($plink);
+
+	if (!$plink = @my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[011] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	if (!$res3 = @mysqli_query($plink, 'SELECT id FROM test ORDER BY id LIMIT 1')) {
+		printf("[012] New persistent connection cannot execute queries, [%d] %s\n", @mysqli_errno($plink), @mysqli_error($plink));
+	}
+
+	@mysqli_free_result($res3);
+	@mysqli_close($plink);
+	mysqli_close($link);
+
+	// remove the "p:<host>" from the host variable
+	$host = substr($host, 2);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[013] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	if (!$res4 = mysqli_query($link, 'SELECT id FROM test ORDER BY id LIMIT 1'))
+		printf("[014] New regular connection cannot execute queries, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res4);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_limits.phpt
@@ -0,0 +1,98 @@
+--TEST--
+Persistent connections - limits (-1, unlimited)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once("connect.inc");
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=-1
+mysqli.max_links=-1
+--FILE--
+<?php
+	require_once("connect.inc");
+	// opens a regular connection
+	require_once("table.inc");
+
+	if (!$res = mysqli_query($link, "SELECT 'works..' as _desc"))
+		printf("[001] Cannot run query, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	printf("Regular connection 1 - '%s'\n", $row['_desc']);
+
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot open second regular connection, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($link2, "SELECT 'works...' as _desc"))
+		printf("[003] Cannot run query, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	printf("Regular connection 2 - '%s'\n", $row['_desc']);
+
+	$host = 'p:' . $host;
+	if (!$plink = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[004] Cannot create persistent connection using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket,
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($plink, "SELECT 'works...' as _desc"))
+		printf("[005] Cannot run query, [%d] %s\n",
+			mysqli_errno($plink), mysqli_error($plink));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	printf("Persistent connection 1 - '%s'\n", $row['_desc']);
+
+	if (!$plink2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[006] Cannot create persistent connection using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket,
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($plink2, "SELECT 'works...' as _desc"))
+		printf("[007] Cannot run query, [%d] %s\n",
+			mysqli_errno($plink2), mysqli_error($plink2));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	printf("Persistent connection 2 - '%s'\n", $row['_desc']);
+
+	$plink3 = mysqli_init();
+	if (!my_mysqli_real_connect($plink3, $host, $user, $passwd, $db, $port, $socket))
+		printf("[008] Cannot create persistent connection using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket,
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($plink3, "SELECT 'works...' as _desc"))
+		printf("[009] Cannot run query, [%d] %s\n",
+			mysqli_errno($plink2), mysqli_error($plink2));
+
+	$row = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	printf("Persistent connection 3 - '%s'\n", $row['_desc']);
+
+	mysqli_close($link);
+	mysqli_close($link2);
+	mysqli_close($plink);
+	mysqli_close($plink2);
+	mysqli_close($plink3);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Regular connection 1 - 'works..'
+Regular connection 2 - 'works...'
+Persistent connection 1 - 'works...'
+Persistent connection 2 - 'works...'
+Persistent connection 3 - 'works...'
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_max_links.phpt
@@ -0,0 +1,196 @@
+--TEST--
+Persistent connections and mysqli.max_links
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+	require_once('table.inc');
+
+	mysqli_query($link, 'DROP USER pcontest');
+	mysqli_query($link, 'DROP USER pcontest@localhost');
+
+	if (!mysqli_query($link, 'CREATE USER pcontest@"%" IDENTIFIED BY "pcontest"') ||
+		!mysqli_query($link, 'CREATE USER pcontest@localhost IDENTIFIED BY "pcontest"')) {
+		printf("skip Cannot create second DB user [%d] %s", mysqli_errno($link), mysqli_error($link));
+		mysqli_close($link);
+		die("skip CREATE USER failed");
+	}
+
+	// we might be able to specify the host using CURRENT_USER(), but...
+	if (!mysqli_query($link, sprintf("GRANT SELECT ON TABLE %s.test TO pcontest@'%%'", $db)) ||
+		!mysqli_query($link, sprintf("GRANT SELECT ON TABLE %s.test TO pcontest@'localhost'", $db))) {
+		printf("skip Cannot GRANT SELECT to second DB user [%d] %s", mysqli_errno($link), mysqli_error($link));
+		mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest');
+		mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest@localhost');
+		mysqli_query($link, 'DROP USER pcontest@localhost');
+		mysqli_query($link, 'DROP USER pcontest');
+		mysqli_close($link);
+		die("skip GRANT failed");
+	}
+
+	if (!($link_pcontest = @my_mysqli_connect($host, 'pcontest', 'pcontest', $db, $port, $socket))) {
+		mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest');
+		mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest@localhost');
+		mysqli_query($link, 'DROP USER pcontest@localhost');
+		mysqli_query($link, 'DROP USER pcontest');
+		mysqli_close($link);
+		die("skip CONNECT using new user failed");
+    }
+	mysqli_close($link);
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=2
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once('table.inc');
+
+
+	if (!mysqli_query($link, 'DROP USER pcontest') ||
+		!mysqli_query($link, 'DROP USER pcontest@localhost') ||
+		!mysqli_query($link, 'CREATE USER pcontest@"%" IDENTIFIED BY "pcontest"') ||
+		!mysqli_query($link, 'CREATE USER pcontest@localhost IDENTIFIED BY "pcontest"') ||
+		!mysqli_query($link, sprintf("GRANT SELECT ON TABLE %s.test TO pcontest@'%%'", $db)) ||
+		!mysqli_query($link, sprintf("GRANT SELECT ON TABLE %s.test TO pcontest@'localhost'", $db))) {
+		printf("[000] Init failed, [%d] %s\n",
+			mysqli_errno($plink), mysqli_error($plink));
+	}
+
+	if (!$plink = my_mysqli_connect('p:' . $host, 'pcontest', 'pcontest', $db, $port, $socket))
+		printf("[001] Cannot connect using the second DB user created during SKIPIF, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	ob_start();
+	phpinfo();
+	$phpinfo = strip_tags(ob_get_contents());
+	ob_end_clean();
+
+	$phpinfo = substr($phpinfo, strpos($phpinfo, 'MysqlI Support => enabled'), 500);
+	if (!preg_match('@Active Persistent Links\s+=>\s+(\d+)@ismU', $phpinfo, $matches))
+		printf("[002] Cannot get # active persistent links from phpinfo()\n");
+	$num_plinks = $matches[1];
+
+	if (!$res = mysqli_query($plink, 'SELECT id, label FROM test WHERE id = 1'))
+		printf("[003] Cannot run query on persistent connection of second DB user, [%d] %s\n",
+			mysqli_errno($plink), mysqli_error($plink));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[004] Cannot run fetch result, [%d] %s\n",
+			mysqli_errno($plink), mysqli_error($plink));
+	mysqli_free_result($res);
+	var_dump($row);
+
+	// change the password for the second DB user and kill the persistent connection
+	if (!mysqli_query($link, 'SET PASSWORD FOR pcontest = PASSWORD("newpass")') ||
+			!mysqli_query($link, 'FLUSH PRIVILEGES'))
+		printf("[005] Cannot change PW of second DB user, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+        // change the password for the second DB user and kill the persistent connection
+	if (!mysqli_query($link, 'SET PASSWORD FOR pcontest@localhost = PASSWORD("newpass")') ||
+			!mysqli_query($link, 'FLUSH PRIVILEGES'))
+		printf("[006] Cannot change PW of second DB user, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// persistent connections cannot be closed but only be killed
+	$pthread_id = mysqli_thread_id($plink);
+	if (!mysqli_query($link, sprintf('KILL %d', $pthread_id)))
+		printf("[007] Cannot KILL persistent connection of second DB user, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	// give the server a second to really kill the thread
+	sleep(1);
+
+	if (!$res = mysqli_query($link, "SHOW FULL PROCESSLIST"))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (isset($running_threads[$pthread_id]))
+		printf("[009] Persistent connection has not been killed\n");
+
+	// this fails and we have 0 (<= $num_plinks) connections
+	if ($plink = @my_mysqli_connect('p:' . $host, 'pcontest', 'pcontest', $db, $port, $socket))
+		printf("[010] Can connect using the old password, [%d] %s\n",
+			mysqli_connect_errno($link), mysqli_connect_error($link));
+
+	ob_start();
+	phpinfo();
+	$phpinfo = strip_tags(ob_get_contents());
+	ob_end_clean();
+	$phpinfo = substr($phpinfo, stripos($phpinfo, 'MysqlI Support => enabled'), 500);
+	if (!preg_match('@Active Persistent Links\s+=>\s+(\d+)@ismU', $phpinfo, $matches))
+		printf("[010] Cannot get # of active persistent links from phpinfo()\n");
+
+	$num_plinks_kill = $matches[1];
+	if ($num_plinks_kill > $num_plinks)
+		printf("[011] Expecting Active Persistent Links < %d, got %d\n", $num_plinks, $num_plinks_kill);
+
+	if (!$plink = my_mysqli_connect('p:' . $host, 'pcontest', 'newpass', $db, $port, $socket))
+		printf("[012] Cannot connect using the new password, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$res = mysqli_query($plink, 'SELECT id, label FROM test WHERE id = 1'))
+		printf("[013] Cannot run query on persistent connection of second DB user, [%d] %s\n",
+			mysqli_errno($plink), mysqli_error($plink));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[014] Cannot run fetch result, [%d] %s\n",
+			mysqli_errno($plink), mysqli_error($plink));
+	mysqli_free_result($res);
+	var_dump($row);
+
+	if ($plink2 = my_mysqli_connect('p:' . $host, 'pcontest', 'newpass', $db, $port, $socket))
+		printf("[015] Can open more persistent connections than allowed, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	ob_start();
+	phpinfo();
+	$phpinfo = strip_tags(ob_get_contents());
+	ob_end_clean();
+	$phpinfo = substr($phpinfo, stripos($phpinfo, 'MysqlI Support => enabled'), 500);
+	if (!preg_match('@Active Persistent Links\s+=>\s+(\d+)@ismU', $phpinfo, $matches))
+		printf("[016] Cannot get # of active persistent links from phpinfo()\n");
+
+	$num_plinks = $matches[1];
+	if ($num_plinks > (int)ini_get('mysqli.max_persistent'))
+		printf("[017] mysqli.max_persistent=%d allows %d open connections!\n", ini_get('mysqli.max_persistent'),$num_plinks);
+
+	mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest');
+	mysqli_query($link, 'DROP USER pcontest');
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest');
+mysqli_query($link, 'REVOKE ALL PRIVILEGES, GRANT OPTION FROM pcontest@localhost');
+mysqli_query($link, 'DROP USER pcontest@localhost');
+mysqli_query($link, 'DROP USER pcontest');
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+
+Warning: %s: Too many open persistent links (%d) in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_reuse.phpt
@@ -0,0 +1,91 @@
+--TEST--
+mysqli_pconnect() - reusing/caching persistent connections - TODO
+--SKIPIF--
+<?php
+die("skip TODO - we need to add a user level way to check if CHANGE_USER gets called by pconnect");
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=2
+mysqli.max_links=2
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$host = 'p:' . $host;
+	if (!$link1 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+	if (!mysqli_query($link1, 'SET @pcondisabled = "Connection 1"'))
+		printf("[002] Cannot set user variable to check if we got the same persistent connection, [%d] %s\n",
+			mysqli_errno($link1), mysqli_error($link1));
+
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link1, 'SELECT @pcondisabled AS _test'))
+		printf("[004] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	printf("Connection 1 - SELECT @pcondisabled -> '%s'\n", $row['_test']);
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link2, 'SELECT @pcondisabled AS _test'))
+		printf("[005] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	printf("Connection 2 (no reuse) - SELECT @pcondisabled -> '%s'\n", $row['_test']);
+	$thread_id = mysqli_thread_id($link2);
+	printf("Connection 2 (no reuse) - Thread ID -> '%s'\n", $thread_id);
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link2, 'SET @pcondisabled = "Connection 2"'))
+		printf("[006] Cannot set user variable to check if we got the same persistent connection, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link2));
+
+	if (!$res = mysqli_query($link2, 'SELECT @pcondisabled AS _test'))
+		printf("[007] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	printf("Connection 2 - SELECT @pcondisabled -> '%s'\n", $row['_test']);
+	mysqli_free_result($res);
+
+	mysqli_close($link2);
+
+	/* reuse of existing persistent connection expected! */
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[008] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+			$host, $user, $db, $port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!$res = mysqli_query($link2, 'SELECT @pcondisabled AS _test'))
+		printf("[009] [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+
+	$row = mysqli_fetch_assoc($res);
+	printf("Connection 2 (reuse) - SELECT @pcondisabled -> '%s'\n", $row['_test']);
+	$thread_id_reuse = mysqli_thread_id($link2);
+	printf("Connection 2 (reuse) - Thread ID -> '%s'\n", $thread_id_reuse);
+	mysqli_free_result($res);
+
+	if ($thread_id != $thread_id_reuse)
+		printf("[010] Seems as if we have got a new connection, connections should have been cached and reused!\n");
+
+	mysqli_close($link1);
+	mysqli_close($link2);
+	print "done!";
+?>
+--EXPECTF--
+Connection 1 - SELECT @pcondisabled -> 'Connection 1'
+Connection 2 (no reuse) - SELECT @pcondisabled -> ''
+Connection 2 (no reuse) - Thread ID -> '%d'
+Connection 2 - SELECT @pcondisabled -> 'Connection 2'
+Connection 2 (reuse) - SELECT @pcondisabled -> 'Connection 2'
+Connection 2 (reuse) - Thread ID -> '%d'
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconn_twice.phpt
@@ -0,0 +1,77 @@
+--TEST--
+Calling connect() on an open persistent connection to create a new persistent connection
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=-1
+mysqli.max_links=-1
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$host = 'p:' . $host;
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (true !== ($tmp = my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)))
+		printf("[003] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	/* it is undefined which pooled connection we get - thread ids may differ */
+
+	if (!($res = mysqli_query($link, "SELECT 'ok' AS it_works")) ||
+		!($row = mysqli_fetch_assoc($res)))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (!$link = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[007] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+
+	if (true !== ($tmp = $link->real_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[009] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	/* it is undefined which pooled connection we get - thread ids may differ */
+
+	if (!($res = $link->query("SELECT 'works also with oo' AS syntax")) ||
+			!($row = $res->fetch_assoc()))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = $link->connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[013] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[014] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (NULL !== ($tmp = $link->connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[015] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"it_works"]=>
+  %unicode|string%(2) "ok"
+}
+array(1) {
+  [%u|b%"syntax"]=>
+  %unicode|string%(18) "works also with oo"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_pconnect.phpt
@@ -0,0 +1,72 @@
+--TEST--
+mysqli_pconnect()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$host = 'p:' . $host;
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	mysqli_close($link);
+
+	$num = 20;
+	$connections = array();
+	for ($i = 0; $i < $num; $i++) {
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[003] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		$connections[] = $link;
+	}
+	while (count($connections)) {
+		do {
+			$index = mt_rand(0, $num);
+		} while (!isset($connections[$index]));
+		mysqli_close($connections[$index]);
+		unset($connections[$index]);
+	}
+
+
+	$connections = array();
+	$num = 20;
+	for ($i = 0; $i < $num; $i++) {
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[004] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		$connections[] = $link;
+	}
+	$left = $num;
+
+	while (count($connections) && $left > 0) {
+		do {
+			$index = mt_rand(0, $num);
+		} while (!isset($connections[$index]) && $left > 0);
+		if (mt_rand(0, 1) > 0) {
+			$left--;
+			mysqli_close($connections[$index]);
+			unset($connections[$index]);
+		} else {
+			$left--;
+			if (!$connections[$index] = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+				printf("[004] Connect failed, [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		}
+		flush();
+	}
+
+	while (count($connections)) {
+		do {
+			$index = mt_rand(0, $num);
+		} while (!isset($connections[$index]));
+		mysqli_close($connections[$index]);
+		unset($connections[$index]);
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_phpinfo.phpt
@@ -0,0 +1,72 @@
+--TEST--
+phpinfo() mysqli section
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	include("connect.inc");
+
+	@ob_clean();
+	ob_start();
+	phpinfo();
+	$phpinfo = ob_get_contents();
+	ob_end_clean();
+
+	/* all versions should at least dump this minimum information */
+	if (!stristr($phpinfo, "mysqli support"))
+		printf("[001] ext/mysqli should have exposed itself.\n");
+
+	if (!stristr($phpinfo, "client api library version"))
+		printf("[002] ext/mysqli should have exposed the library version.\n");
+
+	if (!stristr($phpinfo, "mysqli.default_host"))
+		printf("[003] php.ini setting mysqli.default_host not shown.\n");
+
+	if (!stristr($phpinfo, "mysqli.default_port"))
+		printf("[004] php.ini setting mysqli.default_port not shown.\n");
+
+	if (!stristr($phpinfo, "mysqli.default_pw"))
+		printf("[005] php.ini setting mysqli.default_pw not shown.\n");
+
+	if (!stristr($phpinfo, "mysqli.default_socket"))
+		printf("[006] php.ini setting mysqli.default_socket not shown.\n");
+
+	if (!stristr($phpinfo, "mysqli.default_user"))
+		printf("[007] php.ini setting mysqli.default_user not shown.\n");
+
+	if (!stristr($phpinfo, "mysqli.max_links"))
+		printf("[008] php.ini setting mysqli.max_links not shown.\n");
+
+	if (!stristr($phpinfo, "mysqli.reconnect"))
+		printf("[009] php.ini setting mysqli.reconnect not shown.\n");
+
+	if ($IS_MYSQLND) {
+		$expected = array(
+			'client statistics',
+			'bytes_sent', 'bytes_received', 'packets_sent', 'packets_received',
+			'protocol_overhead_in', 'protocol_overhead_out', 'result_set_queries',
+			'non_result_set_queries', 'no_index_used', 'bad_index_used',
+			'buffered_sets', 'unbuffered_sets', 'ps_buffered_sets', 'ps_unbuffered_sets',
+			'flushed_normal_sets', 'flushed_ps_sets', 'rows_fetched_from_server',
+			'rows_fetched_from_client', 'rows_skipped', 'copy_on_write_saved',
+			'copy_on_write_performed', 'command_buffer_too_small', 'connect_success',
+			'connect_failure', 'connection_reused', 'explicit_close', 'implicit_close',
+			'disconnect_close', 'in_middle_of_command_close', 'explicit_free_result',
+			'implicit_free_result', 'explicit_stmt_close', 'implicit_stmt_close',
+			'size',
+			'mysqli.allow_local_infile',
+			'mysqli.allow_persistent', 'mysqli.max_persistent'
+		);
+		foreach ($expected as $k => $entry)
+			if (!stristr($phpinfo, $entry))
+				printf("[010] Could not find entry for '%s'\n", $entry);
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_ping.phpt
@@ -0,0 +1,47 @@
+--TEST--
+mysqli_ping()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_ping()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_null($tmp = @mysqli_ping($link, $link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	var_dump(mysqli_ping($link));
+
+	// provoke an error to check if mysqli_ping resets it
+	$res = mysqli_query($link, 'SELECT * FROM unknown_table');
+	if (!($errno = mysqli_errno($link)))
+		printf("[003] Statement should have caused an error\n");
+
+	var_dump(mysqli_ping($link));
+	if ($errno === mysqli_errno($link))
+		printf("[004] Error codes should have been reset\n");
+
+	mysqli_close($link);
+
+	if (!is_null($tmp = mysqli_ping($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+
+Warning: mysqli_ping(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_poll.phpt
@@ -0,0 +1,137 @@
+--TEST--
+int mysqli_poll() simple
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only feature, compile PHP using --with-mysqli=mysqlnd");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	function get_connection() {
+		global $host, $user, $passwd, $db, $port, $socket;
+
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		return $link;
+	}
+
+	if (!$link = get_connection())
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (NULL !== ($tmp = @mysqli_poll()))
+		printf("[002] Expecting NULL got %s\n", var_export($tmp, true));
+
+	$l = array($link);
+	if (NULL !== ($tmp = @mysqli_poll($l)))
+		printf("[003] Expecting NULL got %s\n", var_export($tmp, true));
+
+	$l = array($link); $n = NULL;
+	if (NULL !== ($tmp = @mysqli_poll($l, $n)))
+		printf("[004] Expecting NULL got %s\n", var_export($tmp, true));
+
+	$l = array($link); $n = NULL;
+	if (NULL !== ($tmp = @mysqli_poll($l, $n, $n)))
+		printf("[005] Expecting NULL got %s\n", var_export($tmp, true));
+
+	$l = array($link); $e = NULL; $r = NULL;
+	if (NULL !== ($tmp = @mysqli_poll($l, $e, $r, -1)))
+		printf("[007] Expecting boolean/false got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	$l = array($link); $e = NULL; $r = NULL;
+	if (NULL !== ($tmp = @mysqli_poll($l, $e, $r, 0, -1)))
+		printf("[008] Expecting boolean/false got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	$read = $error = $reject = array($link);
+	if (0 !== ($tmp = (mysqli_poll($read, $error, $reject, 0, 1))))
+		printf("[009] Expecting int/0 got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+
+	function poll_async($offset, $link, $links, $errors, $reject, $exp_ready, $use_oo_syntax) {
+
+		if ($exp_ready !== ($tmp = mysqli_poll($links, $errors, $reject, 0, 1000)))
+			printf("[%03d + 1] There should be %d links ready to read from, %d ready\n",
+				$exp_ready, $tmp);
+
+		foreach ($links as $mysqli) {
+			if ($use_oo_syntax) {
+				$res = $mysqli->reap_async_query();
+			} else {
+				$res = mysqli_reap_async_query($mysqli);
+			}
+			if (is_object($res)) {
+				printf("[%03d + 2] Can fetch resultset although no query has been run!\n", $offset);
+			} else if (mysqli_errno($mysqli) > 0) {
+				printf("[%03d + 3] Error indicated through links array: %d/%s",
+					$offset, mysqli_errno($mysqli), mysqli_error($mysqli));
+			} else {
+				printf("[%03d + 4] Cannot fetch and no error set - non resultset query (no SELECT)!\n", $offset);
+			}
+		}
+
+		foreach ($errors as $mysqli)
+			printf("[%03d + 5] Error on %d: %d/%s\n",
+				$offset, mysqli_thread_id($mysqli), mysqli_errno($mysqli), mysqli_error($mysqli));
+
+		foreach ($reject as $mysqli)
+			printf("[%03d + 6] Rejecting thread %d: %d/%s\n",
+				$offset, mysqli_thread_id($mysqli), mysqli_errno($mysqli), mysqli_error($mysqli));
+
+	}
+
+	// Connections on which no query has been send - 1
+	$link = get_connection();
+	$links = array($link);
+	$errors = array($link);
+	$reject = array($link);
+	poll_async(10, $link, $links, $errors, $reject, 0, false);
+	mysqli_close($link);
+
+	$link = get_connection();
+	$links = array($link);
+	$errors = array($link);
+	$reject = array($link);
+	poll_async(11, $link, $links, $errors, $reject, 0, true);
+	mysqli_close($link);
+
+	// Connections on which no query has been send - 2
+	// Difference: pass $links twice
+	$link = get_connection();
+	$links = array($link, $link);
+	$errors = array($link, $link);
+	$reject = array();
+	poll_async(12, $link, $links, $errors, $reject, 0, false);
+
+	// Connections on which no query has been send - 3
+	// Difference: pass two connections
+	$link = get_connection();
+	$links = array($link, get_connection());
+	$errors = array($link, $link);
+	$reject = array();
+	poll_async(13, $link, $links, $errors, $reject, 0, false);
+
+	// Reference mess...
+	$link = get_connection();
+	$links = array($link);
+	$errors = array($link);
+	$ref_errors =& $errors;
+	$reject = array();
+	poll_async(14, $link, $links, $ref_errors, $reject, 0, false);
+
+	print "done!";
+?>
+--EXPECTF--
+[010 + 6] Rejecting thread %d: 0/
+[011 + 6] Rejecting thread %d: 0/
+[012 + 6] Rejecting thread %d: 0/
+[012 + 6] Rejecting thread %d: 0/
+[013 + 6] Rejecting thread %d: 0/
+[013 + 6] Rejecting thread %d: 0/
+[014 + 6] Rejecting thread %d: 0/
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_poll_kill.phpt
@@ -0,0 +1,199 @@
+--TEST--
+int mysqli_poll() and kill
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only feature, compile PHP using --with-mysqli=mysqlnd");
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	function get_connection() {
+		global $host, $user, $passwd, $db, $port, $socket;
+
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		return $link;
+	}
+
+	// Killing connection - 1
+
+	$link = get_connection();
+	if (true !== ($tmp = mysqli_query($link, "SELECT 1 AS 'processed before killed'", MYSQLI_ASYNC |  MYSQLI_USE_RESULT)))
+		printf("[002] Expecting boolean/true got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	// Sleep 0.1s - the asynchronous query should have been processed after the wait period
+	usleep(100000);
+	$thread_id = mysqli_thread_id($link);
+	mysqli_kill(get_connection(), $thread_id);
+
+	$links = array($link);
+	$errors = array($link);
+	$reject = array($link);
+
+	// Yes, 1 - the asynchronous query should have been processed
+	if (1 !== ($tmp = (mysqli_poll($links, $errors, $reject, 0, 10000))))
+		printf("[003] Expecting int/1 got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	if (!is_array($links) || empty($links))
+		printf("[004] Expecting non-empty array got %s/%s\n", gettype($links), var_export($links, true));
+	else
+		foreach ($links as $link) {
+			if (is_object($res = mysqli_reap_async_query($link))) {
+				// Yes, you can fetch a result - the query has been processed
+				var_dump(mysqli_fetch_assoc($res));
+				mysqli_free_result($res);
+			} else if ($link->errno > 0) {
+				printf("[005] Error: %d\n", $link->errno);
+			}
+		}
+
+	// No error!
+	if (!is_array($errors) || !empty($errors))
+		printf("[006] Expecting non-empty array got %s/%s\n", gettype($errors), var_export($errors, true));
+
+	if (!is_array($reject) || !empty($reject))
+		printf("[007] Expecting empty array got %s/%s\n", gettype($reject), var_export($reject, true));
+
+	// Lets pass a dead connection
+	$links = array($link);
+	$errors = array($link);
+	$reject = array($link);
+	if (0 !== ($tmp = mysqli_poll($links, $errors, $reject, 1)))
+		printf("[008] There should be no connection ready! Returned %s/%s, expecting int/0.\n",
+			gettype($tmp), var_export($tmp, true));
+
+	if (!empty($errors))
+		printf("[009] There should be no errors but one rejected connection\n");
+
+	foreach ($reject as $mysqli)
+		if (mysqli_thread_id($mysqli) != $thread_id) {
+			printf("[010] Rejected thread %d should have rejected thread %d\n",
+				mysqli_thread_id($mysqli), $thread_id);
+		}
+
+	// Killing connection - 2
+
+	$link = get_connection();
+	if (true !== ($tmp = mysqli_query($link, "SELECT 1", MYSQLI_ASYNC |  MYSQLI_USE_RESULT)))
+		printf("[011] Expecting boolean/true got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	usleep(100000);
+	$thread_id = mysqli_thread_id($link);
+	mysqli_kill(get_connection(), $thread_id);
+
+	// Yes, 1 - fetch OK packet of kill!
+	$processed = 0;
+	do {
+		$links = array($link, $link);
+		$errors = array($link, $link);
+		$reject = array($link, $link);
+		$ready = mysqli_poll($links, $errors, $reject, 1);
+
+		if (!empty($errors)) {
+			foreach ($errors as $mysqli) {
+				printf("[012] Error on thread %d: %s/%s\n",
+					mysqli_thread_id($mysqli),
+					mysqli_errno($mysqli),
+					mysqli_error($mysqli));
+			}
+			break;
+		}
+
+		if (!empty($reject)) {
+			foreach ($reject as $mysqli) {
+				printf("[013] Rejecting thread %d: %s/%s\n",
+					mysqli_thread_id($mysqli),
+					mysqli_errno($mysqli),
+					mysqli_error($mysqli));
+			}
+			$processed += count($reject);
+		}
+
+		foreach ($links as $mysqli) {
+			if (is_object($res = mysqli_reap_async_query($mysqli))) {
+				printf("Fetching from thread %d...\n", mysqli_thread_id($mysqli));
+				var_dump(mysqli_fetch_assoc($res));
+			} else if (mysqli_errno($mysqli) > 0) {
+				printf("[014] %d/%s\n", mysqli_errno($mysqli), mysqli_error($mysqli));
+			}
+			$processed++;
+		}
+
+	} while ($processed < 2);
+
+
+	// Killing connection - 3
+
+	$link = get_connection();
+	$thread_id = mysqli_thread_id($link);
+	mysqli_kill(get_connection(), $thread_id);
+	// Sleep 0.1s  to ensure the KILL gets recognized
+	usleep(100000);
+	if (false !== ($tmp = mysqli_query($link, "SELECT 1 AS 'processed before killed'", MYSQLI_ASYNC |  MYSQLI_USE_RESULT)))
+		printf("[015] Expecting boolean/false got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	$links = array($link);
+	$errors = array($link);
+	$reject = array($link);
+
+	if (0 !== ($tmp = (mysqli_poll($links, $errors, $reject, 0, 10000))))
+		printf("[016] Expecting int/0 got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+	if (!is_array($links) || empty($links))
+		printf("[017] Expecting non-empty array got %s/%s\n", gettype($links), var_export($links, true));
+	else
+		foreach ($links as $link) {
+			if (is_object($res = mysqli_reap_async_query($link))) {
+				// No, you cannot fetch the result
+				var_dump(mysqli_fetch_assoc($res));
+				mysqli_free_result($res);
+			} else if ($link->errno > 0) {
+				// But you are supposed to handle the error the way its shown here!
+				printf("[018] Error: %d/%s\n", $link->errno, $link->error);
+			}
+		}
+
+	// None of these will indicate an error, check errno on the list of returned connections!
+	if (!is_array($errors) || !empty($errors))
+		printf("[019] Expecting non-empty array got %s/%s\n", gettype($errors), var_export($errors, true));
+
+	if (!is_array($reject) || !empty($reject))
+		printf("[020] Expecting empty array got %s/%s\n", gettype($reject), var_export($reject, true));
+
+
+	mysqli_close($link);
+	print "done!";
+?>
+--XFAIL--
+To be fixed later. Minor issue about fetching error message from killed line
+--EXPECTF--
+array(1) {
+  [%u|b%"processed before killed"]=>
+  %unicode|string%(1) "1"
+}
+Fetching from thread %d...
+array(1) {
+  [1]=>
+  %unicode|string%(1) "1"
+}
+
+Warning: mysqli_reap_async_query(): Premature end of data (mysqlnd_wireprotocol.c:%d) in %s on line %d
+
+Warning: mysqli_reap_async_query(): RSET_HEADER %s
+
+Warning: mysqli_reap_async_query(): Error reading result set's header in %s on line %d
+
+Warning: Error while sending QUERY packet. %s
+
+Warning: mysqli_reap_async_query(): %s
+
+Warning: mysqli_reap_async_query(): Error reading result set's header in %s on line %d
+[018] Error: %d/%s
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_poll_mixing_insert_select.phpt
@@ -0,0 +1,184 @@
+--TEST--
+mysqli_poll() & INSERT SELECT
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only feature, compile PHP using --with-mysqli=mysqlnd");
+?>
+--FILE--
+<?php
+	require_once('table.inc');
+
+	function get_connection() {
+		global $host, $user, $passwd, $db, $port, $socket;
+
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		return $link;
+	}
+
+
+	// Note: some queries will fail! They are supposed to fail.
+	$queries = array(
+			'CREATE TABLE IF NOT EXISTS bogus(id INT)',
+			'SET @a = 1',
+			'SELECT * FROM test ORDER BY id ASC LIMIT 2',
+			"INSERT INTO test(id, label) VALUES (100, 'z')",
+			'SELECT * FROM test ORDER BY id ASC LIMIT 2',
+			'SELECT',
+			'UPDATE test SET id = 101 WHERE id > 3',
+			'UPDATE_FIX test SET id = 101 WHERE id > 3',
+			'DROP TABLE IF EXISTS bogus',
+			'DELETE FROM test WHERE id = @a',
+			'DELETE FROM test WHERE id = 1',
+	);
+
+	$link = get_connection();
+	$have_proc = false;
+	mysqli_real_query($link, "DROP PROCEDURE IF EXISTS p");
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25), OUT ver_out VARCHAR(25)) BEGIN SELECT ver_in INTO ver_out; END;')) {
+			$have_proc = true;
+			$queries[] = "CALL p('myversion', @version)";
+	}
+	mysqli_close($link);
+
+	$links = array();
+	for ($i = 0; $i < count($queries); $i++) {
+
+		$link = get_connection();
+
+		if (true !== ($tmp = mysqli_query($link, $queries[$i], MYSQLI_ASYNC |  MYSQLI_USE_RESULT)))
+			printf("[002] Expecting true got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+		// WARNING KLUDGE NOTE
+		// Add a tiny delay to ensure that queries get executed in a certain order
+		// If your MySQL server is very slow the test may randomly fail!
+		usleep(20000);
+
+		$links[mysqli_thread_id($link)] = array(
+			'query' => $queries[$i],
+			'link' => $link,
+			'processed' => false,
+		);
+	}
+
+	$saved_errors = array();
+	do {
+		$poll_links = $poll_errors = $poll_reject = array();
+		foreach ($links as $thread_id => $link) {
+			if (!$link['processed']) {
+				$poll_links[] = $link['link'];
+				$poll_errors[] = $link['link'];
+				$poll_reject[] = $link['link'];
+			}
+		}
+		if (0 == count($poll_links))
+			break;
+
+		if (0 == ($num_ready = mysqli_poll($poll_links, $poll_errors, $poll_reject, 0, 200000)))
+			continue;
+
+		if (!empty($poll_errors)) {
+			die(var_dump($poll_errors));
+		}
+
+		foreach ($poll_links as $link) {
+			$thread_id = mysqli_thread_id($link);
+			$links[$thread_id]['processed'] = true;
+
+			if (is_object($res = mysqli_reap_async_query($link))) {
+				// result set object
+				while ($row = mysqli_fetch_assoc($res)) {
+					// eat up all results
+					;
+				}
+				mysqli_free_result($res);
+			} else {
+				// either there is no result (no SELECT) or there is an error
+				if (mysqli_errno($link) > 0) {
+					$saved_errors[$thread_id] = mysqli_errno($link);
+					printf("[003] '%s' caused %d\n", $links[$thread_id]['query'],	mysqli_errno($link));
+				}
+			}
+		}
+
+	} while (true);
+
+	// Checking if all lines are still usable
+	foreach ($links as $thread_id => $link) {
+		if (isset($saved_errors[$thread_id]) &&
+			$saved_errors[$thread_id] != mysqli_errno($link['link'])) {
+			printf("[004] Error state not saved for query '%s', %d != %d\n", $link['query'],
+					$saved_errors[$thread_id], mysqli_errno($link['link']));
+		}
+
+		if (!$res = mysqli_query($link['link'], 'SELECT * FROM test WHERE id = 100'))
+			printf("[005] Expecting true got %s/%s\n", gettype($tmp), var_export($tmp, true));
+		if (!$row = mysqli_fetch_row($res))
+			printf("[006] Expecting true got %s/%s\n", gettype($tmp), var_export($tmp, true));
+
+		mysqli_free_result($res);
+	}
+
+	if ($res = mysqli_query($link['link'], "SELECT * FROM test WHERE id = 100")) {
+		$row = mysqli_fetch_assoc($res);
+		var_dump($row);
+		mysqli_free_result($res);
+	}
+
+	if ($have_proc && ($res = mysqli_query($link['link'], "SELECT @version as _version"))) {
+		$row = mysqli_fetch_assoc($res);
+		if ($row['_version'] != 'myversion') {
+			printf("[007] Check procedures\n");
+		}
+		mysqli_free_result($res);
+	}
+
+	foreach ($links as $link)
+		mysqli_close($link['link']);
+
+	$link = get_connection();
+	if (!mysqli_query($link, 'SELECT 1', MYSQLI_ASYNC))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'SELECT 1', MYSQLI_ASYNC))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS bogus"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_query($link, "DROP PROCEDURE IF EXISTS p");
+
+mysqli_close($link);
+?>
+
+--EXPECTF--
+[003] 'SELECT' caused 1064
+[003] 'UPDATE test SET id = 101 WHERE id > 3' caused 1062
+[003] 'UPDATE_FIX test SET id = 101 WHERE id > 3' caused 1064
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(3) "100"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "z"
+}
+[009] [2014] %s
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_poll_reference.phpt
@@ -0,0 +1,220 @@
+--TEST--
+mysqli_poll() & references
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('connect.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only feature, compile PHP using --with-mysqli=mysqlnd");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip cannot connect");
+
+if (mysqli_get_server_version($link) < 50012)
+	die("skip Test needs SQL function SLEEP() available as of MySQL 5.0.12");
+
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	function get_connection() {
+		global $host, $user, $passwd, $db, $port, $socket;
+
+		if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+		return $link;
+	}
+
+
+	$mysqli1 = get_connection();
+	$mysqli2 = get_connection();
+
+	var_dump(mysqli_query($mysqli1, "SELECT SLEEP(0.10)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+	var_dump(mysqli_query($mysqli2, "SELECT SLEEP(0.20)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+
+	$processed = $loops = 0;
+	do {
+		$loops++;
+		if ($loops > 10) {
+			printf("[002] The queries should have finished already\n");
+			break;
+		}
+		// WARNING: All arrays point to the same object - this will give bogus results!
+		// The behaviour is in line with stream_select(). Be warned, be careful.
+		$links = $errors = $reject = array($mysqli1, $mysqli2);
+		if (0 == ($ready = mysqli_poll($links, $errors, $reject, 0, 50000))) {
+			continue;
+		}
+
+		foreach ($links as $link) {
+			if ($res = mysqli_reap_async_query($link)) {
+				mysqli_free_result($res);
+			}
+			$processed++;
+		}
+	} while ($processed < 2);
+
+	mysqli_close($mysqli1);
+	mysqli_close($mysqli2);
+
+	$mysqli1 = get_connection();
+	$mysqli2 = get_connection();
+
+	var_dump(mysqli_query($mysqli1, "SELECT SLEEP(0.10)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+	var_dump(mysqli_query($mysqli2, "SELECT SLEEP(0.20)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+
+	$processed = $loops = 0;
+	do {
+		$loops++;
+		if ($loops > 10) {
+			printf("[003] The queries should have finished already\n");
+			break;
+		}
+		// WARNING: All arrays point to the same object - this will give bogus results!
+		$links = $errors = array($mysqli1, $mysqli2);
+		$reject = array($mysqli1, $mysqli2);
+		if (0 == ($ready = mysqli_poll($links, $errors, $reject, 0, 50000))) {
+			continue;
+		}
+		foreach ($links as $link) {
+			if ($res = mysqli_reap_async_query($link)) {
+				mysqli_free_result($res);
+			}
+			$processed++;
+		}
+	} while ($processed < 2);
+
+	mysqli_close($mysqli1);
+	mysqli_close($mysqli2);
+
+	$mysqli1 = get_connection();
+	$mysqli2 = get_connection();
+
+	var_dump(mysqli_query($mysqli1, "SELECT SLEEP(0.10)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+	var_dump(mysqli_query($mysqli2, "SELECT SLEEP(0.20)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+
+	$processed = $loops = 0;
+	do {
+		$loops++;
+		if ($loops > 10) {
+			printf("[004] The queries should have finished already\n");
+			break;
+		}
+		// WARNING: All arrays point to the same object - this will give bogus results!
+		$links = array($mysqli1, $mysqli2);
+		$errors = $reject = array($mysqli1, $mysqli2);
+		if (0 == ($ready = mysqli_poll($links, $errors, $reject, 0, 50000))) {
+			continue;
+		}
+		foreach ($links as $link) {
+			if ($res = mysqli_reap_async_query($link)) {
+				mysqli_free_result($res);
+			}
+			$processed++;
+		}
+	} while ($processed < 2);
+
+	mysqli_close($mysqli1);
+	mysqli_close($mysqli2);
+
+	// This is bogus code and bogus usage - OK to throw no errors!
+	$mysqli1 = get_connection();
+	$mysqli2 = get_connection();
+
+	var_dump(mysqli_query($mysqli1, "SELECT SLEEP(0.10)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+	$thread_id = mysqli_thread_id($mysqli2);
+	printf("Connection %d should be rejected...\n", $thread_id);
+
+	$processed = $loops = 0;
+	do {
+		$loops++;
+		if ($loops > 10) {
+			printf("[005] The queries should have finished already\n");
+			break;
+		}
+		$links = $errors = $reject = array($mysqli1, $mysqli2);
+		if (0 == ($ready = mysqli_poll($links, $errors, $reject, 0, 50000))) {
+			continue;
+		}
+		// WARNING: Due to the reference issue none of these should ever fire!
+		foreach ($reject as $link) {
+			printf("Connection %d was rejected...\n", mysqli_thread_id($link));
+            if (mysqli_thread_id($link) != $thread_id) {
+                printf("[006] Connector %d should have been rejected. But also %d has been rejected.",
+                  $thread_id, mysqli_thread_id($link));
+            }
+			$processed++;
+		}
+		foreach ($errors as $link) {
+			printf("Connection %d has an error...\n", mysqli_thread_id($link));
+			$processed++;
+		}
+		foreach ($links as $link) {
+			if ($res = mysqli_reap_async_query($link)) {
+				mysqli_free_result($res);
+				$processed++;
+			}
+		}
+	} while ($processed < 2);
+
+	mysqli_close($mysqli1);
+	mysqli_close($mysqli2);
+
+	$mysqli1 = get_connection();
+	$mysqli2 = get_connection();
+
+	var_dump(mysqli_query($mysqli1, "SELECT SLEEP(0.10)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+	var_dump(mysqli_query($mysqli2, "SELECT SLEEP(0.20)", MYSQLI_ASYNC | MYSQLI_USE_RESULT));
+
+	$processed = $loops = 0;
+	$all = array($mysqli1, $mysqli2);
+	do {
+		$loops++;
+		if ($loops > 10) {
+			printf("[006] The queries should have finished already\n");
+			break;
+		}
+		$links = $errors = $reject = $all;
+		ob_start();
+		if (0 == ($ready = mysqli_poll($links, $errors, $reject, 0, 50000))) {
+			$tmp = ob_get_contents();
+			ob_end_clean();
+			if ($tmp != '') {
+				printf("Expected error:\n%s\n", $tmp);
+				break;
+			}
+			continue;
+		}
+		foreach ($links as $link) {
+			if ($res = mysqli_reap_async_query($link)) {
+				mysqli_free_result($res);
+			}
+			$processed++;
+		}
+	} while ($processed < 2);
+
+	$ready = mysqli_poll($links, $errors, $reject, 0, 50000);
+	mysqli_close($mysqli1);
+	mysqli_close($mysqli2);
+
+	print "done!";
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+Connection %d should be rejected...
+Connection %d was rejected...
+bool(true)
+bool(true)
+
+Warning: mysqli_poll(): All arrays passed are clear in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_prepare.phpt
@@ -0,0 +1,135 @@
+--TEST--
+mysqli_prepare()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_prepare()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_prepare($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (false !== ($tmp = @mysqli_prepare($link, false)))
+		printf("[003] Expecting boolean/false, got %s\n", gettype($tmp));
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test", MYSQLI_USE_RESULT))
+		printf("[004] [%d] %s, next test will fail\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_prepare($link, 'SELECT id FROM test WHERE id > ?')))
+		printf("[005] Expecting boolean/false, got %s, [%d] %s\n", gettype($tmp), mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'SELECT id FROM test'))) || !mysqli_stmt_execute($stmt))
+		printf("[006][%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test2"))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'CREATE TABLE test2(id INT) ENGINE =' . $engine))) || !mysqli_stmt_execute($stmt))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'INSERT INTO test2(id) VALUES(?)'))))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$id = 1;
+	if (!mysqli_stmt_bind_param($stmt, 'i', $id) || !mysqli_stmt_execute($stmt))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'REPLACE INTO test2(id) VALUES (?)'))))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$id = 2;
+	if (!mysqli_stmt_bind_param($stmt, 'i', $id) || !mysqli_stmt_execute($stmt))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'UPDATE test2 SET id = ? WHERE id = ?'))))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$id = 3;
+	$where = 2;
+	if (!mysqli_stmt_bind_param($stmt, 'ii', $id, $where) || !mysqli_stmt_execute($stmt))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'DELETE FROM test2 WHERE id = ?'))))
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$where = 3;
+	if (!mysqli_stmt_bind_param($stmt, 'i', $where) || !mysqli_stmt_execute($stmt))
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'SET @testvar = ?'))))
+		printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$testvar = 'testvar';
+	if (!mysqli_stmt_bind_param($stmt, 's', $testvar) || !mysqli_stmt_execute($stmt))
+		printf("[018] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+	if (!is_object(($stmt = mysqli_prepare($link, "DO GET_LOCK('testlock', 1)"))))
+		printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_stmt_close($stmt);
+
+	if (!is_object(($stmt = mysqli_prepare($link, 'SELECT id, @testvar FROM test2'))))
+		printf("[020] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$id = $testvar = null;
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_bind_result($stmt, $id, $testvar))
+		printf("[021] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	while (mysqli_stmt_fetch($stmt)) {
+		if (('testvar' !== $testvar) || (1 !== $id))
+			printf("[022] Expecting 'testvar'/1, got %s/%s. [%d] %s\n",
+				$testvar, $id, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	var_dump(mysqli_stmt_prepare($stmt, 'SELECT 1; SELECT 2'));
+
+	mysqli_stmt_close($stmt);
+
+	if (!is_null($tmp = @mysqli_stmt_prepare($link, 'SELECT id FROM test', 'foo')))
+		printf("[023] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (!is_null($tmp = @mysqli_stmt_prepare($link, 'SELECT id FROM test')))
+		printf("[024] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test2"))
+	printf("[c003] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+--EXPECTF--
+bool(false)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_prepare_no_object.phpt
@@ -0,0 +1,46 @@
+--TEST--
+mysqli_prepare() - no object on failure
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (false !== ($tmp = mysqli_prepare($link, false)))
+		printf("[001] Expecting boolean/false, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	printf("a) [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_prepare($link, '')))
+		printf("[002] Expecting boolean/false, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	printf("b) [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	if (!$mysqli = new my_mysqli($host, $user, $passwd, $db, $port, $socket))
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (false !== ($tmp = $mysqli->prepare(false)))
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	printf("c) [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	if (false !== ($tmp = $mysqli->prepare('')))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	printf("c) [%d] %s\n", $mysqli->errno, $mysqli->error);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+a) [1065] Query was empty
+b) [1065] Query was empty
+c) [1065] Query was empty
+c) [1065] Query was empty
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_ps_select_union.phpt
@@ -0,0 +1,275 @@
+--TEST--
+Prepared Statements and SELECT UNION
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	// Regular (non-prepared) queries
+	print "Using CAST('somestring' AS CHAR)...\n";
+	if (!($res = $link->query("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST('two' AS CHAR)")))
+		printf("[001] [%d] %s\n", $link->errno, $link->error);
+
+	$data = array();
+	while ($row = $res->fetch_assoc()) {
+		$data[] = $row['column1'];
+		var_dump($row['column1']);
+	}
+	$res->free();
+
+	// Prepared Statements
+	if (!($stmt = $link->prepare("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST('two' AS CHAR)")))
+		printf("[002] [%d] %s\n", $link->errno, $link->error);
+
+	$column1 = null;
+	if (!$stmt->execute() || !$stmt->bind_result($column1))
+		printf("[003] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$index = 0;
+	while ($stmt->fetch()) {
+		if ($data[$index] != $column1) {
+			printf("[004] Row %d, expecting %s/%s got %s/%s\n",
+				$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+		}
+		$index++;
+	}
+	$stmt->close();
+
+	if ($IS_MYSQLND) {
+		/*
+		Advantage mysqlnd -
+		The metadata mysqlnd has availabe after prepare is better than
+		the one made availabe by the MySQL Client Library (libmysql).
+		"libmysql" will give wrong results and that is OK -
+		http://bugs.mysql.com/bug.php?id=47483
+		*/
+		if (!($stmt = $link->prepare("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST('two' AS CHAR)")))
+			printf("[005] [%d] %s\n", $link->errno, $link->error);
+
+		$column1 = null;
+		/* Note: bind_result before execute */
+		if (!$stmt->bind_result($column1) || !$stmt->execute())
+			printf("[006] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$index = 0;
+		while ($stmt->fetch()) {
+			if ($data[$index] != $column1) {
+				printf("[007] Row %d, expecting %s/%s got %s/%s\n",
+					$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+			}
+			$index++;
+		}
+		$stmt->close();
+	}
+
+	// Regular (non-prepared) queries
+	print "Mixing CAST('somestring'AS CHAR), integer and CAST(integer AS CHAR)...\n";
+	if (!($res = $link->query("SELECT 1 AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST(2 AS CHAR)")))
+		printf("[008] [%d] %s\n", $link->errno, $link->error);
+
+	$data = array();
+	while ($row = $res->fetch_assoc()) {
+		$data[] = $row['column1'];
+	}
+	$res->free();
+
+	// Prepared Statements
+	if (!($stmt = $link->prepare("SELECT 1 AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST(2 AS CHAR)")))
+		printf("[009] [%d] %s\n", $link->errno, $link->error);
+
+	$column1 = null;
+	if (!$stmt->execute() || !$stmt->bind_result($column1))
+		printf("[010] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$index = 0;
+	while ($stmt->fetch()) {
+		if ($data[$index] != $column1) {
+			printf("[011] Row %d, expecting %s/%s got %s/%s\n",
+				$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+		}
+		var_dump($column1);
+		$index++;
+	}
+	$stmt->close();
+
+	if ($IS_MYSQLND) {
+		/* Advantage mysqlnd - see above... */
+		if (!($stmt = $link->prepare("SELECT 1 AS column1 UNION SELECT CAST('three' AS CHAR) UNION SELECT CAST(2 AS CHAR)")))
+			printf("[012] [%d] %s\n", $link->errno, $link->error);
+
+		$column1 = null;
+		if (!$stmt->bind_result($column1) || !$stmt->execute())
+			printf("[013] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$index = 0;
+		while ($stmt->fetch()) {
+			if ($data[$index] != $column1) {
+				printf("[014] Row %d, expecting %s/%s got %s/%s\n",
+					$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+			}
+			$index++;
+		}
+		$stmt->close();
+	}
+
+	print "Using integer only...\n";
+	if (!($res = $link->query("SELECT 1 AS column1 UNION SELECT 303 UNION SELECT 2")))
+		printf("[015] [%d] %s\n", $link->errno, $link->error);
+
+	$data = array();
+	while ($row = $res->fetch_assoc()) {
+		$data[] = $row['column1'];
+	}
+	$res->free();
+
+	// Prepared Statements
+	if (!($stmt = $link->prepare("SELECT 1 AS column1 UNION SELECT 303 UNION SELECT 2")))
+		printf("[016] [%d] %s\n", $link->errno, $link->error);
+
+	$column1 = null;
+	if (!$stmt->execute() || !$stmt->bind_result($column1))
+		printf("[017] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$index = 0;
+	while ($stmt->fetch()) {
+		if ($data[$index] != $column1) {
+			printf("[018] Row %d, expecting %s/%s got %s/%s\n",
+				$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+		}
+		var_dump($column1);
+		$index++;
+	}
+	$stmt->close();
+
+	if ($IS_MYSQLND) {
+		/* Advantage mysqlnd - see above */
+		if (!($stmt = $link->prepare("SELECT 1 AS column1 UNION SELECT 303 UNION SELECT 2")))
+			printf("[019] [%d] %s\n", $link->errno, $link->error);
+
+		$column1 = null;
+		if (!$stmt->bind_result($column1) || !$stmt->execute())
+			printf("[020] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$index = 0;
+		while ($stmt->fetch()) {
+			if ($data[$index] != $column1) {
+				printf("[021] Row %d, expecting %s/%s got %s/%s\n",
+					$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+			}
+			$index++;
+		}
+		$stmt->close();
+	}
+
+	print "Testing bind_param(), strings only...\n";
+	$two = 'two';
+	$three = 'three';
+	if (!($stmt = $link->prepare("SELECT 'one' AS column1 UNION SELECT ? UNION SELECT ?")))
+		printf("[022] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$column1 = null;
+	if (!$stmt->bind_param('ss', $three, $two) || !$stmt->execute() || !$stmt->bind_result($column1))
+		printf("[023] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$index = 0;
+	$data = array();
+	while ($stmt->fetch()) {
+		$data[$index++] = $column1;
+		var_dump($column1);
+	}
+	$stmt->close();
+
+	if ($IS_MYSQLND) {
+		/* Advantage mysqlnd - see above */
+		$two = 'two';
+		$three = 'three';
+		if (!($stmt = $link->prepare("SELECT 'one' AS column1 UNION SELECT ? UNION SELECT ?")))
+			printf("[024] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$column1 = null;
+		if (!$stmt->bind_param('ss', $three, $two) || !$stmt->bind_result($column1) || !$stmt->execute())
+			printf("[025] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$index = 0;
+		while ($stmt->fetch()) {
+			if ($data[$index] != $column1) {
+				printf("[26] Row %d, expecting %s/%s, got %s/%s\n",
+					$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+			}
+			$index++;
+		}
+		$stmt->close();
+	}
+
+	print "Testing bind_param(), strings only, with CAST AS CHAR...\n";
+	$two = 'two';
+	$three = 'three beers are more than enough';
+	if (!($stmt = $link->prepare("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST(? AS CHAR) UNION SELECT CAST(? AS CHAR)")))
+		printf("[027] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$column1 = null;
+	if (!$stmt->bind_param('ss', $three, $two) || !$stmt->execute() || !$stmt->bind_result($column1))
+		printf("[028] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	$index = 0;
+	$data = array();
+	while ($stmt->fetch()) {
+		$data[$index++] = $column1;
+		var_dump($column1);
+	}
+	$stmt->close();
+
+	if ($IS_MYSQLND) {
+		/* Advantage mysqlnd - see above */
+		$two = 'two';
+		$three = 'three beers are more than enough';
+		if (!($stmt = $link->prepare("SELECT CAST('one' AS CHAR) AS column1 UNION SELECT CAST(? AS CHAR) UNION SELECT CAST(? AS CHAR)")))
+			printf("[029] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$column1 = null;
+		if (!$stmt->bind_param('ss', $three, $two) || !$stmt->bind_result($column1) || !$stmt->execute())
+			printf("[030] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$index = 0;
+		while ($stmt->fetch()) {
+			if ($data[$index] != $column1) {
+				printf("[31] Row %d, expecting %s/%s, got %s/%s\n",
+					$index + 1, gettype($data[$index]), $data[$index], gettype($column1), $column1);
+			}
+			$index++;
+		}
+		$stmt->close();
+	}
+
+	$link->close();
+
+	print "done!";
+?>
+--EXPECTF--
+Using CAST('somestring' AS CHAR)...
+%unicode|string%(3) "one"
+%unicode|string%(5) "three"
+%unicode|string%(3) "two"
+Mixing CAST('somestring'AS CHAR), integer and CAST(integer AS CHAR)...
+%unicode|string%(1) "1"
+%unicode|string%(5) "three"
+%unicode|string%(1) "2"
+Using integer only...
+int(1)
+int(303)
+int(2)
+Testing bind_param(), strings only...
+%unicode|string%(3) "one"
+%unicode|string%(5) "three"
+%unicode|string%(3) "two"
+Testing bind_param(), strings only, with CAST AS CHAR...
+%unicode|string%(3) "one"
+%unicode|string%(32) "three beers are more than enough"
+%unicode|string%(3) "two"
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_query.phpt
@@ -0,0 +1,141 @@
+--TEST--
+mysqli_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_query()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_query($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (false !== ($tmp = @mysqli_query($link, '')))
+		printf("[002a] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_query($link, "SELECT 1 AS a", MYSQLI_USE_RESULT, "foo")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_query($link, 'THIS IS NOT SQL')))
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_query($link, "SELECT 'this is sql but with backslash g'\g")))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ((0 === mysqli_errno($link)) || ('' == mysqli_error($link)))
+		printf("[006] mysqli_errno()/mysqli_error should return some error\n");
+
+	if (!$res = mysqli_query($link, "SELECT 'this is sql but with semicolon' AS valid ; "))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (!$res = mysqli_query($link, "SELECT 'a' AS ''"))
+		printf("[007a] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($tmp = mysqli_fetch_assoc($res));
+	var_dump($tmp[""]);
+	mysqli_free_result($res);
+
+	if (false !== ($res = mysqli_query($link, 'SELECT "this is sql but with semicolon" AS valid ; SHOW VARIABLES')))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_get_server_version($link) > 50000) {
+		// let's try to play with stored procedures
+		mysqli_query($link, 'DROP PROCEDURE IF EXISTS p');
+		if (mysqli_query($link, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;')) {
+			$res = mysqli_query($link, 'CALL p(@version)');
+			$res = mysqli_query($link, 'SELECT @version AS p_version');
+
+			$tmp = mysqli_fetch_assoc($res);
+			if (!is_array($tmp) || empty($tmp) || !isset($tmp['p_version']) || ('' == $tmp['p_version'])) {
+				printf("[008a] Expecting array [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+
+			mysqli_free_result($res);
+		} else {
+			printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+		mysqli_query($link, 'DROP FUNCTION IF EXISTS f');
+		if (mysqli_query($link, 'CREATE FUNCTION f( ver_param VARCHAR(25)) RETURNS VARCHAR(25) DETERMINISTIC RETURN ver_param;')) {
+			$res = mysqli_query($link, 'SELECT f(VERSION()) AS f_version');
+
+			$tmp = mysqli_fetch_assoc($res);
+			if (!is_array($tmp) || empty($tmp) || !isset($tmp['f_version']) || ('' == $tmp['f_version'])) {
+				printf("[009a] Expecting array [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+
+			mysqli_free_result($res);
+		} else {
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+	}
+
+	if (!is_object($res = mysqli_query($link, "SELECT id FROM test ORDER BY id", MYSQLI_USE_RESULT)))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if (!is_object($res = mysqli_query($link, "SELECT id FROM test ORDER BY id", MYSQLI_STORE_RESULT)))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	$valid = array(MYSQLI_USE_RESULT, MYSQLI_STORE_RESULT);
+	do {
+		$mode = mt_rand(-1000, 1000);
+	} while (in_array($mode, $valid));
+
+	if (false !== ($res = @mysqli_query($link, "SELECT id FROM test ORDER BY id", $mode)))
+		printf("[013] Invalid mode should return false got %s/%s, [%d] %s\n",
+			gettype($res), (is_object($res)) ? 'object' : $res,
+			mysqli_errno($link), mysqli_error($link));
+
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_query($link, "SELECT id FROM test")))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+@mysqli_query($link, "DROP FUNCTION IF EXISTS f");
+@mysqli_query($link, 'DROP PROCEDURE IF EXISTS p');
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"valid"]=>
+  %unicode|string%(30) "this is sql but with semicolon"
+}
+array(1) {
+  [%u|b%""]=>
+  %unicode|string%(1) "a"
+}
+%unicode|string%(1) "a"
+
+Warning: mysqli_query(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_query_local_infile_large.phpt
@@ -0,0 +1,103 @@
+--TEST--
+mysql_query(LOAD DATA LOCAL INFILE) with large data set (10MB)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+
+$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+if (!$link)
+	die(sprintf("skip Can't connect [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	// Create a large CVS file
+	$file = tempnam(sys_get_temp_dir(), 'mysqli_test.cvs');
+	if (!$fp = fopen($file, 'w'))
+		printf("[001] Cannot create CVS file '%s'\n", $file);
+
+	$data = str_repeat("a", 127) . ";" . str_repeat("b", 127) . "\n";
+
+	$runtime = 5;
+	$max_bytes = 1024 * 1024 * 10;
+
+	$start = microtime(true);
+	$bytes = 0;
+	$rowno = 0;
+	while (($bytes < $max_bytes) && ((microtime(true) - $start) < $runtime)) {
+		if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1))
+			$bytes += fwrite($fp, (binary)(++$rowno . ";" . $data));
+		else
+			$bytes += fwrite($fp, ++$rowno . ";" . $data);
+	}
+	fclose($fp);
+	printf("Filesize in bytes: %d\nRows: %d\n", $bytes, $rowno);
+
+	require_once("connect.inc");
+ 	if (!($link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+		printf("[002] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+			!mysqli_query($link, "CREATE TABLE test(id INT, col1 VARCHAR(255), col2 VARCHAR(255)) ENGINE = " . $engine))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE test FIELDS TERMINATED BY ';'", mysqli_real_escape_string($link, $file))))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ((!is_string(mysqli_info($link))) || ('' == mysqli_info($link))) {
+		printf("[005] [%d] %s, mysqli_info not set \n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!($res = mysqli_query($link, "SELECT COUNT(*) AS _num FROM test")))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$row = mysqli_fetch_assoc($res);
+	if (($row["_num"] != $rowno))
+		printf("[007] Expecting %d rows, found %d\n", $rowno, $row["_num"]);
+
+	mysqli_free_result($res);
+
+	$random = mt_rand(1, $rowno);
+	if (!$res = mysqli_query($link, "SELECT id, col1, col2 FROM test WHERE id = " . $random))
+			printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$row = mysqli_fetch_assoc($res);
+	var_dump($row);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+$file = tempnam(sys_get_temp_dir(), 'mysqli_test.cvs');
+if (file_exists($file))
+	unlink($file);
+
+require_once("connect.inc");
+if (!($link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)))
+	printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+?>
+--EXPECTF--
+Filesize in bytes: %d
+Rows: %d
+array(3) {
+  [%u|b%"id"]=>
+  %unicode|string%(%d) "%d"
+  [%u|b%"col1"]=>
+  %unicode|string%(127) "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  [%u|b%"col2"]=>
+  %unicode|string%(127) "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_query_stored_proc.phpt
@@ -0,0 +1,195 @@
+--TEST--
+mysqli_query() - Stored Procedures
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) <= 50000) {
+	die(sprintf('skip Needs MySQL 5.0+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[001] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_query($link, 'CREATE PROCEDURE p() READS SQL DATA BEGIN SELECT id, label FROM test ORDER BY id ASC;
+END;')) {
+		/* stored proc which returns one result set */
+		if (mysqli_multi_query($link, 'CALL p()')) {
+			do {
+				if ($res = mysqli_use_result($link)) {
+					// skip results, don't fetch all from server
+					var_dump(mysqli_fetch_assoc($res));
+					mysqli_free_result($res);
+				}
+			} while (mysqli_more_results($link) && mysqli_next_result($link));
+
+		} else {
+			printf("[003] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+		if (mysqli_multi_query($link, 'CALL p()')) {
+			do {
+				if ($res = mysqli_store_result($link)) {
+					// fetch all results from server, but skip on client side
+					var_dump(mysqli_fetch_assoc($res));
+					mysqli_free_result($res);
+				}
+			} while (mysqli_more_results($link) && mysqli_next_result($link));
+
+		} else {
+			printf("[004] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+		if (mysqli_multi_query($link, 'CALL p()')) {
+			do {
+				if ($res = mysqli_store_result($link)) {
+					// fetch all results from server, but skip on client side
+					var_dump(mysqli_fetch_assoc($res));
+					while (mysqli_fetch_assoc($res))
+						;
+					mysqli_free_result($res);
+				}
+			} while (mysqli_more_results($link) && mysqli_next_result($link));
+
+		} else {
+			printf("[005] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+	} else {
+		printf("[002] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[006] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_query($link, 'CREATE PROCEDURE p() READS SQL DATA BEGIN SELECT id, label FROM test ORDER BY id ASC; SELECT id FROM test ORDER BY id ASC; END;')) {
+		/* stored proc which returns two result sets */
+
+		if (mysqli_multi_query($link, 'CALL p()')) {
+			do {
+				if ($res = mysqli_store_result($link)) {
+					// fetch all results from server, but skip on client side
+					var_dump(mysqli_fetch_assoc($res));
+					mysqli_free_result($res);
+				}
+			} while (mysqli_more_results($link) && mysqli_next_result($link));
+
+		} else {
+			printf("[008] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+	} else {
+		printf("[007] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[009] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;')) {
+		/* no result set, just output parameter */
+		if (!mysqli_query($link, 'CALL p(@version)'))
+			printf("[011] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_query($link, "SET @version = 'unknown'"))
+			printf("[012] Cannot reset user variable, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_query($link, 'CALL p(@version)'))
+			printf("[013] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!$res = mysqli_query($link, 'SELECT @version as _vers'))
+			printf("[014] Cannot fetch user variable, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!$row = mysqli_fetch_assoc($res) ||
+				$row['_vers'] == 'unknown')
+			printf("[015] Results seem wrong, got %s, [%d] %s\n",
+				$row['_vers'],
+				mysqli_errno($link), mysqli_error($link));
+		mysqli_free_result($res);
+
+	} else {
+		printf("[010] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[016] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25), OUT ver_out VARCHAR(25)) BEGIN SELECT ver_in INTO ver_out; END;')) {
+		/* no result set, one input, one output parameter */
+		if (!mysqli_query($link, "CALL p('myversion', @version)"))
+			printf("[018] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_query($link, "SET @version = 'unknown'"))
+			printf("[019] Cannot reset user variable, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_query($link, "CALL p('myversion', @version)"))
+			printf("[020] Cannot call SP, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!$res = mysqli_query($link, 'SELECT @version as _vers'))
+			printf("[021] Cannot fetch user variable, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!$row = mysqli_fetch_assoc($res) ||
+				$row['_vers'] == 'myversion')
+			printf("[022] Results seem wrong, got %s, [%d] %s\n",
+				$row['_vers'],
+				mysqli_errno($link), mysqli_error($link));
+		mysqli_free_result($res);
+
+	} else {
+		printf("[017] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+@mysqli_query($link, "DROP PROCEDURE IS EXISTS p");
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+array(1) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_query_unicode.phpt
@@ -0,0 +1,133 @@
+--TEST--
+mysqli_query() - unicode (cyrillic)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+require_once('table.inc');
+if (!$res = mysqli_query($link, "SHOW CHARACTER SET LIKE 'utf8'"))
+	die("skip UTF8 chatset seems not available");
+mysqli_free_result($res);
+mysqli_close($link);
+?>
+--FILE--
+<?php
+	include_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_query()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_query($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require_once('table.inc');
+
+	if (TRUE !== ($tmp = @mysqli_query($link, "set names utf8")))
+		printf("[002.5] Expecting TRUE, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_query($link, "SELECT 1 AS ", MYSQLI_USE_RESULT, "foo")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_query($link, '   ')))
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_query($link, "SELECT '  ,      g'\g")))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ((0 === mysqli_errno($link)) || ('' == mysqli_error($link)))
+		printf("[006] mysqli_errno()/mysqli_error should return some error\n");
+
+	if (!$res = mysqli_query($link, "SELECT ' ,     ' AS  ; "))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (false !== ($res = mysqli_query($link, "SELECT ' ,     ' AS  ; SHOW VARIABLES")))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_get_server_version($link) > 50000) {
+		// let's try to play with stored procedures
+		mysqli_query($link, 'DROP PROCEDURE IF EXISTS ');
+		if (mysqli_query($link, 'CREATE PROCEDURE (OUT  VARCHAR(25)) BEGIN SELECT VERSION() INTO ; END;')) {
+			$res = mysqli_query($link, 'CALL (@version)');
+			$res = mysqli_query($link, 'SELECT @version AS _');
+
+			$tmp = mysqli_fetch_assoc($res);
+			if (!is_array($tmp) || empty($tmp) || !isset($tmp['_']) || ('' == $tmp['_'])) {
+				printf("[008a] Expecting array [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+
+			mysqli_free_result($res);
+		} else {
+			printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+		mysqli_query($link, 'DROP FUNCTION IF EXISTS ');
+		if (mysqli_query($link, 'CREATE FUNCTION ( _ VARCHAR(25)) RETURNS VARCHAR(25) DETERMINISTIC RETURN _;')) {
+			$res = mysqli_query($link, 'SELECT (VERSION()) AS _');
+
+			$tmp = mysqli_fetch_assoc($res);
+			if (!is_array($tmp) || empty($tmp) || !isset($tmp['_']) || ('' == $tmp['_'])) {
+				printf("[009a] Expecting array [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+
+			mysqli_free_result($res);
+		} else {
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+	}
+
+	/*
+	Trying to test what Ramil suggests in http://bugs.mysql.com/bug.php?id=29576
+	However, this won't work, because we're lacking MYSQLI_SET_CHARSET_NAME.
+	if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1)) {
+		if (mysqli_get_server_version() > 50002) {
+			@mysqli_query($link, "DROP USER IF EXISTS ''@'%'");
+			if (TRUE !== mysqli_query($link, "CREATE USER ''@'%'")) {
+				var_dump(mysqli_error($link);
+			}
+		}
+		if (TRUE !== mysqli_query($link, "GRANT SELECT ON $db.* TO ''@'%' IDENTIFIED BY ''")) {
+			var_dump(mysqli_error($link);
+		} else {
+			$link2 = mysqli_init();
+			if (!(mysqli_real_connect($link2, $host, "", '', $db, $port, $socket))) {
+				printf("[011] Cannot connect to the server using host=%s, user=%s, passwd=, dbname=%s, port=%s, socket=%s, [%d] %s\n",
+					$host, "", $db, $port, $socket,
+					mysqli_connect_errno(), mysqli_connect_error());
+			}
+			mysqli_close($link2);
+			if (mysqli_get_server_version() > 50002) {
+				if (!mysqli_query($link, "DROP USER ''@'%'"))
+					printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				} else {
+					printf("[015] Cannot create user or grant privileges, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				}
+			}
+		}
+	}
+	*/
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_query($link, "SELECT id FROM test")))
+		printf("[014] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%""]=>
+  %unicode|string%(%d) " ,     "
+}
+
+Warning: mysqli_query(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_connect.phpt
@@ -0,0 +1,219 @@
+--TEST--
+mysqli_real_connect()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	include("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link)))
+		printf("[001a] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link)))
+		printf("[001b] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link, $link)))
+		printf("[001c] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link, $link, $link)))
+		printf("[001d] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link, $link, $link, $link)))
+		printf("[001e] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link, $link, $link, $link, $link)))
+		printf("[001f] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link, $link, $link, $link, $link, $link)))
+		printf("[001g] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	//  ( mysqli link [, string hostname [, string username [, string passwd [, string dbname [, int port [, string socket [, int flags]]]]]]]
+	if (NULL !== ($tmp = @mysqli_real_connect($link, $link, $link, $link, $link, $link, $link, $link)))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = mysqli_init())
+		printf("[002] mysqli_init() failed\n");
+
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	mysqli_close($link);
+	if (!$link = mysqli_init())
+		printf("[004] mysqli_init() failed\n");
+
+	if (false !== ($tmp = mysqli_real_connect($link, $host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket)))
+		printf("[005] Expecting boolean/false got %s/%s. Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n", gettype($tmp), $tmp, $host, $user . 'unknown_really', $db, $port, $socket);
+
+	// Run the following tests without an anoynmous MySQL user and use a password for the test user!
+	ini_set('mysqli.default_socket', $socket);
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port)) {
+		printf("[006] Usage of mysqli.default_socket failed\n");
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[007] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_port', $port);
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db)) {
+		printf("[008] Usage of mysqli.default_port failed\n");
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[009] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_pw', $passwd);
+	if (!mysqli_real_connect($link, $host, $user)) {
+		printf("[010] Usage of mysqli.default_pw failed\n") ;
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[011] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_user', $user);
+	if (!mysqli_real_connect($link, $host)) {
+		printf("[012] Usage of mysqli.default_user failed\n") ;
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[011] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_host', $host);
+	if (!mysqli_real_connect($link)) {
+		printf("[014] Usage of mysqli.default_host failed\n") ;
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[015] mysqli_init() failed\n");
+	}
+
+	// CLIENT_MULTI_STATEMENTS - should be disabled silently
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, 65536))
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($res = mysqli_query($link, "SELECT 1 AS a; SELECT 2 AS b")) {
+		printf("[017] Should have failed. CLIENT_MULTI_STATEMENT should have been disabled.\n");
+		var_dump($res->num_rows);
+		mysqli_next_result($link);
+		$res = mysqli_store_result($link);
+		var_dump($res->num_rows);
+	}
+
+
+	mysqli_close($link);
+	if (!$link = mysqli_init())
+		printf("[018] mysqli_init() failed\n");
+
+	if (ini_get('open_basedir')) {
+		// CLIENT_LOCAL_FILES should be blocked - but how to test it ?!
+
+		if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, 128))
+			printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$filename = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'mysqli_real_connect_phpt';
+		if (!$fp = fopen($filename, 'w'))
+			printf("[020] Cannot open temporary file %s\n", $filename);
+
+		fwrite($fp, '100;z');
+		fclose($fp);
+
+		// how do we test if gets forbidden because of a missing right or the flag, this test is partly bogus ?
+		if (mysqli_query($link, "LOAD DATA LOCAL INFILE '$filename' INTO TABLE test FIELDS TERMINATED BY ';'"))
+			printf("[021] LOAD DATA INFILE should have been forbidden!\n");
+
+		unlink($filename);
+	}
+
+	mysqli_close($link);
+	@var_dump($link);
+
+	if ($IS_MYSQLND) {
+		ini_set('mysqli.default_host', 'p:' . $host);
+		$link = mysqli_init();
+		if (!@mysqli_real_connect($link)) {
+			printf("[022] Usage of mysqli.default_host=p:%s (persistent) failed\n", $host) ;
+		} else {
+			if (!$res = mysqli_query($link, "SELECT 'mysqli.default_host (persistent)' AS 'testing'"))
+				printf("[023] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			$tmp = mysqli_fetch_assoc($res);
+			if ($tmp['testing'] !== 'mysqli.default_host (persistent)') {
+				printf("[024] Result looks strange - check manually, [%d] %s\n",
+					mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+			mysqli_free_result($res);
+			mysqli_close($link);
+		}
+
+		ini_set('mysqli.default_host', 'p:');
+		$link = mysqli_init();
+		if (@mysqli_real_connect($link)) {
+			printf("[025] Usage of mysqli.default_host=p: did not fail\n") ;
+			mysqli_close($link);
+		}
+		@mysqli_close($link);
+	}
+
+	if (NULL !== ($tmp = mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)))
+		printf("[026] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_real_connect(): (%d/%d): Access denied for user '%s'@'%s' (using password: YES) in %s on line %d
+object(mysqli)#%d (18) {
+  ["affected_rows"]=>
+  NULL
+  ["client_info"]=>
+  %s
+  ["client_version"]=>
+  int(%d)
+  ["connect_errno"]=>
+  int(0)
+  ["connect_error"]=>
+  %s
+  ["errno"]=>
+  %s
+  ["error"]=>
+  %s
+  ["field_count"]=>
+  NULL
+  ["host_info"]=>
+  %s
+  ["info"]=>
+  NULL
+  ["insert_id"]=>
+  NULL
+  ["server_info"]=>
+  NULL
+  ["server_version"]=>
+  NULL
+  ["stat"]=>
+  NULL
+  ["sqlstate"]=>
+  NULL
+  ["protocol_version"]=>
+  NULL
+  ["thread_id"]=>
+  NULL
+  ["warning_count"]=>
+  NULL
+}
+
+Warning: mysqli_real_connect(): Couldn't fetch mysqli in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_connect_pconn.phpt
@@ -0,0 +1,155 @@
+--TEST--
+mysqli_real_connect() - persistent connections
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$IS_MYSQLND)
+	die("skip mysqlnd only test");
+?>
+--INI--
+mysqli.allow_persistent=1
+mysqli.max_persistent=10
+--FILE--
+<?php
+	require_once("connect.inc");
+	$host = 'p:' . $host;
+
+	if (!$link = mysqli_init())
+		printf("[002] mysqli_init() failed\n");
+
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket))
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	mysqli_close($link);
+	if (!$link = mysqli_init())
+		printf("[004] mysqli_init() failed\n");
+
+	if (false !== ($tmp = mysqli_real_connect($link, $host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket)))
+		printf("[005] Expecting boolean/false got %s/%s. Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n", gettype($tmp), $tmp, $host, $user . 'unknown_really', $db, $port, $socket);
+
+	// Run the following tests without an anoynmous MySQL user and use a password for the test user!
+	ini_set('mysqli.default_socket', $socket);
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port)) {
+		printf("[006] Usage of mysqli.default_socket failed\n");
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[007] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_port', $port);
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db)) {
+		printf("[008] Usage of mysqli.default_port failed\n");
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[009] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_pw', $passwd);
+	if (!mysqli_real_connect($link, $host, $user)) {
+		printf("[010] Usage of mysqli.default_pw failed\n") ;
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[011] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_user', $user);
+	if (!mysqli_real_connect($link, $host)) {
+		printf("[012] Usage of mysqli.default_user failed\n") ;
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[011] mysqli_init() failed\n");
+	}
+
+	ini_set('mysqli.default_host', $host);
+	if (!mysqli_real_connect($link)) {
+		printf("[014] Usage of mysqli.default_host failed\n") ;
+	} else {
+		mysqli_close($link);
+		if (!$link = mysqli_init())
+			printf("[015] mysqli_init() failed\n");
+	}
+
+	// CLIENT_MULTI_STATEMENTS - should be disabled silently
+	if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, 65536))
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($res = mysqli_query($link, "SELECT 1 AS a; SELECT 2 AS b")) {
+		printf("[017] Should have failed. CLIENT_MULTI_STATEMENT should have been disabled.\n");
+		var_dump($res->num_rows);
+		mysqli_next_result($link);
+		$res = mysqli_store_result($link);
+		var_dump($res->num_rows);
+	}
+
+
+	mysqli_close($link);
+	if (!$link = mysqli_init())
+		printf("[018] mysqli_init() failed\n");
+
+	if (ini_get('open_basedir')) {
+		// CLIENT_LOCAL_FILES should be blocked - but how to test it ?!
+
+		if (!mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket, 128))
+			printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$filename = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'mysqli_real_connect_phpt';
+		if (!$fp = fopen($filename, 'w'))
+			printf("[020] Cannot open temporary file %s\n", $filename);
+
+		fwrite($fp, '100;z');
+		fclose($fp);
+
+		// how do we test if gets forbidden because of a missing right or the flag, this test is partly bogus ?
+		if (mysqli_query($link, "LOAD DATA LOCAL INFILE '$filename' INTO TABLE test FIELDS TERMINATED BY ';'"))
+			printf("[021] LOAD DATA INFILE should have been forbidden!\n");
+
+		unlink($filename);
+	}
+
+	mysqli_close($link);
+
+	if ($IS_MYSQLND) {
+		$link = mysqli_init();
+		if (!@mysqli_real_connect($link)) {
+			printf("[022] Usage of mysqli.default_host=p:%s (persistent) failed\n", $host) ;
+		} else {
+			if (!$res = mysqli_query($link, "SELECT 'mysqli.default_host (persistent)' AS 'testing'"))
+				printf("[023] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+			$tmp = mysqli_fetch_assoc($res);
+			if ($tmp['testing'] !== 'mysqli.default_host (persistent)') {
+				printf("[024] Result looks strange - check manually, [%d] %s\n",
+					mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+			mysqli_free_result($res);
+			mysqli_close($link);
+		}
+
+		ini_set('mysqli.default_host', 'p:');
+		$link = mysqli_init();
+		if (@mysqli_real_connect($link)) {
+			printf("[025] Usage of mysqli.default_host=p: did not fail\n") ;
+			mysqli_close($link);
+		}
+	}
+
+	if (NULL === ($tmp = mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)))
+		printf("[026] Expecting not NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_real_connect(): (%d/%d): Access denied for user '%s'@'%s' (using password: YES) in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysqli_real_escape_string()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_real_escape_string()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_escape_string($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (NULL !== ($tmp =@mysqli_real_escape_string($link, "foo", "foo")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("foo\\0bar" !== ($tmp = mysqli_real_escape_string($link, "foo" . chr(0) . "bar")))
+		printf("[009] Expecting %s, got %s\n", "foo\\0bar", $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_real_escape_string($link, 'foo')))
+		printf("[010] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	/* Make sure that the function alias exists */
+	if (NULL !== ($tmp = @mysqli_escape_string()))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_real_escape_string(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_big5.phpt
@@ -0,0 +1,82 @@
+--TEST--
+mysqli_real_escape_string() - big5
+--SKIPIF--
+<?php
+if (ini_get('unicode.semantics'))
+	die("skip Test cannot be run in unicode mode");
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to MySQL, [%d] %s\n",
+		mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (!mysqli_set_charset($link, 'big5'))
+	die(sprintf("skip Cannot set charset 'big5'"));
+mysqli_close($link);
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+{
+		printf("[001] Cannot connect to the server using host=%s, user=%s,
+passwd=***, dbname=%s, port=%s, socket=%s - [%d] %s\n", $host, $user, $db,
+$port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY
+KEY(id)) ENGINE=' . $engine . " DEFAULT CHARSET=big5")) {
+		printf("Failed to create test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	var_dump(mysqli_set_charset($link, "big5"));
+
+	if ('HUe\\\\HUe' !== ($tmp = mysqli_real_escape_string($link,
+'HUe\\HUe')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('HUe\"HUe' !== ($tmp = mysqli_real_escape_string($link,
+'HUe"HUe')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("HUe\'HUe" !== ($tmp = mysqli_real_escape_string($link,
+"HUe'HUe")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("HUe\\nHUe" !== ($tmp = mysqli_real_escape_string($link,
+"HUe\nHUe")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("HUe\\rHUe" !== ($tmp = mysqli_real_escape_string($link,
+"HUe\rHUe")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("HUe\\0HUe" !== ($tmp = mysqli_real_escape_string($link, "HUe"
+. chr(0) . "HUe")))
+		printf("[009] Expecting %s, got %s\n", "HUe\\0HUe", $tmp);
+
+	var_dump(mysqli_query($link, "INSERT INTO test(id, label) VALUES (100,
+'')"));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_eucjpms.phpt
@@ -0,0 +1,75 @@
+--TEST--
+mysqli_real_escape_string() - eucjpms
+--SKIPIF--
+<?php
+if (ini_get('unicode.semantics'))
+	die("skip Test cannot be run in unicode mode");
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to MySQL, [%d] %s\n",
+		mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (!mysqli_set_charset($link, 'eucjpms'))
+	die(sprintf("skip Cannot set charset 'eucjpms'"));
+mysqli_close($link);
+?>
+--FILE--
+<?php
+require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+{
+		printf("[001] Cannot connect to the server using host=%s, user=%s,
+passwd=***, dbname=%s, port=%s, socket=%s - [%d] %s\n", $host, $user, $db,
+$port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY
+KEY(id)) ENGINE=' . $engine . " DEFAULT CHARSET=eucjpms")) {
+		printf("Failed to create test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	var_dump(mysqli_set_charset($link, "eucjpms"));
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("\\0" !== ($tmp = mysqli_real_escape_string($link, "" . chr(0) . "")))
+		printf("[009] Expecting %s, got %s\n", "\\0", $tmp);
+
+	var_dump(mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, '')"));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_euckr.phpt
@@ -0,0 +1,74 @@
+--TEST--
+mysqli_real_escape_string() - euckr
+--SKIPIF--
+<?php
+if (ini_get('unicode.semantics'))
+	die("skip Test cannot be run in unicode mode");
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to MySQL, [%d] %s\n",
+		mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (!mysqli_set_charset($link, 'euckr'))
+	die(sprintf("skip Cannot set charset 'euckr'"));
+mysqli_close($link);
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+{
+		printf("[001] Cannot connect to the server using host=%s, user=%s,
+passwd=***, dbname=%s, port=%s, socket=%s - [%d] %s\n", $host, $user, $db,
+$port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY
+KEY(id)) ENGINE=' . $engine . " DEFAULT CHARSET=euckr")) {
+		printf("Failed to create test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	var_dump(mysqli_set_charset($link, "euckr"));
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("\\0" !== ($tmp = mysqli_real_escape_string($link, "" . chr(0) . "")))
+		printf("[009] Expecting %s, got %s\n", "\\0", $tmp);
+
+	var_dump(mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, '')"));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_gb2312.phpt
@@ -0,0 +1,75 @@
+--TEST--
+mysqli_real_escape_string() - gb2312
+--SKIPIF--
+<?php
+if (ini_get('unicode.semantics'))
+	die("skip Test cannot be run in unicode mode");
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to MySQL, [%d] %s\n",
+		mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (!mysqli_set_charset($link, 'gb2312'))
+	die(sprintf("skip Cannot set charset 'gb2312'"));
+mysqli_close($link);
+?>
+--FILE--
+<?php
+
+	require_once("connect.inc");
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+{
+		printf("[001] Cannot connect to the server using host=%s, user=%s,
+passwd=***, dbname=%s, port=%s, socket=%s - [%d] %s\n", $host, $user, $db,
+$port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY
+KEY(id)) ENGINE=' . $engine . " DEFAULT CHARSET=gb2312")) {
+		printf("Failed to create test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	var_dump(mysqli_set_charset($link, "gb2312"));
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("\\0" !== ($tmp = mysqli_real_escape_string($link, "" . chr(0) . "")))
+		printf("[009] Expecting %s, got %s\n", "\\0", $tmp);
+
+	var_dump(mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, '')"));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_gbk.phpt
@@ -0,0 +1,77 @@
+--TEST--
+mysqli_real_escape_string() - gbk
+--SKIPIF--
+<?php
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip set character set not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
+}
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to MySQL, [%d] %s\n",
+		mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (!mysqli_set_charset($link, 'gbk'))
+	die(sprintf("skip Cannot set charset 'gbk'"));
+
+mysqli_close($link);
+?>
+--FILE--
+<?php
+
+	require_once("connect.inc");
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+{
+		printf("[001] Cannot connect to the server using host=%s, user=%s,
+passwd=***, dbname=%s, port=%s, socket=%s - [%d] %s\n", $host, $user, $db,
+$port, $socket, mysqli_connect_errno(), mysqli_connect_error());
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY
+KEY(id)) ENGINE=' . $engine . " DEFAULT CHARSET=gbk")) {
+		printf("Failed to create test table: [%d] %s\n", mysqli_errno($link),
+mysqli_error($link));
+	}
+
+	var_dump(mysqli_set_charset($link, "gbk"));
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("\\0" !== ($tmp = mysqli_real_escape_string($link, "" . chr(0) . "")))
+		printf("[009] Expecting %s, got %s\n", "\\0", $tmp);
+
+	var_dump(mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, '')"));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_nobackslash.phpt
@@ -0,0 +1,65 @@
+--TEST--
+mysqli_real_escape_string() - SQL Mode NO_BACKSLASH_ESCAPE
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once('table.inc');
+
+	if (!mysqli_query($link, 'SET @@sql_mode="NO_BACKSLASH_ESCAPES"'))
+		printf("[001] Cannot set NO_BACKSLASH_ESCAPES, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ('\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[002] Expecting \\, got %s\n", $tmp);
+
+	if ('"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[003] Expecting \", got %s\n", $tmp);
+
+	if ("''" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[004] Expecting '', got %s\n", $tmp);
+
+	if ("\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[005] Expecting \\n, got %s\n", $tmp);
+
+	if ("\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[006] Expecting \\r, got %s\n", $tmp);
+
+	assert("foo" . chr(0) . "bar" === "foo" . chr(0) . "bar");
+	if ("foo" . chr(0) . "bar" !== ($tmp = mysqli_real_escape_string($link, "foo" . chr(0) . "bar")))
+		printf("[007] Expecting %s, got %s\n", "foo" . chr(0) . "bar", $tmp);
+
+	if (!mysqli_query($link, sprintf('INSERT INTO test(id, label) VALUES (100, "%s")',
+			mysqli_real_escape_string($link, "\\"))))
+		printf("[009] Cannot INSERT, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!($res = mysqli_query($link, 'SELECT label FROM test WHERE id = 100')) ||
+			!($row = mysqli_fetch_assoc($res)))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	var_dump($row);
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, 'SET @@sql_mode=""'))
+		printf("[011] Cannot disable NO_BACKSLASH_ESCAPES, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[012] Expecting \\, got %s\n", $tmp);
+
+	if ("foo\\0bar" !== ($tmp = mysqli_real_escape_string($link, "foo" . chr(0) . "bar")))
+		printf("[013] Expecting %s, got %s\n", "foo" . chr(0) . "bar", $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"label"]=>
+  %unicode|string%(1) "\"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_sjis.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysqli_real_escape_string() - sjis
+--SKIPIF--
+<?php
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip set character set not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
+}
+
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to MySQL, [%d] %s\n",
+		mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (!mysqli_set_charset($link, 'sjis'))
+	die(sprintf("skip Cannot set charset 'sjis'"));
+mysqli_close($link);
+?>
+--FILE--
+<?php
+
+	require_once("connect.inc");
+	require_once('table.inc');
+
+	var_dump(mysqli_set_charset($link, "sjis"));
+
+	if ('?p??\\\\?p??' !== ($tmp = mysqli_real_escape_string($link, '?p??\\?p??')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('?p??\"?p??' !== ($tmp = mysqli_real_escape_string($link, '?p??"?p??')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("?p??\'?p??" !== ($tmp = mysqli_real_escape_string($link, "?p??'?p??")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("?p??\\n?p??" !== ($tmp = mysqli_real_escape_string($link, "?p??\n?p??")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("?p??\\r?p??" !== ($tmp = mysqli_real_escape_string($link, "?p??\r?p??")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("?p??\\0?p??" !== ($tmp = mysqli_real_escape_string($link, "?p??" . chr(0) . "?p??")))
+		printf("[009] Expecting %s, got %s\n", "?p??\\0?p??", $tmp);
+
+	var_dump(mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, '?p')"));
+
+	mysqli_close($link);
+	print "done!";
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_escape_string_unicode.phpt
@@ -0,0 +1,88 @@
+--TEST--
+mysqli_real_escape_string()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link	= NULL;
+
+	if (NULL !== ($tmp = @mysqli_real_escape_string()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_real_escape_string($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (NULL !== ($tmp =@mysqli_real_escape_string($link, "", "")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[004] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[005] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[006] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[007] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[008] Expecting \\r, got %s\n", $tmp);
+
+	if ("\\0" !== ($tmp = mysqli_real_escape_string($link, "" . chr(0) . "")))
+		printf("[009] Expecting %s, got %s\n", "\\0", $tmp);
+
+	if (($exp='\\\\\"\\'."'".'\Z\\n\\r\\0') !==
+		($tmp = mysqli_real_escape_string($link, "\\\"'\032\n\r" . chr(0) . "")))
+	{
+		printf("[010] Expecting %s, got %s\n", $exp, $tmp, var_dump($exp, $tmp));
+	}
+
+	if ('\\\\' !== ($tmp = mysqli_real_escape_string($link, '\\')))
+		printf("[011] Expecting \\\\, got %s\n", $tmp);
+
+	if ('\"' !== ($tmp = mysqli_real_escape_string($link, '"')))
+		printf("[012] Expecting \", got %s\n", $tmp);
+
+	if ("\'" !== ($tmp = mysqli_real_escape_string($link, "'")))
+		printf("[013] Expecting ', got %s\n", $tmp);
+
+	if ("\\n" !== ($tmp = mysqli_real_escape_string($link, "\n")))
+		printf("[014] Expecting \\n, got %s\n", $tmp);
+
+	if ("\\r" !== ($tmp = mysqli_real_escape_string($link, "\r")))
+		printf("[015] Expecting \\r, got %s\n", $tmp);
+
+	if ("\\0" !== ($tmp = mysqli_real_escape_string($link, "" . chr(0) . "")))
+		printf("[016] Expecting %s, got %s\n", "\\0", $tmp);
+
+	if (($exp='\\\\\"\\'."'".'\Z\\n\\r\\0') !==
+		($tmp = mysqli_real_escape_string($link, "\\\"'\032\n\r" . chr(0) . "")))
+	{
+		printf("[017] Expecting %s, got %s\n", $exp, $tmp, var_dump($exp, $tmp));
+	}
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_real_escape_string($link, 'foo')))
+		printf("[018] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_real_escape_string(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_real_query.phpt
@@ -0,0 +1,113 @@
+--TEST--
+mysqli_real_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_real_query()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_real_query($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (NULL !== ($tmp = @mysqli_real_query($link, "SELECT 1 AS a", MYSQLI_USE_RESULT, "foo")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_real_query($link, 'THIS IS NOT SQL')))
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_real_query($link, "SELECT 'this is sql but with backslash g'\g")))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ((0 === mysqli_errno($link)) || ('' == mysqli_error($link)))
+		printf("[006] mysqli_errno()/mysqli_error should return some error\n");
+
+	if (!mysqli_real_query($link, "SELECT 'this is sql but with semicolon' AS valid ; "))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = mysqli_use_result($link)))
+	printf("[008] Expecting reseult object, got %s/%s [%d] %s\n", gettype($res), $res, mysqli_errno($link), mysqli_error($link));
+
+	var_dump(mysqli_fetch_assoc($res));
+	mysqli_free_result($res);
+
+	if (false !== ($res = mysqli_real_query($link, "SELECT 'this is sql but with semicolon' AS valid ; SHOW VARIABLES")))
+		printf("[008] Expecting boolean/false, got %s/%s, [%d] %s\n", gettype($res), $res,
+			mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_get_server_version($link) > 50000) {
+		// let's try to play with stored procedures
+		mysqli_real_query($link, 'DROP PROCEDURE IF EXISTS p');
+		if (mysqli_real_query($link, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param;
+END;')) {
+			mysqli_real_query($link, 'CALL p(@version)');
+			mysqli_real_query($link, 'SELECT @version AS p_version');
+			$res = mysqli_store_result($link);
+
+			$tmp = mysqli_fetch_assoc($res);
+			if (!is_array($tmp) || empty($tmp) || !isset($tmp['p_version']) || ('' == $tmp['p_version'])) {
+				printf("[008a] Expecting array [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+
+			mysqli_free_result($res);
+		} else {
+				printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+		mysqli_real_query($link, 'DROP FUNCTION IF EXISTS f');
+		if (mysqli_real_query($link, 'CREATE FUNCTION f( ver_param VARCHAR(25)) RETURNS VARCHAR(25) DETERMINISTIC RETURN
+ver_param;')) {
+			mysqli_real_query($link, 'SELECT f(VERSION()) AS f_version');
+			$res = mysqli_store_result($link);
+
+			$tmp = mysqli_fetch_assoc($res);
+			if (!is_array($tmp) || empty($tmp) || !isset($tmp['f_version']) || ('' == $tmp['f_version'])) {
+				printf("[009a] Expecting array [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				var_dump($tmp);
+			}
+
+			mysqli_free_result($res);
+		} else {
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+	}
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_real_query($link, "SELECT id FROM test")))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+@mysqli_query($link, "DROP PROCEDURE IF EXISTS p");
+@mysqli_query($link, "DROP FUNCTION IF EXISTS f");
+
+mysqli_close($link);
+?>
+--EXPECTF--
+array(1) {
+  [%u|b%"valid"]=>
+  %unicode|string%(30) "this is sql but with semicolon"
+}
+
+Warning: mysqli_real_query(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_reconnect.phpt
@@ -0,0 +1,130 @@
+--TEST--
+Trying implicit reconnect after wait_timeout and KILL using mysqli_ping()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (stristr(mysqli_get_client_info(), 'mysqlnd'))
+	die("skip: test for libmysql");
+?>
+--INI--
+mysqli.reconnect=1
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	if (!$link2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot create second database connection, [%d] %s\n",
+			mysqli_connect_errno(), mysqli_connect_error());
+
+	$thread_id_timeout = mysqli_thread_id($link);
+	$thread_id_control = mysqli_thread_id($link2);
+
+	if (!$res = mysqli_query($link2, "SHOW FULL PROCESSLIST"))
+		printf("[002] Cannot get full processlist, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (!isset($running_threads[$thread_id_timeout]) ||
+			!isset($running_threads[$thread_id_control]))
+		printf("[003] Processlist is borked, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	if (!mysqli_query($link, "SET SESSION wait_timeout = 2"))
+		printf("[004] Cannot set wait_timeout, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SHOW VARIABLES LIKE 'wait_timeout'"))
+		printf("[005] Cannot check if wait_timeout has been set, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[006] Cannot get wait_timeout, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+	mysqli_free_result($res);
+
+	if ($row['Value'] != 2)
+		printf("[007] Failed setting the wait_timeout, test will not work, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	// after 2+ seconds the server should kill the connection
+	sleep(3);
+
+	if (!$res = mysqli_query($link2, "SHOW FULL PROCESSLIST"))
+		printf("[008] Cannot get full processlist, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (isset($running_threads[$thread_id_timeout]))
+		printf("[009] Server should have killed the timeout connection, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	if (true !== mysqli_ping($link))
+		printf("[010] Reconnect should have happened");
+
+	if (!$res = mysqli_query($link, "SELECT DATABASE() as _dbname"))
+		printf("[011] Cannot get database name, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[012] Cannot get database name, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+	if ($row['_dbname'] != $db)
+		printf("[013] Connection should has been made to DB/Schema '%s', expecting '%s', [%d] %s\n",
+			$row['_dbname'], $db, mysqli_errno($link), mysqli_error($link));
+
+	// ... and now we try KILL
+	$thread_id_timeout = mysqli_thread_id($link);
+
+	if (!mysqli_query($link2, sprintf('KILL %d', $thread_id_timeout)))
+		printf("[014] Cannot KILL timeout connection, [%d] %s\n", mysqli_errno($link2), mysqli_error($link2));
+	// Give the server a second to really kill the other thread...
+	sleep(1);
+
+	if (!$res = mysqli_query($link2, "SHOW FULL PROCESSLIST"))
+		printf("[015] Cannot get full processlist, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	$running_threads = array();
+	while ($row = mysqli_fetch_assoc($res))
+		$running_threads[$row['Id']] = $row;
+	mysqli_free_result($res);
+
+	if (isset($running_threads[$thread_id_timeout]) ||
+			!isset($running_threads[$thread_id_control]))
+		printf("[016] Processlist is borked, [%d] %s\n",
+			mysqli_errno($link2), mysqli_error($link));
+
+	if (true !== ($tmp = mysqli_ping($link)))
+		printf("[017] Expecting boolean/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "SELECT DATABASE() as _dbname"))
+		printf("[018] Cannot get database name, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[019] Cannot get database name, [%d] %s\n",
+			mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+	if ($row['_dbname'] != $db)
+		printf("[020] Connection should has been made to DB/Schema '%s', expecting '%s', [%d] %s\n",
+			$row['_dbname'], $db, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+	mysqli_close($link2);
+	print "done!";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_report.phpt
@@ -0,0 +1,307 @@
+--TEST--
+mysqli_report()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_report()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(-1)))
+		printf("[002] Expecting boolean/true even for invalid flags, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_ERROR)))
+		printf("[003] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_STRICT)))
+		printf("[004] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_INDEX)))
+		printf("[005] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_ALL)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_OFF)))
+		printf("[008] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	/*
+	Internal macro MYSQL_REPORT_ERROR
+	*/
+	mysqli_report(MYSQLI_REPORT_ERROR);
+
+	mysqli_multi_query($link, "BAR; FOO;");
+	mysqli_query($link, "FOO");
+	/* This might work if you accept anonymous users in your setup */
+	mysqli_change_user($link, "0123456789-10-456789-20-456789-30-456789-40-456789-50-456789-60-456789-70-456789-80-456789-90-456789", "password", $db);
+	mysqli_kill($link, -1);
+
+	// mysqli_ping() cannot be tested, because one would need to cause an error inside the C function to test it
+	mysqli_prepare($link, "FOO");
+	mysqli_real_query($link, "FOO");
+	if (@mysqli_select_db($link, "Oh lord, let this be an unknown database name"))
+		printf("[009] select_db should have failed\n");
+	// mysqli_store_result() and mysqli_use_result() cannot be tested, because one would need to cause an error inside the C function to test it
+
+
+	// Check that none of the above would have caused any error messages if MYSQL_REPORT_ERROR would
+	// not have been set. If that would be the case, the test would be broken.
+	mysqli_report(MYSQLI_REPORT_OFF);
+
+	mysqli_multi_query($link, "BAR; FOO;");
+	mysqli_query($link, "FOO");
+	mysqli_change_user($link, "This might work if you accept anonymous users in your setup", "password", $db);
+	mysqli_kill($link, -1);
+	mysqli_prepare($link, "FOO");
+	mysqli_real_query($link, "FOO");
+	mysqli_select_db($link, "Oh lord, let this be an unknown database name");
+
+	/*
+	Internal macro MYSQL_REPORT_STMT_ERROR
+	*/
+
+	mysqli_report(MYSQLI_REPORT_ERROR);
+
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, "FOO");
+
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, "SELECT id FROM test WHERE id > ?");
+	$id = 1;
+	mysqli_kill($link, mysqli_thread_id($link));
+	mysqli_stmt_bind_param($stmt, "i", $id);
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	/* mysqli_stmt_execute() = mysql_stmt_execute cannot be tested from PHP */
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+			printf("[008] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, "SELECT id FROM test WHERE id > ?");
+	$id = 1;
+	mysqli_stmt_bind_param($stmt, "i", $id);
+	// mysqli_kill($link, mysqli_thread_id($link));
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	/* mysqli_kill() "trick" does not work for any of the following because of an E_COMMANDS_OUT_OF_SYNC */
+	/* mysqli_stmt_bind_result() = mysql_stmt_bind_result() cannot be tested from PHP */
+	/* mysqli_stmt_fetch() = mysql_stmt_fetch() cannot be tested from PHP */
+	/* mysqli_stmt_result_metadata() = mysql_stmt_result_metadata() cannot be tested from PHP */
+	/* mysqli_stmt_store_result() = mysql_stmt_store_result() cannot be tested from PHP */
+
+	// Check
+	mysqli_report(MYSQLI_REPORT_OFF);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[010] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, "FOO");
+
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, "SELECT id FROM test WHERE id > ?");
+	$id = 1;
+	mysqli_kill($link, mysqli_thread_id($link));
+	mysqli_stmt_bind_param($stmt, "i", $id);
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[011] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, "SELECT id FROM test WHERE id > ?");
+	$id = 1;
+	mysqli_stmt_bind_param($stmt, "i", $id);
+	mysqli_kill($link, mysqli_thread_id($link));
+	mysqli_stmt_execute($stmt);
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	/*
+	MYSQLI_REPORT_STRICT
+
+	MYSQLI_REPORT_STRICT --->
+	php_mysqli_report_error() ->
+		MYSQLI_REPORT_MYSQL_ERROR,
+		MYSQLI_REPORT_STMT_ERROR ->
+			already tested
+
+	php_mysqli_throw_sql_exception() ->
+		my_mysqli_real_connect()
+		my_mysqli_connect()
+
+	can't be tested: mysqli_query() via mysql_use_result()/mysql_store_result()
+	*/
+	mysqli_report(MYSQLI_REPORT_OFF);
+	mysqli_report(MYSQLI_REPORT_STRICT);
+
+	try {
+
+		if ($link = my_mysqli_connect($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+			printf("[012] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+				$host, $user . 'unknown_really', $db, $port, $socket);
+		mysqli_close($link);
+
+	} catch (mysqli_sql_exception $e) {
+		printf("[013] %s\n", $e->getMessage());
+	}
+
+	try {
+		if (!$link = mysqli_init())
+			printf("[014] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+		if ($link = my_mysqli_real_connect($link, $host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+			printf("[015] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+				$host, $user . 'unknown_really', $db, $port, $socket);
+		mysqli_close($link);
+	} catch (mysqli_sql_exception $e) {
+		printf("[016] %s\n", $e->getMessage());
+	}
+
+	/*
+	MYSQLI_REPORT_INDEX --->
+	mysqli_query()
+	mysqli_stmt_execute()
+	mysqli_prepare()
+	mysqli_real_query()
+	mysqli_store_result()
+	mysqli_use_result()
+
+	No test, because of to many prerequisites:
+		- Server needs to be started with and
+			--log-slow-queries --log-queries-not-using-indexes
+		- query must cause the warning on all MySQL versions
+
+	TODO:
+	*/
+	$log_slow_queries = false;
+	$log_queries_not_using_indexes = false;
+	mysqli_report(MYSQLI_REPORT_OFF);
+	mysqli_report(MYSQLI_REPORT_INDEX);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[017] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (mysqli_get_server_version($link) <= 50600) {
+		// this might cause a warning - no index used
+		if (!$res = @mysqli_query($link, "SHOW VARIABLES LIKE 'log_slow_queries'"))
+			printf("[018] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!$row = mysqli_fetch_assoc($res))
+			printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$log_slow_query = ('ON' == $row['Value']);
+
+		if (mysqli_get_server_version($link) >= 50111) {
+			// this might cause a warning - no index used
+			if (!$res = @mysqli_query($link, "SHOW VARIABLES LIKE 'log_queries_not_using_indexes'"))
+				printf("[020] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+			if (!$row = mysqli_fetch_assoc($res))
+				printf("[021] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+			$log_queries_not_using_indexes = ('ON' == $row['Value']);
+
+			if ($log_slow_queries && $log_queries_not_using_indexes) {
+
+				for ($i = 100; $i < 20000; $i++) {
+					if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES ($i, 'z')"))
+						printf("[022 - %d] [%d] %s\n", $i - 99, mysqli_errno($link), mysqli_error($link));
+				}
+
+				// this might cause a warning - no index used
+				if (!$res = @mysqli_query($link, "SELECT id, label FROM test WHERE id = 1323"))
+					printf("[023] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+				mysqli_free_result($res);
+			}
+		}
+	}
+
+	// Maybe we've provoked an index message, maybe not.
+	// All we can do is make a few dummy calls to ensure that all codes gets executed which
+	// checks the flag. Functions to check: mysqli_query() - done above,
+	// mysqli_stmt_execute(), mysqli_prepare(), mysqli_real_query(), mysqli_store_result()
+	// mysqli_use_result(), mysqli_thread_safe(), mysqli_thread_id()
+	mysqli_report(MYSQLI_REPORT_OFF);
+	mysqli_close($link);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[024] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[025] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test'))
+		printf("[026] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[027] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+
+	if (!mysqli_real_query($link, 'SELECT label, id FROM test'))
+		printf("[028] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_use_result($link))
+		printf("[029] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!mysqli_real_query($link, 'SELECT label, id FROM test'))
+		printf("[030]  [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_store_result($link))
+		printf("[031]  [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!$stmt = mysqli_prepare($link, 'SELECT id * 3 FROM test'))
+		printf("[032] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	else
+		mysqli_stmt_close($stmt);
+
+	if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (100, 'z')", MYSQLI_USE_RESULT) ||
+			!mysqli_query($link, 'DELETE FROM test WHERE id > 50', MYSQLI_USE_RESULT))
+		printf("[033] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$tmp = mysqli_thread_safe($link);
+	$tmp = mysqli_thread_id($link);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_multi_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'BAR; FOO' at line 1 in %s on line %d
+
+Warning: mysqli_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FOO' at line 1 in %s on line %d
+
+Warning: mysqli_change_user(): (%d/%d): Access denied for user '%s'@'%s' (using password: %s) in %s on line %d
+
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+
+Warning: mysqli_prepare(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FOO' at line 1 in %s on line %d
+
+Warning: mysqli_real_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FOO' at line 1 in %s on line %d
+
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+
+Warning: mysqli_stmt_prepare(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FOO' at line 1 in %s on line %d
+[013] Access denied for user '%s'@'%s' (using password: YES)
+[016] Access denied for user '%s'@'%s' (using password: YES)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_report_wo_ps.phpt
@@ -0,0 +1,113 @@
+--TEST--
+mysqli_report()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_report()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(-1)))
+		printf("[002] Expecting boolean/true even for invalid flags, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_ERROR)))
+		printf("[003] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_STRICT)))
+		printf("[004] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_INDEX)))
+		printf("[005] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_ALL)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_report(MYSQLI_REPORT_OFF)))
+		printf("[008] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	/*
+	Internal macro MYSQL_REPORT_ERROR
+	*/
+	mysqli_report(MYSQLI_REPORT_ERROR);
+
+	mysqli_multi_query($link, "BAR; FOO;");
+	mysqli_query($link, "FOO");
+	mysqli_change_user($link, "0123456789-10-456789-20-456789-30-456789-40-456789-50-456789-60-456789-70-456789-80-456789-90-456789", "password", $db);
+	mysqli_kill($link, -1);
+
+	// mysqli_ping() cannot be tested, because one would need to cause an error inside the C function to test it
+	mysqli_real_query($link, "FOO");
+	if (@mysqli_select_db($link, "Oh lord, let this be an unknown database name"))
+		printf("[009] select_db should have failed\n");
+	// mysqli_store_result() and mysqli_use_result() cannot be tested, because one would need to cause an error inside the C function to test it
+
+
+	// Check that none of the above would have caused any error messages if MYSQL_REPORT_ERROR would
+	// not have been set. If that would be the case, the test would be broken.
+	mysqli_report(MYSQLI_REPORT_OFF);
+
+	mysqli_multi_query($link, "BAR; FOO;");
+	mysqli_query($link, "FOO");
+	mysqli_change_user($link, "This might work if you accept anonymous users in your setup", "password", $db);
+	mysqli_kill($link, -1);
+	mysqli_real_query($link, "FOO");
+	mysqli_select_db($link, "Oh lord, let this be an unknown database name");
+
+	mysqli_report(MYSQLI_REPORT_OFF);
+	mysqli_report(MYSQLI_REPORT_STRICT);
+
+	try {
+
+		if ($link = my_mysqli_connect($host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+			printf("[010] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+				$host, $user . 'unknown_really', $db, $port, $socket);
+		mysqli_close($link);
+
+	} catch (mysqli_sql_exception $e) {
+		printf("[011] %s\n", $e->getMessage());
+	}
+
+	try {
+		if (!$link = mysqli_init())
+			printf("[012] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+		if ($link = my_mysqli_real_connect($link, $host, $user . 'unknown_really', $passwd . 'non_empty', $db, $port, $socket))
+			printf("[013] Can connect to the server using host=%s, user=%s, passwd=***non_empty, dbname=%s, port=%s, socket=%s\n",
+				$host, $user . 'unknown_really', $db, $port, $socket);
+		mysqli_close($link);
+	} catch (mysqli_sql_exception $e) {
+		printf("[014] %s\n", $e->getMessage());
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_multi_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'BAR; FOO' at line 1 in %s on line %d
+
+Warning: mysqli_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FOO' at line 1 in %s on line %d
+
+Warning: mysqli_change_user(): (%d/%d): Access denied for user '%s'@'%s' (using password: %s) in %s on line %d
+
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+
+Warning: mysqli_real_query(): (%d/%d): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FOO' at line 1 in %s on line %d
+
+Warning: mysqli_kill(): processid should have positive value in %s on line %d
+[011] Access denied for user '%s'@'%s' (using password: YES)
+[014] Access denied for user '%s'@'%s' (using password: YES)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_result_references.phpt
@@ -0,0 +1,154 @@
+--TEST--
+References to result sets
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	$references = array();
+
+	if (!(mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2")) ||
+			!($res = mysqli_store_result($link)))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$idx = 0;
+	while ($row = mysqli_fetch_assoc($res)) {
+		/* mysqlnd: force seperation - create copies */
+		$references[$idx] = array(
+			'id' 		=> &$row['id'],
+			'label'	=> $row['label'] . '');
+		$references[$idx++]['id'] += 0;
+	}
+
+	mysqli_close($link);
+
+	mysqli_data_seek($res, 0);
+	while ($row = mysqli_fetch_assoc($res)) {
+		/* mysqlnd: force seperation - create copies */
+		$references[$idx] = array(
+			'id' 		=> &$row['id'],
+			'label'	=> $row['label'] . '');
+		$references[$idx++]['id'] += 0;
+	}
+
+	mysqli_free_result($res);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!(mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2")) ||
+			!($res = mysqli_use_result($link)))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	while ($row = mysqli_fetch_assoc($res)) {
+		/* mysqlnd: force seperation - create copies*/
+		$references[$idx] = array(
+			'id' 		=> &$row['id'],
+			'label'	=> $row['label'] . '');
+		$references[$idx]['id2'] = &$references[$idx]['id'];
+		$references[$idx]['id'] += 1;
+		$references[$idx++]['id2'] += 1;
+	}
+
+	$references[$idx++] = &$res;
+	mysqli_free_result($res);
+	@debug_zval_dump($references);
+
+	if (!(mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id ASC LIMIT 1")) ||
+			!($res = mysqli_use_result($link)))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$tmp = array();
+	while ($row = mysqli_fetch_assoc($res)) {
+		$tmp[] = $row;
+	}
+	$tmp = unserialize(serialize($tmp));
+	debug_zval_dump($tmp);
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+array(7) refcount(2){
+  [0]=>
+  array(2) refcount(1){
+    [%u|b%"id"]=>
+    long(1) refcount(1)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a" refcount(1)
+  }
+  [1]=>
+  array(2) refcount(1){
+    [%u|b%"id"]=>
+    long(2) refcount(1)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b" refcount(1)
+  }
+  [2]=>
+  array(2) refcount(1){
+    [%u|b%"id"]=>
+    long(1) refcount(1)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a" refcount(1)
+  }
+  [3]=>
+  array(2) refcount(1){
+    [%u|b%"id"]=>
+    long(2) refcount(1)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b" refcount(1)
+  }
+  [4]=>
+  array(3) refcount(1){
+    [%u|b%"id"]=>
+    &long(3) refcount(2)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a" refcount(1)
+    [%u|b%"id2"]=>
+    &long(3) refcount(2)
+  }
+  [5]=>
+  array(3) refcount(1){
+    [%u|b%"id"]=>
+    &long(4) refcount(2)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b" refcount(1)
+    [%u|b%"id2"]=>
+    &long(4) refcount(2)
+  }
+  [6]=>
+  &object(mysqli_result)#2 (5) refcount(2){
+    [%u|b%"current_field"]=>
+    NULL refcount(1)
+    [%u|b%"field_count"]=>
+    NULL refcount(1)
+    [%u|b%"lengths"]=>
+    NULL refcount(1)
+    [%u|b%"num_rows"]=>
+    NULL refcount(1)
+    [%u|b%"type"]=>
+    NULL refcount(1)
+  }
+}
+array(1) refcount(2){
+  [0]=>
+  array(2) refcount(1){
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1" refcount(1)
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a" refcount(1)
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_result_references_mysqlnd.phpt
@@ -0,0 +1,119 @@
+--TEST--
+References to result sets - mysqlnd (no copies but references)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once('connect.inc');
+if (!$IS_MYSQLND)
+	die("skip Test for mysqlnd only");
+
+if ((version_compare(PHP_VERSION, '5.9.9', '>') == 1))
+	die("skip (TODO) PHP 6.0 has a difference debug_zval_dump output format");
+?>
+<?php require_once('skipifemb.inc'); ?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	$references = array();
+
+	if (!(mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id ASC LIMIT 1")) ||
+			!($res = mysqli_store_result($link)))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$idx = 0;
+	while ($row = mysqli_fetch_assoc($res)) {
+		/* will overwrite itself */
+		$references[$idx]['row_ref'] 		= &$row;
+		$references[$idx]['row_copy'] 	= $row;
+		$references[$idx]['id_ref'] 		= &$row['id'];
+		$references[$idx++]['id_copy']	= $row['id'];
+	}
+
+	debug_zval_dump($references);
+	mysqli_free_result($res);
+
+	if (!(mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2")) ||
+			!($res = mysqli_use_result($link)))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$rows = array();
+	for ($i = 0; $i < 2; $i++) {
+		$rows[$i] = mysqli_fetch_assoc($res);
+		$references[$idx]['row_ref'] 		= &$rows[$i];
+		$references[$idx]['row_copy'] 	= $rows[$i];
+		$references[$idx]['id_ref'] 		= &$rows[$i]['id'];
+		$references[$idx]['id_copy']		= $rows[$i]['id'];
+		/* enforce seperation */
+		$references[$idx]['id_copy_mod']= $rows[$i]['id'] + 0;
+	}
+	mysqli_free_result($res);
+
+	debug_zval_dump($references);
+	print "done!";
+?>
+--EXPECTF--
+array(1) refcount(2){
+  [0]=>
+  array(4) refcount(1){
+    [%u|b%"row_ref"]=>
+    &NULL refcount(2)
+    [%u|b%"row_copy"]=>
+    array(2) refcount(1){
+      [%u|b%"id"]=>
+      %unicode|string%(1) "1" refcount(2)
+      [%u|b%"label"]=>
+      %unicode|string%(1) "a" refcount(2)
+    }
+    [%u|b%"id_ref"]=>
+    %unicode|string%(1) "1" refcount(1)
+    [%u|b%"id_copy"]=>
+    %unicode|string%(1) "1" refcount(1)
+  }
+}
+array(2) refcount(2){
+  [0]=>
+  array(4) refcount(1){
+    [%u|b%"row_ref"]=>
+    &NULL refcount(2)
+    [%u|b%"row_copy"]=>
+    array(2) refcount(1){
+      [%u|b%"id"]=>
+      %unicode|string%(1) "1" refcount(1)
+      [%u|b%"label"]=>
+      %unicode|string%(1) "a" refcount(1)
+    }
+    [%u|b%"id_ref"]=>
+    %unicode|string%(1) "1" refcount(1)
+    [%u|b%"id_copy"]=>
+    %unicode|string%(1) "1" refcount(1)
+  }
+  [1]=>
+  array(5) refcount(1){
+    [%u|b%"row_ref"]=>
+    &array(2) refcount(2){
+      [%u|b%"id"]=>
+      &%unicode|string%(1) "2" refcount(2)
+      [%u|b%"label"]=>
+      %unicode|string%(1) "b" refcount(2)
+    }
+    [%u|b%"row_copy"]=>
+    array(2) refcount(1){
+      [%u|b%"id"]=>
+      %unicode|string%(1) "2" refcount(1)
+      [%u|b%"label"]=>
+      %unicode|string%(1) "b" refcount(2)
+    }
+    [%u|b%"id_ref"]=>
+    &%unicode|string%(1) "2" refcount(2)
+    [%u|b%"id_copy"]=>
+    %unicode|string%(1) "2" refcount(1)
+    [%u|b%"id_copy_mod"]=>
+    long(2) refcount(1)
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_result_unclonable.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Trying to clone mysqli_result object
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!($res = mysqli_query($link, "SELECT 'good' AS morning")))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$res_clone = clone $res;
+	print "done!";
+?>
+--EXPECTF--
+Fatal error: Trying to clone an uncloneable object of class mysqli_result in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_rollback.phpt
@@ -0,0 +1,77 @@
+--TEST--
+mysqli_rollback()
+--SKIPIF--
+<?php  ?>
+<?php  ?>
+<?PHP
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	require_once('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		die(sprintf("Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+	if (!have_innodb($link))
+		die(sprintf("Needs InnoDB support, [%d] %s", $link->errno, $link->error));
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_rollback()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_rollback($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @mysqli_rollback($link, 'foo')))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_autocommit($link, false)))
+		printf("[005] Cannot turn off autocommit, expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'CREATE TABLE test(id INT) ENGINE = InnoDB'))
+		printf("[007] Cannot create test table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, 'INSERT INTO test(id) VALUES (1)'))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$tmp = mysqli_rollback($link);
+	if ($tmp !== true)
+		printf("[009] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, 'SELECT COUNT(*) AS num FROM test'))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	if (0 != $tmp['num'])
+		printf("[12] Expecting 0 rows in table test, found %d rows\n", $tmp['num']);
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test'))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_close($link);
+
+	if (!is_null($tmp = mysqli_rollback($link)))
+		printf("[014] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!\n";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_rollback(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_select_db.phpt
@@ -0,0 +1,112 @@
+--TEST--
+mysqli_select_db()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once("table.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_select_db()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_select_db($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!is_null($tmp = @mysqli_select_db($link, $db, "foo")))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	/* does not make too much sense, unless we have access to at least one more database than $db */
+	if (!mysqli_select_db($link, $db))
+		printf("[005] Cannot select DB %s, [%d] %s\n", $db, mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SELECT DATABASE() AS dbname"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['dbname'] !== (string)$db)
+		printf("[008] Expecting database '%s', found '%s'\n", $db, $row['dbname']);
+	mysqli_free_result($res);
+
+	if (mysqli_select_db($link, 'mysql')) {
+		// Yippie, a second database to play with - that's great because mysqli_select_db
+		// ($db) was done by mysqli__connect() already and the previous test
+		// was quite useless
+		if (!$res = mysqli_query($link, "SELECT DATABASE() AS dbname"))
+			printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!$row = mysqli_fetch_assoc($res))
+			printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (strtolower($row['dbname']) !== 'mysql')
+			printf("[011] Expecting database 'mysql', found '%s'\n", $row['dbname']);
+		mysqli_free_result($res);
+	}
+
+	if (!$link->select_db($db))
+		printf("[012] Failed to set '%s' as current DB; [%d] %s\n", $link->errno, $link->error);
+
+	if (!$res = mysqli_query($link, "SELECT DATABASE() AS dbname"))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	$current_db = $row['dbname'];
+
+	mysqli_report(MYSQLI_REPORT_OFF);	  
+	mysqli_select_db($link, 'I can not imagine that this database exists');
+	mysqli_report(MYSQLI_REPORT_ERROR);
+
+	ob_start();
+	mysqli_select_db($link, 'I can not imagine that this database exists');
+	$output = ob_get_contents();
+	ob_end_clean();
+	if (!stristr($output, "1049") && !stristr($output, "1044") && !stristr($output, "1045")) {
+	  /* Error: 1049 SQLSTATE: 42000 (ER_BAD_DB_ERROR) Message: Unknown database '%s'  */
+	  /* Error: 1044 SQLSTATE: 42000 (ER_DBACCESS_DENIED_ERROR) Message: Access denied for user '%s'@'%s' to database '%s' */
+	  /* Error: 1045 SQLSTATE: 28000 (ER_ACCESS_DENIED_ERROR) Message: Access denied for user '%s'@'%s' (using password: %s) */
+	  echo $output;
+	}
+
+	if (!$res = mysqli_query($link, "SELECT DATABASE() AS dbname"))
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[016] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (strtolower($row['dbname']) != strtolower($current_db))
+		printf("[017] Current DB should not change if set fails\n");
+
+	
+	if (!$res = $link->query("SELECT id FROM test WHERE id = 1"))
+		printf("[018] [%d] %s\n");
+
+	$row = $res->fetch_assoc();
+	$res->free();
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_select_db($link, $db)))
+		printf("[017] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!\n";
+?>
+--CLEAN--
+<?php require_once("clean_table.inc"); ?>
+--EXPECTF--
+Warning: mysqli_select_db(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_send_query.phpt
@@ -0,0 +1,50 @@
+--TEST--
+mysqli_send_query()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_send_query')) {
+	die("skip mysqli_send_query() not available");
+}
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+?>
+--FILE--
+<?php
+	/* NOTE: tests is a stub, but function is deprecated, as long as it does not crash when invoking it... */
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (NULL !== ($tmp = @mysqli_send_query()))
+		printf("[001] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = @mysqli_send_query($link)))
+		printf("[002] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[003] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	$query = array();
+	if (NULL !== ($tmp = @mysqli_send_query($link, $query)))
+		printf("[004] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_int($tmp = mysqli_send_query($link, 'SELECT 1')))
+		printf("[005] Expecting integer/any value, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_send_query($link, 'SELECT 1')))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_send_query(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_charset.phpt
@@ -0,0 +1,134 @@
+--TEST--
+mysqli_set_charset()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip set character set not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
+}
+
+if (!function_exists('mysqli_set_charset'))
+ 	die("skip Function not available");
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die(sprintf("skip Cannot connect, [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+if (!($res = mysqli_query($link, 'SELECT version() AS server_version')) ||
+		!($tmp = mysqli_fetch_assoc($res))) {
+	mysqli_close($link);
+	die(sprintf("skip Cannot check server version, [%d] %s\n",
+	mysqli_errno($link), mysqli_error($link)));
+}
+mysqli_free_result($res);
+$version = explode('.', $tmp['server_version']);
+if (empty($version)) {
+	mysqli_close($link);
+	die(sprintf("skip Cannot check server version, based on '%s'",
+		$tmp['server_version']));
+}
+
+if ($version[0] <= 4 && $version[1] < 1) {
+	mysqli_close($link);
+	die(sprintf("skip Requires MySQL Server 4.1+\n"));
+}
+
+if ((($res = mysqli_query($link, 'SHOW CHARACTER SET LIKE "latin1"', MYSQLI_STORE_RESULT)) &&
+		(mysqli_num_rows($res) == 1)) ||
+		(($res = mysqli_query($link, 'SHOW CHARACTER SET LIKE "latin2"', MYSQLI_STORE_RESULT)) &&
+		(mysqli_num_rows($res) == 1))
+		) {
+	// ok, required latin1 or latin2 are available
+	mysqli_close($link);
+} else {
+	die(sprintf("skip Requires character set latin1 or latin2\n"));
+	mysqli_close($link);
+}
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_set_charset()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_charset($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_charset($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$res = mysqli_query($link, 'SELECT @@character_set_connection AS charset, @@collation_connection AS collation'))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if (!$character_set_connection = $tmp['charset'])
+		printf("[008] Cannot determine current character set and collation\n");
+
+	$new_charset = ('latin1' == $character_set_connection) ? 'latin2' : 'latin1';
+	if (!$res = mysqli_query($link, sprintf('SHOW CHARACTER SET LIKE "%s"', $new_charset), MYSQLI_STORE_RESULT))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_num_rows($res) == 0)
+		printf("[010] Test will fail, because alternative test character set '%s' seems not supported\n", $new_charset);
+
+	if (false !== ($ret = mysqli_set_charset($link, "this is not a valid character set")))
+		printf("[011] Expecting boolean/false because of invalid character set, got %s/%s\n", gettype($ret), $ret);
+
+	mysqli_close($link);
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[012] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (true !== ($ret = mysqli_set_charset($link, $new_charset)))
+		printf("[013] Expecting boolean/true, got %s/%s\n", gettype($ret), $ret);
+
+	if (!$res = mysqli_query($link, 'SELECT @@character_set_connection AS charset, @@collation_connection AS collation'))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$tmp = mysqli_fetch_assoc($res);
+	mysqli_free_result($res);
+	if ($new_charset !== $tmp['charset'])
+		printf("[015] Character set not changed? Expecting %s, got %s\n", $new_charset, $tmp['charset']);
+
+	if (!$res = mysqli_query($link, "SHOW CHARACTER SET"))
+		printf("[016] Cannot get list of character sets\n");
+
+	while ($tmp = mysqli_fetch_assoc($res)) {
+		if ('ucs2' == $tmp['Charset'] || 'utf16' == $tmp['Charset'] || 'utf32' == $tmp['Charset'] || 'utf16le' == $tmp['Charset'])
+			continue;
+
+		/* Uncomment to see where it hangs - var_dump($tmp); flush(); */
+		if (!@mysqli_set_charset($link, $tmp['Charset'])) {
+			printf("[017] Cannot set character set to '%s', [%d] %s\n", $tmp['Charset'],
+				mysqli_errno($link), mysqli_error($link));
+			continue;
+		}
+
+		/* Uncomment to see where it hangs - var_dump($tmp); flush(); */
+		if (!mysqli_query($link, sprintf("SET NAMES %s", mysqli_real_escape_string($link, $tmp['Charset']))))
+			printf("[018] Cannot run SET NAMES %s, [%d] %s\n", $tmp['Charset'], mysqli_errno($link), mysqli_error($link));
+	}
+	mysqli_free_result($res);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_set_charset($link, $new_charset)))
+		printf("[016] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_set_charset(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_default.phpt
@@ -0,0 +1,132 @@
+--TEST--
+mysqli_set_local_infile_default()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+if (!$link)
+	die(sprintf("skip Can't connect [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+
+	$link = $tmp = null;
+	if (!is_null($tmp = @mysqli_set_local_infile_default()))
+		printf("[001] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_local_infile_default($link)))
+		printf("[002] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	$link = new mysqli();
+	if (!is_null($tmp = @mysqli_set_local_infile_default($link)))
+		printf("[002a] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	include("table.inc");
+
+	if (!is_null($tmp = @mysqli_set_local_infile_default($link, 'foo')))
+		printf("[003] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+
+	function callback_simple($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation);
+
+		$invocation++;
+		if (!is_resource($fp))
+			printf("[012] First argument passed to callback is not a resource but %s/%s\n",
+				$fp, gettype($fp));
+
+		if (!$buffer = fread($fp, $buflen)) {
+			if ($invocation == 1) {
+				printf("[013] Cannot read from stream\n");
+				$error = 'Cannot read from stream';
+			} else {
+				return strlen($buffer);
+			}
+		}
+
+		$lines = explode("\n", $buffer);
+		if (count($lines) != 4 && strlen($buffer) > 0) {
+			printf("[014] Test is too simple to handle a buffer of size %d that cannot hold all lines\n", $buflen);
+			$error = 'Parser too simple';
+		}
+
+		$buffer = '';
+		foreach ($lines as $k => $line) {
+			if ('' === trim($line))
+				continue;
+
+			$columns = explode(';', $line);
+			if (empty($columns)) {
+				printf("[015] Cannot parse columns\n");
+				$error = 'Cannot parse columns';
+			}
+
+			// increase id column value
+			$columns[0] += 1;
+			$buffer .= implode(';', $columns);
+			$buffer .= "\n";
+		}
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(4);
+	$expected = array(
+		array('id' => 98,   'label' => 'x'),
+		array('id' => 99,   'label' => 'y'),
+		array('id' => 100,  'label' => 'z'),
+	);
+	try_handler(10, $link, $file, 'callback_simple', $expected);
+
+	$expected = array(
+		array('id' => 97,   'label' => 'x'),
+		array('id' => 98,   'label' => 'y'),
+		array('id' => 99,   'label' => 'z'),
+	);
+	try_handler(20, $link, $file, 'default', $expected);
+
+	$expected = array(
+		array('id' => 98,   'label' => 'x'),
+		array('id' => 99,   'label' => 'y'),
+		array('id' => 100,  'label' => 'z'),
+	);
+	try_handler(30, $link, $file, 'callback_simple', $expected);
+
+	mysqli_close($link);
+
+	if (!is_null($tmp = @mysqli_set_local_infile_default($link)))
+		printf("[300] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_simple'
+Callback: 0
+Callback: 1
+Callback set to 'default'
+Callback set to 'callback_simple'
+Callback: 2
+Callback: 3
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler.phpt
@@ -0,0 +1,196 @@
+--TEST--
+mysqli_set_local_infile_handler()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_simple($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation);
+
+		$invocation++;
+		if (!is_resource($fp))
+			printf("[012] First argument passed to callback is not a resource but %s/%s\n",
+				$fp, gettype($fp));
+
+		if (!$buffer = fread($fp, $buflen)) {
+			if ($invocation == 1) {
+				printf("[013] Cannot read from stream\n");
+					$error = 'Cannot read from stream';
+			} else {
+				return strlen($buffer);
+			}
+		}
+
+		$lines = explode("\n", $buffer);
+		if (count($lines) != 4 && strlen($buffer) > 0) {
+			printf("[014] Test is too simple to handle a buffer of size %d that cannot hold all lines\n", $buflen);
+			$error = 'Parser too simple';
+		}
+
+		$buffer = '';
+		foreach ($lines as $k => $line) {
+			if ('' === trim($line))
+				continue;
+
+			$columns = explode(';', $line);
+			if (empty($columns)) {
+				printf("[015] Cannot parse columns\n");
+				$error = 'Cannot parse columns';
+			}
+
+			// increase id column value
+			$columns[0] += 1;
+			$buffer .= implode(';', $columns);
+			$buffer .= "\n";
+		}
+
+		return strlen($buffer);
+	}
+
+	function callback_fclose($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+
+		fclose($fp);
+		return strlen($buffer);
+	}
+
+	function callback_closefile($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+		if (is_resource($fp))
+			fclose($fp);
+		$buffer = "1;'a';\n";
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	}
+
+	function callback_invalid_args($fp, &$buffer, $buflen) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		$buffer = fread($fp, $buflen);
+
+		return strlen($buffer);
+	}
+
+	function callback_error($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		$buffer = fread($fp, $buflen);
+		$error = 'How to access this error?';
+
+		return -1;
+	}
+
+	if (!is_null($tmp = @mysqli_set_local_infile_handler()))
+		printf("[001] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+
+	$handle = null;
+	if (!is_null($tmp = @mysqli_set_local_infile_handler($handle)))
+		printf("[002] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+
+	$handle = @new mysqli();
+	if (!is_null($tmp = @mysqli_set_local_infile_handler($handle, 'callback_simple')))
+		printf("[003] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+
+	if (false !== ($tmp = @mysqli_set_local_infile_handler($link, 'unknown')))
+		printf("[004] Expecting false/boolean got %s/%s\n", $tmp, gettype($tmp));
+
+	$file = create_standard_csv(5);
+
+	$expected = array(
+		array('id' => 98,   'label' => 'x'),
+		array('id' => 99,   'label' => 'y'),
+		array('id' => 100,  'label' => 'z'),
+	);
+	try_handler(10, $link, $file, 'callback_simple', $expected);
+
+	$expected = array();
+	try_handler(20, $link, $file, 'callback_fclose', $expected);
+
+	// FIXME - TODO - KLUDGE -
+  // IMHO this is wrong. ext/mysqli should bail as the function signature
+  // is not complete. That's a BC break, OK, but it makes perfectly sense.
+	$expected = array();
+	try_handler(30, $link, $file, 'callback_invalid_args', $expected);
+
+	$expected = array();
+	try_handler(40, $link, $file, 'callback_error', $expected);
+
+
+	mysqli_close($link);
+
+	if (!is_null($tmp = @mysqli_set_local_infile_handler($link, 'callback_simple')))
+		printf("[300] Expecting NULL/NULL got %s/%s\n", $tmp, gettype($tmp));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_simple'
+Callback: 0
+Callback: 1
+Callback set to 'callback_fclose'
+Callback: 0
+[022] LOAD DATA failed, [2000] File handle close%s
+Callback set to 'callback_invalid_args'
+Callback: 0
+Callback: 1
+[037] More results than expected!
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "97"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "x"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "98"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "y"
+}
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "99"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "z"
+}
+Callback set to 'callback_error'
+Callback: 0
+[042] LOAD DATA failed, [2000] How to access this error?
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_bad_character.phpt
@@ -0,0 +1,82 @@
+--TEST--
+mysqli_set_local_infile_handler() - random ASCII character including \0
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+    die("skip - function not available.");
+
+if (!$TEST_EXPERIMENTAL)
+    die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_bad_character($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+
+		$num_chars = (version_compare(PHP_VERSION, '5.9.9', '>') == 1) ? (floor($buflen / 2) - 10) : ($buflen - 5);
+		$part1 = floor($num_chars / 2);
+		$part2 = $num_chars - $part1;
+
+		$buffer = '';
+		for ($i = 0; $i < $part1; $i++)
+			$buffer .= chr(mt_rand(0, 255));
+
+		$buffer .= ';"';
+
+		for ($i = 0; $i < $part2; $i++)
+			$buffer .= chr(mt_rand(0, 255));
+
+		$buffer .= '";';
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(5);
+	/* we feed the handler with random data, therefore we cannot specify and expected rows */
+	try_handler(20, $link, $file, 'callback_bad_character');
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_bad_character'
+Callback: 0
+Callback: 1
+Callback: 2
+Callback: 3
+Callback: 4
+Callback: 5
+Callback: 6
+Callback: 7
+Callback: 8
+Callback: 9
+Callback: 10
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_buffer_overflow.phpt
@@ -0,0 +1,60 @@
+--TEST--
+mysqli_set_local_infile_handler() - buffer overflow
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_buffer_overflow($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation);
+		$buffer = fread($fp, $buflen);
+
+		$buffer = str_repeat(';', $buflen * 2);
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(5);
+	$expected = array();
+	try_handler(20, $link, $file, 'callback_buffer_overflow', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_buffer_overflow'
+Callback: 0
+
+Warning: mysqli_query(): Too much data returned in %s on line %d
+[022] LOAD DATA failed, [%d] Too much data returned
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_close_link.phpt
@@ -0,0 +1,61 @@
+--TEST--
+mysqli_set_local_infile_handler() - close database link
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require("table.inc");
+	require_once('local_infile_tools.inc');
+
+	function callback_close_link($fp, &$buffer, $buflen, &$error) {
+		global $link;
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+		if (is_object($link))
+			mysqli_close($link);
+
+		$buffer = "1;'a';\n";
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	try_handler(20, $link, $file, 'callback_close_link', $expected);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_close_link'
+Callback: 0
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_closefile.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysqli_set_local_infile_handler() - do not use the file pointer
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once("table.inc");
+	require_once('local_infile_tools.inc');
+
+	function callback_closefile($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+		if (is_resource($fp))
+			fclose($fp);
+		$buffer = "1;'a';\n";
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	try_handler(20, $link, $file, 'callback_closefile', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_closefile'
+Callback: 0
+Callback: 1
+Callback: 2
+Callback: 3
+Callback: 4
+Callback: 5
+Callback: 6
+Callback: 7
+Callback: 8
+Callback: 9
+Callback: 10
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_closures.phpt
@@ -0,0 +1,62 @@
+--TEST--
+mysqli_set_local_infile_handler() - use closures as handler
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	$callback_replace_buffer = function ($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+
+		$buffer = fread($fp, $buflen);
+
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	};
+
+	$file = create_standard_csv(1);
+	if (!try_handler(20, $link, $file, $callback_replace_buffer, null))
+		printf("[008] Failure\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'Closure object'
+Callback: 0
+Callback: 1
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_kill_link.phpt
@@ -0,0 +1,61 @@
+--TEST--
+mysqli_set_local_infile_handler() - kill database link
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require("table.inc");
+	require_once('local_infile_tools.inc');
+
+	function callback_kill_link($fp, &$buffer, $buflen, &$error) {
+		global $link;
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+		if (is_object($link))
+			mysqli_kill($link, mysqli_thread_id($link));
+
+		$buffer = "1;'a';\n";
+		if ($invocation > 10)
+			return 0;
+
+		mysqli_set_local_infile_default($link);
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	try_handler(20, $link, $file, 'callback_kill_link', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_kill_link'
+Callback: 0
+[022] LOAD DATA failed, [2000] Can't execute load data local init callback function
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_negative_len.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysqli_set_local_infile_handler() - negative return value/buflen to indicate an error
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_negative_len($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation);
+		$buffer = fread($fp, $buflen);
+
+		$error = "negative length means error";
+		return -1;
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array();
+	try_handler(20, $link, $file, 'callback_negative_len', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_negative_len'
+Callback: 0
+[022] LOAD DATA failed, [2000] negative length means error
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_nested_call.phpt
@@ -0,0 +1,107 @@
+--TEST--
+mysqli_set_local_infile_handler() - nested calls
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_simple($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback - callback_simple(): %d\n", $invocation);
+
+		$invocation++;
+		if (!is_resource($fp))
+			printf("[012] First argument passed to callback is not a resource but %s/%s\n",
+				$fp, gettype($fp));
+
+		if (!$buffer = fread($fp, $buflen)) {
+			if ($invocation == 1) {
+				printf("[013] Cannot read from stream\n");
+				$error = 'Cannot read from stream';
+			} else {
+				return strlen($buffer);
+			}
+		}
+
+		$lines = explode("\n", $buffer);
+		if (count($lines) != 4 && strlen($buffer) > 0) {
+			printf("[014] Test is too simple to handle a buffer of size %d that cannot hold all lines\n", $buflen);
+			$error = 'Parser too simple';
+		}
+
+		$buffer = '';
+		foreach ($lines as $k => $line) {
+			if ('' === trim($line))
+				continue;
+
+			$columns = explode(';', $line);
+			if (empty($columns)) {
+				printf("[015] Cannot parse columns\n");
+				$error = 'Cannot parse columns';
+			}
+
+			// increase id column value
+			$columns[0] += 1;
+			$buffer .= implode(';', $columns);
+			$buffer .= "\n";
+		}
+
+		/* report the wrong length */
+		return strlen($buffer);
+	}
+
+	function callback_report_short_len($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback - report_short_len(): %d\n", $invocation++);
+		return callback_simple($fp, $buffer, $buflen, $error);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(
+		array('id' => 98,   'label' => 'x'),
+		array('id' => 99,   'label' => 'y'),
+		array('id' => 100,  'label' => 'z'),
+	);
+	try_handler(20, $link, $file, 'callback_report_short_len', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_report_short_len'
+Callback - report_short_len(): 0
+Callback - callback_simple(): 0
+Callback - report_short_len(): 1
+Callback - callback_simple(): 1
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_new_query.phpt
@@ -0,0 +1,71 @@
+--TEST--
+mysqli_set_local_infile_handler() - run new query on db link
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_new_query($fp, &$buffer, $buflen, &$error) {
+		global $link;
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+		if (is_object($link)) {
+			if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+				printf("[Callback 001 - %03d] Cannot run query, [%d] %s\n",
+					$invocation, mysqli_errno($link), mysqli_error($link));
+			}
+			if ($res)
+				mysqli_free_result($res);
+			}
+			$buffer = "1;'a';\n";
+			if ($invocation > 10)
+				return 0;
+
+			mysqli_set_local_infile_default($link);
+			return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	try_handler(20, $link, $file, 'callback_new_query', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_new_query'
+Callback: 0
+[Callback 001 - 001] Cannot run query, [2014] Commands out of sync; you can't run this command now
+[022] LOAD DATA failed, [2000] Can't execute load data local init callback function
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_nofileop.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysqli_set_local_infile_handler() - do not use the file pointer
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_nofileop($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+
+		$buffer = "1;'a';\n";
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	try_handler(20, $link, $file, 'callback_nofileop', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_nofileop'
+Callback: 0
+Callback: 1
+Callback: 2
+Callback: 3
+Callback: 4
+Callback: 5
+Callback: 6
+Callback: 7
+Callback: 8
+Callback: 9
+Callback: 10
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_openbasedir.phpt
@@ -0,0 +1,115 @@
+--TEST--
+mysqli_set_local_infile_handler() - open basedir restrictions
+--SKIPIF--
+<?php
+if (!$fp = @fopen('skipif.inc', 'r'))
+  die("skip open_basedir restrictions forbid opening include files");
+
+include_once('skipif.inc');
+include_once('skipifemb.inc');
+include_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+include_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+if (!$res = mysqli_query($link, 'SHOW VARIABLES LIKE "local_infile"')) {
+	mysqli_close($link);
+	die("skip Cannot check if Server variable 'local_infile' is set to 'ON'");
+}
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+open_basedir="."
+--FILE--
+<?php
+	@include('connect.inc');
+	if (!isset($db)) {
+		// stupid run-tests.php - any idea how to set system ini setting dynamically???
+		print "Warning: tempnam(): open_basedir restriction in effect. File(grrr) is not within the allowed path(s): (grrr) in grrr on line 0
+[005 + 1] Cannot create CVS file ''
+Callback set to 'callback_simple'
+[012] LOAD DATA failed, [0] grrr
+[014/0] [0] ''
+done!";
+		die();
+	}
+
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_simple($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation);
+
+		$invocation++;
+		if (!is_resource($fp))
+			printf("[012] First argument passed to callback is not a resource but %s/%s\n",
+				$fp, gettype($fp));
+
+		if (!$buffer = fread($fp, $buflen)) {
+			if ($invocation == 1) {
+				printf("[013] Cannot read from stream\n");
+					$error = 'Cannot read from stream';
+			} else {
+				return strlen($buffer);
+			}
+		}
+
+		$lines = explode("\n", $buffer);
+		if (count($lines) != 4 && strlen($buffer) > 0) {
+			printf("[014] Test is too simple to handle a buffer of size %d that cannot hold all lines\n", $buflen);
+			$error = 'Parser too simple';
+		}
+
+		$buffer = '';
+		foreach ($lines as $k => $line) {
+			if ('' === trim($line))
+				continue;
+
+			$columns = explode(';', $line);
+			if (empty($columns)) {
+				printf("[015] Cannot parse columns\n");
+				$error = 'Cannot parse columns';
+			}
+
+			// increase id column value
+			$columns[0] += 1;
+			$buffer .= implode(';', $columns);
+			$buffer .= "\n";
+		}
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(5);
+	$expected = array(
+		array('id' => 98,   'label' => 'x'),
+		array('id' => 99,   'label' => 'y'),
+		array('id' => 100,  'label' => 'z'),
+	);
+	try_handler(10, $link, $file, 'callback_simple', $expected);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: tempnam(): open_basedir restriction in effect. File(%s) is not within the allowed path(s): (%s) in %s on line %d
+[005 + 1] Cannot create CVS file ''
+Callback set to 'callback_simple'
+[012] LOAD DATA failed, [%d] %s
+[014/0] [0] ''
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_replace_buffer.phpt
@@ -0,0 +1,78 @@
+--TEST--
+mysqli_set_local_infile_handler() - replace buffer pointer
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_replace_buffer($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+
+		$buffer = fread($fp, $buflen);
+
+		$ret = "1;'a';\n";
+		$buffer = $ret;
+
+		$num_chars = ((version_compare(PHP_VERSION, '5.9.9', '>') == 1)) ? floor($buflen / 2) : $buflen;
+		assert(strlen($buffer) < $num_chars);
+
+		if ($invocation > 10)
+			return 0;
+
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	if (!try_handler(20, $link, $file, 'callback_replace_buffer', $expected))
+		printf("[008] Failure\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_replace_buffer'
+Callback: 0
+Callback: 1
+Callback: 2
+Callback: 3
+Callback: 4
+Callback: 5
+Callback: 6
+Callback: 7
+Callback: 8
+Callback: 9
+Callback: 10
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_short_len.phpt
@@ -0,0 +1,101 @@
+--TEST--
+mysqli_set_local_infile_handler() - report shorter buffer
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_short_len($fp, &$buffer, $buflen, &$error) {
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation);
+
+		$invocation++;
+		if (!is_resource($fp))
+			printf("[012] First argument passed to callback is not a resource but %s/%s\n",
+				$fp, gettype($fp));
+
+		if (!$buffer = fread($fp, $buflen)) {
+			if ($invocation == 1) {
+				printf("[013] Cannot read from stream\n");
+				$error = 'Cannot read from stream';
+			} else {
+				return strlen($buffer);
+			}
+		}
+
+		$lines = explode("\n", $buffer);
+		if (count($lines) != 4 && strlen($buffer) > 0) {
+			printf("[014] Test is too simple to handle a buffer of size %d that cannot hold all lines\n", $buflen);
+			$error = 'Parser too simple';
+		}
+
+		$buffer = '';
+		foreach ($lines as $k => $line) {
+			if ('' === trim($line))
+					continue;
+
+			$columns = explode(';', $line);
+			if (empty($columns)) {
+				printf("[015] Cannot parse columns\n");
+				$error = 'Cannot parse columns';
+			}
+
+			// increase id column value
+			$columns[0] += 1;
+			$buffer .= implode(';', $columns);
+			$buffer .= "\n";
+		}
+
+		/* report the wrong length */
+		return strlen($buffer) - 1;
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(
+		array('id' => 98,   'label' => 'x'),
+		array('id' => 99,   'label' => 'y'),
+		array('id' => 100,  'label' => 'z'),
+	);
+	try_handler(20, $link, $file, 'callback_short_len', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_short_len'
+Callback: 0
+
+Warning: mysqli_query(): Mismatch between the return value of the callback and the content length of the buffer. in %s on line %d
+[022] LOAD DATA failed, [2000] Mismatch between the return value of the callback and the content length of the buffer.
+[024/0] [0] ''
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_local_infile_handler_unregister.phpt
@@ -0,0 +1,64 @@
+--TEST--
+mysqli_set_local_infile_handler() - do not use the file pointer
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_set_local_infile_handler'))
+	die("skip - function not available.");
+
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+	die("skip Cannot connect to MySQL");
+
+include_once("local_infile_tools.inc");
+if ($msg = check_local_infile_support($link, $engine))
+	die(sprintf("skip %s, [%d] %s", $msg, $link->errno, $link->error));
+
+mysqli_close($link);
+?>
+--INI--
+mysqli.allow_local_infile=1
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('local_infile_tools.inc');
+	require_once('table.inc');
+
+	function callback_unregister($fp, &$buffer, $buflen, &$error) {
+		global $link;
+		static $invocation = 0;
+
+		printf("Callback: %d\n", $invocation++);
+		flush();
+		if (is_resource($fp))
+				fclose($fp);
+		$buffer = "1;'a';\n";
+		if ($invocation > 10)
+			return 0;
+
+		mysqli_set_local_infile_default($link);
+		return strlen($buffer);
+	}
+
+	$file = create_standard_csv(1);
+	$expected = array(array('id' => 1, 'label' => 'a'));
+	try_handler(20, $link, $file, 'callback_unregister', $expected);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Callback set to 'callback_unregister'
+Callback: 0
+
+Warning: mysqli_query(): File handle closed in %s on line %d
+[022] LOAD DATA failed, [2000] File handle closed
+[024/0] [0] ''
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_set_opt.phpt
@@ -0,0 +1,69 @@
+--TEST--
+mysqli_set_opt()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_set_opt()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_opt($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$link = mysqli_init();
+
+	if (!is_null($tmp = @mysqli_set_opt($link, MYSQLI_OPT_CONNECT_TIMEOUT)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_opt($link, "s", 'extra_my.cnf')))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_set_opt($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=0', 'foo')))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	// print "run_tests.php don't fool me with your 'ungreedy' expression '.+?'!\n";
+	var_dump(mysqli_set_opt($link, MYSQLI_READ_DEFAULT_GROUP, 'extra_my.cnf'));
+	var_dump(mysqli_set_opt($link, MYSQLI_READ_DEFAULT_FILE, 'extra_my.cnf'));
+	var_dump(mysqli_set_opt($link, MYSQLI_OPT_CONNECT_TIMEOUT, 10));
+	var_dump(mysqli_set_opt($link, MYSQLI_OPT_LOCAL_INFILE, 1));
+	var_dump(mysqli_set_opt($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=0'));
+	var_dump(my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket));
+	var_dump(mysqli_set_opt($link, MYSQLI_READ_DEFAULT_GROUP, 'extra_my.cnf'));
+	var_dump(mysqli_set_opt($link, MYSQLI_READ_DEFAULT_FILE, 'extra_my.cnf'));
+	var_dump(mysqli_set_opt($link, MYSQLI_OPT_CONNECT_TIMEOUT, 10));
+	var_dump(mysqli_set_opt($link, MYSQLI_OPT_LOCAL_INFILE, 1));
+	var_dump(mysqli_set_opt($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=0'));
+	var_dump(mysqli_set_opt($link, MYSQLI_CLIENT_SSL, 'not an mysqli_option'));
+
+	mysqli_close($link);
+
+	var_dump(mysqli_set_opt($link, MYSQLI_INIT_COMMAND, 'SET AUTOCOMMIT=1'));
+
+	print "done!";
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(false)
+
+Warning: mysqli_set_opt(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_sqlstate.phpt
@@ -0,0 +1,50 @@
+--TEST--
+mysqli_sqlstate()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_sqlstate()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_sqlstate($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	var_dump(@mysqli_sqlstate($link, "foo"));
+
+	var_dump(mysqli_sqlstate($link));
+	mysqli_query($link, "SELECT unknown_column FROM test");
+	var_dump(mysqli_sqlstate($link));
+	mysqli_free_result(mysqli_query($link, "SELECT id FROM test"));
+	var_dump(mysqli_sqlstate($link));
+
+	mysqli_close($link);
+
+	var_dump(mysqli_sqlstate($link));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+NULL
+%s(5) "00000"
+%s(5) "42S22"
+%s(5) "00000"
+
+Warning: mysqli_sqlstate(): Couldn't fetch mysqli in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_ssl_set.phpt
@@ -0,0 +1,61 @@
+--TEST--
+mysqli_ssl_set() - test is a stub!
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_ssl_set'))
+	die("skip function not available");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_ssl_set()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_ssl_set($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_ssl_set($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_ssl_set($link, $link, $link)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_ssl_set($link, $link, $link, $link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_ssl_set($link, $link, $link, $link, $link)))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	/*
+	This function always returns TRUE value.
+
+	$link = mysqli_init();
+	if (NULL !== ($tmp = @mysqli_ssl_set(
+		$link,
+		'The path name to the key file.',
+		'The path name to the certificate file.',
+		'The path name to the certificate authority file.',
+		'The pathname to a directory that contains trusted SSL CA certificates in PEM format.',
+		'A list of allowable ciphers to use for SSL encryption.')))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+
+	If SSL setup is incorrect my_mysqli_real_connect()
+	will return an error when you attempt to connect.
+
+	... and the above SSL setup should be always incorrect.
+
+	if (false !== ($tmp = my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)))
+		printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+	*/
+	print "done!\n";
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stat.phpt
@@ -0,0 +1,40 @@
+--TEST--
+mysqli_stat()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stat()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stat($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_null($tmp = @mysqli_stat($link, "foo")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ((!is_string($tmp = mysqli_stat($link))) || ('' === $tmp))
+		printf("[004] Expecting non empty string, got %s/'%s', [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysql_error($link));
+
+	mysqli_close($link);
+
+	if (!is_null($tmp = mysqli_stat($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: mysqli_stat(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_affected_rows.phpt
@@ -0,0 +1,252 @@
+--TEST--
+mysqli_stmt_affected_rows()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_affected_rows()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_affected_rows($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, 'DROP TABLE IF EXISTS test') ||
+		!mysqli_stmt_execute($stmt)) {
+		printf("[003] Failed to drop old test table: [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (!mysqli_stmt_prepare($stmt, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE = ' . $engine) ||
+		!mysqli_stmt_execute($stmt)) {
+		printf("[004] Failed to create test table: [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (0 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[005] Expecting int/0, got %s/'%s'\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (1, 'a')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (100, 'z')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[008] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (100, 'z')") ||
+		!mysqli_stmt_execute($stmt))
+		// NOTE: the error message varies with the MySQL Server version, dump only the error code!
+		printf("[009] [%d] (error message varies with the MySQL Server version, check the error code)\n", mysqli_stmt_errno($stmt));
+
+	/* an error occured: affected rows should return -1 */
+	if (-1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[010] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (1, 'a') ON DUPLICATE KEY UPDATE id = 4") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (2 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[012] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (2, 'b'), (3, 'c')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (2 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[014] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT IGNORE INTO test(id, label) VALUES (1, 'a')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[015] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[016] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!($res = mysqli_query($link, "SELECT count(id) AS num FROM test")) ||
+		!($tmp = mysqli_fetch_assoc($res)))
+		printf("[017] [%d] %s\n", mysqli_error($link), mysqli_error($link));
+	$num = (int)$tmp['num'];
+	mysqli_free_result($res);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) SELECT id + 10, label FROM test") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[018] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if ($num !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[019] Expecting int/%d, got %s/%s\n", $num, gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "REPLACE INTO test(id, label) values (4, 'd')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[020] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (2 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[021] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "REPLACE INTO test(id, label) values (5, 'e')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[022] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[023] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "UPDATE test SET label = 'a' WHERE id = 2") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[024] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[025] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "UPDATE test SET label = 'a' WHERE id = 2") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[026] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (0 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[027] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "UPDATE test SET label = 'a' WHERE id = 100") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[028] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[029] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT label FROM test WHERE id = 100') ||
+		!mysqli_stmt_execute($stmt))
+		printf("[030] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	/* use it like num_rows */
+	/* PS are unbuffered, num_rows cannot determine the row count before all rows have been fetched and/or buffered */
+	if (-1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[031] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (0 !== ($tmp = mysqli_stmt_num_rows($stmt)))
+		printf("[032] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_store_result($stmt))
+		printf("[033] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[034] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (1 !== ($tmp = mysqli_stmt_num_rows($stmt)))
+		printf("[035] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_free_result($stmt);
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT label FROM test WHERE 1 = 2') ||
+		!mysqli_stmt_execute($stmt))
+		printf("[036] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	/* use it like num_rows */
+	if (-1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[037] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_stmt_store_result($stmt)))
+		printf("[038] Expecting boolean/true, got %s\%s\n", gettype($tmp), $tmp);
+
+	if (0 !== ($tmp = mysqli_stmt_num_rows($stmt)))
+		printf("[039] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (0 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[040] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	/* try to use stmt_affected_rows like stmt_num_rows */
+	/* stmt_affected_rows is not really meant for SELECT! */
+	if (mysqli_stmt_prepare($stmt, 'SELECT unknown_column FROM this_table_does_not_exist') ||
+		mysqli_stmt_execute($stmt))
+		printf("[041] The invalid SELECT statement is issued on purpose\n");
+
+	if (-1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[042] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if ($IS_MYSQLND) {
+		if (false !== ($tmp = mysqli_stmt_store_result($stmt)))
+			printf("[043] Expecting boolean/false, got %s\%s\n", gettype($tmp), $tmp);
+	} else {
+		if (true !== ($tmp = mysqli_stmt_store_result($stmt)))
+			printf("[043] Libmysql does not care if the previous statement was bogus, expecting boolean/true, got %s\%s\n", gettype($tmp), $tmp);
+	}
+
+	if (0 !== ($tmp = mysqli_stmt_num_rows($stmt)))
+		printf("[044] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (-1 !== ($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[045] Expecting int/-1, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	if (!mysqli_stmt_prepare($stmt, "DROP TABLE IF EXISTS test") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[046] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+
+	if (!is_null($tmp = mysqli_stmt_affected_rows($stmt)))
+		printf("[047] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+[009] [%d] (error message varies with the MySQL Server version, check the error code)
+
+Warning: mysqli_stmt_affected_rows(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_attr_get.phpt
@@ -0,0 +1,70 @@
+--TEST--
+mysqli_stmt_attr_get()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_attr_get()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_attr_get($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_attr_get($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_null($tmp = @mysqli_stmt_attr_get($link, $link)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$valid_attr = array("max_length" => MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH);
+	if (mysqli_get_client_version() > 50003)
+		$valid_attr["cursor_type"] = MYSQLI_STMT_ATTR_CURSOR_TYPE;
+
+	if ($IS_MYSQLND && mysqli_get_client_version() > 50007)
+		$valid_attr["prefetch_rows"] = MYSQLI_STMT_ATTR_PREFETCH_ROWS;
+
+	do {
+		$invalid_attr = mt_rand(0, 10000);
+	} while (in_array($invalid_attr, $valid_attr));
+
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, 'SELECT * FROM test');
+	if (false !== ($tmp = @mysqli_stmt_attr_get($stmt, $invalid_attr)))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	foreach ($valid_attr as $k => $attr) {
+		if (false === ($tmp = mysqli_stmt_attr_get($stmt, $attr))) {
+			printf("[006] Expecting any type, but not boolean/false, got %s/%s for attribute %s/%s\n",
+				gettype($tmp), $tmp, $k, $attr);
+		}
+	}
+
+	$stmt->close();
+
+	foreach ($valid_attr as $k => $attr) {
+		if (!is_null($tmp = @mysqli_stmt_attr_get($stmt, $attr))) {
+			printf("[007] Expecting NULL/NULL, got %s/%s for attribute %s/%s\n",
+				gettype($tmp), $tmp, $k, $attr);
+		}
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_attr_get_prefetch.phpt
@@ -0,0 +1,29 @@
+--TEST--
+mysqli_stmt_attr_get() - prefetch
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+die("SKIP: prefetch isn't supported at the moment");
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	$stmt = mysqli_stmt_init($link);
+	mysqli_stmt_prepare($stmt, 'SELECT * FROM test');
+	if (1 !== ($tmp = mysqli_stmt_attr_get($stmt, MYSQLI_STMT_ATTR_PREFETCH_ROWS))) {
+		printf("[001] Expecting int/1, got %s/%s for attribute %s/%s\n",
+			gettype($tmp), $tmp, $k, $attr);
+	}
+	$stmt->close();
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_attr_set.phpt
@@ -0,0 +1,277 @@
+--TEST--
+mysqli_stmt_attr_set() - mysqlnd does not check for invalid codes
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_attr_set()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_attr_set($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_attr_set($link, $link)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_attr_set($link, $link, $link)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$valid_attr = array(MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH);
+	if ((mysqli_get_client_version() > 50003) || $IS_MYSQLND) {
+		$valid_attr[] = MYSQLI_STMT_ATTR_CURSOR_TYPE;
+		$valid_attr[] =	MYSQLI_CURSOR_TYPE_NO_CURSOR;
+		$valid_attr[] =	MYSQLI_CURSOR_TYPE_READ_ONLY;
+		$valid_attr[] =	MYSQLI_CURSOR_TYPE_FOR_UPDATE;
+		$valid_attr[] =	MYSQLI_CURSOR_TYPE_SCROLLABLE;
+	}
+
+	if ((mysqli_get_client_version() > 50007) || $IS_MYSQLND)
+		$valid_attr[] = MYSQLI_STMT_ATTR_PREFETCH_ROWS;
+
+
+	$stmt = mysqli_stmt_init($link);
+	if (!is_null($tmp = @mysqli_stmt_attr_set($stmt, 0, 0)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$stmt->prepare("SELECT * FROM test");
+
+	mt_srand(microtime(true));
+
+	for ($i = -100; $i < 1000; $i++) {
+		if (in_array($i, $valid_attr))
+			continue;
+		$invalid_attr = $i;
+		if (false !== ($tmp = @mysqli_stmt_attr_set($stmt, $invalid_attr, 0))) {
+			printf("[006a] Expecting boolean/false for attribute %d, got %s/%s\n", $invalid_attr, gettype($tmp), $tmp);
+		}
+	}
+
+	for ($i = 0; $i < 2; $i++) {
+		do {
+			$invalid_attr = mt_rand(-1 * (min(4294967296, PHP_INT_MAX) + 1), min(4294967296, PHP_INT_MAX));
+		} while (in_array($invalid_attr, $valid_attr));
+		if (false !== ($tmp = @mysqli_stmt_attr_set($stmt, $invalid_attr, 0))) {
+			printf("[006b] Expecting boolean/false for attribute %d, got %s/%s\n", $invalid_attr, gettype($tmp), $tmp);
+		}
+	}
+	$stmt->close();
+
+	//
+	// MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH
+	//
+
+
+	// expecting max_length not to be set and be 0 in all cases
+	$stmt = mysqli_stmt_init($link);
+	$stmt->prepare("SELECT label FROM test");
+	$stmt->execute();
+	$stmt->store_result();
+	$res = $stmt->result_metadata();
+	$fields = $res->fetch_fields();
+	$max_lengths = array();
+	foreach ($fields as $k => $meta) {
+		$max_lengths[$meta->name] = $meta->max_length;
+		if ($meta->max_length !== 0)
+			printf("[007] max_length should be not set (= 0), got %s for field %s\n", $meta->max_length, $meta->name);
+	}
+	$res->close();
+	$stmt->close();
+
+	// expecting max_length to _be_ set
+	$stmt = mysqli_stmt_init($link);
+	$stmt->prepare("SELECT label FROM test");
+	$stmt->attr_set(MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH, 1);
+	$res = $stmt->attr_get(MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH);
+	if ($res !== 1)
+		printf("[007.1] max_length should be 1, got %s\n", $res);
+	$stmt->execute();
+	$stmt->store_result();
+	$res = $stmt->result_metadata();
+	$fields = $res->fetch_fields();
+	$max_lengths = array();
+	foreach ($fields as $k => $meta) {
+		$max_lengths[$meta->name] = $meta->max_length;
+		if ($meta->max_length === 0)
+			printf("[008] max_length should be set (!= 0), got %s for field %s\n", $meta->max_length, $meta->name);
+	}
+	$res->close();
+	$stmt->close();
+
+	// expecting max_length not to be set
+	$stmt = mysqli_stmt_init($link);
+	$stmt->prepare("SELECT label FROM test");
+	$stmt->attr_set(MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH, 0);
+	$res = $stmt->attr_get(MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH);
+	if ($res !== 0)
+		printf("[008.1] max_length should be 0, got %s\n", $res);
+	$stmt->execute();
+	$stmt->store_result();
+	$res = $stmt->result_metadata();
+	$fields = $res->fetch_fields();
+	$max_lengths = array();
+	foreach ($fields as $k => $meta) {
+		$max_lengths[$meta->name] = $meta->max_length;
+		if ($meta->max_length !== 0)
+			printf("[009] max_length should not be set (= 0), got %s for field %s\n", $meta->max_length, $meta->name);
+	}
+	$res->close();
+	$stmt->close();
+
+	//
+	// Cursors
+	//
+
+	if (mysqli_get_client_version() > 50003) {
+
+		$cursor_types = array(
+			MYSQLI_CURSOR_TYPE_NO_CURSOR,
+			MYSQLI_CURSOR_TYPE_READ_ONLY,
+			MYSQLI_CURSOR_TYPE_FOR_UPDATE,
+			MYSQLI_CURSOR_TYPE_SCROLLABLE
+		);
+		do {
+			$invalid_cursor_type = mt_rand(-1000, 1000);
+		} while (in_array($invalid_cursor_type, $cursor_types));
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT id, label FROM test");
+
+		if (false !== ($tmp = @$stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, $invalid_cursor_type)))
+			printf("[010] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+		if (false !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_FOR_UPDATE)))
+			printf("[011] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+		if (false !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_SCROLLABLE)))
+			printf("[012] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_NO_CURSOR)))
+			printf("[013] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_READ_ONLY)))
+			printf("[014] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+		$stmt->close();
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT id, label FROM test");
+		$stmt->execute();
+		$id = $label = NULL;
+		$stmt->bind_result($id, $label);
+		$results = array();
+		while ($stmt->fetch())
+			$results[$id] = $label;
+		$stmt->close();
+		if (empty($results))
+			printf("[015] Results should not be empty, subsequent tests will probably fail!\n");
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT id, label FROM test");
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_NO_CURSOR)))
+			printf("[016] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+		$stmt->execute();
+		$id = $label = NULL;
+		$stmt->bind_result($id, $label);
+		$results2 = array();
+		while ($stmt->fetch())
+			$results2[$id] = $label;
+		$stmt->close();
+		if ($results != $results2) {
+			printf("[017] Results should not differ. Dumping both result sets.\n");
+			var_dump($results);
+			var_dump($results2);
+		}
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT id, label FROM test");
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_CURSOR_TYPE, MYSQLI_CURSOR_TYPE_READ_ONLY)))
+			printf("[018] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+		$stmt->execute();
+		$id = $label = NULL;
+		$stmt->bind_result($id, $label);
+		$results2 = array();
+		while ($stmt->fetch())
+			$results2[$id] = $label;
+		$stmt->close();
+		if ($results != $results2) {
+			printf("[019] Results should not differ. Dumping both result sets.\n");
+			var_dump($results);
+			var_dump($results2);
+		}
+
+	}
+
+
+	//
+	// MYSQLI_STMT_ATTR_PREFETCH_ROWS
+	//
+
+	if (mysqli_get_client_version() > 50007) {
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT id, label FROM test");
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_PREFETCH_ROWS, 1)))
+			printf("[020] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+		$stmt->execute();
+		$id = $label = NULL;
+		$stmt->bind_result($id, $label);
+		$results = array();
+		while ($stmt->fetch())
+			$results[$id] = $label;
+		$stmt->close();
+		if (empty($results))
+			printf("[021] Results should not be empty, subsequent tests will probably fail!\n");
+
+		/* prefetch is not supported
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT label FROM test");
+		if (false !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_PREFETCH_ROWS, -1)))
+			printf("[022] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+		$stmt->close();
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT label FROM test");
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_PREFETCH_ROWS, PHP_INT_MAX)))
+				printf("[023] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+		$stmt->close();
+
+		$stmt = mysqli_stmt_init($link);
+		$stmt->prepare("SELECT id, label FROM test");
+		if (true !== ($tmp = $stmt->attr_set(MYSQLI_STMT_ATTR_PREFETCH_ROWS, 2)))
+			printf("[024] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+		$stmt->execute();
+		$id = $label = NULL;
+		$stmt->bind_result($id, $label);
+		$results2 = array();
+		while ($stmt->fetch())
+			$results2[$id] = $label;
+		$stmt->close();
+		if ($results != $results2) {
+			printf("[025] Results should not differ. Dumping both result sets.\n");
+			var_dump($results);
+			var_dump($results2);
+		}
+		*/
+
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_limits.phpt
@@ -0,0 +1,129 @@
+--TEST--
+Bind limits
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	function bind_many($offset, $link, $num_params, $rows, $eval = true) {
+
+		$drop = "DROP TABLE IF EXISTS test";
+		$create = "CREATE TABLE test(id INT AUTO_INCREMENT PRIMARY KEY, ";
+		$insert = "INSERT INTO test";
+		$columns = "";
+		$values = "";
+		$stmt_params = "";
+		$params = array();
+		for ($i = 0; $i < $num_params; $i++) {
+			$create 		.= "col" . $i . " INT, ";
+			$columns 		.= "col" . $i . ", ";
+			$values 		.= "?, ";
+			$stmt_params 	.= '$params[' . $i . '], ';
+			for ($j = 0; $j < $rows; $j++)
+			  $params[($j * $rows) + $i] = $i;
+		}
+		$create = substr($create, 0, -2) . ")";
+
+		$stmt_types = str_repeat("i", $num_params * $rows);
+		$stmt_params = substr(str_repeat($stmt_params, $rows), 0, -2);
+		$values = substr($values, 0, -2);
+		$insert .= "(" . substr($columns, 0, -2) . ") VALUES ";
+		$insert .= substr(str_repeat("(" . $values . "), ", $rows), 0, -2);
+
+		$stmt_bind_param = 'return mysqli_stmt_bind_param($stmt, "' . $stmt_types . '", ' . $stmt_params . ');';
+
+		printf("Testing %d columns with %d rows...\n", $num_params, $rows);
+
+		if (!$link->query($drop) || !$link->query($create)) {
+			printf("[%03d + 01] [%d] %s\n", $offset, $link->errno, $link->error);
+			return false;
+		}
+		printf("... table created\n");
+
+		if (!$stmt = $link->prepare($insert)) {
+			printf("[%03d + 02] [%d] %s\n", $offset, $link->errno, $link->error);
+			return false;
+		}
+		if ($stmt->param_count != $num_params * $rows) {
+			  printf("[%03d + 03] Parameter count should be %d but got %d\n", $offset, $num_params * $rows, $stmt->param_count);
+			return false;
+		}
+		printf("... statement with %d parameters prepared\n", $stmt->param_count);
+
+		if ($eval) {
+			if (!eval($stmt_bind_param)) {
+				printf("[%03d + 03] [%d] %s\n", $offset, $stmt->errno, $stmt->error);
+				return false;
+			}
+		} else {
+			$param_ref = array($stmt_types);
+			for ($i = 0; $i < $rows; $i++)
+				for ($j = 0; $j < $num_params; $j++)
+					$param_ref[] = &$params[($i * $rows) + $j];
+
+			if (!call_user_func_array(array($stmt, 'bind_param'), $param_ref)) {
+				printf("[%03d + 03] [%d] %s\n", $offset, $stmt->errno, $stmt->error);
+				return false;
+			}
+		}
+		if ($stmt->param_count != $num_params * $rows) {
+			 printf("[%03d + 03] Parameter count should be %d but got %d\n", $offset, $num_params * $rows, $stmt->param_count);
+			return false;
+		}
+
+		if (!$stmt->execute()) {
+			printf("[%03d + 04] [%d] %s\n", $offset, $stmt->errno, $stmt->error);
+			return false;
+		}
+		printf("Statement done\n");
+
+		$stmt->close();
+
+		if (!($res = $link->query("SELECT * FROM test"))) {
+			printf("[%03d + 05] [%d] %s\n", $offset, $link->errno, $link->error);
+			return false;
+		}
+
+		$row = $res->fetch_row();
+		$res->close();
+
+		for ($i = 0; $i < $num_params; $i++) {
+			if ($row[$i + 1] != $i) {
+				printf("[%03d + 06] [%d] %s\n", $offset, $link->errno, $link->error);
+			}
+		}
+
+		return true;
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+	}
+
+	var_dump(bind_many(10, $link, 273, 240, true));
+	var_dump(bind_many(20, $link, 273, 240, false));
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("clean_table.inc");
+?>
+--EXPECTF--
+Testing 273 columns with 240 rows...
+... table created
+... statement with 65520 parameters prepared
+Statement done
+bool(true)
+Testing 273 columns with 240 rows...
+... table created
+... statement with 65520 parameters prepared
+Statement done
+bool(true)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_param.phpt
@@ -0,0 +1,404 @@
+--TEST--
+mysqli_stmt_bind_param()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/*
+	The way we test the INSERT and data types overlaps with
+	the mysqli_stmt_bind_result test in large parts. There is only
+	one difference. This test uses mysqli_query()/mysqli_fetch_assoc() to
+	fetch the inserted values. This way we test
+	mysqli_query()/mysqli_fetch_assoc() for all possible data types
+	in this file and we test mysqli_stmt_bind_result() in the other
+	test -- therefore the "duplicate" makes some sense to me.
+	*/
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_bind_param()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_bind_param($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_bind_param($link, $link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	$label = null;
+
+	/*
+	libmysql gives a less descriptive error message but mysqlnd,
+	we did not unify the error messages but ignore this slight difference silently
+	*/
+	if (!false === ($tmp = @mysqli_stmt_bind_param($stmt, " ", $tmp)))
+		printf("[003d] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!false === ($tmp = @mysqli_stmt_bind_param($stmt, "", $id, $label)))
+		printf("[003a] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	/* TODO: somehwhat undocumented syntax! */
+	$param = array($id);
+	if (!false === ($tmp = mysqli_stmt_bind_param($stmt, "is", $param)))
+		printf("[003b] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	$param = array($id, $label, $id);
+	if (!false === ($tmp = mysqli_stmt_bind_param($stmt, "is", $param)))
+		printf("[003c] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!false === ($tmp = mysqli_stmt_bind_param($stmt, "a", $id)))
+		printf("[004] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!false === ($tmp = mysqli_stmt_bind_param($stmt, "a", $id, $label)))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!false === ($tmp = mysqli_stmt_bind_param($stmt, "aa", $id, $label)))
+		printf("[006] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!false === ($tmp = mysqli_stmt_bind_param($stmt, "ia", $id, $label)))
+		printf("[007] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!true === ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (function_exists("memory_get_usage")) {
+		$mem = memory_get_usage();
+		for ($i = 0; $i < 20000; $i++) {
+			if (!true === ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+				printf("[008][$i] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+		}
+		if (($tmp = (memory_get_usage() - $mem)) > 600)
+			printf("[009] Function seems to be leaking, because it used %d bytes. During tests it used only 92 bytes.", $tmp);
+	}
+
+	$id = 100;
+	$label = "z";
+	if (!mysqli_stmt_execute($stmt))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+
+	if (!($res = mysqli_query($link, "SELECT id, label FROM test WHERE id = " . $id)))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	$row = mysqli_fetch_assoc($res);
+	if (($row['id'] != $id) || ($row['label'] != $label))
+		printf("[012] Expecting '%s'/%s', got '%s'/%s'!\n", $id, $label, $row['id'], $row['label']);
+	mysqli_free_result($res);
+
+	function func_mysqli_stmt_bind_datatype($link, $engine, $bind_type, $sql_type, $bind_value, $offset, $alternative = null) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%03d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT NOT NULL, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+			// don't bail - it might be that the server does not support the data type
+			return false;
+		}
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%03d] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUE (?, ?)")) {
+			printf("[%03d] [%d] %s\n", $offset + 2, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		$id = 1;
+		if (!mysqli_stmt_bind_param($stmt, "i" . $bind_type, $id, $bind_value)) {
+			printf("[%03d] [%d] %s\n", $offset + 3, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d] [%d] %s\n", $offset + 4, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+		mysqli_stmt_close($stmt);
+
+		if (!$res = mysqli_query($link, "SELECT id, label FROM test")) {
+			printf("[%03d] [%d] %s\n", $offset + 5, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!$row = mysqli_fetch_assoc($res)) {
+			printf("[%03d] [%d] %s\n", $offset + 5, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if ($alternative) {
+			if (($row['id'] != $id) || (($row['label'] != $bind_value) && ($row['label'] != $alternative))) {
+				printf("[%03d] Testing '%s', '%s': expecting '%s'/'%s' (%s), got '%s'/'%s'\n",
+					$offset + 6, $bind_type, $sql_type,
+					$id, $bind_value, gettype($bind_value), $row['id'], $row['label']);
+				return false;
+			}
+		} else {
+			if (($row['id'] != $id) || ($row['label'] != $bind_value)) {
+				printf("[%03d] Testing '%s', '%s': expecting '%s'/'%s', got '%s'/'%s'\n",
+					$offset + 6, $bind_type, $sql_type,
+					$id, $bind_value, $row['id'], $row['label']);
+				return false;
+			}
+		}
+
+		mysqli_free_result($res);
+		return true;
+	}
+
+	function func_mysqli_stmt_bind_make_string($len) {
+
+		$ret = '';
+		for ($i = 0; $i < $len; $i++)
+			$ret .= chr(mt_rand(65, 90));
+
+		return $ret;
+	}
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "TINYINT", -11, 20);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "TINYINT", NULL, 30);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "TINYINT UNSIGNED", 1, 40);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "TINYINT UNSIGNED", NULL, 50);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BOOL", 1, 60);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BOOL", NULL, 70);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BOOLEAN", 0, 80);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BOOLEAN", NULL, 90);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "SMALLINT", -32768, 100);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "SMALLINT", 32767, 110);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "SMALLINT", NULL, 120);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "SMALLINT UNSIGNED", 65535, 130);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "SMALLINT UNSIGNED", NULL, 140);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "MEDIUMINT", -8388608, 150);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "MEDIUMINT", 8388607, 160);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "MEDIUMINT", NULL, 170);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "MEDIUMINT UNSIGNED", 16777215, 180);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "MEDIUMINT UNSIGNED", NULL, 190);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "INTEGER", -2147483648, 200);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "INTEGER", 2147483647, 210);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "INTEGER", NULL, 220);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "INTEGER UNSIGNED", (defined("PHP_INT_MAX")) ? min(4294967295, PHP_INT_MAX) : 1, 230);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "INTEGER UNSIGNED", 4294967295, 240);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "INTEGER UNSIGNED", NULL, 250);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BIGINT", -1 * PHP_INT_MAX + 1, 260);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BIGINT", NULL, 270);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BIGINT", PHP_INT_MAX, 280);
+	func_mysqli_stmt_bind_datatype($link, $engine, "i", "BIGINT UNSIGNED", NULL, 290);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "BIGINT", "-9223372036854775808", 900);
+	// ?? func_mysqli_stmt_bind_datatype($link, $engine, "d", "BIGINT", -9223372036854775808, 910);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "BIGINT UNSIGNED", "18446744073709551615", 920);
+
+/*
+	??
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT", -9223372036854775808 - 1.1, 300);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT UNSIGNED", 18446744073709551615 + 1.1, 320);
+	*/
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT", NULL, 310);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT UNSIGNED ", NULL, 330);
+	if (2147483647 == PHP_INT_MAX) {
+		func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT UNSIGNED", PHP_INT_MAX, 930, '2.14748e+09');
+		func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT", -1 * PHP_INT_MAX + 1, 940, '-2.14748e+09');
+	}
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "FLOAT", "-9223372036854775808", 300, '-9.22337e+18');
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "FLOAT UNSIGNED", "18446744073709551615", 320, '1.84467e+19');
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT", -10.01, 950);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "FLOAT UNSIGNED", 10.01, 960);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DOUBLE(10,2)", NULL, 350);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", NULL, 370);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DOUBLE(10,2)", -99999999.99, 340);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", 99999999.99, 360);
+
+	/*
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DOUBLE(10,2)", -99999999.99, 340);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", 99999999.99, 360);
+		*/
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DECIMAL(10,2)", -99999999.99, 380);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DECIMAL(10,2)", NULL, 390);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DECIMAL(10,2)", 99999999.99, 400);
+	func_mysqli_stmt_bind_datatype($link, $engine, "d", "DECIMAL(10,2)", NULL, 410);
+
+	// don't care about date() strict TZ warnings...
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "DATE", @date('Y-m-d'), 420);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "DATE NOT NULL", @date('Y-m-d'), 430);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "DATE", NULL, 440);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "DATETIME", @date('Y-m-d H:i:s'), 450);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "DATETIME NOT NULL", @date('Y-m-d H:i:s'), 460);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "DATETIME", NULL, 470);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TIMESTAMP", @date('Y-m-d H:i:s'), 480);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TIME", @date('H:i:s'), 490);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TIME NOT NULL", @date('H:i:s'), 500);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TIME", NULL, 510);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "YEAR", @date('Y'), 520);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "YEAR NOT NULL", @date('Y'), 530);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "YEAR", NULL, 540);
+
+	$string255 = func_mysqli_stmt_bind_make_string(255);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "CHAR(1)", "a", 550);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "CHAR(255)", $string255, 560);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "CHAR(1) NOT NULL", "a", 570);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "CHAR(1)", NULL, 580);
+
+	$string65k = func_mysqli_stmt_bind_make_string(65535);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARCHAR(1)", "a", 590);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARCHAR(255)", $string255, 600);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARCHAR(65635)", $string65k, 610);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARCHAR(1) NOT NULL", "a", 620);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARCHAR(1)", NULL, 630);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "BINARY(1)", "a", 640);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "BINARY(1)", chr(0), 650);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "BINARY(1) NOT NULL", "b", 660);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "BINARY(1)", NULL, 670);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARBINARY(1)", "a", 680);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARBINARY(1)", chr(0), 690);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARBINARY(1) NOT NULL", "b", 700);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "VARBINARY(1)", NULL, 710);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYBLOB", "a", 720);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYBLOB", chr(0), 730);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYBLOB NOT NULL", "b", 740);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYBLOB", NULL, 750);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYTEXT", "a", 760);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYTEXT NOT NULL", "a", 770);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "TINYTEXT", NULL, 780);
+
+	// Note: you cannot insert any blob values this way. But you can check the API at least partly this way
+	// Extra BLOB tests are in mysqli_stmt_send_long()
+	func_mysqli_stmt_bind_datatype($link, $engine, "b", "BLOB", "", 790);
+	func_mysqli_stmt_bind_datatype($link, $engine, "b", "TEXT", "", 800);
+	func_mysqli_stmt_bind_datatype($link, $engine, "b", "MEDIUMBLOB", "", 810);
+	func_mysqli_stmt_bind_datatype($link, $engine, "b", "MEDIUMTEXT", "", 820);
+	func_mysqli_stmt_bind_datatype($link, $engine, "b", "LONGBLOB", "", 830);
+	func_mysqli_stmt_bind_datatype($link, $engine, "b", "LONGTEXT", "", 840);
+
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "ENUM('a', 'b')", "a", 850);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "ENUM('a', 'b')", NULL, 860);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "SET('a', 'b')", "a", 870);
+	func_mysqli_stmt_bind_datatype($link, $engine, "s", "SET('a', 'b')", NULL, 880);
+
+	if (mysqli_get_server_version($link) >= 50600)
+		func_mysqli_stmt_bind_datatype($link, $engine, "s", "TIME", "13:27:34.123456", 890, "13:27:34");
+
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[2000] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	$label = null;
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[2001] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_execute($stmt);
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[2002] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+	include("table.inc");
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[2003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[2004] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (true !== ($tmp = $stmt->bind_param('is', $id, $label)))
+		printf("[2005] Expecting boolean/true got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp,
+			$stmt->errno, $stmt->error);
+
+	$id = 100; $label = 'z';
+	if (!$stmt->execute())
+		printf("[2006] [%d] %s\n", $stmt->errno, $stmt->error);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test WHERE id = 100"))
+		printf("[2007] Expecting record 100/z, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[2008] Expecting row, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if ($row['id'] != 100  || $row['label'] != 'z') {
+		printf("[2009] Row seems wrong, dumping record\n");
+		var_dump($row);
+	}
+	mysqli_free_result($res);
+
+	$value_list = array(array('id' => 101, 'label' => 'a'), array('id' => 102, 'label' => 'b'));
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[2010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+        foreach ($value_list as $k => $values) {
+		if (!mysqli_stmt_bind_param($stmt, 'is', $values['id'], $values['label'])) {
+			printf("[2011] bind_param() failed for id = %d, [%d] %s\n",
+				$values['id'], mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			continue;
+		}
+		if (!$stmt->execute())
+			printf("[2012] [%d] execute() failed for id = %d, [%d] %s\n",
+				$values['id'], mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$res = mysqli_query($link, sprintf("SELECT label FROM test WHERE id = %d", $values['id'])))
+			printf("[2013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		if (!$row = mysqli_fetch_assoc($res))
+			printf("[2014] Cannot find row id = %d\n", $values['id']);
+		else if (isset($row['label']) && ($values['label'] != $row['label']))
+			printf("[2015] Expecting label = %s, got label = %s\n", $values['label'], $row['label']);
+
+		mysqli_free_result($res);
+	}
+
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	/* Check that the function alias exists. It's a deprecated function,
+	but we have not announce the removal so far, therefore we need to check for it */
+	if (!is_null($tmp = @mysqli_stmt_bind_param()))
+			printf("[021] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_bind_param(): Number of elements in type definition string doesn't match number of bind variables in %s on line %d
+
+Warning: mysqli_stmt_bind_param(): Number of elements in type definition string doesn't match number of bind variables in %s on line %d
+
+Warning: mysqli_stmt_bind_param(): Number of variables doesn't match number of parameters in prepared statement in %s on line %d
+
+Warning: mysqli_stmt_bind_param(): Number of elements in type definition string doesn't match number of bind variables in %s on line %d
+
+Warning: mysqli_stmt_bind_param(): Undefined fieldtype a (parameter 3) in %s on line %d
+
+Warning: mysqli_stmt_bind_param(): Undefined fieldtype a (parameter 4) in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_param_call_user_func.phpt
@@ -0,0 +1,366 @@
+--TEST--
+mysqli_stmt_bind_param used with call_user_func_array() (see also bug #43568)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+// TODO remove once a decision has been made on call_user_func_array()
+if (version_compare(PHP_VERSION, '5.3.0-dev') == -1)
+	die("skip needs PHP 5.3.0-dev+, see http://bugs.php.net/bug.php?id=43568");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[002] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	if (!mysqli_stmt_bind_param($stmt, 'i', $id) ||
+		!mysqli_stmt_execute($stmt))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[004] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Regular, procedural, using variables\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => &$stmt,
+		1 => &$types,
+		2 => &$id
+	);
+	if (!call_user_func_array('mysqli_stmt_bind_param', $params))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, procedural, using references for everything\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => &$types,
+		1 => &$id
+	);
+	if (!call_user_func_array(array($stmt, 'bind_param'), $params))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, object oriented, using references for everything\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[015] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => $types,
+		1 => &$id
+	);
+	if (!call_user_func_array(array($stmt, 'bind_param'), $params))
+		printf("[017] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[018] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[019] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, object oriented, using variable for types. using references for bound parameter\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[020] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[021] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	$params = array(
+		0 => 'i',
+		1 => &$id
+	);
+	if (!call_user_func_array(array($stmt, 'bind_param'), $params))
+		printf("[022] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[023] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[024] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, object oriented, using constant for types. using references for bound parameter\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[025] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[026] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => &$stmt,
+		1 => $types,
+		2 => &$id
+	);
+	if (!call_user_func_array('mysqli_stmt_bind_param', $params))
+		printf("[027] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[028] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[029] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, procedural, using references for everything but using variable for types\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[025] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[026] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => $stmt,
+		1 => $types,
+		2 => &$id
+	);
+	if (!call_user_func_array('mysqli_stmt_bind_param', $params))
+		printf("[027] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[028] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[029] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, procedural, using references for bound parameter, using variables for resource and types\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[030] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[031] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => $stmt,
+		1 => $types,
+		2 => &$id
+	);
+	if (!call_user_func_array('mysqli_stmt_bind_param', $params))
+		printf("[032] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[033] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[034] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, procedural, using references for bound parameter, using variables for resource and types\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[035] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[036] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	$params = array(
+		0 => $stmt,
+		1 => 'i',
+		2 => &$id
+	);
+	if (!call_user_func_array('mysqli_stmt_bind_param', $params))
+		printf("[037] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[038] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[039] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, procedural, using references for bound parameter, using variable for resource, using constant for types\n";
+	var_dump($id);
+	var_dump($label);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[040] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[041] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	if (!call_user_func_array('mysqli_stmt_bind_param', array($stmt, 'i', &$id)))
+		printf("[042] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[043] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label) ||
+		(true !== mysqli_stmt_fetch($stmt)))
+		printf("[044] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	print "Call user func, procedural, using references for bound parameter, using variable for resource, using constant for types, array\n";
+	var_dump($id);
+	var_dump($label);
+
+	//
+	// Any of those shall fail - see also bugs.php.net/43568
+	//
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[045] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[046] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	$params = array(
+		0 => 'i',
+		1 => &$id
+	);
+	if (!call_user_func_array(array($stmt, 'bind_param'), $params))
+		printf("[047] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[048] [%d] (Message might vary with MySQL Server version, e.g. No data supplied for parameters in prepared statement)\n", mysqli_stmt_errno($stmt));
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[049] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test WHERE id = ?'))
+		printf("[050] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$types = 'i';
+	$id = 1;
+	$params = array(
+		0 => $stmt,
+		1 => 'i',
+		2 => &$id
+	);
+	if (!call_user_func_array('mysqli_stmt_bind_param', $params))
+		printf("[051] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[052] [%d] (Message might vary with MySQL Server version, e.g. No data supplied for parameters in prepared statement)\n", mysqli_stmt_errno($stmt));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Regular, procedural, using variables
+int(1)
+%unicode|string%(1) "a"
+Call user func, procedural, using references for everything
+int(1)
+%unicode|string%(1) "a"
+Call user func, object oriented, using references for everything
+int(1)
+%unicode|string%(1) "a"
+Call user func, object oriented, using variable for types. using references for bound parameter
+int(1)
+%unicode|string%(1) "a"
+Call user func, object oriented, using constant for types. using references for bound parameter
+int(1)
+%unicode|string%(1) "a"
+Call user func, procedural, using references for everything but using variable for types
+int(1)
+%unicode|string%(1) "a"
+Call user func, procedural, using references for bound parameter, using variables for resource and types
+int(1)
+%unicode|string%(1) "a"
+Call user func, procedural, using references for bound parameter, using variables for resource and types
+int(1)
+%unicode|string%(1) "a"
+Call user func, procedural, using references for bound parameter, using variable for resource, using constant for types
+int(1)
+%unicode|string%(1) "a"
+Call user func, procedural, using references for bound parameter, using variable for resource, using constant for types, array
+int(1)
+%unicode|string%(1) "a"
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_param_check_param_no_change.phpt
@@ -0,0 +1,110 @@
+--TEST--
+mysqli_stmt_bind_param() - checking whether the parameters are modified (bug#44390)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+	$link->set_charset('latin1');
+
+	class foo {
+	  // @var $bar string
+	  public $bar;
+	}
+
+	$foo = new foo;
+	$foo->bar = "";
+
+	echo "Test 1:\n";
+	$stmt = $link->prepare("SELECT ? FOO");
+	var_dump($foo); // here you can see the bar member var beeing a string
+	$stmt->bind_param("s", $foo->bar);
+	var_dump($foo); // this will show $foo->bar beeing a reference string
+	$stmt->bind_result($one);
+	$stmt->execute();
+	$stmt->fetch();
+	$stmt->free_result();
+	echo("$one\n\n");
+
+	// it is getting worse. Binding the same var twice with different
+	// types you can get unexpected results (e.g. binary trash for the
+	// string and misc data for the integer. See next 2 tests.
+
+	echo "Test 2:\n";
+	$stmt = $link->prepare("SELECT ? FOO, ? BAR");
+	var_dump($foo);
+	$stmt->bind_param("si", $foo->bar, $foo->bar);
+	echo "---\n";
+	var_dump($foo);
+	echo "---\n";
+	$stmt->execute();
+	var_dump($foo);
+	echo "---\n";
+	$stmt->bind_result($one, $two);
+	$stmt->fetch();
+	$stmt->free_result();
+	echo("$one - $two\n\n");
+
+
+	echo "Test 3:\n";
+	$stmt = $link->prepare("SELECT ? FOO, ? BAR");
+	var_dump($foo);
+	$stmt->bind_param("is", $foo->bar, $foo->bar);
+	var_dump($foo);
+	$stmt->bind_result($one, $two);
+	$stmt->execute();
+	$stmt->fetch();
+	$stmt->free_result();
+	echo("$one - $two\n\n");
+	echo "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Test 1:
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  %unicode|string%(%d) ""
+}
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  &%unicode|string%(%d) ""
+}
+
+
+Test 2:
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  %unicode|string%(%d) ""
+}
+---
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  &%unicode|string%(%d) ""
+}
+---
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  &%unicode|string%(%d) ""
+}
+---
+ - 0
+
+Test 3:
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  %unicode|string%(%d) ""
+}
+object(foo)#%d (1) {
+  [%u|b%"bar"]=>
+  &%unicode|string%(%d) ""
+}
+0 - 
+
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_param_many_columns.phpt
@@ -0,0 +1,103 @@
+--TEST--
+mysqli_stmt_bind_param() - Binding with very high number of columns
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+memory_limit=256M
+--FILE--
+<?php
+	/*
+	The way we test the INSERT and data types overlaps with
+	the mysqli_stmt_bind_result test in large parts. There is only
+	one difference. This test uses mysqli_query()/mysqli_fetch_assoc() to
+	fetch the inserted values. This way we test
+	mysqli_query()/mysqli_fetch_assoc() for all possible data types
+	in this file and we test mysqli_stmt_bind_result() in the other
+	test -- therefore the "duplicate" makes some sense to me.
+	*/
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+
+	$cols = 2500;
+
+	list($old_max_allowed_packet) = $link->query("SELECT @@max_allowed_packet")->fetch_row();
+	if (!$link->query("SET GLOBAL max_allowed_packet=(2<<29)")) {
+		if (1227 == mysqli_errno($link)) {
+			/* [1227] Access denied; you need the SUPER privilege for this operation */
+			$cols = 10;
+		} else {
+			$cols = 10;
+			printf("[002] Failed to set max_allowed_packet the test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		}
+	}
+	mysqli_close($link);
+
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+
+	if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+		printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		exit(1);
+	}
+
+	$str = array();
+	for ($i = 1; $i <= $cols; $i++) {
+		$str[] ="a$i BLOB";
+	}
+	$link->query("CREATE TABLE test(" . implode(" , ", $str) . ") ENGINE=MyISAM");
+	if (mysqli_errno($link)) {
+		printf("Failed to create the test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+		die("");
+	}
+	$stmt = $link->prepare("INSERT INTO test VALUES(".str_repeat("?, ", $cols-1) . "?)");
+	var_dump($stmt->id);
+	$s = str_repeat("a", 2 << 12);
+	$eval_str="\$stmt->bind_param(\"".str_repeat("s",$cols)."\", ";
+	for ($i = 1; $i < $cols; $i++) {
+		$eval_str.="\$s,";
+	}
+	$eval_str.="\$s";
+	$eval_str.=");";
+	eval($eval_str);
+	printf("executing\n");
+	if (!$stmt->execute()) {
+		printf("failed");
+		printf("Failed to execute: [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	} else {
+		var_dump(true);
+	}
+
+	mysqli_stmt_close($stmt);
+
+
+	if (!$link->query("SET GLOBAL max_allowed_packet=$old_max_allowed_packet")) {
+		if (1227 != mysqli_errno($link))
+			printf("Failed to set max_allowed_packet the test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+int(1)
+executing
+bool(true)
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_param_references.phpt
@@ -0,0 +1,207 @@
+--TEST--
+mysqli_stmt_bind_param() - playing with references
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	function findRow($offset, $link, $id, $label) {
+
+		$sql = sprintf("SELECT id, label FROM test WHERE id = '%d' AND label = '%s'",
+				$id, $label);
+		if (!$res = mysqli_query($link, $sql)) {
+			printf("[%03d + 1] %s failed, [%d] %s\n",
+				$offset, $sql, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+		if (!$row = mysqli_fetch_assoc($res)) {
+			printf("[%03d + 2] fetch for %s failed, [%d] %s\n",
+				$offset, $sql, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		mysqli_free_result($res);
+		if ($row['id'] != $id) {
+			printf("[%03d + 3] Expecting %s/%s got %s/%s\n",
+				$offset, gettype($id), $id,
+				gettype($row['id']), $row['id']
+				);
+			return false;
+		}
+
+		if ($row['label'] != $label) {
+			printf("[%03d + 4] Expecting %s/%s got %s/%s\n",
+				$offset, gettype($label), $label,
+				gettype($row['label']), $row['label']
+				);
+			return false;
+		}
+
+		$sql = sprintf("DELETE FROM test WHERE id = '%d' AND label = '%s'",
+				$id, $label);
+		if (!mysqli_query($link, $sql)) {
+			printf("[%03d + 5] %s failed, [%d] %s\n",
+				$offset, $sql, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		return true;
+	}
+	// or we will get dups around [28]
+	mysqli_query($link, "ALTER TABLE test DROP PRIMARY KEY");
+
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[001] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 100;
+	$label = 'v';
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[002] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	// no need to check the return value, will bail and make EXPECTF fail if need be
+	findRow(4, $link, $id, $label);
+
+	$id++;
+	$label_ref = &$label;
+	$label = 'w';
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label_ref)))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(7, $link, $id, $label_ref);
+
+	$id++;
+	$label_ref_ref = &$label_ref;
+	$label = 'x';
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label_ref_ref)))
+		printf("[007] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(9, $link, $id, $label_ref_ref);
+
+	$id = 9;
+	$label = $id;
+	$label_num = &$label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label_num)))
+		printf("[010] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(12, $link, $id, $label_num);
+
+	$label_num = &$id;
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label_num)))
+		printf("[013] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(15, $link, $id, $label_num);
+
+	$label = 9;
+	$id = &$label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[015] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(17, $link, $id, $label);
+
+	$base = 9;
+	$id = &$base;
+	$label = &$id;
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[018] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[019] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(20, $link, $id, $label);
+
+	$id_ref = &$id;
+	$label_ref = &$label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id_ref, $label_ref)))
+		printf("[021] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[022] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(23, $link, $id_ref, $label_ref);
+
+	$id_ref_ref = &$GLOBALS['id_ref'];
+	$label_ref_ref = &$GLOBALS['label_ref_ref'];
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id_ref_ref, $label_ref_ref)))
+		printf("[024] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[025] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(26, $link, $id_ref_ref, $label_ref_ref);
+
+	unset($id);
+	unset($label);
+	$id = 102;
+	$label = new stdClass();
+	$label->label = 'y';
+	$id_ref = &$GLOBALS['id'];
+	$label_ref = &$label->label;
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id_ref, $label_ref)))
+		printf("[027] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+	if (true !== @mysqli_stmt_execute($stmt))
+		printf("[028] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(29, $link, $id_ref, $label_ref);
+
+	$id = 103;
+	$label_a = &$label_b;
+	$label_b = &$label_a;
+	$label_a = 'z';
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label_b)))
+		printf("[030] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[031] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(32, $link, $id, $label_b);
+
+	class foo {
+		public $foo;
+		function foo() {
+			$this->foo = &$this->bar;
+		}
+	}
+	class bar extends foo {
+		public $bar = 'v';
+	}
+	$bar = new bar();
+	$id++;
+	$label = &$GLOBALS['bar']->foo;
+
+	if (true !== ($tmp = mysqli_stmt_bind_param($stmt, "is", $id, $label)))
+		printf("[033] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[034] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	findRow(35, $link, $id, $label);
+
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_param_type_juggling.phpt
@@ -0,0 +1,127 @@
+--TEST--
+mysqli_stmt_bind_param() - binding variable twice
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	function bind_twice($link, $engine, $sql_type1, $sql_type2, $bind_type1, $bind_type2, $bind_value1, $bind_value2, $offset) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%03d + 1] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+		mysqli_autocommit($link, true);
+
+		$sql = sprintf("CREATE TABLE test(col1 %s, col2 %s) ENGINE=%s", $sql_type1, $sql_type2, $engine);
+		if (!mysqli_query($link, $sql)) {
+			printf("[%03d + 2] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%03d + 3] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(col1, col2) VALUES (?, ?)")) {
+			printf("[%03d + 4] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_bind_param($stmt, $bind_type1 . $bind_type2, $bind_value1, $bind_value1)) {
+			printf("[%03d + 5] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d + 6] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_bind_param($stmt, $bind_type1 . $bind_type2, $bind_value1, $bind_value2)) {
+			printf("[%03d + 7] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d + 8] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		mysqli_stmt_close($stmt);
+		if (!$res = mysqli_query($link, "SELECT col1, col2 FROM test")) {
+			printf("[%03d + 9] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (2 !== ($tmp = mysqli_num_rows($res))) {
+			printf("[%03d + 10] Expecting 2 rows, got %d rows [%d] %s\n", $offset, $tmp, mysqli_errno($link), mysqli_error($link));
+		}
+
+		$row = mysqli_fetch_assoc($res);
+		if (($row['col1'] != $bind_value1) || ($row['col2'] != $bind_value1)) {
+			printf("[%03d + 11] Expecting col1 = %s, col2 = %s got col1 = %s, col2 = %s - [%d] %s\n",
+				$offset, $bind_value1, $bind_value1,
+				$row['col1'], $row['col2'],
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		$row = mysqli_fetch_assoc($res);
+		if (($row['col1'] != $bind_value1) || ($row['col2'] != $bind_value2)) {
+			printf("[%03d + 12] Expecting col1 = %s, col2 = %s got col1 = %s, col2 = %s - [%d] %s\n",
+				$offset, $bind_value1, $bind_value2,
+				$row['col1'], $row['col2'],
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+		mysqli_free_result($res);
+		return true;
+	}
+
+	bind_twice($link, $engine, 'CHAR(1)', 'CHAR(1)', 's', 's', 'a', 'b', 10);
+	bind_twice($link, $engine, 'INT', 'INT', 'i', 'i', 1, 2, 20);
+	bind_twice($link, $engine, 'FLOAT', 'FLOAT', 'd', 'd', 1.01, 1.02, 30);
+
+	/* type juggling - note that int->char works */
+	bind_twice($link, $engine, 'CHAR(1)', 'CHAR(1)', 's', 's', 1, 2, 40);
+	/* type juggling - note that string->integer works */
+	bind_twice($link, $engine, 'INT', 'INT', 'i', 'i', '1', '2', 50);
+	/* type juggling - note that string->float works*/
+	bind_twice($link, $engine, 'FLOAT', 'FLOAT', 'd', 'd', '1.01', '1.02', 60);
+
+	/* now, let's have two columns of different type and do type juggling */
+	/*
+	what the test will do is:
+		1) col1 INT, col2 CHAR(1)
+    2) bind_param('is', 1, 1)
+    3) execute()
+		4) bind_param('is', 1, 'a')
+		5) execute()
+
+		col1 INT, col2 INT
+    bind_param('ii', '1', '2')	--> OK  (int column, string value)
+		bind_param('ii', 1, 2) 			--> OK  (int column, int value)
+    col1 CHAR(1), col2 CHAR(2)
+    bind_param('ss', 1, 2)  		--> OK (string column, int value)
+
+		So, what about:
+		col1 INT, COL2 CHAR(1)
+		bind_param('is', 1, 1)     ---> ??
+	*/
+	bind_twice($link, $engine, 'INT', 'CHAR(1)', 'i', 's', 1, 'a', 70);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_result.phpt
@@ -0,0 +1,331 @@
+--TEST--
+mysqli_stmt_bind_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$hint_str_or_unicode = (version_compare(PHP_VERSION, '5.9.9', '>') == 1) ? "unicode":"string";
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_bind_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_bind_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 1"))
+		printf("[002a] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_null($tmp = @mysqli_stmt_bind_result($stmt)))
+		printf("[002b] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	$stmt = mysqli_stmt_init($link);
+
+	$id = null;
+	$label = null;
+	$foo = null;
+
+	if (!is_null($tmp = mysqli_stmt_bind_result($stmt)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 1"))
+		printf("[004] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = mysqli_stmt_bind_result($stmt, $id)))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label, $foo)))
+		printf("[007] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	while (mysqli_stmt_fetch($stmt)) {
+		var_dump($id);
+		var_dump($label);
+	}
+	mysqli_stmt_close($stmt);
+
+
+	function func_mysqli_stmt_bind_result($link, $engine, $bind_type, $sql_type, $bind_value, $offset, $type_hint = null) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+			// don't bail - column type might not be supported by the server, ignore this
+			return false;
+		}
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%04d] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)")) {
+			printf("[%04d] [%d] %s\n", $offset + 2, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		$id = null;
+		if (!mysqli_stmt_bind_param($stmt, "i" . $bind_type, $id, $bind_value)) {
+			printf("[%04d] [%d] %s\n", $offset + 3, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		for ($id = 1; $id < 4; $id++) {
+			if (!mysqli_stmt_execute($stmt)) {
+				printf("[%04d] [%d] %s\n", $offset + 3 + $id, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				mysqli_stmt_close($stmt);
+				return false;
+			}
+		}
+		mysqli_stmt_close($stmt);
+
+		$stmt = mysqli_stmt_init($link);
+
+		if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 7, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%04d] [%d] %s\n", $offset + 8, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		$result = mysqli_stmt_result_metadata($stmt);
+
+		$bind_res = null;
+		if (!mysqli_stmt_bind_result($stmt, $id, $bind_res)) {
+			printf("[%04d] [%d] %s\n", $offset + 9, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+		$num = 0;
+		$fields = mysqli_fetch_fields($result);
+
+		while (mysqli_stmt_fetch($stmt)) {
+			if (!gettype($bind_res)=="unicode") {
+				if ($bind_res !== $bind_value && (!$type_hint || ($type_hint !== gettype($bind_res)))) {
+					printf("[%04d] [%d] Expecting %s/'%s' [type hint = %s], got %s/'%s'\n",
+						$offset + 10, $num,
+						gettype($bind_value), $bind_value, $type_hint,
+						gettype($bind_res), $bind_res);
+						mysqli_stmt_close($stmt);
+						return false;
+				}
+			}
+			$num++;
+		}
+
+		if ($num != 3) {
+			printf("[%04d] [%d] %s, expecting 3 results, got only %d results\n",
+				$offset + 11, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), $num);
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		mysqli_stmt_close($stmt);
+		return true;
+	}
+
+
+	function func_mysqli_stmt_bind_make_string($len) {
+
+		$ret = '';
+		for ($i = 0; $i < $len; $i++)
+			$ret .= chr(mt_rand(65, 90));
+
+		return $ret;
+	}
+
+	func_mysqli_stmt_bind_result($link, $engine, "i", "TINYINT", -11, 20);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "TINYINT", NULL, 40);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "TINYINT UNSIGNED", 1, 60);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "TINYINT UNSIGNED", NULL, 80);
+
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BOOL", 1, 100);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BOOL", NULL, 120);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BOOLEAN", 0, 140);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BOOLEAN", NULL, 160);
+
+	func_mysqli_stmt_bind_result($link, $engine, "i", "SMALLINT", -32768, 180);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "SMALLINT", 32767, 200);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "SMALLINT", NULL, 220);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "SMALLINT UNSIGNED", 65535, 240);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "SMALLINT UNSIGNED", NULL, 260);
+
+	func_mysqli_stmt_bind_result($link, $engine, "d", "MEDIUMINT", -8388608, 280, "integer");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "MEDIUMINT", 8388607, 300, "integer");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "MEDIUMINT", NULL, 320);
+	func_mysqli_stmt_bind_result($link, $engine, "d", "MEDIUMINT UNSIGNED", 16777215, 340, "integer");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "MEDIUMINT UNSIGNED", NULL, 360);
+
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER", (defined("PHP_INT_MAX")) ? max(-1 * PHP_INT_MAX + 1, -2147483648) : 1, 380);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER", -2147483647, 400, "integer");
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER", (defined("PHP_INT_MAX")) ? min(2147483647, PHP_INT_MAX) : 1, 420);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER", NULL, 440);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER UNSIGNED", (defined("PHP_INT_MAX")) ? min(4294967295, 2147483647) : 1, 460);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER UNSIGNED", 4294967295, 480, (defined("PHP_INT_MAX") && (4294967295 > PHP_INT_MAX)) ? "string" : null);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "INTEGER UNSIGNED", NULL, 500);
+
+	/* test is broken too: we bind "integer" but value is a float
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT", -9223372036854775808, 520);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT UNSIGNED", 18446744073709551615, 560);
+	*/
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT", NULL, 540);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT UNSIGNED", NULL, 580);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT", -1, 1780);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT UNSIGNED", 1, 1800);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT", -1 * PHP_INT_MAX + 1, 1820);
+	func_mysqli_stmt_bind_result($link, $engine, "i", "BIGINT UNSIGNED", PHP_INT_MAX, 1840);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "BIGINT UNSIGNED", "18446744073709551615", 1860);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "BIGINT", "-9223372036854775808", 1880);
+
+	func_mysqli_stmt_bind_result($link, $engine, "d", "FLOAT", -9223372036854775808 - 1.1, 600);
+	func_mysqli_stmt_bind_result($link, $engine, "d", "FLOAT", NULL, 620);
+	func_mysqli_stmt_bind_result($link, $engine, "d", "FLOAT UNSIGNED", 18446744073709551615 + 1.1, 640);
+	func_mysqli_stmt_bind_result($link, $engine, "d", "FLOAT UNSIGNED ", NULL, 660);
+
+	// Yes, we need the temporary variable. The PHP casting will fouls us otherwise.
+	$tmp = strval('-99999999.99');
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DOUBLE(10,2)", $tmp, 680, "string");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DOUBLE(10,2)", NULL, 700);
+	$tmp = strval('99999999.99');
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", $tmp , 720, "string");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", NULL, 740);
+	$tmp = strval('-99999999.99');
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DECIMAL(10,2)", $tmp, 760, "string");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DECIMAL(10,2)", NULL, 780);
+	$tmp = strval('99999999.99');
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DECIMAL(10,2)", $tmp, 800, "string");
+	func_mysqli_stmt_bind_result($link, $engine, "d", "DECIMAL(10,2)", NULL, 820);
+
+	// don't care about date() strict TZ warnings...
+	func_mysqli_stmt_bind_result($link, $engine, "s", "DATE", @date('Y-m-d'), 840);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "DATE NOT NULL", @date('Y-m-d'), 860);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "DATE", NULL, 880);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "DATETIME", @date('Y-m-d H:i:s'), 900);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "DATETIME NOT NULL", @date('Y-m-d H:i:s'), 920);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "DATETIME", NULL, 940);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TIMESTAMP", @date('Y-m-d H:i:s'), 960);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TIME", @date('H:i:s'), 980);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TIME NOT NULL", @date('H:i:s'), 1000);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TIME", NULL, 1020);
+
+	$tmp = intval(@date('Y'));
+	func_mysqli_stmt_bind_result($link, $engine, "s", "YEAR", $tmp, 1040, "integer");
+	func_mysqli_stmt_bind_result($link, $engine, "s", "YEAR NOT NULL", $tmp, 1060, "integer");
+	func_mysqli_stmt_bind_result($link, $engine, "s", "YEAR", NULL, 1080);
+
+	$string255 = func_mysqli_stmt_bind_make_string(255);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "CHAR(1)", "a", 1110, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "CHAR(255)", $string255, 1120, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "CHAR(1) NOT NULL", "a", 1140, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "CHAR(1)", NULL, 1160);
+
+	$string65k = func_mysqli_stmt_bind_make_string(65535);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARCHAR(1)", "a", 1180, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARCHAR(255)", $string255, 1200, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARCHAR(65635)", $string65k, 1220, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARCHAR(1) NOT NULL", "a", 1240, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARCHAR(1)", NULL, 1260);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "BINARY(1)", "a", 1280);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "BINARY(1)", chr(0), 1300);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "BINARY(1) NOT NULL", "b", 1320);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "BINARY(1)", NULL, 1340);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARBINARY(1)", "a", 1360);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARBINARY(1)", chr(0), 1380);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARBINARY(1) NOT NULL", "b", 1400);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "VARBINARY(1)", NULL, 1420);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYBLOB", "a", 1440);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYBLOB", chr(0), 1460);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYBLOB NOT NULL", "b", 1480);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYBLOB", NULL, 1500);
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYTEXT", "a", 1520, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYTEXT NOT NULL", "a", 1540, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "TINYTEXT", NULL, 1560, $hint_str_or_unicode);
+
+	// Note: you cannot insert any blob values this way. But you can check the API at least partly this way
+	// Extra BLOB tests are in mysqli_stmt_send_long()
+	func_mysqli_stmt_bind_result($link, $engine, "b", "BLOB", b"", 1580);
+	func_mysqli_stmt_bind_result($link, $engine, "b", "TEXT", "", 1600, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "b", "MEDIUMBLOB", b"", 1620);
+	func_mysqli_stmt_bind_result($link, $engine, "b", "MEDIUMTEXT", "", 1640, $hint_str_or_unicode);
+
+	/* Is this one related? http://bugs.php.net/bug.php?id=35759 */
+	if (($IS_MYSQLND) || (!$IS_MYSQLND && (ini_get('memory_limit') > 4294967296))) {
+		/* NOTE: the MySQL Client Library - not mysqlnd - will allocate
+		a hugge max_length(type) = 4GB bind buffer */
+		func_mysqli_stmt_bind_result($link, $engine, "b", "LONGBLOB", "", 1660);
+		func_mysqli_stmt_bind_result($link, $engine, "b", "LONGTEXT", "", 1680, $hint_str_or_unicode);
+	}
+
+	func_mysqli_stmt_bind_result($link, $engine, "s", "ENUM('a', 'b')", "a", 1700, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "ENUM('a', 'b')", NULL, 1720, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "SET('a', 'b')", "a", 1740, $hint_str_or_unicode);
+	func_mysqli_stmt_bind_result($link, $engine, "s", "SET('a', 'b')", NULL, 1760, $hint_str_or_unicode);
+
+	if (mysqli_get_server_version($link) >= 50600)
+		func_mysqli_stmt_bind_result($link, $engine, "s", "TIME", "13:31:34.123456", 1770, "13:31:34");
+
+	/* Check that the function alias exists. It's a deprecated function,
+	but we have not announce the removal so far, therefore we need to check for it */
+	if (!is_null($tmp = @mysqli_stmt_bind_result()))
+		printf("[3000] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (1000, 'z')"))
+		printf("[3001] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	if (false !== @mysqli_stmt_bind_result($stmt, $id))
+		printf("[3002] Bind result should not be allowed");
+
+	mysqli_stmt_close($stmt);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_bind_result(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_bind_result(): Number of bind variables doesn't match number of fields in prepared statement in %s on line %d
+
+Warning: mysqli_stmt_bind_result(): Number of bind variables doesn't match number of fields in prepared statement in %s on line %d
+int(1)
+%s(1) "a"
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_result_bit.phpt
@@ -0,0 +1,159 @@
+--TEST--
+mysqli_stmt_bind_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	function dec32bin($dec, $bits) {
+
+		$maxval = pow(2, $bits);
+		$bin = '';
+		for ($bitval = $maxval; $bitval >= 1; $bitval = $bitval / 2) {
+			if (($dec / $bitval) >= 1) {
+				$bin .= '1';
+				$dec -= $bitval;
+			} else {
+				$bin .= '0';
+			}
+		}
+		return $bin;
+	}
+
+	if (!$link_ins = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$link_sel = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[002] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	for ($bits = 1; $bits <= 46; $bits++) {
+
+		if (1 == $bits)
+			$max_value = 1;
+		else
+			$max_value = pow(2, $bits) - 1;
+
+		if (!mysqli_query($link_ins, "DROP TABLE IF EXISTS test")) {
+			printf("[003 - %d] [%d] %s\n", $bits, mysqli_errno($link_ins), mysqli_error($link_ins));
+		}
+
+		if (!mysqli_query($link_ins, sprintf("CREATE TABLE test(id BIGINT, bit_value BIT(%d) NOT NULL, bit_null BIT(%d) DEFAULT NULL) ENGINE = %s", $bits, $bits, $engine))) {
+			// don't bail - column type might not be supported by the server, ignore this
+			continue;
+		}
+		if (!$stmt_ins = mysqli_stmt_init($link_ins)) {
+			printf("[004 - %d] [%d] %s\n", $bits, mysqli_errno($link_ins), mysqli_error($link_ins));
+			continue;
+		}
+
+		if (!mysqli_stmt_prepare($stmt_ins, "INSERT INTO test(id, bit_value) VALUES (?, ?)")) {
+			printf("[005 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt_ins), mysqli_stmt_error($stmt_ins));
+			mysqli_stmt_close($stmt_ins);
+			continue;
+		}
+
+		if (!($stmt_sel = mysqli_stmt_init($link_sel))) {
+			printf("[006 - %d] [%d] %s\n", $bits, mysqli_errno($link_sel), mysqli_error($link_sel));
+			mysqli_stmt_close($stmt_ins);
+				continue;
+		}
+
+		$tests = 0;
+		$rand_max = mt_getrandmax();
+		while ($tests < 10) {
+
+			$tests++;
+			if (1 == $tests)
+				$value = 0;
+			else if (2 == $tests)
+				$value = $max_value;
+			else {
+				if ($max_value > $rand_max) {
+					$max_loops = floor($max_value/$rand_max);
+					$num_loops = mt_rand(1, $max_loops);
+					$value = 0;
+					for ($i = 0; $i < $num_loops; $i++)
+						$value += mt_rand(0, $rand_max);
+				} else {
+					$value = mt_rand(0, $max_value);
+				}
+			}
+
+			$bin = ($bits < 32) ? decbin($value) : dec32bin($value, $bits);
+			for ($i = 0; ($i < strlen($bin)) && ($bin[$i] == '0'); $i++)
+				;
+			$bin2 = substr($bin, $i, strlen($bin));
+
+			if (!mysqli_stmt_bind_param($stmt_ins, "dd", $value, $value)) {
+				printf("[007 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt_ins), mysqli_stmt_error($stmt_ins));
+				mysqli_stmt_close($stmt_ins);
+				continue;
+			}
+			if (!mysqli_stmt_execute($stmt_ins)) {
+				printf("[008 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt_ins), mysqli_stmt_error($stmt_ins));
+				break;
+			}
+			$sql = sprintf("SELECT id, BIN(bit_value) AS _bin, bit_value, bit_value + 0 AS _bit_value0, bit_null FROM test WHERE id = %s", $value);
+			if ((!mysqli_stmt_prepare($stmt_sel, $sql)) ||
+				(!mysqli_stmt_execute($stmt_sel))) {
+				printf("[009 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt_sel), mysqli_stmt_error($stmt_sel));
+				break;
+			}
+
+			$row = array('id' => -1, '_bin' => - 1, 'bit_value' => -1, '_bit_value0' => -1, 'bit_null' => -1);
+			if (!mysqli_stmt_bind_result($stmt_sel, $row['id'], $row['_bin'], $row['bit_value'], $row['_bit_value0'], $row['bit_null'])) {
+				printf("[010 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt_sel), mysqli_stmt_error($stmt_sel));
+				break;
+			}
+
+			if (!($ret = mysqli_stmt_fetch($stmt_sel))) {
+				printf("[011 - %d] mysqli_stmt_fetch() has failed for %d bits - ret = %s/%s, [%d] %s, [%d] %s\n",
+					$bits, $bits,
+					gettype($ret), $ret,
+					mysqli_stmt_errno($stmt_sel), mysqli_stmt_error($stmt_sel),
+					mysqli_errno($link_sel), mysqli_errno($link_sel)
+				);
+				break;
+			}
+
+			if (($value != $row['id']) || (($bin != $row['_bin']) && ($bin2 != $row['_bin']))) {
+				debug_zval_dump($row);
+				printf("[012 - %d] Insert of %s in BIT(%d) column might have failed. id = %s, bin = %s (%s/%s)\n",
+					$bits, $value, $bits, $row['id'], $row['_bin'], $bin, $bin2);
+				break;
+			}
+			if ($value != $row['bit_value']) {
+				debug_zval_dump($row);
+				printf("[013 - %d] Expecting %s got %s\n", $bits, $value, $row['bit_value']);
+				break;
+			}
+
+			if (null !== $row['bit_null']) {
+				debug_zval_dump($row);
+				printf("[014 - %d] Expecting null got %s/%s\n", $bits, gettype($row['bit_value']), $row['bit_value']);
+				break;
+			}
+
+		}
+
+		mysqli_stmt_close($stmt_ins);
+		mysqli_stmt_close($stmt_sel);
+	}
+
+	mysqli_close($link_ins);
+	mysqli_close($link_sel);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_result_format.phpt
@@ -0,0 +1,337 @@
+--TEST--
+Playing with SELECT FORMAT(...) AS _format - see also bugs.php.net/42378
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--INI--
+memory_limit=83886080
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	function create_table($link, $column, $min, $max, $engine, $offset) {
+
+		if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+			printf("[%03d] Cannot drop table test, [%d] %s\n",
+				$offset,
+				mysqli_errno($link), mysqli_error($link));
+			return array();
+		}
+
+		$sql = sprintf("CREATE TABLE test(id INT AUTO_INCREMENT PRIMARY KEY, col1 %s) ENGINE=%s",
+			$column, $engine);
+		if (!mysqli_query($link, $sql)) {
+			printf("[%03d] Cannot create table test, [%d] %s\n",
+				$offset + 1,
+				mysqli_errno($link), mysqli_error($link));
+			return array();
+		}
+
+		$values = array();
+		for ($i = 1; $i <= 100; $i++) {
+			$col1 = mt_rand($min, $max);
+			$values[$i] = $col1;
+			$sql = sprintf("INSERT INTO test(id, col1) VALUES (%d, %f)",
+				$i, $col1);
+			if (!mysqli_query($link, $sql)) {
+				printf("[%03d] Cannot insert data, [%d] %s\n",
+					$offset + 2,
+					mysqli_errno($link), mysqli_error($link));
+				return array();
+			}
+		}
+
+		return $values;
+	}
+
+	function test_format($link, $format, $from, $order_by, $expected, $offset) {
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%03d] Cannot create PS, [%d] %s\n",
+				$offset,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if ($order_by)
+			$sql = sprintf('SELECT %s AS _format FROM %s ORDER BY %s', $format, $from, $order_by);
+		else
+			$sql = sprintf('SELECT %s AS _format FROM %s', $format, $from);
+
+		if (!mysqli_stmt_prepare($stmt, $sql)) {
+			printf("[%03d] Cannot prepare PS, [%d] %s\n",
+				$offset + 1,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d] Cannot execute PS, [%d] %s\n",
+				$offset + 2,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_store_result($stmt)) {
+			printf("[%03d] Cannot store result set, [%d] %s\n",
+				$offset + 3,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!is_array($expected)) {
+
+			$result = null;
+			if (!mysqli_stmt_bind_result($stmt, $result)) {
+				printf("[%03d] Cannot bind result, [%d] %s\n",
+					$offset + 4,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			if (!mysqli_stmt_fetch($stmt)) {
+				printf("[%03d] Cannot fetch result,, [%d] %s\n",
+					$offset + 5,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			if ($result !== $expected) {
+				printf("[%03d] Expecting %s/%s got %s/%s with %s - %s.\n",
+					$offset + 6,
+					gettype($expected), $expected,
+					gettype($result), $result,
+					$format, $sql);
+			}
+
+		} else {
+
+			$order_by_col = $result = null;
+			if (!mysqli_stmt_bind_result($stmt, $order_by_col, $result)) {
+				printf("[%03d] Cannot bind result, [%d] %s\n",
+					$offset + 7,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			reset($expected);
+			while ((list($k, $v) = each($expected)) && mysqli_stmt_fetch($stmt)) {
+				if ($result !== $v) {
+					printf("[%03d] Row %d - expecting %s/%s got %s/%s [%s] with %s - %s.\n",
+						$offset + 8,
+						$k,
+						gettype($v), $v,
+						gettype($result), $result,
+						$order_by_col,
+						$format, $sql);
+				}
+			}
+
+		}
+
+		mysqli_stmt_free_result($stmt);
+		mysqli_stmt_close($stmt);
+
+		return true;
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect - [%d] %s\n",
+			mysqli_connect_errno(),
+			mysqli_connect_error());
+
+	/* select from dual - pseudo table */
+	test_format($link, 'FORMAT(1.01, 0)', 'DUAL', null, '1', 10);
+	test_format($link, 'FORMAT(1.23, 1)', 'DUAL', null, '1.2', 20);
+	test_format($link, 'FORMAT(1.23, 2)', 'DUAL', null, '1.23', 30);
+	test_format($link, 'FORMAT(1234.567, 3)', 'DUAL', null, '1,234.567', 40);
+	/* no typo! */
+	test_format($link, 'FORMAT(1234.567, 4)', 'DUAL', null, '1,234.5670', 50);
+
+	mysqli_close($link);
+	require_once('table.inc');
+
+	/* select from existing table */
+	test_format($link, 'FORMAT(id, 0)', 'test', null, '1', 60);
+	test_format($link, 'FORMAT(id + 0.1, 1)', 'test', null, '1.1', 70);
+	test_format($link, 'FORMAT(id + 0.01, 2)', 'test', null, '1.01', 80);
+
+	/* create new table and select from it */
+	$expected = create_table($link, 'FLOAT', -10000, 10000, $engine, 90);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 100);
+
+	$expected = create_table($link, 'FLOAT UNSIGNED', 0, 10000, $engine, 110);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 120);
+
+	$expected = create_table($link, 'TINYINT', -128, 127, $engine, 130);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 140);
+
+	$expected = create_table($link, 'SMALLINT UNSIGNED', 0, 65535, $engine, 150);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 160);
+
+	$expected = create_table($link, 'MEDIUMINT', 0, 8388607, $engine, 170);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 180);
+
+	$expected = create_table($link, 'INT UNSIGNED', 0, 1000, $engine, 190);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 200);
+
+	$expected = create_table($link, 'BIGINT', -1000, 1000, $engine, 210);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 220);
+
+	$expected = create_table($link, 'DECIMAL(5,0)', -1000, 1000, $engine, 230);
+	foreach ($expected as $k => $v)
+		$expected[$k] = number_format(round($v), 0, '.', ',');
+	test_format($link, 'id AS order_by_col, FORMAT(col1, 0)', 'test', 'id', $expected, 240);
+
+	// http://bugs.php.net/bug.php?id=42378
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+		printf("[300] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (mysqli_query($link, "CREATE TABLE `test` (
+  `targetport` int(11) NOT NULL default '0',
+  `sources` double(17,4) default NULL,
+  `current_sources` double(17,0) default NULL,
+  `reports` double(17,4) default NULL,
+  `current_reports` double(17,0) default NULL,
+  `targets` double(17,4) default NULL,
+  `current_targets` double(17,0) default NULL,
+  `maxsources` int(11) default NULL,
+  `maxtargets` int(11) default NULL,
+  `maxreports` int(11) default NULL,
+  `trend` float default NULL,
+  PRIMARY KEY  (`targetport`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1")) {
+
+		do {
+			$values = array();
+			for ($i = 0; $i < 200; $i++) {
+				$current_targets = mt_rand(-100000, 100000) / 10;
+				do {
+					$trend = (mt_rand(0, 3) > 1) ? (mt_rand(-10000, 10000) / 100) : 'NULL';
+				} while (isset($values[$trend]));
+
+				$sql = sprintf('INSERT INTO test(targetport, current_targets, maxreports, trend) VALUES (%d, %f, %s, %s)',
+					$i,
+					$current_targets,
+					(mt_rand(0, 1) > 0) ? mt_rand(0, 1000) : 'NULL',
+					$trend);
+				if (!mysqli_query($link, $sql)) {
+					printf("[301] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+					break 2;
+				}
+				if ($current_targets > 0 && $trend != 'NULL')
+					$values[$trend] = $i;
+			}
+			krsort($values);
+
+			if (!$stmt = mysqli_stmt_init($link)) {
+				printf("[302] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+
+			if (!mysqli_stmt_prepare($stmt, 'SELECT trend, targetport, FORMAT(trend, 2) FROM test WHERE current_targets > 0 AND trend IS NOT NULL ORDER BY trend DESC LIMIT 100')) {
+				printf("[303] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			if (!mysqli_stmt_execute($stmt)) {
+				printf("[304] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			if (!mysqli_stmt_store_result($stmt)) {
+				printf("[305] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			$trend = $targetport = $format = null;
+			if (!mysqli_stmt_bind_result($stmt, $trend, $targetport, $format)) {
+
+				printf("[305] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			reset($values);
+			while (mysqli_stmt_fetch($stmt)) {
+				list($exp_trend, $exp_targetport) = each($values);
+				if ($targetport != $exp_targetport) {
+					printf("[306] Values fetched from MySQL seem to be wrong, check manually\n");
+					printf("%s/%s - %s/%s - '%s'\n", $trend, $exp_trend, $targetport, $exp_targetport, $format);
+				}
+			}
+			mysqli_stmt_free_result($stmt);
+			mysqli_stmt_close($stmt);
+
+			// same but OO interface
+			if (!$stmt = mysqli_stmt_init($link)) {
+				printf("[307] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+				break;
+			}
+
+			if (!$stmt->prepare('SELECT trend, targetport, FORMAT(trend, 2) FROM test WHERE current_targets > 0 AND trend IS NOT NULL ORDER BY trend DESC LIMIT 100')) {
+				printf("[308] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			if (!$stmt->execute()) {
+				printf("[309] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			if (!$stmt->store_result()) {
+				printf("[310] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			$trend = $targetport = $format = null;
+			if (!$stmt->bind_result($trend, $targetport, $format)) {
+
+				printf("[311] [%d] %s\n", mysqli_stmt_errno($link), mysqli_stmt_error($link));
+				break;
+			}
+
+			reset($values);
+			while ($stmt->fetch()) {
+				list($exp_trend, $exp_targetport) = each($values);
+				if ($targetport != $exp_targetport) {
+					printf("[312] Values fetched from MySQL seem to be wrong, check manually\n");
+					printf("%s/%s - %s/%s - '%s'\n", $trend, $exp_trend, $targetport, $exp_targetport, $format);
+				}
+			}
+			$stmt->free_result();
+			$stmt->close();
+
+		} while (false);
+
+	} else {
+		var_dump(mysqli_error($link));
+	}
+
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_result_references.phpt
@@ -0,0 +1,314 @@
+--TEST--
+mysqli_stmt_bind_result() - playing with references
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 1"))
+		printf("[001] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 1"))
+		printf("[001] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+
+	print "plain vanilla...\n";
+	unset($id); unset($label);
+	$id = $label = null;
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[002] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+	var_dump($label);
+
+
+	print "reference, one level...\n";
+	unset($id); unset($id_ref); unset($label); unset($label_ref);
+	$id = null;
+	$id_ref = &$id;
+	$label = null;
+	$label_ref = &$label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id_ref, $label_ref)))
+		printf("[004] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	var_dump($id_ref);
+	var_dump($id);
+	var_dump($label_ref);
+	var_dump($label);
+
+
+	print "reference, two levels...\n";
+	unset($id); unset($id_ref); unset($id_ref_ref); unset($label); unset($label_ref); unset($label_ref_ref);
+	$id = null;
+	$id_ref = &$id;
+	$id_ref_ref = &$id_ref;
+	$label = null;
+	$label_ref = &$label;
+	$label_ref_ref = &$label_ref;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id_ref_ref, $label_ref_ref)))
+		printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	var_dump($id_ref_ref);
+	var_dump($id_ref);
+	var_dump($id);
+	var_dump($label_ref_ref);
+	var_dump($label_ref);
+	var_dump($label);
+
+	print "reference, \$GLOBALS...\n";
+	unset($id); unset($id_ref); unset($label); unset($label_ref);
+	$id = 100;
+	$id_ref = &$GLOBALS['id'];
+	$label = null;
+	$label_ref = &$GLOBALS['label'];
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id_ref, $label_ref)))
+		printf("[008] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	var_dump($id_ref);
+	var_dump($id);
+	var_dump($label_ref);
+	var_dump($label);
+
+	print "reference, same target...\n";
+	$id = null;
+	$label = &$id;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[010] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+	var_dump($label);
+
+	print "reference, simple object...\n";
+	unset($obj);
+	$obj = new stdClass();
+	$obj->id = null;
+	$obj->label = null;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $obj->id, $obj->label)))
+		printf("[012] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($obj->id);
+	var_dump($obj->label);
+
+
+	print "reference, simple object w reference...\n";
+	unset($id); unset($label); unset($obj);
+	$obj = new stdClass();
+	$obj->id = null;
+	$obj->label = null;
+	$id = &$obj->id;
+	$label = &$obj->label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[012] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($obj->id);
+	var_dump($obj->label);
+
+	print "reference, simple object w reference, change after bind...\n";
+	unset($id); unset($label); unset($obj);
+	$obj = new stdClass();
+	$obj->id = null;
+	$obj->label = null;
+	$id = &$obj->id;
+	$label = &$obj->label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[012] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$label = &$obj->id;
+	$id = null;
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($obj->id);
+	var_dump($id);
+	var_dump($obj->label);
+	var_dump($label);
+
+	print "reference, one level, change after bind...\n";
+	unset($id); unset($label); unset($id_ref); unset($label_ref);
+	$id = null;
+	$id_ref = &$id;
+	$label = null;
+	$label_ref = &$label;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id_ref, $label_ref)))
+		printf("[014] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$id_ref = 1;
+	$label_ref = 1;
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[015] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	var_dump($id_ref);
+	var_dump($id);
+	var_dump($label_ref);
+	var_dump($label);
+
+	print "reference, circle...\n";
+	unset($id); unset($label_a); unset($label_b);
+	$id = null;
+	$label_a = &$label_b;
+	$label_b = &$label_a;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label_a)))
+		printf("[016] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[017] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+	var_dump($label_a);
+	var_dump($label_b);
+
+	print "reference, object, forward declaration...\n";
+	unset($bar); unset($id); unset($label_ref);
+	class foo {
+		public $foo;
+		public function foo() {
+			$this->foo = &$this->bar;
+		}
+	}
+	class bar extends foo {
+		public $bar = null;
+	}
+	$bar = new bar();
+	$id = null;
+	$label_ref = &$bar->bar;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label_ref)))
+		printf("[018] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[019] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+	var_dump($bar);
+	var_dump($label_ref);
+
+	print "references, object, private...\n";
+	unset($bar); unset($id); unset($label);
+	class mega_bar extends bar {
+		private $id;
+		public $id_ref;
+		public function mega_bar() {
+			$this->foo();
+			$this->id_ref = &$this->id;
+		}
+	}
+	$bar = new mega_bar();
+	$id = &$bar->id_ref;
+	$label = &$bar->foo;
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[020] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt) || mysqli_stmt_fetch($stmt))
+		printf("[021] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	var_dump($id);
+	var_dump($label);
+	var_dump($bar);
+
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+plain vanilla...
+int(1)
+%unicode|string%(1) "a"
+reference, one level...
+int(1)
+int(1)
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+reference, two levels...
+int(1)
+int(1)
+int(1)
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+reference, $GLOBALS...
+int(1)
+int(1)
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+reference, same target...
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+reference, simple object...
+int(1)
+%unicode|string%(1) "a"
+reference, simple object w reference...
+int(1)
+%unicode|string%(1) "a"
+reference, simple object w reference, change after bind...
+int(1)
+int(1)
+%unicode|string%(1) "a"
+int(1)
+reference, one level, change after bind...
+int(1)
+int(1)
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+reference, circle...
+int(1)
+%unicode|string%(1) "a"
+%unicode|string%(1) "a"
+reference, object, forward declaration...
+int(1)
+object(bar)#%d (2) {
+  [%u|b%"bar"]=>
+  &%unicode|string%(1) "a"
+  [%u|b%"foo"]=>
+  &%unicode|string%(1) "a"
+}
+%unicode|string%(1) "a"
+references, object, private...
+int(1)
+%unicode|string%(1) "a"
+object(mega_bar)#5 (4) {
+  [%s]=>
+  &int(1)
+  [%u|b%"id_ref"]=>
+  &int(1)
+  [%u|b%"bar"]=>
+  &%unicode|string%(1) "a"
+  [%u|b%"foo"]=>
+  &%unicode|string%(1) "a"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_bind_result_zerofill.phpt
@@ -0,0 +1,97 @@
+--TEST--
+mysqli_stmt_bind_result() - ZEROFILL
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	function zerofill($offset, $link, $datatype, $insert = 1) {
+
+		mysqli_query($link, 'ALTER TABLE test DROP zero');
+		$sql = sprintf('ALTER TABLE test ADD zero %s UNSIGNED ZEROFILL', $datatype);
+		if (!mysqli_query($link, $sql)) {
+			// no worries - server might not support it
+			return true;
+		}
+
+		if (!mysqli_query($link, sprintf('UPDATE test SET zero = %s', $insert))) {
+			printf("[%03d] UPDATE failed, [%d] %s\n",
+				$offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!($stmt = mysqli_prepare($link, 'SELECT zero FROM test LIMIT 1'))) {
+			printf("[%03d] SELECT failed, [%d] %s\n",
+				$offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		$result = null;
+		if (!mysqli_stmt_bind_result($stmt, $result)) {
+			printf("[%03d] Bind failed, [%d] %s\n",
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt)) {
+			printf("[%03d] Execute or fetch failed, [%d] %s\n",
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		$res = mysqli_stmt_result_metadata($stmt);
+		$meta = mysqli_fetch_fields($res);
+		mysqli_stmt_free_result($stmt);
+
+		$meta = $meta[0];
+		$length = $meta->length;
+		if ($length > strlen($insert)) {
+
+			$expected = str_repeat('0', $length - strlen($insert));
+			$expected .= $insert;
+			if ($expected !== $result) {
+				printf("[%03d] Expecting '%s' got '%s'\n", $offset, $expected, $result);
+				return false;
+			}
+
+		} else if ($length <= 1) {
+			printf("[%03d] Length reported is too small to run test\n", $offset);
+			return false;
+		}
+
+
+		return true;
+	}
+
+	/*
+	We map those to PHP numeric types -
+		no padding/filling done. Neither with libmysql nor with mysqlnd.
+	zerofill(2, $link, 'TINYINT');
+	zerofill(3, $link, 'SMALLINT');
+	zerofill(4, $link, 'MEDIUMINT');
+	zerofill(5, $link, 'INT');
+	zerofill(6, $link, 'INTEGER');
+	zerofill(7, $link, 'BIGINT');
+	zerofill(8, $link, 'FLOAT');
+	zerofill(9, $link, 'DOUBLE');
+	zerofill(10, $link, 'DOUBLE PRECISION');
+	*/
+	zerofill(11, $link, 'DECIMAL');
+	zerofill(12, $link, 'DEC');
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_close.phpt
@@ -0,0 +1,91 @@
+--TEST--
+mysqli_stmt_close()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_close()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_close($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// Yes, amazing, eh? AFAIK a work around of a constructor bug...
+	if (!is_null($tmp = mysqli_stmt_close($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_close($stmt)))
+		printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = mysqli_stmt_close($stmt)))
+		printf("[007] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_param($stmt, "is", $id, $label))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 100; $label = 'z';
+	if (!mysqli_stmt_execute($stmt))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_kill($link, mysqli_thread_id($link));
+
+	if (true !== ($tmp = mysqli_stmt_close($stmt)))
+		printf("[012] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	require('table.inc');
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test"))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[015] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_fetch($stmt))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_kill($link, mysqli_thread_id($link));
+
+	if (true !== ($tmp = mysqli_stmt_close($stmt)))
+		printf("[017] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_close(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_close(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_data_seek.phpt
@@ -0,0 +1,99 @@
+--TEST--
+mysqli_stmt_data_seek()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_data_seek()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_data_seek($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_null($tmp = mysqli_stmt_data_seek($stmt, 1)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test ORDER BY id"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+
+	$id = null;
+	if (!mysqli_stmt_bind_result($stmt, $id))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_store_result($stmt))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_null($tmp = mysqli_stmt_data_seek($stmt, 2)))
+		printf("[009] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_fetch($stmt))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+
+	if (!is_null($tmp = mysqli_stmt_data_seek($stmt, 0)))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_fetch($stmt))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+
+	if (!is_null($tmp = mysqli_stmt_data_seek($stmt, mysqli_stmt_num_rows($stmt) + 100)))
+		printf("[013] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_stmt_fetch($stmt))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+
+	if (false !== ($tmp = mysqli_stmt_data_seek($stmt, -1)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_stmt_fetch($stmt))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_data_seek($stmt, 0)))
+		printf("[017] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_data_seek(): invalid object or resource mysqli_stmt
+ in %s on line %d
+int(3)
+int(1)
+int(1)
+
+Warning: mysqli_stmt_data_seek(): Offset must be positive in %s on line %d
+int(1)
+
+Warning: mysqli_stmt_data_seek(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_datatype_change.phpt
@@ -0,0 +1,94 @@
+--TEST--
+Playing with datatype change between prepare and execute
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	if (!$c1 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+	if (!$c2 = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+		exit(1);
+	}
+
+	$c1->query("use $db");
+	$c2->query("use $db");
+	$c1->query("drop table if exists type_change");
+	$c1->query("create table type_change(a int, b char(10)) ENGINE = " . $engine);
+	$c1->query("insert into type_change values (1, 'one'), (2, 'two')");
+	$s1 = $c1->prepare("select a from type_change order by a");
+	var_dump($s1->execute(), $s1->bind_result($col1));
+	echo "---- Row 1\n";
+	var_dump($s1->fetch());
+	var_dump($col1);
+	echo "---- Row 2\n";
+	var_dump($s1->fetch());
+	var_dump($col1);
+	echo "---- Row 3\n";
+	var_dump($s1->fetch());
+	echo "----\n";
+
+	echo "ALTER\n";
+	var_dump($c2->query("alter table type_change drop a"));
+	var_dump($s1->execute());
+	var_dump($c1->error);
+
+	echo "---- Row 1\n";
+	var_dump($s1->fetch());
+	var_dump($col1);
+	echo "---- Row 2\n";
+	var_dump($s1->fetch());
+	var_dump($col1);
+	echo "---- Row 3\n";
+	var_dump($s1->fetch());
+	echo "----\n";
+
+	echo "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS type_change"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+mysqli_close($link);
+?>
+
+--EXPECTF--
+bool(true)
+bool(true)
+---- Row 1
+bool(true)
+int(1)
+---- Row 2
+bool(true)
+int(2)
+---- Row 3
+NULL
+----
+ALTER
+bool(true)
+bool(false)
+%unicode|string%(34) "Unknown column 'a' in 'field list'"
+---- Row 1
+bool(false)
+int(2)
+---- Row 2
+bool(false)
+int(2)
+---- Row 3
+bool(false)
+----
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_errno.phpt
@@ -0,0 +1,68 @@
+--TEST--
+mysqli_stmt_errno()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_errno()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_errno($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// properly initialized?
+	if (0 !== ($tmp = mysqli_stmt_errno($stmt)))
+		printf("[004] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_stmt_prepare($stmt, "SELECT i_do_not_exist_believe_me FROM test ORDER BY id"))
+		printf("[005] Statement should have failed!\n");
+
+	// set after error server?
+	if (0 === ($tmp = mysqli_stmt_errno($stmt)))
+		printf("[006] Expecting int/any non zero, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test ORDER BY id"))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	// reset after error & success
+	if (0 != ($tmp = mysqli_stmt_errno($stmt)))
+		printf("[008] Expecting zero, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_kill($link, mysqli_thread_id($link));
+
+	if (true === ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[009] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	// set after client error
+	if (0 === ($tmp = mysqli_stmt_errno($stmt)))
+		printf("[010] Execting int/any non zero, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_errno($stmt)))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_errno(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_error.phpt
@@ -0,0 +1,68 @@
+--TEST--
+mysqli_stmt_error()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_error()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_error($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// properly initialized?
+	if ('' !== ($tmp = mysqli_stmt_error($stmt)))
+		printf("[004] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_stmt_prepare($stmt, "SELECT i_do_not_exist_believe_me FROM test ORDER BY id"))
+		printf("[005] Statement should have failed!\n");
+
+	// set after error server?
+	if ('' === ($tmp = mysqli_stmt_error($stmt)))
+		printf("[006] Expecting string/any non empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test ORDER BY id"))
+		printf("[007] [%d] %s\n", mysqli_stmt_error($stmt), mysqli_stmt_error($stmt));
+
+	// reset after error & success
+	if ('' !== ($tmp = mysqli_stmt_error($stmt)))
+		printf("[008] Expecting empty string, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_kill($link, mysqli_thread_id($link));
+
+	if (true === ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[009] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	// set after client error
+	if ('' === ($tmp = mysqli_stmt_error($stmt)))
+		printf("[010] Execting string/any non empty, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_error($stmt)))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_error(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_execute.phpt
@@ -0,0 +1,150 @@
+--TEST--
+mysqli_stmt_execute()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) <= 40100) {
+	die(sprintf('skip Needs MySQL 4.1+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_execute()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_execute($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_stmt_prepare($stmt, "SELECT i_do_not_exist_believe_me FROM test ORDER BY id"))
+		printf("[005] Statement should have failed!\n");
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test ORDER BY id LIMIT 1"))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[008] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[009] [%d] %s\n", mysqli_stmt_execute($stmt), mysqli_stmt_execute($stmt));
+
+	// no input variables bound
+	if (false !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[010] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	$id = 100;
+	$label = "z";
+	if (!mysqli_stmt_bind_param($stmt, "is", $id, $label))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	// calling reset between executions
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test ORDER BY id LIMIT ?"))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$limit = 1;
+	if (!mysqli_stmt_bind_param($stmt, "i", $limit))
+		printf("[015] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[016] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	if (!mysqli_stmt_bind_result($stmt, $id) || !mysqli_stmt_fetch($stmt))
+		printf("[017] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if ($id !== 1)
+		printf("[018] Expecting int/1 got %s/%s\n", gettype($id), $id);
+
+	if (true !== ($tmp = mysqli_stmt_reset($stmt)))
+		printf("[019] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[020] Expecting boolean/true after reset to prepare status, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	if (!mysqli_stmt_fetch($stmt))
+		printf("[021] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if ($id !== 1)
+		printf("[022] Expecting int/1 got %s/%s\n", gettype($id), $id);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[023] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test ORDER BY id LIMIT 1"))
+		printf("[024] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[025] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_reset($stmt)))
+		printf("[026] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump(mysqli_stmt_execute($stmt));
+	var_dump(mysqli_stmt_fetch($stmt));
+
+	mysqli_kill($link, mysqli_thread_id($link));
+
+	if (false !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[027] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[028] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_execute(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_execute(): invalid object or resource mysqli_stmt
+ in %s on line %d
+bool(true)
+bool(true)
+[027] Expecting boolean/false, got boolean/1
+
+Warning: mysqli_stmt_execute(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_execute_stored_proc.phpt
@@ -0,0 +1,198 @@
+--TEST--
+mysqli_stmt_execute() - Stored Procedures
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) <= 50000) {
+	die(sprintf('skip Needs MySQL 5.0+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+	require_once('table.inc');
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[009] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;')) {
+		/* no result set, one output parameter */
+		if (!$stmt = mysqli_prepare($link, 'CALL p(@version)'))
+			printf("[011] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[012] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		/* yes, I really want to call it twice! */
+		if (!mysqli_stmt_execute($stmt))
+			printf("[013] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_close($stmt))
+			printf("[014] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$stmt = mysqli_prepare($link, 'SELECT @version AS _version'))
+			printf("[015] Cannot prepare SELECT, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[016] Cannot execute SELECT, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		$version = 'unknown';
+		if (!mysqli_stmt_bind_result($stmt, $version) ||
+				!mysqli_stmt_fetch($stmt))
+			printf("[017] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (($version == "unknown") || ($version == ""))
+			printf("[018] Results seem wrong, got %s, [%d] %s\n",
+				$version,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		mysqli_stmt_free_result($stmt);
+		mysqli_stmt_close($stmt);
+
+	} else {
+		printf("[010] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+
+	if (function_exists('mysqli_stmt_get_result')) {
+
+		if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+			printf("[019] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+		if (mysqli_real_query($link, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;')) {
+			// no result set, one output parameter
+			if (!$stmt = mysqli_prepare($link, 'CALL p(@version)'))
+				printf("[020] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+			if (!mysqli_stmt_execute($stmt))
+				printf("[021] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (!mysqli_stmt_close($stmt))
+				printf("[022] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (!$stmt = mysqli_prepare($link, 'SELECT @version AS _version'))
+				printf("[023] Cannot prepare SELECT, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+			if (!mysqli_stmt_execute($stmt))
+				printf("[024] Cannot execute SELECT, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (!$res = mysqli_stmt_get_result($stmt))
+				printf("[025] Cannot get result set, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if ((!($row = mysqli_fetch_assoc($res))) || ($row['_version'] == ""))
+				printf("[026] Results seem wrong, got %s, [%d] %s\n",
+					$row['_version'],
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			mysqli_free_result($res);
+			mysqli_stmt_close($stmt);
+
+		} else {
+			printf("[027] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+		}
+
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[028] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25), OUT ver_out VARCHAR(25)) BEGIN SELECT ver_in INTO ver_out; END;')) {
+		// no result set, one input parameter, output parameter
+		// yes, I really do not want to bind input values...
+		if (!$stmt = mysqli_prepare($link, "CALL p('myversion', @version)"))
+			printf("[029] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[030] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_close($stmt))
+			printf("[031] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$stmt = mysqli_prepare($link, 'SELECT @version AS _version'))
+			printf("[032] Cannot prepare SELECT, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[033] Cannot execute SELECT, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		$version = 'unknown';
+		if (!mysqli_stmt_bind_result($stmt, $version) ||
+				!mysqli_stmt_fetch($stmt))
+			printf("[034] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if ($version != "myversion")
+			printf("[035] Results seem wrong, got %s, [%d] %s\n",
+				$version,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		mysqli_stmt_free_result($stmt);
+		mysqli_stmt_close($stmt);
+
+	} else {
+		printf("[036] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[037] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25), OUT ver_out VARCHAR(25)) BEGIN SELECT ver_in INTO ver_out; END;')) {
+		// no result set, one input parameter, output parameter
+		// yes, I really do not want to bind input values...
+		if (!$stmt = mysqli_prepare($link, 'CALL p(?, @version)'))
+			printf("[038] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$version = 'myversion';
+		if (!mysqli_stmt_bind_param($stmt, 's', $version))
+			printf("[039] Cannot bind input parameter, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[040] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_close($stmt))
+			printf("[041] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$stmt = mysqli_prepare($link, 'SELECT @version AS _version'))
+			printf("[042] Cannot prepare SELECT, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[043] Cannot execute SELECT, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		$version = 'unknown';
+		if (!mysqli_stmt_bind_result($stmt, $version) ||
+				!mysqli_stmt_fetch($stmt))
+			printf("[044] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if ($version !== "myversion")
+			printf("[045] Results seem wrong, got %s, [%d] %s\n",
+				$version,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		mysqli_stmt_free_result($stmt);
+		mysqli_stmt_close($stmt);
+
+	} else {
+		printf("[046] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test_bind_fetch"))
+	printf("[c002] Cannot drop table, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+@mysqli_query($link, 'DROP PROCEDURE IF EXISTS p');
+
+mysqli_close($link);
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_execute_stored_proc_next_result.phpt
@@ -0,0 +1,131 @@
+--TEST--
+mysqli_stmt_execute() - SP, next result
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) < 50503) {
+	die(sprintf('skip Needs MySQL 5.5.3+, found version %d.', mysqli_get_server_version($link)));
+}
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		  $host, $user, $db, $port, $socket);
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[003] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25)) BEGIN SELECT ver_in AS _ver_out; END;')) {
+		// one result set
+		if (!$stmt = mysqli_prepare($link, 'CALL p(?)'))
+			printf("[005] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$version = 'myversion';
+		if (!mysqli_stmt_bind_param($stmt, 's', $version))
+			printf("[006] Cannot bind input parameter, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[007] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		$version = 'unknown';
+		if (!mysqli_stmt_bind_result($stmt, $version) ||
+				!mysqli_stmt_fetch($stmt))
+			printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if ($version !== "myversion")
+			printf("[009] Results seem wrong, got %s, [%d] %s\n",
+				$version,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		mysqli_stmt_free_result($stmt);
+
+		printf("[010] More results: %s\n", (mysqli_more_results($link)) ? "yes" : "no");
+		printf("[011] Next result: %s\n", (mysqli_next_result($link)) ? "yes" : "no");
+
+		if (!mysqli_stmt_close($stmt))
+			printf("[012] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$link->query("SELECT 1"))
+			printf("[013] [%d] %s\n", $link->errno, $link->error);
+
+	} else {
+		printf("[004] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[014] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25)) BEGIN SELECT ver_in AS _ver_out; SELECT 1 AS _more; END;')) {
+		// two result sets
+		if (!$stmt = mysqli_prepare($link, 'CALL p(?)'))
+			printf("[015] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$version = 'myversion';
+		if (!mysqli_stmt_bind_param($stmt, 's', $version))
+			printf("[016] Cannot bind input parameter, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[017] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		$version = NULL;
+		if (!mysqli_stmt_bind_result($stmt, $version) ||
+				!mysqli_stmt_fetch($stmt))
+			printf("[018] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if ($version !== "myversion")
+			printf("[019] Results seem wrong, got %s, [%d] %s\n",
+				$version,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_more_results($link) || !mysqli_next_result($link))
+			printf("[020] [%d] %s\n", $link->errno, $link->error);
+
+		$more = NULL;
+		if (!mysqli_stmt_bind_result($stmt, $more) ||
+				!mysqli_stmt_fetch($stmt))
+			printf("[021] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if ($more !== 1)
+			printf("[022] Results seem wrong, got %s, [%d] %s\n",
+				$more,
+				mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_close($stmt))
+			printf("[023] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+
+		if (!$link->query("SELECT 1"))
+			printf("[024] [%d] %s\n", $link->errno, $link->error);
+
+	} else {
+		printf("[025] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+@mysqli_query($link, 'DROP PROCEDURE IF EXISTS p');
+
+mysqli_close($link);
+?>
+--XFAIL--
+Unsupported and undefined, under development
+--EXPECTF--
+[010] More results: yes
+[011] Next result: yes
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_execute_stored_proc_out.phpt
@@ -0,0 +1,81 @@
+--TEST--
+mysqli_stmt_execute() - OUT
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf('skip Cannot connect to MySQL, [%d] %s.', mysqli_connect_errno(), mysqli_connect_error()));
+}
+if (mysqli_get_server_version($link) < 50503) {
+	die(sprintf('skip Needs MySQL 5.5.3+, found version %d.', mysqli_get_server_version($link)));
+}
+/*
+if ($IS_MYSQLND) {
+	die(sprintf("skip WHY ?!"));
+}
+*/
+?>
+--FILE--
+<?php
+	require_once('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		  $host, $user, $db, $port, $socket);
+	}
+
+	if (!mysqli_query($link, 'DROP PROCEDURE IF EXISTS p'))
+		printf("[003] [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_real_query($link, 'CREATE PROCEDURE p(IN ver_in VARCHAR(25), OUT ver_out VARCHAR(25)) BEGIN SELECT ver_in INTO ver_out; END;')) {
+		if (!$stmt = mysqli_prepare($link, 'CALL p(?, ?)'))
+			printf("[005] Cannot prepare CALL, [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+		$ver_in = 'myversion';
+		$ver_out = '';
+		if (!mysqli_stmt_bind_param($stmt, 'ss', $ver_in, $ver_out))
+			printf("[006] Cannot bind parameter, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[007] Cannot execute CALL, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		printf("[008] More results: %s\n", (mysqli_more_results($link) ? "yes" : "no"));
+		printf("[009] Next results: %s\n", (mysqli_next_result($link) ? "yes" : "no"));
+
+		if (!mysqli_stmt_bind_result($stmt, $ver_out) || !mysqli_stmt_fetch($stmt))
+			printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if ("myversion" !== $ver_out)
+			printf("[011] Results seem wrong got '%s'\n", $ver_out);
+
+		if (!mysqli_stmt_close($stmt))
+			printf("[012] Cannot close statement, [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!$res = $link->query("SELECT 1"))
+			printf("[013] [%d] %s\n", $link->errno, $link->error);
+
+	} else {
+		printf("[004] Cannot create SP, [%d] %s.\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+require_once("connect.inc");
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+   printf("[c001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+@mysqli_query($link, 'DROP PROCEDURE IF EXISTS p');
+
+mysqli_close($link);
+?>
+--XFAIL--
+Unsupported and undefined, under development
+--EXPECTF--
+[008] More results: %s
+[009] Next results: %s
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_fetch.phpt
@@ -0,0 +1,98 @@
+--TEST--
+mysqli_stmt_fetch()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/*
+	NOTE: no datatype tests here! This is done by
+	mysqli_stmt_bind_result.phpt already. Restrict
+	this test case to the basics.
+	*/
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_fetch()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_fetch($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 2"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	// FIXME - different versions return different values ?!
+	if ((NULL !== ($tmp = mysqli_stmt_fetch($stmt))) && (false !== $tmp))
+		printf("[006] Expecting NULL or boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[008] NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 2"))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = NULL;
+	$label = NULL;
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[012] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[013] Expecting boolean/true, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_kill($link, mysqli_thread_id($link)))
+		printf("[014] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[015] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[016] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	/* Check that the function alias exists. It's a deprecated function,
+	but we have not announce the removal so far, therefore we need to check for it */
+	if (!is_null($tmp = @mysqli_stmt_fetch()))
+		printf("[017] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_fetch(): invalid object or resource mysqli_stmt
+ in %s on line %d
+[014] [%d] Commands out of sync; you can't run this command now
+
+Warning: mysqli_stmt_fetch(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_fetch_bit.phpt
@@ -0,0 +1,76 @@
+--TEST--
+Fetching BIT column values using the PS API
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+	require_once('connect.inc');
+	require_once('table.inc');
+	if (mysqli_get_server_version($link) < 50003)
+		// b'001' syntax not supported before 5.0.3
+		die("skip Syntax used for test not supported with MySQL Server before 5.0.3");
+	if (!$IS_MYSQLND && (mysqli_get_client_version() < 50003))
+		// better don't trust libmysql before 5.0.3
+		die("skip Syntax used for test not supported with MySQL Server before 5.0.3");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	/* NOTE: works only for up to 31 bits! This limitation should be documented. */
+	for ($bits = 1; $bits < 32; $bits++) {
+		$max_value = pow(2, $bits) - 1;
+		$tests = 0;
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+			!mysqli_query($link, $sql = sprintf('CREATE TABLE test(id INT, label BIT(%d)) ENGINE="%s"', $bits, $engine)))
+			printf("[002 - %d] [%d] %s\n",$bits, mysqli_errno($link), mysqli_error($link));
+
+		if (!$stmt = mysqli_stmt_init($link))
+			printf("[003 - %d] [%d] %s\n", $bits, mysqli_errno($link), mysqli_error($link));
+
+		while ($tests < min($max_value, 20)) {
+			$tests++;
+			$value = mt_rand(0, $max_value);
+			$sql = sprintf("INSERT INTO test(id, label) VALUES (%d, b'%s')", $value, decbin($value));
+
+			if (!mysqli_stmt_prepare($stmt, $sql) ||
+					!mysqli_stmt_execute($stmt))
+				printf("[004 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			$id = $_label0 = $label = null;
+			$sql = sprintf("SELECT id, label + 0 AS _label0, label FROM test WHERE id = %d", $value);
+			if (!mysqli_stmt_prepare($stmt, $sql) ||
+					!mysqli_stmt_execute($stmt) ||
+					!mysqli_stmt_bind_result($stmt, $id, $_label0, $label))
+				printf("[005 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (!mysqli_stmt_fetch($stmt))
+				printf("[006 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (($id !== $_label0) || ($value !== $_label0)) {
+				printf("[007 - %d] Insert of %d in BIT(%d) column might have failed. MySQL reports odd values, id = %s, _label0 = %s, label = %s.\n", $bits, $value, $bits, $id, $_label0, $label);
+			}
+			if ($value != $label) {
+				printf("[008 - %d] Wrong values, (original) value = %s, id = %s,  label + 0 AS label0 = %s, label = %s\n",
+					$bits, $value, $id, $_label0, $label);
+			}
+		}
+
+		mysqli_stmt_close($stmt);
+
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_fetch_fields_win32_unicode.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysqli_stmt_fetch_fields() unicode, win32
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+	require_once('table.inc');
+
+	$bind_res = $id = null;
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test") ||
+		!mysqli_stmt_execute($stmt) ||
+		!($result = mysqli_stmt_result_metadata($stmt)) ||
+		!mysqli_stmt_bind_result($stmt, $id, $bind_res) ||
+		!($fields = mysqli_fetch_fields($result))) {
+		printf("FAIL 1\n");
+	}
+	while (mysqli_stmt_fetch($stmt)) {
+		;
+	}
+	mysqli_free_result($result);
+	mysqli_stmt_close($stmt);
+
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test") ||
+		!mysqli_stmt_execute($stmt) ||
+		!($result = mysqli_stmt_result_metadata($stmt)) ||
+		!mysqli_stmt_bind_result($stmt, $id, $bind_res)) {
+		printf("FAIL 2\n");
+	}
+	print "OK: 1\n";
+	if (!($fields = mysqli_fetch_fields($result)))
+		printf("Aua 3\n");
+	print "OK: 2\n";
+	while (mysqli_stmt_fetch($stmt)) {
+		;
+	}
+	mysqli_free_result($result);
+	mysqli_stmt_close($stmt);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+OK: 1
+OK: 2
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_fetch_geom.phpt
@@ -0,0 +1,141 @@
+--TEST--
+mysqli_stmt_fetch - geometry / spatial types
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	if (!defined("MYSQLI_TYPE_GEOMETRY"))
+		die("skip MYSQLI_TYPE_GEOMETRY not defined");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	function func_mysqli_stmt_fetch_geom($link, $engine, $sql_type, $bind_value, $offset) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+			// don't bail - column type might not be supported by the server, ignore this
+			return false;
+		}
+
+		for ($id = 1; $id < 4; $id++) {
+			$sql = sprintf("INSERT INTO test(id, label) VALUES (%d, %s)", $id, $bind_value);
+			if (!mysqli_query($link, $sql)) {
+				printf("[%04d] [%d] %s\n", $offset + 2 + $id, mysqli_errno($link), mysqli_error($link));
+			}
+		}
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%04d] [%d] %s\n", $offset + 6, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 7, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt) || !mysqli_stmt_store_result($stmt)) {
+			printf("[%04d] [%d] %s\n", $offset + 8, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		if (!mysqli_stmt_bind_result($stmt, $id, $bind_res)) {
+			printf("[%04d] [%d] %s\n", $offset + 9, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		$result = mysqli_stmt_result_metadata($stmt);
+		$fields = mysqli_fetch_fields($result);
+		if ($fields[1]->type != MYSQLI_TYPE_GEOMETRY) {
+			printf("[%04d] [%d] %s wrong type %d\n", $offset + 10, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), $fields[1]->type);
+		}
+
+		$num = 0;
+		$rows = array();
+		while (true === @mysqli_stmt_fetch($stmt)) {
+			$rows[] = array('id' => $id, 'label' => $bind_res);
+			$num++;
+		}
+
+		if ($num != 3) {
+			printf("[%04d] [%d] %s, expecting 3 results, got only %d results\n",
+				$offset + 17, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), $num);
+			return false;
+		}
+		mysqli_stmt_close($stmt);
+
+		foreach ($rows as $row) {
+			if (!$stmt = mysqli_stmt_init($link)) {
+				printf("[%04d] [%d] %s\n", $offset + 10, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+
+			if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)")) {
+				printf("[%04d] [%d] %s\n", $offset + 11, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			$new_id = $row['id'] + 10;
+			if (!mysqli_stmt_bind_param($stmt, "is", $new_id, $row['label'])) {
+				printf("[%04d] [%d] %s\n", $offset + 12, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			if (!mysqli_stmt_execute($stmt)) {
+				printf("[%04d] [%d] %s\n", $offset + 13, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+			mysqli_stmt_close($stmt);
+
+			if (!$res_normal = mysqli_query($link, sprintf("SELECT id, label FROM test WHERE id = %d",
+					$new_id))) {
+				printf("[%04d] [%d] %s\n", $offset + 14, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+
+			if (!$row_normal = mysqli_fetch_assoc($res_normal)) {
+				printf("[%04d] [%d] %s\n", $offset + 15, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+
+			if ($row_normal['label'] != $row['label']) {
+				printf("[%04d] PS and non-PS return different data.\n", $offset + 16);
+				return false;
+			}
+			mysqli_free_result($res_normal);
+		}
+
+		return true;
+	}
+
+	func_mysqli_stmt_fetch_geom($link, $engine, "GEOMETRY", "GeomFromText('POINT(2 2)')", 20);
+	func_mysqli_stmt_fetch_geom($link, $engine, "POINT", "GeomFromText('POINT(1 1)')", 40);
+	func_mysqli_stmt_fetch_geom($link, $engine, "LINESTRING", "GeomFromText('LINESTRING(0 0,1 1,2 2)')", 60);
+	func_mysqli_stmt_fetch_geom($link, $engine, "POLYGON", "GeomFromText('POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))')", 80);
+	func_mysqli_stmt_fetch_geom($link, $engine, "MULTIPOINT", "GeomFromText('MULTIPOINT(1 1, 2 2)')", 100);
+	func_mysqli_stmt_fetch_geom($link, $engine, "MULTILINESTRING", "GeomFromText('MULTILINESTRING((0 0,1 1,2 2),(0 0,1 1,3 3))')", 120);
+	func_mysqli_stmt_fetch_geom($link, $engine, "MULTIPOLYGON", "GeomFromText('MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5)),((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5)))')", 140);
+	func_mysqli_stmt_fetch_geom($link, $engine, "GEOMETRYCOLLECTION", "GeomFromText('GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))')", 160);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_field_count.phpt
@@ -0,0 +1,100 @@
+--TEST--
+mysqli_stmt_field_counts()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_field_count()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_field_count($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$stmt = mysqli_stmt_init($link);
+	if (!is_null($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_stmt_prepare($stmt, ''))
+		printf("[004] Prepare should fail for an empty statement\n");
+	if (!is_null($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT 1'))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	if (1 !== ($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[007] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT 1, 2'))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	if (2 !== ($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[009] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test'))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	if (2 !== ($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[011] Expecting int/2, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT label FROM test') ||
+		!mysqli_stmt_execute($stmt))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	if (1 !== ($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[013] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	$label = null;
+	if (mysqli_stmt_bind_param($stmt, "s", $label))
+		printf("[014] expected error - got ok\n");
+	while (mysqli_stmt_fetch($stmt))
+		if (1 !== ($tmp = mysqli_stmt_field_count($stmt)))
+			printf("[015] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'INSERT INTO test(id) VALUES (100)'))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	if (0 !== ($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[017] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "UPDATE test SET label = 'z' WHERE id = 1") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[018] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (0 !== ($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[019] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (mysqli_stmt_prepare($stmt, 'SELECT id FROM test'))
+		printf("[020] Prepare should fail, statement has been closed\n");
+	if (!is_null($tmp = mysqli_stmt_field_count($stmt)))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_field_count(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_field_count(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_bind_param(): Number of variables doesn't match number of parameters in prepared statement in %s on line %d
+
+Warning: mysqli_stmt_prepare(): Couldn't fetch mysqli_stmt in %s on line %d
+
+Warning: mysqli_stmt_field_count(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_free_result.phpt
@@ -0,0 +1,86 @@
+--TEST--
+mysqli_stmt_free_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/*
+	NOTE: no datatype tests here! This is done by
+	mysqli_stmt_bind_result.phpt already. Restrict
+	this test case to the basics.
+	*/
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_free_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_free_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_free_result($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (NULL !== ($tmp = mysqli_stmt_free_result($stmt)))
+		printf("[006] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (NULL !== ($tmp = mysqli_stmt_free_result($stmt)))
+		printf("[008] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_stmt_store_result($stmt)))
+		printf("[009] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id"))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_store_result($stmt)))
+		printf("[013] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($tmp = mysqli_stmt_free_result($stmt)))
+		printf("[014] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_free_result($stmt)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_free_result(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_free_result(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result.phpt
@@ -0,0 +1,187 @@
+--TEST--
+mysqli_stmt_get_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_stmt_get_result'))
+	die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	/*
+	NOTE: no datatype tests here! This is done by
+	mysqli_stmt_bind_result.phpt already. Restrict
+	this test case to the basics.
+	*/
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_get_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_get_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 2"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	// FIXME - different versions return different values ?!
+	if ((NULL !== ($tmp = mysqli_stmt_get_result($stmt))) && (false !== $tmp))
+		printf("[006] Expecting NULL or boolean/false, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_store_result($stmt))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (is_object($tmp = mysqli_stmt_store_result($stmt)))
+		printf("[009] non-object, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	mysqli_stmt_close($stmt);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[011] Expecting NULL, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 2"))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	// FIXME - different versions return different values ?!
+	if ((NULL !== ($tmp = mysqli_stmt_get_result($stmt))) && (false !== $tmp))
+		printf("[013] Expecting NULL or boolean/false, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($tmp = mysqli_stmt_get_result($stmt)))
+		printf("[016] NULL, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	mysqli_free_result($tmp);
+	mysqli_stmt_close($stmt);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = mysqli_stmt_get_result($stmt)))
+		printf("[018] Expecting NULL, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 2"))
+		printf("[019] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = mysqli_stmt_get_result($stmt)))
+		printf("[020] Expecting false, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[023] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($tmp = mysqli_stmt_get_result($stmt)))
+		printf("[024] Expecting object, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (false !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[025] false, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label))) {
+		printf("[026] [%d] [%s]\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+		printf("[027] [%d] [%s]\n", mysqli_errno($link), mysqli_error($link));
+		printf("[028] Expecting boolean/true, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+	}
+
+	if (false !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[029] false, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	mysqli_stmt_close($stmt);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[032] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 2"))
+		printf("[033] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[034] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = NULL;
+	$label = NULL;
+	if (true !== ($tmp = mysqli_stmt_bind_result($stmt, $id, $label)))
+		printf("[035] Expecting boolean/true, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	if (!is_object($tmp = $result = mysqli_stmt_get_result($stmt)))
+		printf("[036] Expecting array, got %s/%s, [%d] %s\n",
+			gettype($tmp), var_export($tmp, 1),
+			mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[037] Expecting boolean/false, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	printf("[038] [%d] [%s]\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	printf("[039] [%d] [%s]\n", mysqli_errno($link), mysqli_error($link));
+	while ($row = mysqli_fetch_assoc($result)) {
+		var_dump($row);
+	}
+	mysqli_free_result($result);
+
+	if (!mysqli_kill($link, mysqli_thread_id($link)))
+		printf("[040] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_stmt_get_result($stmt)))
+		printf("[041] Expecting false, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_fetch($stmt)))
+		printf("[042] Expecting NULL, got %s/%s\n", gettype($tmp), var_export($tmp, 1));
+
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_fetch(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_fetch(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_get_result(): invalid object or resource mysqli_stmt
+ in %s on line %d
+[038] [2014] [Commands out of sync; you can't run this command now]
+[039] [0] []
+array(2) {
+  [%u|b%"id"]=>
+  int(1)
+  [%u|b%"label"]=>
+  %s(1) "a"
+}
+array(2) {
+  [%u|b%"id"]=>
+  int(2)
+  [%u|b%"label"]=>
+  %s(1) "b"
+}
+
+Warning: mysqli_stmt_fetch(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result2.phpt
@@ -0,0 +1,176 @@
+--TEST--
+mysqli_stmt_get_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+if (!function_exists('mysqli_stmt_get_result'))
+	die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	/*
+	NOTE: no datatype tests here! This is done by
+	mysqli_stmt_bind_result.phpt already. Restrict
+	this test case to the basics.
+	*/
+	require_once("connect.inc");
+
+	$tmp	= NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_get_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_get_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_null($tmp = @mysqli_stmt_get_result($stmt, "foo")))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 1"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!mysqli_stmt_execute($stmt))
+			printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+			printf("[007] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+				gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+		}
+		while ($row = mysqli_fetch_assoc($res))
+			var_dump($row);
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+
+		if (false !== ($res = mysqli_stmt_get_result($stmt))) {
+			printf("[008] boolean/false got %s/%s, [%d] %s\n",
+				gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+		}
+
+		mysqli_stmt_execute($stmt);
+		if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+			printf("[009] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+				gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+		}
+		while ($row = mysqli_fetch_assoc($res))
+			var_dump($row);
+		var_dump(mysqli_fetch_assoc($res));
+		mysqli_free_result($res);
+
+	mysqli_stmt_close($stmt);
+
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_fetch($stmt))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($res = mysqli_stmt_get_result($stmt))) {
+		printf("[013] boolean/false got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	mysqli_stmt_close($stmt);
+
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[015] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_fetch($stmt))
+		printf("[017] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[018] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[019] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	$id = $label = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[020] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$row = mysqli_fetch_assoc($res);
+	if (NULL !== $id || NULL !== $label)
+		printf("[021] Bound variables should not have been set\n");
+	mysqli_free_result($res);
+
+	mysqli_stmt_close($stmt);
+
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 2") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[022] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[023] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+	if (!in_array($res->type, array(MYSQLI_STORE_RESULT, MYSQLI_USE_RESULT))) {
+		printf("[024] Unknown result set type %s\n", $res->type);
+	}
+	if ($res->type !== MYSQLI_STORE_RESULT)
+		printf("[025] Expecting int/%d got %s/%s", MYSQLI_STORE_RESULT, gettype($res->type), $res->type);
+
+	mysqli_free_result($res);
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	if (NULL !== ($res = mysqli_stmt_get_result($stmt))) {
+		printf("[022] Expecting NULL got %s/%s\n",
+			gettype($res), $res);
+	}
+
+		print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  int(1)
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+NULL
+array(2) {
+  [%u|b%"id"]=>
+  int(1)
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+NULL
+[017] [2014] Commands out of sync; you can't run this command now
+
+Warning: mysqli_stmt_get_result(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_bit.phpt
@@ -0,0 +1,133 @@
+--TEST--
+Fetching BIT column values using the PS API
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	if (!function_exists('mysqli_stmt_get_result'))
+		die("skip mysqli_stmt_get_result() not available");
+
+	require_once('connect.inc');
+	require_once('table.inc');
+	if (mysqli_get_server_version($link) < 50003)
+		// b'001' syntax not supported before 5.0.3
+		die("skip Syntax used for test not supported with MySQL Server before 5.0.3");
+	if (!$IS_MYSQLND && (mysqli_get_client_version() < 50003))
+		// better don't trust libmysql before 5.0.3
+		die("skip Syntax used for test not supported with MySQL Server before 5.0.3");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+
+	function dec32bin($dec, $bits) {
+
+		$maxval = pow(2, $bits);
+		$bin = '';
+		for ($bitval = $maxval; $bitval >= 1; $bitval = $bitval / 2) {
+			if (($dec / $bitval) >= 1) {
+				$bin .= '1';
+				$dec -= $bitval;
+			} else {
+				$bin .= '0';
+			}
+		}
+		return $bin;
+	}
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	for ($bits = 1; $bits <= 46; $bits++) {
+		if (1 == $bits)
+			$max_value = 1;
+		else
+			$max_value = pow(2, $bits) - 1;
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+			!mysqli_query($link, $sql = sprintf('CREATE TABLE test(id BIGINT UNSIGNED, bit_value BIT(%d) NOT NULL, bit_null BIT(%d) DEFAULT NULL) ENGINE="%s"', $bits, $bits, $engine)))
+			printf("[002 - %d] [%d] %s\n",$bits, mysqli_errno($link), mysqli_error($link));
+
+		if (!$stmt = mysqli_stmt_init($link))
+			printf("[003 - %d] [%d] %s\n", $bits, mysqli_errno($link), mysqli_error($link));
+
+		$tests = 0;
+		$rand_max = mt_getrandmax();
+		while ($tests < 10) {
+
+			$tests++;
+			if (1 == $tests)
+				$value = 0;
+			else if (2 == $tests)
+				$value = $max_value;
+			else {
+				if ($max_value > $rand_max) {
+					$max_loops = floor($max_value/$rand_max);
+					$num_loops = mt_rand(1, $max_loops);
+					$value = 0;
+					for ($i = 0; $i < $num_loops; $i++)
+						$value += mt_rand(0, $rand_max);
+				} else {
+					$value = mt_rand(0, $max_value);
+				}
+			}
+
+			$bin = ($bits < 32) ? decbin($value) : dec32bin($value, $bits);
+			$sql = sprintf("INSERT INTO test(id, bit_value) VALUES (%s, b'%s')", $value, $bin);
+			for ($i = 0; ($i < strlen($bin)) && ($bin[$i] == '0'); $i++)
+				;
+			$bin2 = substr($bin, $i, strlen($bin));
+
+			if (!mysqli_stmt_prepare($stmt, $sql) ||
+					!mysqli_stmt_execute($stmt))
+				printf("[004 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			$sql = sprintf("SELECT bin(bit_value) AS _bin, id, bit_value, bit_null FROM test WHERE id = %s", $value);
+			if (!mysqli_stmt_prepare($stmt, $sql) ||
+					!mysqli_stmt_execute($stmt))
+				printf("[005 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (!$res = mysqli_stmt_get_result($stmt))
+				printf("[006 - %d] [%d] %s\n", $bits, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			if (!$row = mysqli_fetch_assoc($res))
+				printf("[007 - %d] [%d] %s\n", $bits, mysqli_errno($link), mysqli_error($link));
+			mysqli_free_result($res);
+
+			if (($value != $row['id']) || (($bin != $row['_bin']) && ($bin2 != $row['_bin']))) {
+				debug_zval_dump($row);
+				printf("[008 - %d] Insert of %s in BIT(%d) column might have failed. id = %s, bin = %s (%s/%s)\n",
+					$bits, $value, $bits, $row['id'], $row['_bin'], $bin, $bin2);
+				break;
+			}
+			if ($value != $row['bit_value']) {
+				debug_zval_dump($row);
+				printf("%10s %64s\n%10s %64s\n", '_bin', $row['_bin'], 'insert', $bin);
+				printf("[009 - %d] Expecting %s got %s\n", $bits, $value, $row['bit_value']);
+				break;
+			}
+
+			if (null !== $row['bit_null']) {
+				debug_zval_dump($row);
+				printf("[010 - %d] Expecting null got %s/%s\n", $bits, gettype($row['bit_value']), $row['bit_value']);
+				break;
+			}
+
+		}
+
+		mysqli_stmt_close($stmt);
+
+	}
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_field_count.phpt
@@ -0,0 +1,50 @@
+--TEST--
+mysqli_stmt_get_result() - meta data, field_count()
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	if (!function_exists('mysqli_stmt_get_result'))
+		die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 3"))
+		printf("[002] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[004] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (!is_object($res_meta = mysqli_stmt_result_metadata($stmt)) ||
+		'mysqli_result' != get_class($res_meta)) {
+		printf("[005] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	printf("%s %s\n",
+	$res_meta->field_count,
+	$res->field_count);
+
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+2 2
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_geom.phpt
@@ -0,0 +1,143 @@
+--TEST--
+mysqli_stmt_get_result - geometry / spatial types
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	if (!function_exists('mysqli_stmt_get_result'))
+		die("skip mysqli_stmt_get_result() not available");
+
+	if (!defined("MYSQLI_TYPE_GEOMETRY"))
+		die("skip MYSQLI_TYPE_GEOMETRY not defined");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	function func_mysqli_stmt_get_result_geom($link, $engine, $sql_type, $bind_value, $offset) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+			// don't bail - column type might not be supported by the server, ignore this
+			return false;
+		}
+
+		for ($id = 1; $id < 4; $id++) {
+			$sql = sprintf("INSERT INTO test(id, label) VALUES (%d, %s)", $id, $bind_value);
+			if (!mysqli_query($link, $sql)) {
+				printf("[%04d] [%d] %s\n", $offset + 2 + $id, mysqli_errno($link), mysqli_error($link));
+			}
+		}
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%04d] [%d] %s\n", $offset + 6, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 7, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%04d] [%d] %s\n", $offset + 8, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+		if (!$res = mysqli_stmt_get_result($stmt)) {
+			printf("[%04d] [%d] %s\n", $offset + 9, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		$result = mysqli_stmt_result_metadata($stmt);
+		$fields = mysqli_fetch_fields($result);
+		if ($fields[1]->type != MYSQLI_TYPE_GEOMETRY) {
+			printf("[%04d] [%d] %s wrong type %d\n", $offset + 10, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), $fields[1]->type);
+		}
+
+		$num = 0;
+		while ($row = mysqli_fetch_assoc($res)) {
+			$bind_res = &$row['label'];
+
+			if (!$stmt2 = mysqli_stmt_init($link)) {
+				printf("[%04d] [%d] %s\n", $offset + 11, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+
+			if (!mysqli_stmt_prepare($stmt2, "INSERT INTO test(id, label) VALUES (?, ?)")) {
+				printf("[%04d] [%d] %s\n", $offset + 12, mysqli_stmt_errno($stmt2), mysqli_stmt_error($stmt2));
+				return false;
+			}
+
+			$id = $row['id'] + 10;
+			if (!mysqli_stmt_bind_param($stmt2, "is", $id, $bind_res)) {
+				printf("[%04d] [%d] %s\n", $offset + 13, mysqli_stmt_errno($stmt2), mysqli_stmt_error($stmt2));
+				return false;
+			}
+
+			if (!mysqli_stmt_execute($stmt2)) {
+				printf("[%04d] [%d] %s\n", $offset + 14, mysqli_stmt_errno($stmt2), mysqli_stmt_error($stmt2));
+				return false;
+			}
+			mysqli_stmt_close($stmt2);
+
+			if (!$res_normal = mysqli_query($link, sprintf("SELECT id, label FROM test WHERE id = %d",
+					$row['id'] + 10))) {
+				printf("[%04d] [%d] %s\n", $offset + 15, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+
+			if (!$row_normal = mysqli_fetch_assoc($res_normal)) {
+				printf("[%04d] [%d] %s\n", $offset + 16, mysqli_errno($link), mysqli_error($link));
+				return false;
+			}
+
+			if ($row_normal['label'] != $bind_res) {
+				printf("[%04d] PS and non-PS return different data.\n", $offset + 17);
+				return false;
+			}
+			mysqli_free_result($res_normal);
+			$num++;
+		}
+
+		if ($num != 3) {
+			printf("[%04d] [%d] %s, expecting 3 results, got only %d results\n",
+				$offset + 18, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), $num);
+			mysqli_free_result($res);
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+		mysqli_free_result($res);
+		mysqli_stmt_close($stmt);
+
+		return true;
+	}
+
+	func_mysqli_stmt_get_result_geom($link, $engine, "GEOMETRY", "GeomFromText('POINT(2 2)')", 20);
+	func_mysqli_stmt_get_result_geom($link, $engine, "POINT", "GeomFromText('POINT(1 1)')", 40);
+	func_mysqli_stmt_get_result_geom($link, $engine, "LINESTRING", "GeomFromText('LINESTRING(0 0,1 1,2 2)')", 60);
+	func_mysqli_stmt_get_result_geom($link, $engine, "POLYGON", "GeomFromText('POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))')", 80);
+	func_mysqli_stmt_get_result_geom($link, $engine, "MULTIPOINT", "GeomFromText('MULTIPOINT(1 1, 2 2)')", 100);
+	func_mysqli_stmt_get_result_geom($link, $engine, "MULTILINESTRING", "GeomFromText('MULTILINESTRING((0 0,1 1,2 2),(0 0,1 1,3 3))')", 120);
+	func_mysqli_stmt_get_result_geom($link, $engine, "MULTIPOLYGON", "GeomFromText('MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5)),((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5)))')", 140);
+	func_mysqli_stmt_get_result_geom($link, $engine, "GEOMETRYCOLLECTION", "GeomFromText('GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))')", 160);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_metadata.phpt
@@ -0,0 +1,237 @@
+--TEST--
+mysqli_stmt_get_result() - meta data
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_stmt_get_result'))
+	die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 3"))
+		printf("[002] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[004] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (!is_object($res_meta = mysqli_stmt_result_metadata($stmt)) ||
+		'mysqli_result' != get_class($res_meta)) {
+		printf("[005] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	var_dump(mysqli_fetch_assoc($res));
+	var_dump(mysqli_fetch_assoc($res_meta));
+
+	mysqli_free_result($res);
+	mysqli_free_result($res_meta);
+	mysqli_stmt_close($stmt);
+
+	// !mysqli_stmt_prepare($stmt, "SELECT id, label, id + 1 as _id,  concat(label, '_') _label FROM test as _test ORDER BY id ASC LIMIT 3") ||
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id , label, id + 1 AS _id, label AS _label, null AS _null, CONCAT(label, '_') _label_concat  FROM test _test ORDER BY id ASC LIMIT 3") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[007] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (!is_object($res_meta = mysqli_stmt_result_metadata($stmt)) ||
+		'mysqli_result' != get_class($res_meta)) {
+		printf("[008] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (($tmp1 = mysqli_num_fields($res)) !== ($tmp2 = mysqli_num_fields($res_meta))) {
+		printf("[009] %s/%s !== %s/%s\n", gettype($tmp1), $tmp1, gettype($tmp2), $tmp2);
+	}
+
+	/*
+	if (($tmp1 = mysqli_field_count($link)) !== ($tmp2 = $res->field_count()))
+		printf("[010] %s/%s !== %s/%s\n", gettype($tmp1), $tmp1, gettype($tmp2), $tmp2);
+
+	if (($tmp1 = $res_meta->field_count()) !== $tmp2)
+		printf("[011] %s/%s !== %s/%s\n", gettype($tmp1), $tmp1, gettype($tmp2), $tmp2);
+	*/
+
+	if (($tmp1 = mysqli_field_tell($res)) !== ($tmp2 = $res_meta->current_field))
+		printf("[012] %s/%s !== %s/%s\n", gettype($tmp1), $tmp1, gettype($tmp2), $tmp2);
+
+	if (0 !== $tmp1)
+		printf("[013] Expecting int/0 got %s/%s\n", gettype($tmp1), $tmp1);
+
+	$fields = array();
+	while ($info = $res->fetch_field())
+		$fields['res'][] = $info;
+	var_dump($info);
+	while ($info = $res_meta->fetch_field())
+		$fields['meta'][] = $info;
+	var_dump($info);
+	$fields['all_res'] = $res->fetch_fields();
+	$fields['all_meta'] = $res_meta->fetch_fields();
+
+	if (count($fields['res']) != count($fields['meta'])) {
+		printf("[014] stmt_get_result indicates %d fields, stmt_result_metadata indicates %d fields\n",
+			count($fields['res']),
+			count($fields['meta']));
+	}
+
+	foreach ($fields['res'] as $k => $info) {
+		printf("%s\n", $info->name);
+		if ($info->name !== $fields['meta'][$k]->name)
+			printf("[015 - %d] Expecting name %s/%s got %s/%s\n",
+				$k, gettype($info->name), $info->name, gettype($fields['meta'][$k]->name), $fields['meta'][$k]->name);
+
+		if ($info->orgname !== $fields['meta'][$k]->orgname)
+			printf("[016 - %d] Expecting orgname %s/%s got %s/%s\n",
+				$k, gettype($info->orgname), $info->orgname, gettype($fields['meta'][$k]->orgname), $fields['meta'][$k]->orgname);
+
+		if ($info->table !== $fields['meta'][$k]->table)
+			printf("[017 - %d] Expecting table %s/%s got %s/%s\n",
+				$k, gettype($info->table), $info->table, gettype($fields['meta'][$k]->table), $fields['meta'][$k]->table);
+
+		if ($info->orgtable !== $fields['meta'][$k]->orgtable)
+			printf("[018 - %d] Expecting orgtable %s/%s got %s/%s\n",
+				$k, gettype($info->orgtable), $info->orgtable, gettype($fields['meta'][$k]->orgtable), $fields['meta'][$k]->orgtable);
+
+		if ($info->def !== $fields['meta'][$k]->def)
+			printf("[019 - %d] Expecting def %s/%s got %s/%s\n",
+				$k, gettype($info->def), $info->def, gettype($fields['meta'][$k]->def), $fields['meta'][$k]->def);
+/*
+		if ($info->max_length !== $fields['meta'][$k]->max_length)
+			printf("[020 - %d] Expecting max_length %s/%s got %s/%s\n",
+				$k, gettype($info->max_length), $info->max_length, gettype($fields['meta'][$k]->max_length), $fields['meta'][$k]->max_length);
+*/
+		if ($info->length !== $fields['meta'][$k]->length)
+			printf("[021 - %d] Expecting length %s/%s got %s/%s\n",
+				$k, gettype($info->length), $info->length, gettype($fields['meta'][$k]->length), $fields['meta'][$k]->length);
+
+		if ($info->charsetnr !== $fields['meta'][$k]->charsetnr)
+			printf("[022 - %d] Expecting charsetnr %s/%s got %s/%s\n",
+				$k, gettype($info->charsetnr), $info->charsetnr, gettype($fields['meta'][$k]->charsetnr), $fields['meta'][$k]->charsetnr);
+
+		if ($info->flags !== $fields['meta'][$k]->flags)
+			printf("[023 - %d] Expecting flags %s/%s got %s/%s\n",
+				$k, gettype($info->flags), $info->flags, gettype($fields['meta'][$k]->flags), $fields['meta'][$k]->flags);
+
+		if ($info->type !== $fields['meta'][$k]->type)
+			printf("[024 - %d] Expecting type %s/%s got %s/%s\n",
+				$k, gettype($info->type), $info->type, gettype($fields['meta'][$k]->type), $fields['meta'][$k]->type);
+
+		if ($info->decimals !== $fields['meta'][$k]->decimals)
+			printf("[025 - %d] Expecting decimals %s/%s got %s/%s\n",
+				$k, getdecimals($info->decimals), $info->decimals, getdecimals($fields['meta'][$k]->decimals), $fields['meta'][$k]->decimals);
+
+		/* Make them equal for the check */
+		$tmp = $fields['all_res'][$k]->max_length;
+		$fields['all_res'][$k]->max_length = $fields['all_meta'][$k]->max_length;
+
+		if ($fields['all_res'][$k] != $fields['all_meta'][$k]) {
+			printf("[026 - %d] fetch_fields() seems to have returned different data, dumping\n", $k);
+			var_dump($fields['all_res'][$k]);
+			var_dump($fields['all_meta'][$k]);
+		}
+		$fields['all_res'][$k]->max_length = $tmp;
+	}
+
+	$num = count($fields['res']);
+	for ($i = 0; $i < 100; $i++) {
+		$pos = mt_rand(-1, $num + 1);
+		if ($pos >= 0 && $pos < $num) {
+			if (true !== mysqli_field_seek($res, $pos))
+				printf("[027] field_seek(res) failed\n");
+			if (true !== $res_meta->field_seek($pos))
+				printf("[028] field_seek(res__meta) failed\n");
+
+			$tmp1 = $res->fetch_field();
+			$tmp2 = mysqli_fetch_field($res_meta);
+			$tmp2->max_length = $tmp1->max_length;
+			if ($tmp1 != $tmp2) {
+				printf("[029] Field info differs, dumping data\n");
+				var_dump($tmp1);
+				var_dump($tmp2);
+			}
+
+			if ($tmp1 != $fields['res'][$pos]) {
+				printf("[030] Field info differs, dumping data\n");
+				var_dump($tmp1);
+				var_dump($fields['res'][$pos]);
+			}
+
+			$pos++;
+			if ($pos !== ($tmp = mysqli_field_tell($res)))
+				printf("[031] Expecting %s/%s got %s/%s\n",
+					gettype($pos), $pos, gettype($tmp), $tmp);
+
+			if ($pos !== ($tmp = mysqli_field_tell($res_meta)))
+				printf("[032] Expecting %s/%s got %s/%s\n",
+					gettype($pos), $pos, gettype($tmp), $tmp);
+		} else {
+
+			if (false !== @mysqli_field_seek($res, $pos))
+				printf("[033] field_seek(%d) did not fail\n", $pos);
+			if (false !== @mysqli_field_seek($res_meta, $pos))
+				printf("[034] field_seek(%d) did not fail\n", $pos);
+		}
+	}
+
+	$res->free_result();
+	mysqli_free_result($res_meta);
+
+	var_dump(mysqli_fetch_field($res));
+
+	mysqli_stmt_close($stmt);
+
+	var_dump(mysqli_fetch_field($res));
+
+	mysqli_close($link);
+
+	var_dump(mysqli_fetch_field($res));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  int(1)
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+NULL
+bool(false)
+bool(false)
+id
+label
+_id
+_label
+_null
+_label_concat
+
+Warning: mysqli_fetch_field(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+
+Warning: mysqli_fetch_field(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+
+Warning: mysqli_fetch_field(): Couldn't fetch mysqli_result in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_metadata_fetch_field.phpt
@@ -0,0 +1,176 @@
+--TEST--
+mysqli_stmt_get_result() - meta data, field info
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_stmt_get_result'))
+	die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	require('table.inc');
+	$charsets = my_get_charsets($link);
+
+	if (!($stmt = mysqli_stmt_init($link)) ||
+		!mysqli_stmt_prepare($stmt, "SELECT id, label, id + 1 as _id,  concat(label, '_') ___label FROM test ORDER BY id ASC LIMIT 3") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[001] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[002] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (!is_object($res_meta = mysqli_stmt_result_metadata($stmt)) ||
+		'mysqli_result' != get_class($res_meta)) {
+		printf("[003] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	$i = 0;
+	while ($field = $res->fetch_field()) {
+		var_dump($field);
+		$i++;
+		if (2 == $i) {
+			/*
+			Label column, result set charset.
+			All of the following columns are "too hot" - too server dependent
+			*/
+			if ($field->charsetnr != $charsets['results']['nr']) {
+				printf("[004] Expecting charset %s/%d got %d\n",
+					$charsets['results']['charset'],
+					$charsets['results']['nr'], $field->charsetnr);
+			}
+			if ($field->length != (1 * $charsets['results']['maxlen'])) {
+				printf("[005] Expecting length %d got %d\n",
+					$charsets['results']['maxlen'],
+					$field->max_length);
+			}
+		}
+	}
+
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"orgname"]=>
+  %unicode|string%(5) "label"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(0)
+  [%u|b%"type"]=>
+  int(254)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(3) "_id"
+  [%u|b%"orgname"]=>
+  %unicode|string%(0) ""
+  [%u|b%"table"]=>
+  %unicode|string%(0) ""
+  [%u|b%"orgtable"]=>
+  %unicode|string%(0) ""
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(0) ""
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(32897)
+  [%u|b%"type"]=>
+  int(8)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+object(stdClass)#%d (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(8) "___label"
+  [%u|b%"orgname"]=>
+  %unicode|string%(0) ""
+  [%u|b%"table"]=>
+  %unicode|string%(0) ""
+  [%u|b%"orgtable"]=>
+  %unicode|string%(0) ""
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(0) ""
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(%d)
+  [%u|b%"length"]=>
+  int(%d)
+  [%u|b%"charsetnr"]=>
+  int(%d)
+  [%u|b%"flags"]=>
+  int(0)
+  [%u|b%"type"]=>
+  int(253)
+  [%u|b%"decimals"]=>
+  int(31)
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_non_select.phpt
@@ -0,0 +1,95 @@
+--TEST--
+mysqli_stmt_get_result() - SHOW, DESCRIBE, EXPLAIN
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_stmt_get_result'))
+	die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	/*
+	NOTE: no datatype tests here! This is done by
+	mysqli_stmt_bind_result.phpt already. Restrict
+	this test case to the basics.
+	*/
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (mysqli_query($link, 'PREPARE mystmt FROM "SHOW ENGINES"')) {
+		mysqli_query($link, 'DEALLOCATE PREPARE mystmt');
+
+		if (!$stmt->prepare('SHOW ENGINES') ||
+			!$stmt->execute())
+			printf("[002] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		if (!$res = $stmt->get_result())
+			printf("[003] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$engines = mysqli_fetch_all($res, MYSQLI_NUM);
+		if	(empty($engines)) {
+			printf("[004] It is very unlikely that SHOW ENGINES returns no data, check manually\n");
+		} else {
+			$found = false;
+			foreach ($engines as $k => $engine)
+				foreach ($engine as $k => $v)
+					if (stristr('MyISAM', $v)) {
+						$found = true;
+						break;
+					}
+			if (!$found)
+				printf("[005] It is very unlikely that SHOW ENGINES does not show MyISAM, check manually\n");
+		}
+		mysqli_free_result($res);
+	}
+
+	if (mysqli_query($link, 'PREPARE mystmt FROM "DESCRIBE test id"')) {
+		mysqli_query($link, 'DEALLOCATE PREPARE mystmt');
+
+		if (!$stmt->prepare('DESCRIBE test id') ||
+			!$stmt->execute())
+			printf("[006] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		if (!$res = $stmt->get_result())
+			printf("[007] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$description = mysqli_fetch_assoc($res);
+		if ($description['Field'] != 'id') {
+			printf("[008] Returned data seems wrong, [%d] %s\n",
+				mysqli_errno($link), mysqli_error($link));
+			var_dump($description);
+		}
+		mysqli_free_result($res);
+	}
+
+	if (mysqli_query($link, 'PREPARE mystmt FROM "EXPLAIN SELECT id FROM test"')) {
+		mysqli_query($link, 'DEALLOCATE PREPARE mystmt');
+
+		if (!$stmt->prepare('EXPLAIN SELECT id FROM test') ||
+			!$stmt->execute())
+			printf("[009] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		if (!$res = $stmt->get_result())
+			printf("[010] [%d] %s\n", $stmt->errno, $stmt->error);
+
+		$tmp = mysqli_fetch_assoc($res);
+		if (empty($tmp))
+			printf("[011] Empty EXPLAIN result set seems wrong, check manually, [%d] %s\n",
+				mysqli_errno($link), mysqli_error($link));
+		mysqli_free_result($res);
+	}
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_seek.phpt
@@ -0,0 +1,129 @@
+--TEST--
+mysqli_stmt_get_result() - seeking
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!function_exists('mysqli_stmt_get_result'))
+	die('skip mysqli_stmt_get_result not available');
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id ASC LIMIT 3"))
+		printf("[002] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[003] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($res = mysqli_stmt_get_result($stmt)) || 'mysqli_result' != get_class($res)) {
+		printf("[004] Expecting object/mysqli_result got %s/%s, [%d] %s\n",
+			gettype($res), $res, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (3 !== $res->num_rows)
+		printf("[005] Expecting 3 rows, got %s/%s rows\n", gettype($res->num_rows), $res->num_rows);
+
+	if (2 !== $res->field_count)
+		printf("[006] Expecting 2 fields, got %s/%s rows\n", gettype($res->field_count), $res->field_count);
+
+	if (0 !== $res->current_field)
+		printf("[006] Expecting offset 0, got %s/%s rows\n", gettype($res->current_field), $res->current_field);
+
+	for ($i = 2; $i > 0; $i--) {
+		if (!$res->data_seek($i))
+			printf("[007] Cannot seek to position %d, [%d] %s\n",
+				$i, mysqli_stmt_errno($stmt), $stmt->error);
+		$row = $res->fetch_array(MYSQLI_BOTH);
+		if (($row[0] !== $row['id']) || ($row[0] !== $i + 1)) {
+			printf("[008] Record looks wrong, dumping data\n");
+			var_dump($row);
+		} else {
+			unset($row[0]);
+			unset($row['id']);
+		}
+		if ($row[1] !== $row['label']) {
+			printf("[009] Record looks wrong, dumping data\n");
+			var_dump($row);
+		} else {
+			unset($row[1]);
+			unset($row['label']);
+		}
+		if (!empty($row)) {
+			printf("[010] Not empty, dumping unexpected data\n");
+			var_dump($row);
+		}
+	}
+
+	if (false !== ($tmp = $res->data_seek(-1)))
+		printf("[011] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $res->data_seek($res->num_rows + 1)))
+		printf("[012] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = $res->data_seek(PHP_INT_MAX + 1)))
+		printf("[013] Expecting boolean/false got %s/%s\n", gettype($tmp), $tmp);
+
+	for ($i = 0; $i < 100; $i++) {
+		/* intentionally out of range! */
+		$pos = mt_rand(-1, 4);
+		$tmp = mysqli_data_seek($res, $pos);
+		if (($pos >= 0 && $pos < 3)) {
+			if (true !== $tmp)
+				printf("[015] Expecting boolan/true got %s/%s\n", gettype($tmp), $tmp);
+			$row = $res->fetch_array(MYSQLI_NUM);
+			if ($row[0] !== $pos + 1)
+				printf("[016] Expecting id = %d for pos %d got %s/%s\n",
+					$pos + 1, $pos, gettype($row[0]), $row[0]);
+		} else {
+			if (false !== $tmp)
+				printf("[014] Expecting boolan/false got %s/%s\n", gettype($tmp), $tmp);
+		}
+	}
+
+	mysqli_stmt_close($stmt);
+
+	if (true !== ($tmp = mysqli_data_seek($res, 0)))
+		printf("[015] Expecting boolan/true got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_array($row = $res->fetch_array(MYSQLI_NUM)))
+		printf("[016] Expecting array got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_free_result($res);
+
+	if (NULL !== ($tmp = mysqli_data_seek($res, 0)))
+		printf("[017] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($row = $res->fetch_array(MYSQLI_NUM)))
+		printf("[018] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_data_seek($res, 0)))
+		printf("[019] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	if (NULL !== ($row = $res->fetch_array(MYSQLI_NUM)))
+		printf("[020] Expecting NULL got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+
+Warning: mysqli_data_seek(): Couldn't fetch mysqli_result in %s on line %d
+
+Warning: mysqli_result::fetch_array(): Couldn't fetch mysqli_result in %s on line %d
+
+Warning: mysqli_data_seek(): Couldn't fetch mysqli_result in %s on line %d
+
+Warning: mysqli_result::fetch_array(): Couldn't fetch mysqli_result in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_result_types.phpt
@@ -0,0 +1,259 @@
+--TEST--
+mysqli_stmt_get_result - data types
+--SKIPIF--
+<?php
+	require_once('skipif.inc');
+	require_once('skipifemb.inc');
+	require_once('skipifconnectfailure.inc');
+
+	if (!function_exists('mysqli_stmt_get_result'))
+		die("skip mysqli_stmt_get_result() not available");
+?>
+--FILE--
+<?php
+	require('connect.inc');
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	$hint_str_or_unicode = (version_compare(PHP_VERSION, '5.9.9', '>') == 1) ? 'unicode' : 'string';
+
+	function func_mysqli_stmt_get_result($link, $engine, $bind_type, $sql_type, $bind_value, $offset, $type_hint = null) {
+
+		if (!mysqli_query($link, "DROP TABLE IF EXISTS test")) {
+			printf("[%04d] [%d] %s\n", $offset, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT, label %s, PRIMARY KEY(id)) ENGINE = %s", $sql_type, $engine))) {
+			// don't bail - column type might not be supported by the server, ignore this
+			return false;
+		}
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%04d] [%d] %s\n", $offset + 1, mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)")) {
+			printf("[%04d] [%d] %s\n", $offset + 2, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		$id = null;
+		if (!mysqli_stmt_bind_param($stmt, "i" . $bind_type, $id, $bind_value)) {
+			printf("[%04d] [%d] %s\n", $offset + 3, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		for ($id = 1; $id < 4; $id++) {
+			if (!mysqli_stmt_execute($stmt)) {
+				printf("[%04d] [%d] %s\n", $offset + 3 + $id, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				mysqli_stmt_close($stmt);
+				return false;
+			}
+		}
+		mysqli_stmt_close($stmt);
+
+		$stmt = mysqli_stmt_init($link);
+
+		if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test")) {
+			printf("[%04d] [%d] %s\n", $offset + 7, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%04d] [%d] %s\n", $offset + 8, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		$result = mysqli_stmt_result_metadata($stmt);
+
+		if (!$res = mysqli_stmt_get_result($stmt)) {
+			printf("[%04d] [%d] %s\n", $offset + 9, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+		$num = 0;
+		$fields = mysqli_fetch_fields($result);
+
+		while ($row = mysqli_fetch_assoc($res)) {
+			$bind_res = &$row['label'];
+			if (!gettype($bind_res) == 'unicode') {
+				if ($bind_res !== $bind_value && (!$type_hint || ($type_hint !== gettype($bind_res)))) {
+					printf("[%04d] [%d] Expecting %s/'%s' [type hint = %s], got %s/'%s'\n",
+						$offset + 10, $num,
+						gettype($bind_value), $bind_value, $type_hint,
+						gettype($bind_res), $bind_res);
+						mysqli_free_result($res);
+						mysqli_stmt_close($stmt);
+						return false;
+				}
+			}
+			$num++;
+		}
+
+		if ($num != 3) {
+			printf("[%04d] [%d] %s, expecting 3 results, got only %d results\n",
+				$offset + 11, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt), $num);
+			mysqli_free_result($res);
+			mysqli_stmt_close($stmt);
+			return false;
+		}
+
+		mysqli_free_result($res);
+		mysqli_stmt_close($stmt);
+		return true;
+	}
+
+
+	function func_mysqli_stmt_bind_make_string($len) {
+
+		$ret = '';
+		for ($i = 0; $i < $len; $i++)
+			$ret .= chr(mt_rand(65, 90));
+
+		return $ret;
+	}
+
+	func_mysqli_stmt_get_result($link, $engine, "i", "TINYINT", -11, 20);
+	func_mysqli_stmt_get_result($link, $engine, "i", "TINYINT", NULL, 40);
+	func_mysqli_stmt_get_result($link, $engine, "i", "TINYINT UNSIGNED", 1, 60);
+	func_mysqli_stmt_get_result($link, $engine, "i", "TINYINT UNSIGNED", NULL, 80);
+
+	func_mysqli_stmt_get_result($link, $engine, "i", "BOOL", 1, 100);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BOOL", NULL, 120);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BOOLEAN", 0, 140);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BOOLEAN", NULL, 160);
+
+	func_mysqli_stmt_get_result($link, $engine, "i", "SMALLINT", -32768, 180);
+	func_mysqli_stmt_get_result($link, $engine, "i", "SMALLINT", 32767, 200);
+	func_mysqli_stmt_get_result($link, $engine, "i", "SMALLINT", NULL, 220);
+	func_mysqli_stmt_get_result($link, $engine, "i", "SMALLINT UNSIGNED", 65535, 240);
+	func_mysqli_stmt_get_result($link, $engine, "i", "SMALLINT UNSIGNED", NULL, 260);
+
+	func_mysqli_stmt_get_result($link, $engine, "d", "MEDIUMINT", -8388608, 280, "integer");
+	func_mysqli_stmt_get_result($link, $engine, "d", "MEDIUMINT", 8388607, 300, "integer");
+	func_mysqli_stmt_get_result($link, $engine, "d", "MEDIUMINT", NULL, 320);
+	func_mysqli_stmt_get_result($link, $engine, "d", "MEDIUMINT UNSIGNED", 16777215, 340, "integer");
+	func_mysqli_stmt_get_result($link, $engine, "d", "MEDIUMINT UNSIGNED", NULL, 360);
+
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER", (defined("PHP_INT_MAX")) ? max(-1 * PHP_INT_MAX + 1, -2147483648) : 1, 380);
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER", -2147483647, 400, "integer");
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER", (defined("PHP_INT_MAX")) ? min(2147483647, PHP_INT_MAX) : 1, 420);
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER", NULL, 440);
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER UNSIGNED", (defined("PHP_INT_MAX")) ? min(4294967295, 2147483647) : 1, 460);
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER UNSIGNED", 4294967295, 480, (defined("PHP_INT_MAX") && (4294967295 > PHP_INT_MAX)) ? "string" : null);
+	func_mysqli_stmt_get_result($link, $engine, "i", "INTEGER UNSIGNED", NULL, 500);
+
+	/* test is broken too: we bind "integer" but value is a float
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT", -9223372036854775808, 520);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT UNSIGNED", 18446744073709551615, 560);
+	*/
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT", NULL, 540);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT UNSIGNED", NULL, 580);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT", -1, 1780);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT UNSIGNED", 1, 1800);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT", -1 * PHP_INT_MAX + 1, 1820);
+	func_mysqli_stmt_get_result($link, $engine, "i", "BIGINT UNSIGNED", PHP_INT_MAX, 1840);
+	func_mysqli_stmt_get_result($link, $engine, "s", "BIGINT UNSIGNED", "18446744073709551615", 1860);
+	func_mysqli_stmt_get_result($link, $engine, "s", "BIGINT", "-9223372036854775808", 1880);
+
+	func_mysqli_stmt_get_result($link, $engine, "d", "FLOAT", -9223372036854775808 - 1.1, 600);
+	func_mysqli_stmt_get_result($link, $engine, "d", "FLOAT", NULL, 620);
+	func_mysqli_stmt_get_result($link, $engine, "d", "FLOAT UNSIGNED", 18446744073709551615 + 1.1, 640);
+	func_mysqli_stmt_get_result($link, $engine, "d", "FLOAT UNSIGNED ", NULL, 660);
+
+	// Yes, we need the temporary variable. The PHP casting will fouls us otherwise.
+	$tmp = strval('-99999999.99');
+	func_mysqli_stmt_get_result($link, $engine, "d", "DOUBLE(10,2)", $tmp, 680, "string");
+	func_mysqli_stmt_get_result($link, $engine, "d", "DOUBLE(10,2)", NULL, 700);
+	$tmp = strval('99999999.99');
+	func_mysqli_stmt_get_result($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", $tmp , 720, "string");
+	func_mysqli_stmt_get_result($link, $engine, "d", "DOUBLE(10,2) UNSIGNED", NULL, 740);
+	$tmp = strval('-99999999.99');
+	func_mysqli_stmt_get_result($link, $engine, "d", "DECIMAL(10,2)", $tmp, 760, "string");
+	func_mysqli_stmt_get_result($link, $engine, "d", "DECIMAL(10,2)", NULL, 780);
+	$tmp = strval('99999999.99');
+	func_mysqli_stmt_get_result($link, $engine, "d", "DECIMAL(10,2)", $tmp, 800, "string");
+	func_mysqli_stmt_get_result($link, $engine, "d", "DECIMAL(10,2)", NULL, 820);
+
+	// don't care about date() strict TZ warnings...
+	func_mysqli_stmt_get_result($link, $engine, "s", "DATE", @date('Y-m-d'), 840);
+	func_mysqli_stmt_get_result($link, $engine, "s", "DATE NOT NULL", @date('Y-m-d'), 860);
+	func_mysqli_stmt_get_result($link, $engine, "s", "DATE", NULL, 880);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "DATETIME", @date('Y-m-d H:i:s'), 900);
+	func_mysqli_stmt_get_result($link, $engine, "s", "DATETIME NOT NULL", @date('Y-m-d H:i:s'), 920);
+	func_mysqli_stmt_get_result($link, $engine, "s", "DATETIME", NULL, 940);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "TIMESTAMP", @date('Y-m-d H:i:s'), 960);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "TIME", @date('H:i:s'), 980);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TIME NOT NULL", @date('H:i:s'), 1000);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TIME", NULL, 1020);
+
+	$tmp = intval(@date('Y'));
+	func_mysqli_stmt_get_result($link, $engine, "s", "YEAR", $tmp, 1040, "integer");
+	func_mysqli_stmt_get_result($link, $engine, "s", "YEAR NOT NULL", $tmp, 1060, "integer");
+	func_mysqli_stmt_get_result($link, $engine, "s", "YEAR", NULL, 1080);
+
+	$string255 = func_mysqli_stmt_bind_make_string(255);
+	func_mysqli_stmt_get_result($link, $engine, "s", "CHAR(1)", "a", 1110, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "CHAR(255)", $string255, 1120, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "CHAR(1) NOT NULL", "a", 1140, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "CHAR(1)", NULL, 1160);
+
+	$string65k = func_mysqli_stmt_bind_make_string(65535);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARCHAR(1)", "a", 1180, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARCHAR(255)", $string255, 1200, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARCHAR(65635)", $string65k, 1220, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARCHAR(1) NOT NULL", "a", 1240, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARCHAR(1)", NULL, 1260);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "BINARY(1)", "a", 1280);
+	func_mysqli_stmt_get_result($link, $engine, "s", "BINARY(1)", chr(0), 1300);
+	func_mysqli_stmt_get_result($link, $engine, "s", "BINARY(1) NOT NULL", "b", 1320);
+	func_mysqli_stmt_get_result($link, $engine, "s", "BINARY(1)", NULL, 1340);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARBINARY(1)", "a", 1360);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARBINARY(1)", chr(0), 1380);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARBINARY(1) NOT NULL", "b", 1400);
+	func_mysqli_stmt_get_result($link, $engine, "s", "VARBINARY(1)", NULL, 1420);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYBLOB", "a", 1440);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYBLOB", chr(0), 1460);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYBLOB NOT NULL", "b", 1480);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYBLOB", NULL, 1500);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYTEXT", "a", 1520, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYTEXT NOT NULL", "a", 1540, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "TINYTEXT", NULL, 1560, $hint_str_or_unicode);
+
+	// Note: you cannot insert any blob values this way. But you can check the API at least partly this way
+	// Extra BLOB tests are in mysqli_stmt_send_long()
+	func_mysqli_stmt_get_result($link, $engine, "b", "BLOB", b"", 1580);
+	func_mysqli_stmt_get_result($link, $engine, "b", "TEXT", "", 1600, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "b", "MEDIUMBLOB", b"", 1620);
+	func_mysqli_stmt_get_result($link, $engine, "b", "MEDIUMTEXT", "", 1640, $hint_str_or_unicode);
+
+	/* Is this one related? http://bugs.php.net/bug.php?id=35759 */
+	func_mysqli_stmt_get_result($link, $engine, "b", "LONGBLOB", "", 1660);
+	func_mysqli_stmt_get_result($link, $engine, "b", "LONGTEXT", "", 1680, $hint_str_or_unicode);
+
+	func_mysqli_stmt_get_result($link, $engine, "s", "ENUM('a', 'b')", "a", 1700, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "ENUM('a', 'b')", NULL, 1720, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "SET('a', 'b')", "a", 1740, $hint_str_or_unicode);
+	func_mysqli_stmt_get_result($link, $engine, "s", "SET('a', 'b')", NULL, 1760, $hint_str_or_unicode);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_get_warnings.phpt
@@ -0,0 +1,107 @@
+--TEST--
+mysqli_stmt_get_warnings() - TODO
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+require_once("connect.inc");
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	die(sprintf("skip Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket));
+}
+
+if (!mysqli_query($link, "DROP TABLE IF EXISTS test") ||
+	!mysqli_query($link, "CREATE TABLE test(id SMALLINT)"))
+	die(sprintf("skip [%d] %s\n", $link->errno, $link->error));
+
+if (!@mysqli_query("INSERT INTO test(id) VALUES (100001)"))
+	die("skip Strict sql mode seems to be active. We won't get a warning to check for.");
+
+mysqli_query($link, "DROP TABLE IF EXISTS test");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_get_warnings()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_get_warnings($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = mysqli_stmt_get_warnings($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "DROP TABLE IF EXISTS test") || !mysqli_stmt_execute($stmt))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = mysqli_stmt_get_warnings($stmt)))
+		printf("[006] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "CREATE TABLE test(id SMALLINT, label CHAR(1))") || !mysqli_stmt_execute($stmt))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = mysqli_stmt_get_warnings($stmt)))
+		printf("[008] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (100000, 'a'), (100001, 'b')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object($warning = mysqli_stmt_get_warnings($stmt)))
+		printf("[010] Expecting mysqli_warning object, got %s/%s\n", gettype($warning), $warning);
+
+	if ('mysqli_warning' !== get_class($warning))
+		printf("[011] Expecting object of type mysqli_warning got type '%s'", get_class($warning));
+
+	if (!method_exists($warning, 'next'))
+		printf("[012] Object mysqli_warning seems to lack method next()\n");
+
+	$i = 0;
+	do {
+
+		if ('' == $warning->message)
+			printf("[013 - %d] Message should not be empty\n", $i);
+
+		if ('' == $warning->sqlstate)
+			printf("[014 - %d] SQL State should not be empty\n", $i);
+
+		if (0 == $warning->errno)
+			printf("[015 - %d] Error number should not be zero\n", $i);
+
+		$i++;
+
+	} while ($warning->next());
+
+	if (2 != $i)
+		printf("[016] Expected 2 warnings, got %d warnings\n", $i);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_get_warnings($stmt)))
+		printf("[015] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_get_warnings(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_get_warnings(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_init.phpt
@@ -0,0 +1,58 @@
+--TEST--
+mysqli_stmt_init()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	/*
+	NOTE: no datatype tests here! This is done by
+	mysqli_stmt_bind_result.phpt already. Restrict
+	this test case to the basics.
+	*/
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_init()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_init($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_object($stmt = mysqli_stmt_init($link)))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($stmt2 = @mysqli_stmt_init($link)))
+		printf("[003a] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_init($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_stmt_init($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_close(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_init() expects parameter 1 to be mysqli, object given in %s on line %d
+
+Warning: mysqli_stmt_init(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_insert_id.phpt
@@ -0,0 +1,77 @@
+--TEST--
+mysqli_stmt_insert_id()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_insert_id()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	$stmt = @new mysqli_stmt($link);
+	if (!is_null($tmp = @mysqli_insert_id($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	$stmt = mysqli_stmt_init($link);
+	if (NULL !== ($tmp = @mysqli_stmt_insert_id($stmt)))
+		printf("[003] Expecting NULL/NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test ORDER BY id LIMIT 1") ||
+		!mysqli_stmt_execute($stmt)) {
+		printf("[004] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (0 !== ($tmp = mysqli_stmt_insert_id($stmt)))
+		printf("[005] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+	mysqli_stmt_close($stmt);
+
+	// no auto_increment column
+	$stmt = mysqli_stmt_init($link);
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (100, 'a')") ||
+		!mysqli_stmt_execute($stmt)) {
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (0 !== ($tmp = mysqli_stmt_insert_id($stmt)))
+		printf("[007] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (mysqli_get_server_version($link) > 50000 &&
+		(!mysqli_stmt_prepare($stmt, "ALTER TABLE test MODIFY id INT NOT NULL AUTO_INCREMENT") ||
+		!mysqli_stmt_execute($stmt))) {
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	} else if (mysqli_get_server_version($link) < 50000){
+		mysqli_query($link, "ALTER TABLE test MODIFY id INT NOT NULL AUTO_INCREMENT");
+	}
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(label) VALUES ('a')") ||
+		!mysqli_stmt_execute($stmt)) {
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+	if (0 === ($tmp = mysqli_stmt_insert_id($stmt)))
+		printf("[010] Expecting int/any non zero, got %s/%s\n", gettype($tmp), $tmp);
+	mysqli_stmt_close($stmt);
+
+	mysqli_close($link);
+
+	var_dump(mysqli_stmt_insert_id($stmt));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_insert_id(): Couldn't fetch mysqli_stmt in %s on line %d
+NULL
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_num_rows.phpt
@@ -0,0 +1,118 @@
+--TEST--
+mysqli_stmt_num_rows()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_num_rows()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_num_rows($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	function func_test_mysqli_stmt_num_rows($stmt, $query, $expected, $offset) {
+
+		if (!mysqli_stmt_prepare($stmt, $query)) {
+			printf("[%03d] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_execute($stmt)) {
+			printf("[%03d] [%d] %s\n", $offset + 1, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if (!mysqli_stmt_store_result($stmt)) {
+			printf("[%03d] [%d] %s\n", $offset + 2, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+			return false;
+		}
+
+		if ($expected !== ($tmp = mysqli_stmt_num_rows($stmt)))
+			printf("[%03d] Expecting %s/%d, got %s/%d\n", $offset + 3,
+				gettype($expected), $expected,
+				gettype($tmp), $tmp);
+
+		mysqli_stmt_free_result($stmt);
+
+		return true;
+	}
+
+	func_test_mysqli_stmt_num_rows($stmt, "SELECT 1 AS a", 1, 10);
+	func_test_mysqli_stmt_num_rows($stmt, "SHOW VARIABLES LIKE '%nixnutz%'", 0, 20);
+	// Note: for statements that return no result set mysqli_num_rows() differs from mysqli_stmt_num_rows() slightly
+	// mysqli_num_rows() failed to fetch the result set and the PHP parameter check makes it return NULL
+	// mysqli_stmt_numrows() has a valid resource to work on and it will return int/0 instead. No bug, but
+	// slightly different behaviour... - if you really check the data types and don't rely on casting like 98% of all PHP
+	// users do.
+	func_test_mysqli_stmt_num_rows($stmt, "INSERT INTO test(id, label) VALUES (100, 'z')", 0, 30);
+
+	if ($res = mysqli_query($link, 'SELECT COUNT(id) AS num FROM test')) {
+		$row = mysqli_fetch_assoc($res);
+		mysqli_free_result($res);
+		func_test_mysqli_stmt_num_rows($stmt, "SELECT id, label FROM test", (int)$row['num'], 40);
+	} else {
+		printf("[050] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	}
+
+	print "run_tests.php don't fool me with your 'ungreedy' expression '.+?'!\n";
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id FROM test'))
+		printf("[051] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (mysqli_stmt_execute($stmt)) {
+
+		$i = 0;
+		do {
+			if (0 !== ($tmp = mysqli_stmt_num_rows($stmt)))
+				printf("[53 - %03d] Expecting int/0, got %s/%s\n", $i, gettype($tmp), $tmp);
+			$i++;
+		} while (mysqli_stmt_fetch($stmt));
+
+		/* NOTE to users
+		Behaviour with libmysql is UNDEFINED, see http://news.php.net/php.internals/55210
+		Because it is undefined it is allowed to the mysqlnd DEVELOPER to implement
+		any behaviour they like, including the one checked for in this test.
+		What the test does is cover an implementation detail of the mysqlnd library.
+		This implementation detail may, at any time, change without prior notice.
+		On the contrary, the mysqlnd way is a reasonable one and, maybe, one fine
+		day, after Klingons visited earh, becomes the official one. Meanwhile do
+		not rely on it.
+		*/
+		if ($IS_MYSQLND && (7 !== ($tmp = mysqli_stmt_num_rows($stmt))))
+			printf("[54] Expecting int/7, got %s/%s\n", gettype($tmp), $tmp);
+
+	} else {
+		printf("[055] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_num_rows($stmt)))
+		printf("[056] Expecting NULL, got %s/%s\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+run_tests.php don't fool me with your 'ungreedy' expression '.+?'!
+
+Warning: mysqli_stmt_num_rows(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_param_count.phpt
@@ -0,0 +1,72 @@
+--TEST--
+mysqli_stmt_param_count()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_param_count()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_param_count($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = mysqli_stmt_param_count($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	function func_test_mysqli_stmt_param_count($stmt, $query, $expected, $offset) {
+
+		if (!mysqli_stmt_prepare($stmt, $query)) {
+			printf("[%03d] [%d] %s\n", $offset, mysqli_stmt_errno($stmt), mysqli_error($stmt));
+			return false;
+		}
+
+		if ($expected !== ($tmp = mysqli_stmt_param_count($stmt)))
+			printf("[%03d] Expecting %s/%d, got %s/%d\n", $offset + 3,
+				gettype($expected), $expected,
+				gettype($tmp), $tmp);
+		return true;
+	}
+
+	func_test_mysqli_stmt_param_count($stmt, "SELECT 1 AS a", 0, 10);
+	func_test_mysqli_stmt_param_count($stmt, "INSERT INTO test(id) VALUES (?)", 1, 20);
+	func_test_mysqli_stmt_param_count($stmt, "INSERT INTO test(id, label) VALUES (?, ?)", 2, 30);
+	func_test_mysqli_stmt_param_count($stmt, "INSERT INTO test(id, label) VALUES (?, '?')", 1, 40);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_param_count($stmt)))
+		printf("[40] Expecting NULL, got %s/%s\n");
+
+	mysqli_close($link);
+
+	/* Check that the function alias exists. It's a deprecated function,
+	but we have not announce the removal so far, therefore we need to check for it */
+	if (!is_null($tmp = @mysqli_stmt_param_count()))
+		printf("[041] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_param_count(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_param_count(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_prepare.phpt
@@ -0,0 +1,56 @@
+--TEST--
+mysqli_stmt_prepare()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	// Note: No SQL tests here! We can expand one of the *fetch()
+	// tests to a generic SQL test, if we ever need that.
+	// We would duplicate the SQL test cases if we have it here and in one of the
+	// fetch tests, because the fetch tests would have to call prepare/execute etc.
+	// anyway.
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_prepare()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_prepare($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = @mysqli_stmt_prepare($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (false !== ($tmp = mysqli_stmt_prepare($stmt, '')))
+		printf("[005] Expecting boolean/false, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_stmt_prepare($stmt, 'SELECT id FROM test')))
+		printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_prepare($stmt, "SELECT id FROM test")))
+		printf("[007] Expecting NULL, got %s/%s\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_prepare(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_reset.phpt
@@ -0,0 +1,112 @@
+--TEST--
+mysqli_stmt_reset()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	// Note: No SQL tests here! We can expand one of the *fetch()
+	// tests to a generic SQL test, if we ever need that.
+	// We would duplicate the SQL test cases if we have it here and in one of the
+	// fetch tests, because the fetch tests would have to call prepare/execute etc.
+	// anyway.
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_reset()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_reset($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = mysqli_stmt_reset($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_stmt_prepare($stmt, 'SELECT id FROM test')))
+		printf("[005] Expecting boolean/true, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_reset($stmt)))
+		printf("[006] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (true !== ($tmp = mysqli_stmt_execute($stmt)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	$id = null;
+	if (!mysqli_stmt_bind_result($stmt, $id))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_fetch($stmt))
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	var_dump($id);
+	mysqli_stmt_close($stmt);
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[011] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT, label BLOB, PRIMARY KEY(id))"))
+		printf("[012] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(label) VALUES (?)"))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$label = null;
+	if (!mysqli_stmt_bind_param($stmt, "b", $label))
+		printf("[014] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$label = 'abc';
+	for ($i = 0; $i < 10; $i++) {
+		if (!mysqli_stmt_send_long_data($stmt, 0, $label))
+			printf("[015 - %d] [%d] %s\n", $i, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+
+	if (!mysqli_stmt_reset($stmt))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_execute($stmt))
+		printf("[017] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!$res = mysqli_query($link, "SELECT label FROM test"))
+		printf("[018] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if ($row['label'] != '')
+		printf("[020] Expecting empty string, got string/%s\n", $row['label']);
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_reset($stmt)))
+		printf("[021] Expecting NULL, got %s/%s\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_reset(): invalid object or resource mysqli_stmt
+ in %s on line %d
+int(1)
+
+Warning: mysqli_stmt_reset(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_result_metadata.phpt
@@ -0,0 +1,134 @@
+--TEST--
+mysqli_stmt_result_metadata()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_result_metadata()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_result_metadata($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = mysqli_stmt_result_metadata($stmt)))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id, label FROM test"))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!is_object(($res = mysqli_stmt_result_metadata($stmt))))
+		printf("[006] Expecting object, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (2 !== ($tmp = mysqli_num_fields($res)))
+		printf("[007] Expecting int/2, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($field0_fetch = mysqli_fetch_field($res)))
+		printf("[008] Expecting object, got %s/%s, [%d] %s\n",
+			gettype($field0_fetch), $field0_fetch, mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($field0_direct = mysqli_fetch_field_direct($res, 0)))
+		printf("[009] Expecting object, got %s/%s, [%d] %s\n",
+			gettype($field0_direct), $field0_direct, mysqli_errno($link), mysqli_error($link));
+
+	if ($field0_fetch != $field0_direct) {
+		printf("[010] mysqli_fetch_field() differs from mysqli_fetch_field_direct()\n");
+		var_dump($field0_fetch);
+		var_dump($field0_direct);
+	}
+
+	var_dump($field0_fetch);
+
+	if (!is_array($tmp = mysqli_fetch_fields($res)))
+		printf("[011] Expecting array, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	if (empty($tmp[0]) || empty($tmp[1]) || $tmp[0] != $field0_direct) {
+		printf("[012] mysqli_fetch_fields() return value is suspicious\n");
+		var_dump($tmp);
+	}
+
+	if (!mysqli_field_seek($res, 1))
+		printf("[013] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($field1_direct = mysqli_fetch_field_direct($res, 1)))
+		printf("[014] Expecting object, got %s/%s, [%d] %s\n",
+			gettype($field1_direct), $field1_direct, mysqli_errno($link), mysqli_error($link));
+
+	if ($tmp[1] != $field1_direct) {
+		printf("[015] mysqli_fetch_field_direct() differs from mysqli_fetch_fields()\n");
+		var_dump($field1_direct);
+		var_dump($tmp);
+	}
+
+	if (1 !== ($tmp = mysqli_field_tell($res)))
+		printf("[016] Expecting int/1, got %s/%s, [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_result_metadata($stmt)))
+		printf("[017] Expecting NULL, got %s/%s\n");
+
+	/* Check that the function alias exists. It's a deprecated function,
+	but we have not announce the removal so far, therefore we need to check for it */
+	if (!is_null($tmp = @mysqli_stmt_result_metadata()))
+		printf("[018] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+
+Warning: mysqli_stmt_result_metadata(): invalid object or resource mysqli_stmt
+ in %s on line %d
+object(stdClass)#5 (13) {
+  [%u|b%"name"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"orgname"]=>
+  %unicode|string%(2) "id"
+  [%u|b%"table"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"orgtable"]=>
+  %unicode|string%(4) "test"
+  [%u|b%"def"]=>
+  %unicode|string%(0) ""
+  [%u|b%"db"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"catalog"]=>
+  %unicode|string%(%d) "%s"
+  [%u|b%"max_length"]=>
+  int(0)
+  [%u|b%"length"]=>
+  int(11)
+  [%u|b%"charsetnr"]=>
+  int(63)
+  [%u|b%"flags"]=>
+  int(49155)
+  [%u|b%"type"]=>
+  int(3)
+  [%u|b%"decimals"]=>
+  int(0)
+}
+
+Warning: mysqli_stmt_result_metadata(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_result_metadata_sqltests.phpt
@@ -0,0 +1,232 @@
+--TEST--
+mysqli_stmt_result_metadata() - non SELECT statements
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+die("skip Check again when the Klingons visit earth - http://bugs.mysql.com/bug.php?id=42490");
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	function testStatement($offset, $link, $sql, $expected_lib, $expected_mysqlnd, $check_mysqlnd, $compare) {
+
+		if (!$stmt = mysqli_stmt_init($link)) {
+			printf("[%04d - %s] [%d] %s\n",
+				$offset, $sql,
+				mysqli_errno($link), mysqli_error($link));
+			return false;
+		}
+
+		if (!@mysqli_stmt_prepare($stmt, $sql)) {
+			/* Not all server versions will support all statements */
+			/* Failing to prepare is OK */
+			return true;
+		}
+
+		if (empty($expected_lib) && (false !== $res)) {
+			printf("[%04d - %s] No metadata expected\n",
+				$offset + 1, $sql);
+			return false;
+		} else if (!empty($expected_lib) && (false == $res)) {
+			printf("[%04d - %s] Metadata expected\n",
+				$offset + 2, $sql);
+			return false;
+		}
+		if (!empty($expected_lib)) {
+			if (!is_object($res)) {
+				printf("[%04d - %s] [%d] %s\n",
+					$offset + 3, $sql,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+			if (get_class($res) != 'mysqli_result') {
+				printf("[%04d - %s] Expecting object/mysqli_result got object/%s\n",
+					$offset + 4, $sql, get_class($res));
+				return false;
+			}
+
+			$meta = array(
+				'num_fields'		=> mysqli_num_fields($res),
+				'fetch_field'		=> mysqli_fetch_field($res),
+				'fetch_field_direct0'	=> mysqli_fetch_field_direct($res, 0),
+				'fetch_field_direct1'	=> @mysqli_fetch_field_direct($res, 1),
+				'fetch_fields'		=> count(mysqli_fetch_fields($res)),
+				'field_count'		=> $res->field_count,
+				'field_seek-1'		=> @mysqli_field_seek($res, -1),
+				'field_seek0'		=> mysqli_field_seek($res, 0),
+				'field_tell'		=> mysqli_field_tell($res),
+			);
+			if (is_object($meta['fetch_field'])) {
+				$meta['fetch_field']->charsetnr	= 'ignore';
+				$meta['fetch_field']->flags	= 'ignore';
+			}
+			if (is_object($meta['fetch_field_direct0'])) {
+				$meta['fetch_field_direct0']->charsetnr	= 'ignore';
+				$meta['fetch_field_direct0']->flags	= 'ignore';
+			}
+			if (is_object($meta['fetch_field_direct1'])) {
+				$meta['fetch_field_direct1']->charsetnr	= 'ignore';
+				$meta['fetch_field_direct1']->flags	= 'ignore';
+			}
+			mysqli_free_result($res);
+
+			if ($meta != $expected_lib) {
+				printf("[%04d - %s] Metadata differes from expected values\n",
+					$offset + 5, $sql);
+				var_dump($meta);
+				var_dump($expected_lib);
+				return false;
+			}
+		}
+
+		if (function_exists('mysqli_stmt_get_result')) {
+			/* mysqlnd only */
+			if (!mysqli_stmt_execute($stmt)) {
+				printf("[%04d - %s] [%d] %s\n",
+					$offset + 6, $sql,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			$res = mysqli_stmt_get_result($stmt);
+			if (false === $res && !empty($expected_mysqlnd)) {
+				printf("[%04d - %s] Expecting resultset [%d] %s\n",
+					$offset + 7, $sql,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			} else if (empty($expected_mysqlnd) && false !== $res) {
+				printf("[%04d - %s] Unexpected resultset [%d] %s\n",
+					$offset + 8, $sql,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+
+			if (!is_object($res)) {
+				printf("[%04d - %s] [%d] %s\n",
+					$offset + 9, $sql,
+					mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+				return false;
+			}
+			if ('mysqli_result' != get_class($res)) {
+				printf("[%04d - %s] Expecting object/mysqli_result got object/%s\n",
+					$offset + 10, $sql,
+					get_class($res));
+				return false;
+			}
+
+			$meta_res = array(
+				'num_fields'		=> mysqli_num_fields($res),
+				'fetch_field'		=> mysqli_fetch_field($res),
+				'fetch_field_direct0'	=> mysqli_fetch_field_direct($res, 0),
+				'fetch_field_direct1'	=> @mysqli_fetch_field_direct($res, 1),
+				'fetch_fields'		=> count(mysqli_fetch_fields($res)),
+				'field_count'		=> mysqli_field_count($link),
+				'field_seek-1'		=> @mysqli_field_seek($res, -1),
+				'field_seek0'		=> mysqli_field_seek($res, 0),
+				'field_tell'		=> mysqli_field_tell($res),
+			);
+			if (is_object($meta_res['fetch_field'])) {
+				$meta_res['fetch_field']->charsetnr	= 'ignore';
+				$meta_res['fetch_field']->flags	= 'ignore';
+			}
+			if (is_object($meta_res['fetch_field_direct0'])) {
+				$meta_res['fetch_field_direct0']->charsetnr	= 'ignore';
+				$meta_res['fetch_field_direct0']->flags	= 'ignore';
+			}
+			if (is_object($meta_res['fetch_field_direct1'])) {
+				$meta_res['fetch_field_direct1']->charsetnr	= 'ignore';
+				$meta_res['fetch_field_direct1']->flags	= 'ignore';
+			}
+			mysqli_free_result($res);
+			if ($check_mysqlnd && $meta_res != $expected_mysqlnd) {
+				printf("[%04d - %s] Metadata differs from expected\n",
+					$offset + 11, $sql);
+				var_dump($meta_res);
+				var_dump($expected_mysqlnd);
+			} else {
+				if ($meta_res['field_count'] < 1) {
+					printf("[%04d - %s] Metadata seems wrong, no fields?\n",
+					$offset + 12, $sql);
+					var_dump($meta_res);
+					var_dump(mysqli_fetch_assoc($res));
+				}
+			}
+
+			if ($compare && $meta_res != $meta) {
+				printf("[%04d - %s] Metadata returned by mysqli_stmt_result_metadata() and mysqli_stmt_get_result() differ\n",
+					$offset + 13, $sql);
+				var_dump($meta_res);
+				var_dump($meta);
+			}
+
+		}
+
+		mysqli_stmt_close($stmt);
+		return true;
+	}
+
+	/* Note: very weak testing, we accept almost any result */
+
+	testStatement(100, $link, 'ANALYZE TABLE test', array(), array(1), false, false);
+	testStatement(120, $link, 'OPTIMIZE TABLE test', array(), array(1), false, false);
+	testStatement(140, $link, 'REPAIR TABLE test', array(), array(1), false, false);
+
+	testStatement(160, $link, 'SHOW AUTHORS', array(), array(1), false, false);
+	testStatement(180, $link, 'SHOW CHARACTER SET', array(), array(1), false, false);
+	testStatement(200, $link, 'SHOW COLLATION', array(), array(1), false, false);
+	testStatement(220, $link, 'SHOW CONTRIBUTORS', array(), array(1), false, false);
+	testStatement(240, $link, 'SHOW CREATE DATABASE ' . $db, array(), array(1), false, false);
+	testStatement(260, $link, 'SHOW DATABASES', array(), array(1), false, false);
+	testStatement(280, $link, 'SHOW ENGINE InnoDB STATUS', array(), array(1), false, false);
+	testStatement(300, $link, 'SHOW ENGINES', array(), array(1), false, false);
+	testStatement(320, $link, 'SHOW PLUGINS', array(), array(1), false, false);
+	testStatement(340, $link, 'SHOW PROCESSLIST', array(), array(1), false, false);
+	testStatement(360, $link, 'SHOW FULL PROCESSLIST', array(), array(1), false, false);
+	testStatement(380, $link, 'SHOW STATUS', array(), array(1), false, false);
+	testStatement(400, $link, 'SHOW TABLE STATUS', array(), array(1), false, false);
+	testStatement(420, $link, 'SHOW TABLE STATUS', array(), array(1), false, false);
+	testStatement(440, $link, 'SHOW TABLES', array(), array(1), false, false);
+	testStatement(460, $link, 'SHOW OPEN TABLES', array(), array(1), false, false);
+	testStatement(460, $link, 'SHOW VARIABLES', array(), array(1), false, false);
+
+	$field0 = new stdClass();
+	$field0->name 		= 'id';
+	$field0->orgname 	= 'id';
+	$field0->table		= 'test';
+	$field0->orgtable	= 'test';
+	$field0->def 		= '';
+	$field0->max_length	= 0;
+	$field0->length		= 11;
+	$field0->charsetnr	= 'ignore';
+	$field0->flags		= 'ignore';
+	$field0->type		= MYSQLI_TYPE_LONG;
+	$field0->decimals	= 0;
+	$meta_lib = array(
+		'num_fields'		=> 1,
+		'fetch_field'		=> $field0,
+		'fetch_field_direct0'	=> $field0,
+		'fetch_field_direct1'	=> false,
+		'fetch_fields'		=> 1,
+		'field_count'		=> 1,
+		'field_seek-1'		=> false,
+		'field_seek0'		=> true,
+		'field_tell'		=> 0,
+	);
+	$meta_mysqlnd = $meta_lib;
+	testStatement(480, $link, 'SELECT id FROM test', $meta_lib, $meta_mysqlnd, true, true);
+
+	testStatement(500, $link, 'CHECKSUM TABLE test', array(), array(1), false, false);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_send_long_data.phpt
@@ -0,0 +1,135 @@
+--TEST--
+mysqli_stmt_send_long_data()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_send_long_data()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_send_long_data($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = @mysqli_stmt_send_long_data($stmt, '')))
+		printf("[004] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[005] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT, label LONGBLOB, PRIMARY KEY(id)) ENGINE = %s", $engine)))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[007] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	$label = null;
+	if (!mysqli_stmt_bind_param($stmt, "ib", $id, $label))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!$res = mysqli_query($link, "SHOW VARIABLES LIKE 'max_allowed_packet'"))
+		printf("[009] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (isset($row['VARIABLE_VALUE']) && !isset($row['Value']))
+		// MySQL 6.0
+		$row['Value'] = $row['VARIABLE_VALUE'];
+
+	if (0 === ($max_allowed_packet = (int)$row['Value']))
+		printf("[011] Cannot determine max_allowed_packet size and/or bogus max_allowed_packet setting used.\n");
+
+	// let's ignore upper limits for LONGBLOB (2^32) ...
+	// maximum packet size up to which we test is 10M
+	$tmp = '';
+	$blob = '';
+	for ($i = 0; $i < 1024; $i++) {
+		$tmp .= 'a';
+	}
+
+	$limit = min(floor($max_allowed_packet / 1024 / 2), 10240);
+	for ($i = 0; $i < $limit; $i++)
+			$blob .= $tmp;
+	/*
+	if (floor($max_allowed_packet / 1024) <= 10240) {
+			$limit = strlen($blob) - $max_allowed_packet - 1;
+			for ($i = 0; $i < $limit; $i++)
+					$blob .= 'a';
+	}
+	*/
+	assert(strlen($blob) <= $max_allowed_packet);
+
+	if (false !== ($tmp = mysqli_stmt_send_long_data($stmt, -1, $blob)))
+		printf("[012] Expecting boolean/false, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = @mysqli_stmt_send_long_data($stmt, PHP_INT_MAX + 1, $blob)))
+		printf("[013] Expecting boolean/false, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (false !== ($tmp = mysqli_stmt_send_long_data($stmt, 999, $blob)))
+		printf("[014] Expecting boolean/false, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = mysqli_stmt_send_long_data($stmt, 1, $blob)))
+		printf("[015] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[016] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	mysqli_stmt_close($stmt);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[017] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (1 != ($tmp = mysqli_num_rows($res)))
+		printf("[018] Expecting 1 rows, mysqli_num_rows() reports %d rows. [%d] %s\n",
+			$tmp, mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[019] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (empty($row['id']) || empty($row['label']) || ($row['id'] != 1))
+		printf("[020] Record seems to be incomplete\n");
+
+	if ($blob != $row['label'])
+		printf("[021] Blob value has not been stored properly!\n");
+
+	if (NULL !== ($tmp = @mysqli_stmt_send_long_data($stmt, '')))
+		printf("[022] Expecting NULL, got %s/%s\n");
+
+	/* Check that the function alias exists. It's a deprecated function,
+	but we have not announce the removal so far, therefore we need to check for it */
+	if (!is_null($tmp = @mysqli_stmt_send_long_data()))
+		printf("[023] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_send_long_data(): Invalid parameter number in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_send_long_data_packet_size_libmysql.phpt
@@ -0,0 +1,98 @@
+--TEST--
+mysqli_stmt_send_long_data() - exceed packet size, libmysql - bug #26824
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (stristr(mysqli_get_client_info(), 'mysqlnd'))
+	die("skip: test for libmysql");
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT, label LONGBLOB, PRIMARY KEY(id)) ENGINE = %s", $engine)))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[004] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	$label = null;
+	if (!mysqli_stmt_bind_param($stmt, "ib", $id, $label))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!$res = mysqli_query($link, "SHOW VARIABLES LIKE 'max_allowed_packet'"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (0 === ($max_allowed_packet = (int)$row['Value']))
+		printf("[008] Cannot determine max_allowed_packet size and/or bogus max_allowed_packet setting used.\n");
+
+	// let's ignore upper limits for LONGBLOB (2^32) ...
+	// maximum packet size up to which we test is 10M
+	$tmp = '';
+	$blob = '';
+	for ($i = 0; $i < 1024; $i++) {
+		$tmp .= 'a';
+	}
+
+	$limit = min(floor($max_allowed_packet / 1024 / 2), 10240);
+	for ($i = 0; $i < $limit; $i++)
+		$blob .= $tmp;
+
+	assert(strlen($blob) <= $max_allowed_packet);
+
+	if (true != ($tmp = mysqli_stmt_send_long_data($stmt, 1, $blob)))
+		printf("[009] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	/*
+	TODO - we skip this part of the test for now, because of bugs.mysql.com/26824
+	if (floor($max_allowed_packet / 1024 / 2) <= 10240) {
+			// test with a blob smaller than 10M allows us to test
+			// for too long packages without wasting too much memory
+			$limit = $max_allowed_packet - strlen($blob) + 1;
+			$blob2 = $blob;
+			for ($i = 0; $i < $limit; $i++)
+					$blob2 .= 'b';
+
+			assert(strlen($blob2) > $max_allowed_packet);
+
+			if (true != ($tmp = mysqli_stmt_send_long_data($stmt, 1, $blob2)))
+					printf("[011] Expecting boolean/false, got %s/%s. [%d] %s\n",
+							gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+			$id = 2;
+			if (false !== ($tmp = mysqli_stmt_execute($stmt)))
+					printf("[012] Expecting boolean/false, got %s/%s, [%d] %s\n",
+							gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+	}
+	*/
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_send_long_data_packet_size_mysqlnd.phpt
@@ -0,0 +1,103 @@
+--TEST--
+mysqli_stmt_send_long_data() - exceed packet size, mysqlnd
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+
+if (!stristr(mysqli_get_client_info(), 'mysqlnd'))
+	die("skip: warnings only available in mysqlnd");
+?>
+--FILE--
+<?php
+	require('table.inc');
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[001] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, sprintf("CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT, label LONGBLOB, PRIMARY KEY(id)) ENGINE = %s", $engine)))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (?, ?)"))
+		printf("[004] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = null;
+	$label = null;
+	if (!mysqli_stmt_bind_param($stmt, "ib", $id, $label))
+		printf("[005] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!$res = mysqli_query($link, "SHOW VARIABLES LIKE 'max_allowed_packet'"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!$row = mysqli_fetch_assoc($res))
+		printf("[007] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (0 === ($max_allowed_packet = (int)$row['Value']))
+		printf("[008] Cannot determine max_allowed_packet size and/or bogus max_allowed_packet setting used.\n");
+
+	// let's ignore upper limits for LONGBLOB (2^32) ...
+	// maximum packet size up to which we test is 10M
+	$tmp = '';
+	$blob = '';
+	$tmp = str_repeat('a', 1024);
+
+	$limit = min(floor($max_allowed_packet / 1024 / 2), 10240);
+	$blob = str_repeat($tmp, $limit);
+
+	assert(strlen($blob) <= $max_allowed_packet);
+
+	if (true !== ($tmp = mysqli_stmt_send_long_data($stmt, 1, $blob)))
+		printf("[009] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	$id = 1;
+	if (true !== mysqli_stmt_execute($stmt))
+		printf("[010] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+		/*
+		TODO - we skip this because of the open bug http://bugs.mysql.com/bug.php?id=26824
+		It would always fail.
+
+		This should be added to the EXPECTF, if you reactivate the test
+Warning: mysqli_stmt_send_long_data(): Skipped %d bytes. Last command STMT_SEND_LONG_DATA hasn't consumed all the output from the server in %s on line %d
+
+Warning: mysqli_stmt_send_long_data(): There was an error while sending long data. Probably max_allowed_packet_size is smaller than the data. You have to increase it or send smaller chunks of data. Answer was %d bytes long. in %s on line %d
+
+
+
+		if (floor($max_allowed_packet / 1024 / 2) <= 10240) {
+				// test with a blob smaller than 10M allows us to test
+				// for too long packages without wasting too much memory
+				$limit = $max_allowed_packet - strlen($blob) + 1;
+				$blob2 = $blob;
+		$blob2 .= str_repeat('b', $limit);
+
+				assert(strlen($blob2) > $max_allowed_packet);
+
+				if (false !== ($tmp = mysqli_stmt_send_long_data($stmt, 1, $blob2)))
+						printf("[011] Expecting boolean/false, got %s/%s. [%d] %s\n",
+								gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+				$id = 2;
+				if (false !== ($tmp = mysqli_stmt_execute($stmt)))
+						printf("[012] Expecting boolean/false, got %s/%s, [%d] %s\n",
+								gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+		}
+		*/
+	mysqli_stmt_close($stmt);
+	mysqli_close($link);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_sqlstate.phpt
@@ -0,0 +1,63 @@
+--TEST--
+mysqli_stmt_sqlstate()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_sqlstate()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_sqlstate($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_null($tmp = @mysqli_stmt_sqlstate($link, '')))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (NULL !== ($tmp = mysqli_stmt_sqlstate($stmt)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "SELECT id FROM test"))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if ('00000' !== ($tmp = mysqli_stmt_sqlstate($stmt)))
+		printf("[007] Expecting string/00000, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (mysqli_stmt_prepare($stmt, "SELECT believe_me FROM i_dont_belive_that_this_table_exists"))
+		printf("[008] Should fail! [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if ('' === ($tmp = mysqli_stmt_sqlstate($stmt)))
+		printf("[009] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	mysqli_stmt_close($stmt);
+
+	if (NULL !== ($tmp = mysqli_stmt_sqlstate($stmt)))
+		printf("[010] Expecting NULL, got %s/%s\n");
+
+	mysqli_close($link);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_stmt_sqlstate(): invalid object or resource mysqli_stmt
+ in %s on line %d
+
+Warning: mysqli_stmt_sqlstate(): Couldn't fetch mysqli_stmt in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_store_result.phpt
@@ -0,0 +1,90 @@
+--TEST--
+mysqli_stmt_store_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_stmt_store_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_stmt_store_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_null($tmp = @mysqli_stmt_store_result(new mysqli_stmt())))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	// stmt object status test
+	if (NULL !== ($tmp = @mysqli_stmt_store_result($stmt)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, "INSERT INTO test(id, label) VALUES (100, 'z')") ||
+		!mysqli_stmt_execute($stmt))
+		printf("[006] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (true !== ($tmp = @mysqli_stmt_store_result($stmt)))
+		printf("[007] Expecting boolean/true, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_stmt_prepare($stmt, 'SELECT id, label FROM test ORDER BY id') ||
+		!mysqli_stmt_execute($stmt))
+		printf("[008] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!$link_buf = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[009] [%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
+
+	if (!$stmt_buf = mysqli_stmt_init($link_buf))
+		printf("[010] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_stmt_prepare($stmt_buf, "SELECT id, label FROM test ORDER BY id") ||
+		!mysqli_stmt_execute($stmt_buf))
+		printf("[011] [%d] %s\n", mysqli_stmt_errno($stmt_buf), mysqli_stmt_error($stmt_buf));
+
+	$id = $label = $id_buf = $label_buf = null;
+	if (!mysqli_stmt_bind_result($stmt, $id, $label))
+		printf("[012] [%d] %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
+
+	if (!mysqli_stmt_bind_result($stmt_buf, $id_buf, $label_buf))
+		printf("[013] [%d] %s\n", mysqli_stmt_errno($stmt_buf), mysqli_stmt_error($stmt_buf));
+
+	while (mysqli_stmt_fetch($stmt)) {
+		if (!mysqli_stmt_fetch($stmt_buf)) {
+			printf("[014] Unbuffered statement indicates more rows than buffered, [%d] %s\n",
+				mysqli_stmt_errno($stmt_buf), mysqli_stmt_error($stmt_buf));
+		}
+		if ($id !== $id_buf)
+			printf("[015] unbuffered '%s'/%s, buffered '%s'/%s\n",
+				$id, gettype($id), $id_buf, gettype($id_buf));
+		if ($label !== $label_buf)
+			printf("[016] unbuffered '%s'/%s, buffered '%s'/%s\n",
+				$label, gettype($label), $label_buf, gettype($label_buf));
+	}
+
+	mysqli_stmt_close($stmt);
+	mysqli_stmt_close($stmt_buf);
+
+	if (NULL !== ($tmp = @mysqli_stmt_store_result($stmt)))
+		printf("[017] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+	mysqli_close($link_buf);
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_stmt_unclonable.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Trying to clone mysqli_stmt object
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!$stmt = mysqli_stmt_init($link))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	/* no, still bails out */
+	$stmt_clone = clone $stmt;
+	print "done!";
+?>
+--EXPECTF--
+Fatal error: Trying to clone an uncloneable object of class mysqli_stmt in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_store_result.phpt
@@ -0,0 +1,64 @@
+--TEST--
+mysqli_store_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_store_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_store_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$res = mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = mysqli_store_result($link)))
+		printf("[004] Expecting object, got %s/%s. [%d] %s\n",
+			gettype($res), $res, mysqli_errno($link), mysqli_error($link));
+
+	if (true !== ($tmp = mysqli_data_seek($res, 2)))
+		printf("[005] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, "DELETE FROM test"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($res = mysqli_store_result($link)))
+		printf("[007] Expecting boolean/false, got %s/%s. [%d] %s\n",
+			gettype($res), $res, mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_data_seek($res, 1)))
+		printf("[009] Expecting boolean/false, got %s/%s\n",
+			gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_store_result($link)))
+		printf("[010] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_store_result(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_thread_id.phpt
@@ -0,0 +1,44 @@
+--TEST--
+mysqli_thread_id()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_thread_id()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_thread_id($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!is_int($tmp = mysqli_thread_id($link)) || (0 === $tmp))
+		printf("[003] Expecting int/any but zero, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	// should work if the thread id is correct
+	mysqli_kill($link, mysqli_thread_id($link));
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_thread_id($link)))
+		printf("[005] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_thread_id(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_thread_safe.phpt
@@ -0,0 +1,16 @@
+--TEST--
+mysqli_thread_safe()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+?>
+--FILE--
+<?php
+	if (!is_bool($tmp = mysqli_thread_safe()))
+		printf("[001] Expecting boolean/any, got %s/%s.\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_unclonable.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Trying to clone mysqli object
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	$link_clone = clone $link;
+	mysqli_close($link);
+
+	print "done!";
+?>
+--EXPECTF--
+Fatal error: Trying to clone an uncloneable object of class mysqli in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_use_result.phpt
@@ -0,0 +1,66 @@
+--TEST--
+mysqli_use_result()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_use_result()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_use_result($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (!$res = mysqli_real_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($res = mysqli_use_result($link)))
+		printf("[004] Expecting object, got %s/%s. [%d] %s\n",
+			gettype($res), $res, mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_data_seek($res, 2)))
+		printf("[005] Expecting boolean/true, got %s/%s. [%d] %s\n",
+			gettype($tmp), $tmp, mysqli_errno($link), mysqli_error($link));
+
+	mysqli_free_result($res);
+
+	if (!mysqli_query($link, "DELETE FROM test"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($res = mysqli_use_result($link)))
+		printf("[007] Expecting boolean/false, got %s/%s. [%d] %s\n",
+			gettype($res), $res, mysqli_errno($link), mysqli_error($link));
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test ORDER BY id"))
+		printf("[008] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (false !== ($tmp = mysqli_data_seek($res, 1)))
+		printf("[009] Expecting boolean/false, got %s/%s\n",
+			gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_use_result($link)))
+		printf("[010] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_data_seek(): Function cannot be used with MYSQL_USE_RESULT in %s on line %d
+
+Warning: mysqli_use_result(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_warning_count.phpt
@@ -0,0 +1,52 @@
+--TEST--
+mysqli_warning_count()
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	$tmp    = NULL;
+	$link   = NULL;
+
+	if (!is_null($tmp = @mysqli_warning_count()))
+		printf("[001] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!is_null($tmp = @mysqli_warning_count($link)))
+		printf("[002] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	require('table.inc');
+
+	if (NULL !== ($tmp = @mysqli_warning_count($link, "too_many")))
+		printf("[003] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!$res = mysqli_query($link, "SELECT id, label FROM test"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (0 !== ($tmp = mysqli_warning_count($link)))
+		printf("[005] Expecting int/0, got %s/%s\n", gettype($tmp), $tmp);
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS this_table_does_not_exist"))
+		printf("[006] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (1 !== ($tmp = mysqli_warning_count($link)))
+		printf("[007] Expecting int/1, got %s/%s\n", gettype($tmp), $tmp);
+
+	mysqli_close($link);
+
+	if (NULL !== ($tmp = mysqli_warning_count($link)))
+		printf("[010] Expecting NULL, got %s/%s\n", gettype($tmp), $tmp);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Warning: mysqli_warning_count(): Couldn't fetch mysqli in %s on line %d
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/mysqli_warning_unclonable.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Trying to clone mysqli_warning object
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once('skipifemb.inc');
+require_once('skipifconnectfailure.inc');
+require_once('connect.inc');
+if (!$TEST_EXPERIMENTAL)
+	die("skip - experimental (= unsupported) feature");
+?>
+--FILE--
+<?php
+	require_once("connect.inc");
+
+	if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))
+		printf("[001] Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+			$host, $user, $db, $port, $socket);
+
+	if (!mysqli_query($link, "DROP TABLE IF EXISTS test"))
+		printf("[002] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "CREATE TABLE test (id SMALLINT)"))
+		printf("[003] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!mysqli_query($link, "INSERT INTO test (id) VALUES (1000000)"))
+		printf("[004] [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+
+	if (!is_object($warning = mysqli_get_warnings($link)) || 'mysqli_warning' != get_class($warning)) {
+		printf("[005] Expecting object/mysqli_warning, got %s/%s\n", gettype($tmp), (is_object($tmp) ? var_dump($tmp, true) : $tmp));
+	}
+
+	$warning_clone = clone $warning;
+	print "done!";
+?>
+--CLEAN--
+<?php
+	require_once("clean_table.inc");
+?>
+--EXPECTF--
+Fatal error: Trying to clone an uncloneable object of class mysqli_warning in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/reflection_tools.inc
@@ -0,0 +1,121 @@
+<?php
+	function inspectClass($class) {
+
+		/* not used: public ReflectionClass[] getInterfaces()  */
+
+		printf("\nInspecting class '%s'\n", $class->getName());
+		printf("isInternal: %s\n", ($class->isInternal()) ? 'yes' : 'no');
+		printf("isUserDefined: %s\n", ($class->isUserDefined()) ? 'yes' : 'no');
+		printf("isInstantiable: %s\n", ($class->isInstantiable()) ? 'yes' : 'no');
+		printf("isInterface: %s\n", ($class->isInterface()) ? 'yes' : 'no');
+		printf("isAbstract: %s\n", ($class->isAbstract()) ? 'yes' : 'no');
+		printf("isFinal: %s\n", ($class->isFinal()) ? 'yes' : 'no');
+		printf("isIteratable: %s\n", ($class->isIterateable()) ? 'yes' : 'no');
+		printf("Modifiers: '%d'\n", $class->getModifiers());
+		printf("Parent Class: '%s'\n", $class->getParentClass());
+		printf("Extension: '%s'\n", $class->getExtensionName());
+
+		if ($method = $class->getConstructor())
+			inspectMethod($method);
+
+		if ($methods = $class->getMethods()) {
+			$tmp = array();
+			foreach ($methods as $method)
+				$tmp[$method->getName()] = $method;
+
+			ksort($tmp, SORT_STRING);
+			foreach ($tmp as $method)
+				inspectMethod($method);
+		}
+
+		if ($properties = $class->getProperties()) {
+			$tmp = array();
+			foreach ($properties as $prop)
+				$tmp[$prop->getName()] = $prop;
+			ksort($tmp, SORT_STRING);
+			foreach ($tmp as $prop)
+			inspectProperty($prop);
+		}
+
+
+		if ($properties = $class->getDefaultProperties()) {
+			ksort($properties, SORT_STRING);
+			foreach ($properties as $name => $v)
+				printf("Default property '%s'\n", $name);
+		}
+
+		if ($properties = $class->getStaticProperties()) {
+			ksort($properties, SORT_STRING);
+			foreach ($properties as $name => $v)
+				printf("Static property '%s'\n", $name);
+		}
+
+		if ($constants = $class->getConstants()) {
+			ksort($constants, SORT_STRING);
+			foreach ($constant as $name => $value)
+				printf("Constant '%s' = '%s'\n", $name, $value);
+		}
+
+	}
+
+	function inspectProperty(&$prop) {
+
+		printf("\nInspecting property '%s'\n", $prop->getName());
+		printf("isPublic: %s\n", ($prop->isPublic()) ? 'yes' : 'no');
+		printf("isPrivate: %s\n", ($prop->isPrivate()) ? 'yes' : 'no');
+		printf("isProtected: %s\n", ($prop->isProtected()) ? 'yes' : 'no');
+		printf("isStatic: %s\n", ($prop->isStatic()) ? 'yes' : 'no');
+		printf("isDefault: %s\n", ($prop->isDefault()) ? 'yes' : 'no');
+		printf("Modifiers: %d\n", $prop->getModifiers());
+		// printf("Value\n"); var_export($prop->getValue());
+
+	}
+
+	function inspectMethod(&$method) {
+
+		printf("\nInspecting method '%s'\n", $method->getName());
+		printf("isFinal: %s\n", ($method->isFinal()) ? 'yes' : 'no');
+		printf("isAbstract: %s\n", ($method->isAbstract()) ? 'yes' : 'no');
+		printf("isPublic: %s\n", ($method->isPublic()) ? 'yes' : 'no');
+		printf("isPrivate: %s\n", ($method->isPrivate()) ? 'yes' : 'no');
+		printf("isProtected: %s\n", ($method->isProtected()) ? 'yes' : 'no');
+		printf("isStatic: %s\n", ($method->isStatic()) ? 'yes' : 'no');
+		printf("isConstructor: %s\n", ($method->isConstructor()) ? 'yes' : 'no');
+		printf("isDestructor: %s\n", ($method->isDestructor()) ? 'yes' : 'no');
+		printf("isInternal: %s\n", ($method->isInternal()) ? 'yes' : 'no');
+		printf("isUserDefined: %s\n", ($method->isUserDefined()) ? 'yes' : 'no');
+		printf("returnsReference: %s\n", ($method->returnsReference()) ? 'yes' : 'no');
+		printf("Modifiers: %d\n", $method->getModifiers());
+		printf("Number of Parameters: %d\n", $method->getNumberOfParameters());
+		printf("Number of Required Parameters: %d\n", $method->getNumberOfRequiredParameters());
+
+		if ($params = $method->getParameters()) {
+			$tmp = array();
+			foreach ($params as $k => $param)
+				$tmp[$param->getName()] = $param;
+
+//			ksort($tmp, SORT_STRING);
+			foreach ($tmp as $param)
+				inspectParameter($method, $param);
+		}
+
+		if ($static = $method->getStaticVariables()) {
+			sort($static, SORT_STRING);
+			printf("Static variables: %s\n", implode('/', $static));
+		}
+
+	}
+
+	function inspectParameter(&$method, &$param) {
+
+		printf("\nInspecting parameter '%s' of method '%s'\n",
+		$param->getName(), $method->getName());
+		printf("isArray: %s\n", ($param->isArray()) ? 'yes': 'no');
+		printf("allowsNull: %s\n", ($param->allowsNull()) ? 'yes' : 'no');
+		printf("isPassedByReference: %s\n", ($param->isPassedByReference()) ? 'yes' : 'no');
+		printf("isOptional: %s\n", ($param->isOptional()) ? 'yes' : 'no');
+		printf("isDefaultValueAvailable: %s\n", ($param->isDefaultValueAvailable()) ? 'yes' : 'no');
+		// printf("getDefaultValue: %s\n", ($param->getDefaultValue()) ? 'yes' : 'no');
+
+	}
+?>
\ No newline at end of file
--- a/ext/mysqli/tests/skipif.inc
+++ b/ext/mysqli/tests/skipif.inc
@@ -2,9 +2,4 @@
 if (!extension_loaded('mysqli')){
 	die('skip mysqli extension not available');
 }
-include "connect.inc";
-$driver = new mysqli_driver();
-if (!$driver->embedded && !($con = @mysqli_connect($host, $user, $passwd, "", 3306))) {
-	die('skip could not connect to MySQL');
-}
-?>
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/skipifconnectfailure.inc
@@ -0,0 +1,10 @@
+<?php
+require_once('connect.inc');
+if ($skip_on_connect_failure) {
+	include_once('connect.inc');
+	$link = @my_mysqli_connect($host, $user, $passwd, $db, $port, $socket);
+	if (!is_object($link))
+		die(sprintf("skip Can't connect to MySQL Server - [%d] %s", mysqli_connect_errno(), mysqli_connect_error()));
+	mysqli_close($link);
+}
+?>
--- a/ext/mysqli/tests/skipifemb.inc
+++ b/ext/mysqli/tests/skipifemb.inc
@@ -1,5 +1,5 @@
 <?php
-  $driver = new mysqli_driver();
-  if ($driver->embedded) 
-    die("skip test doesn't run with embedded server");
-?>
+	$driver = new mysqli_driver();
+	if ($driver->embedded)
+		die("skip test doesn't run with embedded server");
+?>
\ No newline at end of file
--- a/ext/mysqli/tests/skipifnotemb.inc
+++ b/ext/mysqli/tests/skipifnotemb.inc
@@ -1,5 +1,5 @@
 <?php
-  $driver = new mysqli_driver();
-  if (!$driver->embedded) 
-    die("skip test for with embedded server only");
-?>
+	$driver = new mysqli_driver();
+	if (!$driver->embedded)
+		die("skip test for with embedded server only");
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqli/tests/skipifunicode.inc
@@ -0,0 +1,5 @@
+<?php
+if (version_compare(PHP_VERSION, '5.9.9', '>') == 1) {
+	die('skip Not functional with PHP 6 (fomerly PHP 6 && unicode.semantics=On)');
+}
+?>
--- /dev/null
+++ b/ext/mysqli/tests/table.inc
@@ -0,0 +1,23 @@
+<?PHP
+require_once('connect.inc');
+
+if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {
+	printf("Cannot connect to the server using host=%s, user=%s, passwd=***, dbname=%s, port=%s, socket=%s\n",
+		$host, $user, $db, $port, $socket);
+	exit(1);
+}
+
+if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {
+	printf("Failed to drop old test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	exit(1);
+}
+
+if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=' . $engine)) {
+	printf("Failed to create test table: [%d] %s\n", mysqli_errno($link), mysqli_error($link));
+	exit(1);
+}
+
+if (!mysqli_query($link, "INSERT INTO test(id, label) VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')")) {
+	printf("[%d] %s\n",  mysqli_errno($link), mysqli_error($link));
+}
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/mysqlnd/CREDITS
@@ -0,0 +1,2 @@
+MySQLnd
+Georg Richter, Andrey Hristov, Ulf Wendel
--- /dev/null
+++ b/ext/mysqlnd/config-win.h
@@ -0,0 +1,115 @@
+/* Copyright Abandoned 1996 TCX DataKonsult AB & Monty Program KB & Detron HB 
+This file is public domain and comes with NO WARRANTY of any kind */
+
+/* Defines for Win32 to make it compatible for MySQL */
+
+#ifndef _MYSQLND_CONFIG_WIN_H
+#define _MYSQLND_CONFIG_WIN_H
+
+#include <sys/locking.h>
+#include <windows.h>
+#include <math.h>			/* Because of rint() */
+#include <fcntl.h>
+#include <io.h>
+#include <malloc.h>
+
+#include <win32/php_stdint.h>
+
+#ifndef HAVE_INT8_T
+#define HAVE_INT8_T
+#endif
+#ifndef HAVE_UINT8_T
+#define HAVE_UINT8_T
+#endif
+#ifndef HAVE_INT16_T
+#define HAVE_INT16_T
+#endif
+#ifndef HAVE_UINT16_T
+#define HAVE_UINT16_T
+#endif
+#ifndef HAVE_INT32_T
+#define HAVE_INT32_T
+#endif
+#ifndef HAVE_UINT32_T
+#define HAVE_UINT32_T
+#endif
+#ifndef HAVE_INT64_T
+#define HAVE_INT64_T
+#endif
+#ifndef HAVE_UINT64_T
+#define HAVE_UINT64_T
+#endif
+
+
+#ifndef _WIN64
+#ifndef _WIN32
+#define _WIN32				/* Compatible with old source */
+#endif
+#ifndef __WIN32__
+#define __WIN32__
+#endif
+#endif /* _WIN64 */
+#ifndef __WIN__
+#define __WIN__				/* To make it easier in VC++ */
+#endif
+
+/* Type information */
+
+#define SIZEOF_CHAR		1
+#define SIZEOF_LONG		4
+#define SIZEOF_LONG_LONG	8
+
+
+#ifndef _WIN64
+/* Optimized store functions for Intel x86 */
+
+#define sint2korr(A)	(*((int16_t *) (A)))
+#define sint3korr(A)	((int32_t) ((((zend_uchar) (A)[2]) & 128) ? \
+										(((uint32_t) 255L << 24) | \
+										(((uint32_t) (zend_uchar) (A)[2]) << 16) |\
+										(((uint32_t) (zend_uchar) (A)[1]) << 8) | \
+										((uint32_t) (zend_uchar) (A)[0])) : \
+										(((uint32_t) (zend_uchar) (A)[2]) << 16) |\
+										(((uint32_t) (zend_uchar) (A)[1]) << 8) | \
+										((uint32_t) (zend_uchar) (A)[0])))
+#define sint4korr(A)	(*((int32_t *) (A)))
+#define uint2korr(A)	(*((uint16_t *) (A)))
+#define uint3korr(A)	(int32_t) (*((uint32_t *) (A)) & 0xFFFFFF)
+#define uint4korr(A)	(*((uint32_t *) (A)))
+#define uint5korr(A)	((uint64_t)(((uint32_t) ((zend_uchar) (A)[0])) +\
+									(((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
+									(((uint32_t) ((zend_uchar) (A)[2])) << 16) +\
+									(((uint32_t) ((zend_uchar) (A)[3])) << 24)) +\
+									(((uint64_t) ((zend_uchar) (A)[4])) << 32))
+#define uint8korr(A)	(*((uint64_t *) (A)))
+#define sint8korr(A)	(*((int64_t *) (A)))
+#define int2store(T,A)	*((uint16_t*) (T))= (uint16_t) (A)
+#define int3store(T,A)		{	*(T)=  (zend_uchar) ((A));\
+								*(T+1)=(zend_uchar) (((uint32_t) (A) >> 8));\
+								*(T+2)=(zend_uchar) (((A) >> 16)); }
+#define int4store(T,A)	*((int32_t *) (T))= (int32_t) (A)
+#define int5store(T,A)	{	*(T)= (zend_uchar)((A));\
+							*((T)+1)=(zend_uchar) (((A) >> 8));\
+							*((T)+2)=(zend_uchar) (((A) >> 16));\
+							*((T)+3)=(zend_uchar) (((A) >> 24)); \
+							*((T)+4)=(zend_uchar) (((A) >> 32)); }
+#define int8store(T,A)	*((uint64_t *) (T))= (uint64_t) (A)
+
+#define float8get(V,M)	{	*((int32_t *) &V) = *((int32_t*) M); \
+							*(((int32_t *) &V)+1) = *(((int32_t*) M)+1); }
+#define float8store(T,V) {	*((int32_t *) T) = *((int32_t*) &V); \
+							*(((int32_t *) T)+1) = *(((int32_t*) &V)+1); }
+#define float4get(V,M) { *((int32_t *) &(V)) = *((int32_t*) (M)); }
+
+#endif /* _WIN64 */
+
+#endif /* _MYSQLND_CONFIG_WIN_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/config.w32
@@ -0,0 +1,31 @@
+// $Id$
+// vim:ft=javascript
+
+ARG_WITH("mysqlnd", "Mysql Native Client Driver", "yes");
+if (PHP_MYSQLND != "no") {
+
+	if (CHECK_LIB("ws2_32.lib", "mysqlnd")) {
+		mysqlnd_source = 
+			"mysqlnd.c " +
+			"mysqlnd_block_alloc.c " +
+			"mysqlnd_charset.c " +
+			"mysqlnd_debug.c " +
+			"mysqlnd_loaddata.c " +
+			"mysqlnd_net.c " +
+			"mysqlnd_ps.c " +
+			"mysqlnd_ps_codec.c " +
+			"mysqlnd_result.c " +
+			"mysqlnd_result_meta.c " +
+			"mysqlnd_statistics.c " +
+			"mysqlnd_wireprotocol.c " +
+			"php_mysqlnd.c";
+		EXTENSION("mysqlnd", mysqlnd_source, false);
+		if (((PHP_ZLIB=="no") && (CHECK_LIB("zlib_a.lib;zlib.lib", "mysqlnd", PHP_MYSQLND))) || 
+			(PHP_ZLIB_SHARED && CHECK_LIB("zlib.lib", "mysqlnd", PHP_MYSQLND)) || (PHP_ZLIB == "yes" && (!PHP_ZLIB_SHARED)))
+		{
+			AC_DEFINE("MYSQLND_COMPRESSION_ENABLED", 1, "Compression support");
+			AC_DEFINE("MYSQLND_SSL_SUPPORTED", 1, "SSL support");
+		}
+		PHP_INSTALL_HEADERS("", "ext/mysqlnd");
+	}
+}
--- /dev/null
+++ b/ext/mysqlnd/config9.m4
@@ -0,0 +1,52 @@
+dnl
+dnl $Id$
+dnl config.m4 for mysqlnd driver
+
+PHP_ARG_ENABLE(mysqlnd, whether to enable mysqlnd,
+  [  --enable-mysqlnd        Enable mysqlnd explicitly, will be done implicitly
+                          when required by other extensions], no, yes)
+
+PHP_ARG_ENABLE(mysqlnd_compression_support, whether to disable compressed protocol support in mysqlnd,
+[  --disable-mysqlnd-compression-support
+                            Disable support for the MySQL compressed protocol in mysqlnd], yes, no)
+
+if test -z "$PHP_ZLIB_DIR"; then
+  PHP_ARG_WITH(zlib-dir, for the location of libz,
+  [  --with-zlib-dir[=DIR]       mysqlnd: Set the path to libz install prefix], no, no)
+fi
+
+dnl If some extension uses mysqlnd it will get compiled in PHP core
+if test "$PHP_MYSQLND" != "no" || test "$PHP_MYSQLND_ENABLED" = "yes"; then
+  mysqlnd_ps_sources="mysqlnd_ps.c mysqlnd_ps_codec.c"
+  mysqlnd_base_sources="mysqlnd.c mysqlnd_charset.c mysqlnd_wireprotocol.c \
+                   mysqlnd_loaddata.c mysqlnd_net.c mysqlnd_statistics.c \
+				   mysqlnd_result.c mysqlnd_result_meta.c mysqlnd_debug.c\
+				   mysqlnd_block_alloc.c php_mysqlnd.c"
+
+
+  if test "$PHP_MYSQLND_COMPRESSION_SUPPORT" != "no"; then
+    AC_DEFINE([MYSQLND_COMPRESSION_WANTED], 1, [Enable compressed protocol support])
+  fi
+  AC_DEFINE([MYSQLND_SSL_SUPPORTED], 1, [Enable SSL support])
+
+  mysqlnd_sources="$mysqlnd_base_sources $mysqlnd_ps_sources"
+  PHP_NEW_EXTENSION(mysqlnd, $mysqlnd_sources, $ext_shared)
+  PHP_ADD_BUILD_DIR([ext/mysqlnd], 1)
+  PHP_INSTALL_HEADERS([ext/mysqlnd/])
+fi
+
+if test "$PHP_MYSQLND" != "no" || test "$PHP_MYSQLND_ENABLED" = "yes" || test "$PHP_MYSQLI" != "no"; then
+  PHP_ADD_BUILD_DIR([ext/mysqlnd], 1)
+
+  dnl This creates a file so it has to be after above macros
+  PHP_CHECK_TYPES([int8 uint8 int16 uint16 int32 uint32 uchar ulong int8_t uint8_t int16_t uint16_t int32_t uint32_t int64_t uint64_t], [
+    ext/mysqlnd/php_mysqlnd_config.h
+  ],[
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+  ])
+fi
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd.c
@@ -0,0 +1,2457 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_result.h"
+#include "mysqlnd_statistics.h"
+#include "mysqlnd_charset.h"
+#include "mysqlnd_debug.h"
+/* for php_get_current_user() */
+#include "ext/standard/basic_functions.h"
+
+/*
+  TODO :
+  - Don't bind so tightly the metadata with the result set. This means
+	that the metadata reading should not expect a MYSQLND_RES pointer, it
+	does not need it, but return a pointer to the metadata (MYSQLND_FIELD *).
+	For normal statements we will then just assign it to a member of
+	MYSQLND_RES. For PS statements, it will stay as part of the statement
+	(MYSQLND_STMT) between prepare and execute. At execute the new metadata
+	will be sent by the server, so we will discard the old one and then
+	finally attach it to the result set. This will make the code more clean,
+	as a prepared statement won't have anymore stmt->result != NULL, as it
+	is now, just to have where to store the metadata.
+
+  - Change mysqlnd_simple_command to accept a heap dynamic array of MYSQLND_STRING
+	terminated by a string with ptr being NULL. Thus, multi-part messages can be
+	sent to the network like writev() and this can save at least for
+	mysqlnd_stmt_send_long_data() new malloc. This change will probably make the
+	code in few other places cleaner.
+*/
+
+extern MYSQLND_CHARSET *mysqlnd_charsets;
+
+
+
+PHPAPI const char * const mysqlnd_old_passwd  = "mysqlnd cannot connect to MySQL 4.1+ using the old insecure authentication. "
+"Please use an administration tool to reset your password with the command SET PASSWORD = PASSWORD('your_existing_password'). This will "
+"store a new, and more secure, hash value in mysql.user. If this user is used in other scripts executed by PHP 5.2 or earlier you might need to remove the old-passwords "
+"flag from your my.cnf file";
+
+PHPAPI const char * const mysqlnd_server_gone = "MySQL server has gone away";
+PHPAPI const char * const mysqlnd_out_of_sync = "Commands out of sync; you can't run this command now";
+PHPAPI const char * const mysqlnd_out_of_memory = "Out of memory";
+
+PHPAPI MYSQLND_STATS *mysqlnd_global_stats = NULL;
+static zend_bool mysqlnd_library_initted = FALSE;
+
+static struct st_mysqlnd_conn_methods *mysqlnd_conn_methods;
+
+/* {{{ mysqlnd_library_end */
+PHPAPI void mysqlnd_library_end(TSRMLS_D)
+{
+	if (mysqlnd_library_initted == TRUE) {
+		mysqlnd_stats_end(mysqlnd_global_stats);
+		mysqlnd_global_stats = NULL;
+		mysqlnd_library_initted = FALSE;
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::free_options */
+static void
+MYSQLND_METHOD(mysqlnd_conn, free_options)(MYSQLND * conn TSRMLS_DC)
+{
+	zend_bool pers = conn->persistent;
+
+	if (conn->options.charset_name) {
+		mnd_pefree(conn->options.charset_name, pers);
+		conn->options.charset_name = NULL;
+	}
+	if (conn->options.num_commands) {
+		unsigned int i;
+		for (i = 0; i < conn->options.num_commands; i++) {
+			/* allocated with pestrdup */
+			mnd_pefree(conn->options.init_commands[i], pers);
+		}
+		mnd_pefree(conn->options.init_commands, pers);
+		conn->options.init_commands = NULL;
+	}
+	if (conn->options.cfg_file) {
+		mnd_pefree(conn->options.cfg_file, pers);
+		conn->options.cfg_file = NULL;
+	}
+	if (conn->options.cfg_section) {
+		mnd_pefree(conn->options.cfg_section, pers);
+		conn->options.cfg_section = NULL;
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::free_contents */
+static void
+MYSQLND_METHOD(mysqlnd_conn, free_contents)(MYSQLND * conn TSRMLS_DC)
+{
+	zend_bool pers = conn->persistent;
+
+	DBG_ENTER("mysqlnd_conn::free_contents");
+
+	mysqlnd_local_infile_default(conn);
+	if (conn->current_result) {
+		conn->current_result->m.free_result(conn->current_result, TRUE TSRMLS_CC);
+		conn->current_result = NULL;
+	}
+
+	if (conn->net) {
+		conn->net->m.free_contents(conn->net TSRMLS_CC);
+	}
+
+	DBG_INF("Freeing memory of members");
+
+	if (conn->host) {
+		DBG_INF("Freeing host");
+		mnd_pefree(conn->host, pers);
+		conn->host = NULL;
+	}
+	if (conn->user) {
+		DBG_INF("Freeing user");
+		mnd_pefree(conn->user, pers);
+		conn->user = NULL;
+	}
+	if (conn->passwd) {
+		DBG_INF("Freeing passwd");
+		mnd_pefree(conn->passwd, pers);
+		conn->passwd = NULL;
+	}
+	if (conn->connect_or_select_db) {
+		DBG_INF("Freeing connect_or_select_db");
+		mnd_pefree(conn->connect_or_select_db, pers);
+		conn->connect_or_select_db = NULL;
+	}
+	if (conn->unix_socket) {
+		DBG_INF("Freeing unix_socket");
+		mnd_pefree(conn->unix_socket, pers);
+		conn->unix_socket = NULL;
+	}
+	DBG_INF_FMT("scheme=%s", conn->scheme);
+	if (conn->scheme) {
+		DBG_INF("Freeing scheme");
+		mnd_pefree(conn->scheme, pers);
+		conn->scheme = NULL;
+	}
+	if (conn->server_version) {
+		DBG_INF("Freeing server_version");
+		mnd_pefree(conn->server_version, pers);
+		conn->server_version = NULL;
+	}
+	if (conn->host_info) {
+		DBG_INF("Freeing host_info");
+		mnd_pefree(conn->host_info, pers);
+		conn->host_info = NULL;
+	}
+	if (conn->scramble) {
+		DBG_INF("Freeing scramble");
+		mnd_pefree(conn->scramble, pers);
+		conn->scramble = NULL;
+	}
+	if (conn->last_message) {
+		mnd_pefree(conn->last_message, pers);
+		conn->last_message = NULL;
+	}
+	conn->charset = NULL;
+	conn->greet_charset = NULL;
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::dtor */
+static void
+MYSQLND_METHOD_PRIVATE(mysqlnd_conn, dtor)(MYSQLND * conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::dtor");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	conn->m->free_contents(conn TSRMLS_CC);
+	conn->m->free_options(conn TSRMLS_CC);
+
+	if (conn->net) {
+		DBG_INF("Freeing net");
+		mysqlnd_net_free(conn->net TSRMLS_CC);
+		conn->net = NULL;
+	}
+
+	if (conn->protocol) {
+		DBG_INF("Freeing protocol");
+		mysqlnd_protocol_free(conn->protocol TSRMLS_CC);
+		conn->protocol = NULL;
+	}
+
+	if (conn->stats) {
+		mysqlnd_stats_end(conn->stats);
+	}
+
+	mnd_pefree(conn, conn->persistent);
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::simple_command_handle_response */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, simple_command_handle_response)(MYSQLND * conn, enum mysqlnd_packet_type ok_packet,
+															 zend_bool silent, enum php_mysqlnd_server_command command,
+															 zend_bool ignore_upsert_status TSRMLS_DC)
+{
+	enum_func_status ret = FAIL;
+
+	DBG_ENTER("mysqlnd_conn::simple_command_handle_response");
+	DBG_INF_FMT("silent=%u packet=%u command=%s", silent, ok_packet, mysqlnd_command_to_text[command]);
+
+	switch (ok_packet) {
+		case PROT_OK_PACKET:{
+			MYSQLND_PACKET_OK * ok_response = conn->protocol->m.get_ok_packet(conn->protocol, FALSE TSRMLS_CC);
+			if (!ok_response) {
+				SET_OOM_ERROR(conn->error_info);
+				break;
+			}
+			if (FAIL == (ret = PACKET_READ(ok_response, conn))) {
+				if (!silent) {
+					DBG_ERR_FMT("Error while reading %s's OK packet", mysqlnd_command_to_text[command]);
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading %s's OK packet. PID=%u",
+									 mysqlnd_command_to_text[command], getpid());
+				}
+			} else {
+				DBG_INF_FMT("OK from server");
+				if (0xFF == ok_response->field_count) {
+					/* The server signalled error. Set the error */
+					SET_CLIENT_ERROR(conn->error_info, ok_response->error_no, ok_response->sqlstate, ok_response->error);
+					ret = FAIL;
+					/*
+					  Cover a protocol design error: error packet does not
+					  contain the server status. Therefore, the client has no way
+					  to find out whether there are more result sets of
+					  a multiple-result-set statement pending. Luckily, in 5.0 an
+					  error always aborts execution of a statement, wherever it is
+					  a multi-statement or a stored procedure, so it should be
+					  safe to unconditionally turn off the flag here.
+					*/
+					conn->upsert_status.server_status &= ~SERVER_MORE_RESULTS_EXISTS;
+					SET_ERROR_AFF_ROWS(conn);
+				} else {
+					SET_NEW_MESSAGE(conn->last_message, conn->last_message_len,
+									ok_response->message, ok_response->message_len,
+									conn->persistent);
+
+					if (!ignore_upsert_status) {
+						conn->upsert_status.warning_count = ok_response->warning_count;
+						conn->upsert_status.server_status = ok_response->server_status;
+						conn->upsert_status.affected_rows = ok_response->affected_rows;
+						conn->upsert_status.last_insert_id = ok_response->last_insert_id;
+					}
+				}
+			}
+			PACKET_FREE(ok_response);
+			break;
+		}
+		case PROT_EOF_PACKET:{
+			MYSQLND_PACKET_EOF * ok_response = conn->protocol->m.get_eof_packet(conn->protocol, FALSE TSRMLS_CC);
+			if (!ok_response) {
+				SET_OOM_ERROR(conn->error_info);
+				break;
+			}
+			if (FAIL == (ret = PACKET_READ(ok_response, conn))) {
+				SET_CLIENT_ERROR(conn->error_info, CR_MALFORMED_PACKET, UNKNOWN_SQLSTATE,
+								 "Malformed packet");
+				if (!silent) {
+					DBG_ERR_FMT("Error while reading %s's EOF packet", mysqlnd_command_to_text[command]);
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading %s's EOF packet. PID=%d",
+									 mysqlnd_command_to_text[command], getpid());
+				}
+			} else if (0xFF == ok_response->field_count) {
+				/* The server signalled error. Set the error */
+				SET_CLIENT_ERROR(conn->error_info, ok_response->error_no, ok_response->sqlstate, ok_response->error);
+				SET_ERROR_AFF_ROWS(conn);
+			} else if (0xFE != ok_response->field_count) {
+				SET_CLIENT_ERROR(conn->error_info, CR_MALFORMED_PACKET, UNKNOWN_SQLSTATE, "Malformed packet");
+				if (!silent) {
+					DBG_ERR_FMT("EOF packet expected, field count wasn't 0xFE but 0x%2X", ok_response->field_count);
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "EOF packet expected, field count wasn't 0xFE but 0x%2X",
+									ok_response->field_count);
+				}
+			} else {
+				DBG_INF_FMT("OK from server");
+			}
+			PACKET_FREE(ok_response);
+			break;
+		}
+		default:
+			SET_CLIENT_ERROR(conn->error_info, CR_MALFORMED_PACKET, UNKNOWN_SQLSTATE, "Malformed packet");
+			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Wrong response packet %u passed to the function", ok_packet);
+			break;
+	}
+	DBG_INF(ret == PASS ? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::simple_command */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, simple_command)(MYSQLND * conn, enum php_mysqlnd_server_command command,
+			   const char * const arg, size_t arg_len, enum mysqlnd_packet_type ok_packet, zend_bool silent,
+			   zend_bool ignore_upsert_status TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	MYSQLND_PACKET_COMMAND * cmd_packet;
+
+	DBG_ENTER("mysqlnd_conn::simple_command");
+	DBG_INF_FMT("command=%s ok_packet=%u silent=%u", mysqlnd_command_to_text[command], ok_packet, silent);
+
+	switch (CONN_GET_STATE(conn)) {
+		case CONN_READY:
+			break;
+		case CONN_QUIT_SENT:
+			SET_CLIENT_ERROR(conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
+			DBG_ERR("Server is gone");
+			DBG_RETURN(FAIL);
+		default:
+			SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+			DBG_ERR_FMT("Command out of sync. State=%u", CONN_GET_STATE(conn));
+			DBG_RETURN(FAIL);
+	}
+
+	/* clean UPSERT info */
+	if (!ignore_upsert_status) {
+		memset(&conn->upsert_status, 0, sizeof(conn->upsert_status));
+	}
+	SET_ERROR_AFF_ROWS(conn);
+	SET_EMPTY_ERROR(conn->error_info);
+
+	cmd_packet = conn->protocol->m.get_command_packet(conn->protocol, FALSE TSRMLS_CC);
+	if (!cmd_packet) {
+		SET_OOM_ERROR(conn->error_info);
+		DBG_RETURN(FAIL);
+	}
+
+	cmd_packet->command = command;
+	if (arg && arg_len) {
+		cmd_packet->argument = arg;
+		cmd_packet->arg_len  = arg_len;
+	}
+
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_COM_QUIT + command - 1 /* because of COM_SLEEP */ );
+
+	if (! PACKET_WRITE(cmd_packet, conn)) {
+		if (!silent) {
+			DBG_ERR_FMT("Error while sending %s packet", mysqlnd_command_to_text[command]);
+			php_error(E_WARNING, "Error while sending %s packet. PID=%d", mysqlnd_command_to_text[command], getpid());
+		}
+		DBG_ERR("Server is gone");
+		ret = FAIL;
+	} else if (ok_packet != PROT_LAST) {
+		ret = conn->m->simple_command_handle_response(conn, ok_packet, silent, command, ignore_upsert_status TSRMLS_CC);
+	}
+
+	PACKET_FREE(cmd_packet);
+	DBG_INF(ret == PASS ? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::set_server_option */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, set_server_option)(MYSQLND * const conn, enum_mysqlnd_server_option option TSRMLS_DC)
+{
+	enum_func_status ret;
+	char buffer[2];
+	DBG_ENTER("mysqlnd_conn::set_server_option");
+
+	int2store(buffer, (unsigned int) option);
+	ret = conn->m->simple_command(conn, COM_SET_OPTION, buffer, sizeof(buffer), PROT_EOF_PACKET, FALSE, TRUE TSRMLS_CC);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::restart_psession */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, restart_psession)(MYSQLND * conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::restart_psession");
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_CONNECT_REUSED);
+	/* Free here what should not be seen by the next script */
+	if (conn->last_message) {
+		mnd_pefree(conn->last_message, conn->persistent);
+		conn->last_message = NULL;
+	}
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::end_psession */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, end_psession)(MYSQLND * conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::end_psession");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+#define MYSQLND_ASSEBLED_PACKET_MAX_SIZE 3UL*1024UL*1024UL*1024UL
+/* {{{ mysqlnd_connect_run_authentication */
+static enum_func_status
+mysqlnd_connect_run_authentication(
+			MYSQLND * conn,
+			const char * const user,
+			const char * const passwd,
+			const char * const db,
+			size_t db_len,
+			const MYSQLND_PACKET_GREET * const greet_packet,
+			const MYSQLND_OPTIONS * const options,
+			unsigned long mysql_flags
+			TSRMLS_DC)
+{
+	const MYSQLND_CHARSET * charset = NULL;
+	enum_func_status ret = FAIL;
+	MYSQLND_PACKET_AUTH * auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
+	MYSQLND_PACKET_OK * ok_packet = conn->protocol->m.get_ok_packet(conn->protocol, FALSE TSRMLS_CC);
+
+	DBG_ENTER("mysqlnd_connect_run_authentication");
+
+	if (!auth_packet || !ok_packet) {
+		SET_OOM_ERROR(conn->error_info);
+		goto err;
+	}
+
+#ifdef MYSQLND_SSL_SUPPORTED
+	if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
+		auth_packet->send_half_packet = TRUE;
+	}
+#endif
+	auth_packet->user		= user;
+	auth_packet->password	= passwd;
+
+	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
+		auth_packet->charset_no	= charset->nr;
+	} else {
+#if MYSQLND_UNICODE
+		auth_packet->charset_no	= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */
+#else
+		auth_packet->charset_no	= greet_packet->charset_no;
+#endif
+	}
+	auth_packet->db			= db;
+	auth_packet->db_len		= db_len;
+	auth_packet->max_packet_size= MYSQLND_ASSEBLED_PACKET_MAX_SIZE;
+	auth_packet->client_flags= mysql_flags;
+
+	conn->scramble = auth_packet->server_scramble_buf = mnd_pemalloc(SCRAMBLE_LENGTH, conn->persistent);
+	if (!conn->scramble) {
+		SET_OOM_ERROR(conn->error_info);
+		goto err;
+	}
+	memcpy(auth_packet->server_scramble_buf, greet_packet->scramble_buf, SCRAMBLE_LENGTH);
+
+	if (!PACKET_WRITE(auth_packet, conn)) {
+		CONN_SET_STATE(conn, CONN_QUIT_SENT);
+		SET_CLIENT_ERROR(conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
+		goto err;
+	}
+
+#ifdef MYSQLND_SSL_SUPPORTED
+	if (auth_packet->send_half_packet) {
+		zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
+		DBG_INF("Switching to SSL");
+
+		conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
+
+		if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
+			goto err;
+		}
+
+		auth_packet->send_half_packet = FALSE;
+		if (!PACKET_WRITE(auth_packet, conn)) {
+			CONN_SET_STATE(conn, CONN_QUIT_SENT);
+			SET_CLIENT_ERROR(conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
+			goto err;
+		}
+	}
+#endif
+
+
+	if (FAIL == PACKET_READ(ok_packet, conn) || ok_packet->field_count >= 0xFE) {
+		if (ok_packet->field_count == 0xFE) {
+			/* old authentication with new server  !*/
+			DBG_ERR(mysqlnd_old_passwd);
+			SET_CLIENT_ERROR(conn->error_info, CR_UNKNOWN_ERROR, UNKNOWN_SQLSTATE, mysqlnd_old_passwd);
+		} else if (ok_packet->field_count == 0xFF) {
+			if (ok_packet->sqlstate[0]) {
+				strlcpy(conn->error_info.sqlstate, ok_packet->sqlstate, sizeof(conn->error_info.sqlstate));
+				DBG_ERR_FMT("ERROR:%u [SQLSTATE:%s] %s", ok_packet->error_no, ok_packet->sqlstate, ok_packet->error);
+			}
+			conn->error_info.error_no = ok_packet->error_no;
+			strlcpy(conn->error_info.error, ok_packet->error, sizeof(conn->error_info.error));
+		}
+		goto err;
+	}
+
+	SET_NEW_MESSAGE(conn->last_message, conn->last_message_len,
+					ok_packet->message, ok_packet->message_len,
+					conn->persistent);
+	conn->charset = mysqlnd_find_charset_nr(auth_packet->charset_no);
+	ret = PASS;
+err:
+	PACKET_FREE(auth_packet);
+	PACKET_FREE(ok_packet);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+#define MYSQLND_CAPABILITIES (CLIENT_LONG_PASSWORD | CLIENT_LONG_FLAG | CLIENT_TRANSACTIONS | \
+				CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | \
+				CLIENT_MULTI_RESULTS)
+
+
+
+/* {{{ mysqlnd_conn::connect */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, connect)(MYSQLND * conn,
+						 const char *host, const char *user,
+						 const char *passwd, unsigned int passwd_len,
+						 const char *db, unsigned int db_len,
+						 unsigned int port,
+						 const char * socket_or_pipe,
+						 unsigned int mysql_flags
+						 TSRMLS_DC)
+{
+	char *errstr = NULL;
+	int errcode = 0, host_len;
+	zend_bool unix_socket = FALSE;
+	zend_bool reconnect = FALSE;
+	zend_bool saved_compression = FALSE;
+
+	MYSQLND_PACKET_GREET * greet_packet = NULL;
+
+	DBG_ENTER("mysqlnd_conn::connect");
+
+	DBG_INF_FMT("host=%s user=%s db=%s port=%u flags=%u persistent=%u state=%u",
+				host?host:"", user?user:"", db?db:"", port, mysql_flags,
+				conn? conn->persistent:0, conn? CONN_GET_STATE(conn):-1);
+
+	if (conn && CONN_GET_STATE(conn) > CONN_ALLOCED && CONN_GET_STATE(conn) ) {
+		DBG_INF("Connecting on a connected handle.");
+
+		if (CONN_GET_STATE(conn) < CONN_QUIT_SENT) {
+			MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_CLOSE_IMPLICIT);
+			reconnect = TRUE;
+			conn->m->send_close(conn TSRMLS_CC);
+		}
+
+		conn->m->free_contents(conn TSRMLS_CC);
+		MYSQLND_DEC_CONN_STATISTIC(conn->stats, STAT_OPENED_CONNECTIONS);
+		if (conn->persistent) {
+			MYSQLND_DEC_CONN_STATISTIC(conn->stats, STAT_OPENED_PERSISTENT_CONNECTIONS);
+		}
+		/* Now reconnect using the same handle */
+		if (conn->net->compressed) {
+			/*
+			  we need to save the state. As we will re-connect, net->compressed should be off, or
+			  we will look for a compression header as part of the greet message, but there will
+			  be none.
+			*/
+			saved_compression = TRUE;
+			conn->net->compressed = FALSE;
+		}
+	}
+
+	if (!host || !host[0]) {
+		host = "localhost";
+	}
+	if (!user) {
+		DBG_INF_FMT("no user given, using empty string");
+		user = "";
+	}
+	if (!passwd) {
+		DBG_INF_FMT("no password given, using empty string");
+		passwd = "";
+		passwd_len = 0;
+	}
+	if (!db) {
+		DBG_INF_FMT("no db given, using empty string");
+		db = "";
+		db_len = 0;
+	}
+
+	host_len = strlen(host);
+	{
+		char * transport = NULL;
+		int transport_len;
+#ifndef PHP_WIN32
+		if (host_len == sizeof("localhost") - 1 && !strncasecmp(host, "localhost", host_len)) {
+			DBG_INF_FMT("socket=%s", socket_or_pipe? socket_or_pipe:"n/a");
+			if (!socket_or_pipe) {
+				socket_or_pipe = "/tmp/mysql.sock";
+			}
+			transport_len = spprintf(&transport, 0, "unix://%s", socket_or_pipe);
+			unix_socket = TRUE;
+		} else
+#endif
+		{
+			if (!port) {
+				port = 3306;
+			}
+			transport_len = spprintf(&transport, 0, "tcp://%s:%u", host, port);
+		}
+		if (!transport) {
+			SET_OOM_ERROR(conn->error_info);
+			goto err; /* OOM */
+		}
+		DBG_INF_FMT("transport=%s conn->scheme=%s", transport, conn->scheme);
+		conn->scheme = mnd_pestrndup(transport, transport_len, conn->persistent);
+		conn->scheme_len = transport_len;
+		efree(transport); /* allocated by spprintf */
+		transport = NULL;
+		if (!conn->scheme) {
+			goto err; /* OOM */
+		}
+	}
+
+	greet_packet = conn->protocol->m.get_greet_packet(conn->protocol, FALSE TSRMLS_CC);
+	if (!greet_packet) {
+		SET_OOM_ERROR(conn->error_info);
+		goto err; /* OOM */
+	}
+
+	if (FAIL == conn->net->m.connect(conn->net, conn->scheme, conn->scheme_len, conn->persistent, &errstr, &errcode TSRMLS_CC)) {
+		goto err;
+	}
+
+	DBG_INF_FMT("stream=%p", conn->net->stream);
+
+	if (FAIL == PACKET_READ(greet_packet, conn)) {
+		DBG_ERR("Error while reading greeting packet");
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading greeting packet. PID=%d", getpid());
+		goto err;
+	} else if (greet_packet->error_no) {
+		DBG_ERR_FMT("errorno=%u error=%s", greet_packet->error_no, greet_packet->error);
+		SET_CLIENT_ERROR(conn->error_info, greet_packet->error_no, greet_packet->sqlstate, greet_packet->error);
+		goto err;
+	} else if (greet_packet->pre41) {
+		DBG_ERR_FMT("Connecting to 3.22, 3.23 & 4.0 is not supported. Server is %-.32s", greet_packet->server_version);
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Connecting to 3.22, 3.23 & 4.0 "
+						" is not supported. Server is %-.32s", greet_packet->server_version);
+		SET_CLIENT_ERROR(conn->error_info, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE,
+						 "Connecting to 3.22, 3.23 & 4.0 servers is not supported");
+		goto err;
+	}
+
+	conn->thread_id			= greet_packet->thread_id;
+	conn->protocol_version	= greet_packet->protocol_version;
+	conn->server_version	= mnd_pestrdup(greet_packet->server_version, conn->persistent);
+
+	conn->greet_charset = mysqlnd_find_charset_nr(greet_packet->charset_no);
+	if (!conn->greet_charset) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+			"Server sent charset (%d) unknown to the client. Please, report to the developers", greet_packet->charset_no);
+		SET_CLIENT_ERROR(conn->error_info, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE,
+			"Server sent charset unknown to the client. Please, report to the developers");
+		goto err;
+	}
+	/* we allow load data local infile by default */
+	mysql_flags |= CLIENT_LOCAL_FILES | CLIENT_PS_MULTI_RESULTS;
+	mysql_flags |= MYSQLND_CAPABILITIES;
+
+	mysql_flags |= conn->options.flags; /* use the flags from set_client_option() */
+
+	if (db) {
+		mysql_flags |= CLIENT_CONNECT_WITH_DB;
+	}
+
+	if (PG(open_basedir) && strlen(PG(open_basedir))) {
+		mysql_flags ^= CLIENT_LOCAL_FILES;
+	}
+
+#ifndef MYSQLND_COMPRESSION_ENABLED
+	if (mysql_flags & CLIENT_COMPRESS) {
+		mysql_flags &= ~CLIENT_COMPRESS;
+	}
+#else
+	if (conn->net->options.flags & MYSQLND_NET_FLAG_USE_COMPRESSION) {
+		mysql_flags |= CLIENT_COMPRESS;
+	}
+#endif
+#ifndef MYSQLND_SSL_SUPPORTED
+	if (mysql_flags & CLIENT_SSL) {
+		mysql_flags &= ~CLIENT_SSL;
+	}
+#else
+	if (conn->net->options.ssl_key || conn->net->options.ssl_cert ||
+		conn->net->options.ssl_ca || conn->net->options.ssl_capath || conn->net->options.ssl_cipher)
+	{
+		mysql_flags |= CLIENT_SSL;
+	}
+#endif
+
+	if (FAIL == mysqlnd_connect_run_authentication(conn, user, passwd, db, db_len, greet_packet, &conn->options, mysql_flags TSRMLS_CC)) {
+		goto err;
+	}
+
+	{
+		CONN_SET_STATE(conn, CONN_READY);
+
+		if (saved_compression) {
+			conn->net->compressed = TRUE;
+		}
+		/*
+		  If a connect on a existing handle is performed and mysql_flags is
+		  passed which doesn't CLIENT_COMPRESS, then we need to overwrite the value
+		  which we set based on saved_compression.
+		*/
+		conn->net->compressed = mysql_flags & CLIENT_COMPRESS? TRUE:FALSE;
+
+		conn->user				= mnd_pestrdup(user, conn->persistent);
+		conn->user_len			= strlen(conn->user);
+		conn->passwd			= mnd_pestrndup(passwd, passwd_len, conn->persistent);
+		conn->passwd_len		= passwd_len;
+		conn->port				= port;
+		conn->connect_or_select_db = mnd_pestrndup(db, db_len, conn->persistent);
+		conn->connect_or_select_db_len = db_len;
+
+		if (!conn->user || !conn->passwd || !conn->connect_or_select_db) {
+			SET_OOM_ERROR(conn->error_info);
+			goto err; /* OOM */
+		}
+
+		if (!unix_socket) {
+			conn->host = mnd_pestrdup(host, conn->persistent);
+			if (!conn->host) {
+				SET_OOM_ERROR(conn->error_info);
+				goto err; /* OOM */
+			}
+			conn->host_len = strlen(conn->host);
+			{
+				char *p;
+				spprintf(&p, 0, "%s via TCP/IP", conn->host);
+				if (!p) {
+					SET_OOM_ERROR(conn->error_info);
+					goto err; /* OOM */
+				}
+				conn->host_info =  mnd_pestrdup(p, conn->persistent);
+				efree(p); /* allocated by spprintf */
+				if (!conn->host_info) {
+					SET_OOM_ERROR(conn->error_info);
+					goto err; /* OOM */
+				}
+			}
+		} else {
+			conn->unix_socket	= mnd_pestrdup(socket_or_pipe, conn->persistent);
+			conn->host_info		= mnd_pestrdup("Localhost via UNIX socket", conn->persistent);
+			if (!conn->unix_socket || !conn->host_info) {
+				SET_OOM_ERROR(conn->error_info);
+				goto err; /* OOM */
+			}
+			conn->unix_socket_len = strlen(conn->unix_socket);
+		}
+		conn->client_flag		= mysql_flags;
+		conn->max_packet_size	= MYSQLND_ASSEBLED_PACKET_MAX_SIZE;
+		/* todo: check if charset is available */
+		conn->server_capabilities = greet_packet->server_capabilities;
+		conn->upsert_status.warning_count = 0;
+		conn->upsert_status.server_status = greet_packet->server_status;
+		conn->upsert_status.affected_rows = 0;
+
+		SET_EMPTY_ERROR(conn->error_info);
+
+		mysqlnd_local_infile_default(conn);
+
+#if MYSQLND_UNICODE
+		{
+			unsigned int as_unicode = 1;
+			conn->m->set_client_option(conn, MYSQLND_OPT_NUMERIC_AND_DATETIME_AS_UNICODE, (char *)&as_unicode TSRMLS_CC);
+			DBG_INF("unicode set");
+		}
+#endif
+		if (conn->options.init_commands) {
+			unsigned int current_command = 0;
+			for (; current_command < conn->options.num_commands; ++current_command) {
+				const char * const command = conn->options.init_commands[current_command];
+				if (command) {
+					MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_INIT_COMMAND_EXECUTED_COUNT);
+					if (PASS != conn->m->query(conn, command, strlen(command) TSRMLS_CC)) {
+						MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_INIT_COMMAND_FAILED_COUNT);
+						goto err;
+					}
+					if (conn->last_query_type == QUERY_SELECT) {
+						MYSQLND_RES * result = conn->m->use_result(conn TSRMLS_CC);
+						if (result) {
+							result->m.free_result(result, TRUE TSRMLS_CC);
+						}
+					}
+				}
+			}
+		}
+
+
+		MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, STAT_CONNECT_SUCCESS, 1, STAT_OPENED_CONNECTIONS, 1);
+		if (reconnect) {
+			MYSQLND_INC_GLOBAL_STATISTIC(STAT_RECONNECT);
+		}
+		if (conn->persistent) {
+			MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, STAT_PCONNECT_SUCCESS, 1, STAT_OPENED_PERSISTENT_CONNECTIONS, 1);
+		}
+
+		DBG_INF_FMT("connection_id=%llu", conn->thread_id);
+
+		PACKET_FREE(greet_packet);
+
+		DBG_RETURN(PASS);
+	}
+err:
+	PACKET_FREE(greet_packet);
+
+	if (errstr) {
+		DBG_ERR_FMT("[%u] %.128s (trying to connect via %s)", errcode, errstr, conn->scheme);
+		SET_CLIENT_ERROR(conn->error_info, errcode? errcode:CR_CONNECTION_ERROR, UNKNOWN_SQLSTATE, errstr);
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "[%u] %.128s (trying to connect via %s)", errcode, errstr, conn->scheme);
+		/* no mnd_ since we don't allocate it */
+		efree(errstr);
+	}
+	conn->m->free_contents(conn TSRMLS_CC);
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_CONNECT_FAILURE);
+
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_connect */
+PHPAPI MYSQLND * mysqlnd_connect(MYSQLND * conn,
+						 const char *host, const char *user,
+						 const char *passwd, unsigned int passwd_len,
+						 const char *db, unsigned int db_len,
+						 unsigned int port,
+						 const char *socket_or_pipe,
+						 unsigned int mysql_flags
+						 TSRMLS_DC)
+{
+	enum_func_status ret = FAIL;
+	zend_bool self_alloced = FALSE;
+
+	DBG_ENTER("mysqlnd_connect");
+	DBG_INF_FMT("host=%s user=%s db=%s port=%u flags=%u", host?host:"", user?user:"", db?db:"", port, mysql_flags);
+
+	if (!conn) {
+		self_alloced = TRUE;
+		if (!(conn = mysqlnd_init(FALSE))) {
+			/* OOM */
+			DBG_RETURN(NULL);
+		}
+	}
+
+	ret = conn->m->connect(conn, host, user, passwd, passwd_len, db, db_len, port, socket_or_pipe, mysql_flags TSRMLS_CC);
+
+	if (ret == FAIL) {
+		if (self_alloced) {
+			/*
+			  We have alloced, thus there are no references to this
+			  object - we are free to kill it!
+			*/
+			conn->m->dtor(conn TSRMLS_CC);
+		}
+		DBG_RETURN(NULL);
+	}
+	DBG_RETURN(conn);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::change_user */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, change_user)(MYSQLND * const conn,
+										  const char *user,
+										  const char *passwd,
+										  const char *db,
+										  zend_bool silent TSRMLS_DC)
+{
+	size_t user_len;
+	enum_func_status ret = FAIL;
+	MYSQLND_PACKET_CHG_USER_RESPONSE * chg_user_resp;
+	char buffer[MYSQLND_MAX_ALLOWED_USER_LEN + 1 + 1 + SCRAMBLE_LENGTH + MYSQLND_MAX_ALLOWED_DB_LEN + 1 + 2 /* charset*/ + 2];
+	char *p = buffer;
+	const MYSQLND_CHARSET * old_cs = conn->charset;
+
+	DBG_ENTER("mysqlnd_conn::change_user");
+	DBG_INF_FMT("conn=%llu user=%s passwd=%s db=%s silent=%u",
+				conn->thread_id, user?user:"", passwd?"***":"null", db?db:"", (silent == TRUE)?1:0 );
+
+	SET_ERROR_AFF_ROWS(conn);
+
+	if (!user) {
+		user = "";
+	}
+	if (!passwd) {
+		passwd = "";
+	}
+	if (!db) {
+		db = "";
+	}
+
+	/* 1. user ASCIIZ */
+	user_len = MIN(strlen(user), MYSQLND_MAX_ALLOWED_USER_LEN);
+	memcpy(p, user, user_len);
+	p += user_len;
+	*p++ = '\0';
+
+	/* 2. password SCRAMBLE_LENGTH followed by the scramble or \0 */
+	if (passwd[0]) {
+		*p++ = SCRAMBLE_LENGTH;
+		php_mysqlnd_scramble((unsigned char *)p, conn->scramble, (unsigned char *)passwd);
+		p += SCRAMBLE_LENGTH;
+	} else {
+		*p++ = '\0';
+	}
+
+	/* 3. db ASCIIZ */
+	if (db[0]) {
+		size_t db_len = MIN(strlen(db), MYSQLND_MAX_ALLOWED_DB_LEN);
+		memcpy(p, db, db_len);
+		p += db_len;
+	}
+	*p++ = '\0';
+
+	/*
+	  4. request the current charset, or it will be reset to the system one.
+	  5.0 doesn't support it. Support added in 5.1.23 by fixing the following bug : 
+	  Bug #30472 libmysql doesn't reset charset, insert_id after succ. mysql_change_user() call
+	*/
+	if (mysqlnd_get_server_version(conn) >= 50123) {
+		int2store(p, conn->charset->nr);
+		p+=2;
+	}
+
+	if (PASS != conn->m->simple_command(conn, COM_CHANGE_USER, buffer, p - buffer,
+									   PROT_LAST /* we will handle the OK packet*/,
+									   silent, TRUE TSRMLS_CC)) {
+		DBG_RETURN(FAIL);
+	}
+
+	chg_user_resp = conn->protocol->m.get_change_user_response_packet(conn->protocol, FALSE TSRMLS_CC);
+	if (!chg_user_resp) {
+		SET_OOM_ERROR(conn->error_info);
+		goto end;
+	}
+	ret = PACKET_READ(chg_user_resp, conn);
+	conn->error_info = chg_user_resp->error_info;
+
+	if (conn->error_info.error_no) {
+		ret = FAIL;
+		/*
+		  COM_CHANGE_USER is broken in 5.1. At least in 5.1.15 and 5.1.14, 5.1.11 is immune.
+		  bug#25371 mysql_change_user() triggers "packets out of sync"
+		  When it gets fixed, there should be one more check here
+		*/
+		if (mysqlnd_get_server_version(conn) > 50113L && mysqlnd_get_server_version(conn) < 50118L) {
+			MYSQLND_PACKET_OK * redundant_error_packet = conn->protocol->m.get_ok_packet(conn->protocol, FALSE TSRMLS_CC);
+			if (redundant_error_packet) {
+				PACKET_READ(redundant_error_packet, conn);
+				PACKET_FREE(redundant_error_packet);
+				DBG_INF_FMT("Server is %u, buggy, sends two ERR messages", mysqlnd_get_server_version(conn));
+			} else {
+				SET_OOM_ERROR(conn->error_info);
+			}
+		}
+	}
+	if (ret == PASS) {
+		char * tmp = NULL;
+		/* if we get conn->user as parameter and then we first free it, then estrndup it, we will crash */
+		tmp = mnd_pestrndup(user, user_len, conn->persistent);
+		if (conn->user) {
+			mnd_pefree(conn->user, conn->persistent);
+		}
+		conn->user = tmp;
+
+		tmp = mnd_pestrdup(passwd, conn->persistent);
+		if (conn->passwd) {
+			mnd_pefree(conn->passwd, conn->persistent);
+		}
+		conn->passwd = tmp;
+
+		if (conn->last_message) {
+			mnd_pefree(conn->last_message, conn->persistent);
+			conn->last_message = NULL;
+		}
+		memset(&conn->upsert_status, 0, sizeof(conn->upsert_status));
+		/* set charset for old servers */
+		if (mysqlnd_get_server_version(conn) < 50123) {
+			ret = conn->m->set_charset(conn, old_cs->name TSRMLS_CC);
+		}
+	} else if (ret == FAIL && chg_user_resp->server_asked_323_auth == TRUE) {
+		/* old authentication with new server  !*/
+		DBG_ERR(mysqlnd_old_passwd);
+		SET_CLIENT_ERROR(conn->error_info, CR_UNKNOWN_ERROR, UNKNOWN_SQLSTATE, mysqlnd_old_passwd);
+	}
+end:
+	PACKET_FREE(chg_user_resp);
+
+	/*
+	  Here we should close all statements. Unbuffered queries should not be a
+	  problem as we won't allow sending COM_CHANGE_USER.
+	*/
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::query */
+/*
+  If conn->error_info.error_no is not zero, then we had an error.
+  Still the result from the query is PASS
+*/
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, query)(MYSQLND * conn, const char * query, unsigned int query_len TSRMLS_DC)
+{
+	enum_func_status ret = FAIL;
+	DBG_ENTER("mysqlnd_conn::query");
+	DBG_INF_FMT("conn=%llu query=%s", conn->thread_id, query);
+
+	if (PASS == conn->m->send_query(conn, query, query_len TSRMLS_CC) &&
+		PASS == conn->m->reap_query(conn TSRMLS_CC))
+	{
+		ret = PASS;
+		if (conn->last_query_type == QUERY_UPSERT && conn->upsert_status.affected_rows) {
+			MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn->stats, STAT_ROWS_AFFECTED_NORMAL, conn->upsert_status.affected_rows);
+		}
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::send_query */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, send_query)(MYSQLND * conn, const char * query, unsigned int query_len TSRMLS_DC)
+{
+	enum_func_status ret;
+	DBG_ENTER("mysqlnd_conn::send_query");
+	DBG_INF_FMT("conn=%llu query=%s", conn->thread_id, query);
+
+	ret = conn->m->simple_command(conn, COM_QUERY, query, query_len,
+								 PROT_LAST /* we will handle the OK packet*/,
+								 FALSE, FALSE TSRMLS_CC);
+	if (PASS == ret) {
+		CONN_SET_STATE(conn, CONN_QUERY_SENT);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::reap_query */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, reap_query)(MYSQLND * conn TSRMLS_DC)
+{
+	enum_mysqlnd_connection_state state = CONN_GET_STATE(conn);
+	DBG_ENTER("mysqlnd_conn::reap_query");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	if (state <= CONN_READY || state == CONN_QUIT_SENT) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Connection not opened, clear or has been closed");
+		DBG_ERR_FMT("Connection not opened, clear or has been closed. State=%u", state);
+		DBG_RETURN(FAIL);
+	}
+	/*
+	  Here read the result set. We don't do it in simple_command because it need
+	  information from the ok packet. We will fetch it ourselves.
+	*/
+	DBG_RETURN(conn->m->query_read_result_set_header(conn, NULL TSRMLS_CC));
+}
+/* }}} */
+
+
+#include "php_network.h"
+
+MYSQLND ** mysqlnd_stream_array_check_for_readiness(MYSQLND ** conn_array TSRMLS_DC)
+{
+	int cnt = 0;
+	MYSQLND **p = conn_array, **p_p;
+	MYSQLND **ret = NULL;
+
+	while (*p) {
+		if (CONN_GET_STATE(*p) <= CONN_READY || CONN_GET_STATE(*p) == CONN_QUIT_SENT) {
+			cnt++;
+		}
+		p++;
+	}
+	if (cnt) {
+		MYSQLND **ret_p = ret = ecalloc(cnt + 1, sizeof(MYSQLND *));
+		p_p = p = conn_array;
+		while (*p) {
+			if (CONN_GET_STATE(*p) <= CONN_READY || CONN_GET_STATE(*p) == CONN_QUIT_SENT) {
+				*ret_p = *p;
+				*p = NULL;
+				ret_p++;
+			} else {
+				*p_p = *p;
+				p_p++;
+			}
+			p++;
+		}
+		*ret_p = NULL;
+	}
+	return ret;
+}
+
+
+/* {{{ stream_select mysqlnd_stream_array_to_fd_set functions */
+static int mysqlnd_stream_array_to_fd_set(MYSQLND **conn_array, fd_set *fds, php_socket_t *max_fd TSRMLS_DC)
+{
+	php_socket_t this_fd;
+	int cnt = 0;
+	MYSQLND **p = conn_array;
+
+	while (*p) {
+		/* get the fd.
+		 * NB: Most other code will NOT use the PHP_STREAM_CAST_INTERNAL flag
+		 * when casting.  It is only used here so that the buffered data warning
+		 * is not displayed.
+		 * */
+		if (SUCCESS == php_stream_cast((*p)->net->stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL,
+										(void*)&this_fd, 1) && this_fd >= 0) {
+
+			PHP_SAFE_FD_SET(this_fd, fds);
+
+			if (this_fd > *max_fd) {
+				*max_fd = this_fd;
+			}
+			cnt++;
+		}
+		p++;
+	}
+	return cnt ? 1 : 0;
+}
+
+static int mysqlnd_stream_array_from_fd_set(MYSQLND **conn_array, fd_set *fds TSRMLS_DC)
+{
+	php_socket_t this_fd;
+	int ret = 0;
+	zend_bool disproportion = FALSE;
+
+
+	MYSQLND **fwd = conn_array, **bckwd = conn_array;
+
+	while (*fwd) {
+		if (SUCCESS == php_stream_cast((*fwd)->net->stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL,
+										(void*)&this_fd, 1) && this_fd >= 0) {
+			if (PHP_SAFE_FD_ISSET(this_fd, fds)) {
+				if (disproportion) {
+					*bckwd = *fwd;
+				}
+				bckwd++;
+				fwd++;
+				ret++;
+				continue;
+			}
+		}
+		disproportion = TRUE;
+		fwd++;
+	}
+	*bckwd = NULL;/* NULL-terminate the list */
+
+	return ret;
+}
+/* }}} */
+
+#ifndef PHP_WIN32
+#define php_select(m, r, w, e, t)	select(m, r, w, e, t)
+#else
+#include "win32/select.h"
+#endif
+
+/* {{{ _mysqlnd_poll */
+PHPAPI enum_func_status
+_mysqlnd_poll(MYSQLND **r_array, MYSQLND **e_array, MYSQLND ***dont_poll, long sec, long usec, uint * desc_num TSRMLS_DC)
+{
+
+	struct timeval	tv;
+	struct timeval *tv_p = NULL;
+	fd_set			rfds, wfds, efds;
+	php_socket_t	max_fd = 0;
+	int				retval, sets = 0;
+	int				set_count, max_set_count = 0;
+	DBG_ENTER("mysqlnd_poll");
+
+	if (sec < 0 || usec < 0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Negative values passed for sec and/or usec");
+		DBG_RETURN(FAIL);
+	}
+
+	*dont_poll = mysqlnd_stream_array_check_for_readiness(r_array TSRMLS_CC);
+
+	FD_ZERO(&rfds);
+	FD_ZERO(&wfds);
+	FD_ZERO(&efds);
+
+	if (r_array != NULL) {
+		set_count = mysqlnd_stream_array_to_fd_set(r_array, &rfds, &max_fd TSRMLS_CC);
+		if (set_count > max_set_count) {
+			max_set_count = set_count;
+		}
+		sets += set_count;
+	}
+
+	if (e_array != NULL) {
+		set_count = mysqlnd_stream_array_to_fd_set(e_array, &efds, &max_fd TSRMLS_CC);
+		if (set_count > max_set_count) {
+			max_set_count = set_count;
+		}
+		sets += set_count;
+	}
+
+	if (!sets) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, *dont_poll ? "All arrays passed are clear":"No stream arrays were passed");
+		DBG_ERR_FMT(*dont_poll ? "All arrays passed are clear":"No stream arrays were passed");
+		DBG_RETURN(FAIL);
+	}
+
+	PHP_SAFE_MAX_FD(max_fd, max_set_count);
+
+	/* Solaris + BSD do not like microsecond values which are >= 1 sec */
+	if (usec > 999999) {
+		tv.tv_sec = sec + (usec / 1000000);
+		tv.tv_usec = usec % 1000000;
+	} else {
+		tv.tv_sec = sec;
+		tv.tv_usec = usec;
+	}
+
+	tv_p = &tv;
+
+	retval = php_select(max_fd + 1, &rfds, &wfds, &efds, tv_p);
+
+	if (retval == -1) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "unable to select [%d]: %s (max_fd=%d)",
+						errno, strerror(errno), max_fd);
+		DBG_RETURN(FAIL);
+	}
+
+	if (r_array != NULL) {
+		mysqlnd_stream_array_from_fd_set(r_array, &rfds TSRMLS_CC);
+	}
+	if (e_array != NULL) {
+		mysqlnd_stream_array_from_fd_set(e_array, &efds TSRMLS_CC);
+	}
+
+	*desc_num = retval;
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/*
+  COM_FIELD_LIST is special, different from a SHOW FIELDS FROM :
+  - There is no result set header - status from the command, which
+    impacts us to allocate big chunk of memory for reading the metadata.
+  - The EOF packet is consumed by the metadata packet reader.
+*/
+
+/* {{{ mysqlnd_conn::list_fields */
+MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_conn, list_fields)(MYSQLND * conn, const char *table, const char *achtung_wild TSRMLS_DC)
+{
+	/* db + \0 + wild + \0 (for wild) */
+	char buff[MYSQLND_MAX_ALLOWED_DB_LEN * 2 + 1 + 1], *p;
+	size_t table_len, wild_len;
+	MYSQLND_RES *result = NULL;
+	DBG_ENTER("mysqlnd_conn::list_fields");
+	DBG_INF_FMT("conn=%llu table=%s wild=%s", conn->thread_id, table? table:"",achtung_wild? achtung_wild:"");
+
+	p = buff;
+	if (table && (table_len = strlen(table))) {
+		size_t to_copy = MIN(table_len, MYSQLND_MAX_ALLOWED_DB_LEN);
+		memcpy(p, table, to_copy);
+		p += to_copy;
+		*p++ = '\0';
+	}
+
+	if (achtung_wild && (wild_len = strlen(achtung_wild))) {
+		size_t to_copy = MIN(wild_len, MYSQLND_MAX_ALLOWED_DB_LEN);
+		memcpy(p, achtung_wild, to_copy);
+		p += to_copy;
+		*p++ = '\0';
+	}
+
+	if (PASS != conn->m->simple_command(conn, COM_FIELD_LIST, buff, p - buff,
+									   PROT_LAST /* we will handle the OK packet*/,
+									   FALSE, TRUE TSRMLS_CC)) {
+		DBG_RETURN(NULL);
+	}
+
+	/*
+	   Prepare for the worst case.
+	   MyISAM goes to 2500 BIT columns, double it for safety.
+	*/
+	result = conn->m->result_init(5000, conn->persistent TSRMLS_CC);
+	if (!result) {
+		DBG_RETURN(NULL);
+	}
+
+	if (FAIL == result->m.read_result_metadata(result, conn TSRMLS_CC)) {
+		DBG_ERR("Error ocurred while reading metadata");
+		result->m.free_result(result, TRUE TSRMLS_CC);
+		DBG_RETURN(NULL);
+	}
+
+	result->type = MYSQLND_RES_NORMAL;
+	result->m.fetch_row = result->m.fetch_row_normal_unbuffered;
+	result->unbuf = mnd_ecalloc(1, sizeof(MYSQLND_RES_UNBUFFERED));
+	if (!result->unbuf) {
+		/* OOM */
+		SET_OOM_ERROR(conn->error_info);
+		result->m.free_result(result, TRUE TSRMLS_CC);
+		DBG_RETURN(NULL);
+	}
+	result->unbuf->eof_reached = TRUE;
+
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::list_method */
+MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_conn, list_method)(MYSQLND * conn, const char * query, const char *achtung_wild, char *par1 TSRMLS_DC)
+{
+	char *show_query = NULL;
+	size_t show_query_len;
+	MYSQLND_RES *result = NULL;
+
+	DBG_ENTER("mysqlnd_conn::list_method");
+	DBG_INF_FMT("conn=%llu query=%s wild=%u", conn->thread_id, query, achtung_wild);
+
+	if (par1) {
+		if (achtung_wild) {
+			show_query_len = spprintf(&show_query, 0, query, par1, achtung_wild);
+		} else {
+			show_query_len = spprintf(&show_query, 0, query, par1);
+		}
+	} else {
+		if (achtung_wild) {
+			show_query_len = spprintf(&show_query, 0, query, achtung_wild);
+		} else {
+			show_query_len = strlen(show_query = (char *)query);
+		}
+	}
+
+	if (PASS == conn->m->query(conn, show_query, show_query_len TSRMLS_CC)) {
+		result = conn->m->store_result(conn TSRMLS_CC);
+	}
+	if (show_query != query) {
+		efree(show_query); /* allocated by spprintf */
+	}
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::errno */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_conn, errno)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->error_info.error_no;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::error */
+static const char *
+MYSQLND_METHOD(mysqlnd_conn, error)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->error_info.error;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::sqlstate */
+static const char *
+MYSQLND_METHOD(mysqlnd_conn, sqlstate)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->error_info.sqlstate[0] ? conn->error_info.sqlstate:MYSQLND_SQLSTATE_NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_old_escape_string */
+PHPAPI ulong mysqlnd_old_escape_string(char *newstr, const char *escapestr, size_t escapestr_len TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_old_escape_string");
+	DBG_RETURN(mysqlnd_cset_escape_slashes(mysqlnd_find_charset_name("latin1"), newstr, escapestr, escapestr_len TSRMLS_CC));
+}
+/* }}} */
+
+/* {{{ mysqlnd_conn::ssl_set */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, ssl_set)(MYSQLND * const conn, const char * key, const char * const cert, const char * const ca, const char * const capath, const char * const cipher TSRMLS_DC)
+{
+	return (PASS == conn->net->m.set_client_option(conn->net, MYSQLND_OPT_SSL_KEY, key TSRMLS_CC) &&
+		PASS == conn->net->m.set_client_option(conn->net, MYSQLND_OPT_SSL_CERT, cert TSRMLS_CC) &&
+		PASS == conn->net->m.set_client_option(conn->net, MYSQLND_OPT_SSL_CA, ca TSRMLS_CC) &&
+		PASS == conn->net->m.set_client_option(conn->net, MYSQLND_OPT_SSL_CAPATH, capath TSRMLS_CC) &&
+		PASS == conn->net->m.set_client_option(conn->net, MYSQLND_OPT_SSL_CIPHER, cipher TSRMLS_CC)) ? PASS : FAIL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::escape_string */
+static ulong
+MYSQLND_METHOD(mysqlnd_conn, escape_string)(MYSQLND * const conn, char *newstr, const char *escapestr, size_t escapestr_len TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::escape_string");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+	if (conn->upsert_status.server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES) {
+		DBG_RETURN(mysqlnd_cset_escape_quotes(conn->charset, newstr, escapestr, escapestr_len TSRMLS_CC));
+	}
+	DBG_RETURN(mysqlnd_cset_escape_slashes(conn->charset, newstr, escapestr, escapestr_len TSRMLS_CC));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::dump_debug_info */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, dump_debug_info)(MYSQLND * const conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::dump_debug_info");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+	DBG_RETURN(conn->m->simple_command(conn, COM_DEBUG, NULL, 0, PROT_EOF_PACKET, FALSE, TRUE TSRMLS_CC));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::select_db */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, select_db)(MYSQLND * const conn, const char * const db, unsigned int db_len TSRMLS_DC)
+{
+	enum_func_status ret;
+
+	DBG_ENTER("mysqlnd_conn::select_db");
+	DBG_INF_FMT("conn=%llu db=%s", conn->thread_id, db);
+
+	ret = conn->m->simple_command(conn, COM_INIT_DB, db, db_len, PROT_OK_PACKET, FALSE, TRUE TSRMLS_CC);
+	/*
+	  The server sends 0 but libmysql doesn't read it and has established
+	  a protocol of giving back -1. Thus we have to follow it :(
+	*/
+	SET_ERROR_AFF_ROWS(conn);
+	if (ret == PASS) {
+		if (conn->connect_or_select_db) {
+			mnd_pefree(conn->connect_or_select_db, conn->persistent);
+		}
+		conn->connect_or_select_db = mnd_pestrndup(db, db_len, conn->persistent);
+		conn->connect_or_select_db_len = db_len;
+		if (!conn->connect_or_select_db) {
+			/* OOM */
+			SET_OOM_ERROR(conn->error_info);
+			ret = FAIL;
+		}
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::ping */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, ping)(MYSQLND * const conn TSRMLS_DC)
+{
+	enum_func_status ret;
+
+	DBG_ENTER("mysqlnd_conn::ping");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	ret = conn->m->simple_command(conn, COM_PING, NULL, 0, PROT_OK_PACKET, TRUE, TRUE TSRMLS_CC);
+	/*
+	  The server sends 0 but libmysql doesn't read it and has established
+	  a protocol of giving back -1. Thus we have to follow it :(
+	*/
+	SET_ERROR_AFF_ROWS(conn);
+
+	DBG_INF_FMT("ret=%u", ret);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::statistic */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, statistic)(MYSQLND * conn, char **message, unsigned int * message_len TSRMLS_DC)
+{
+	enum_func_status ret;
+	MYSQLND_PACKET_STATS * stats_header;
+
+	DBG_ENTER("mysqlnd_conn::statistic");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	ret = conn->m->simple_command(conn, COM_STATISTICS, NULL, 0, PROT_LAST, FALSE, TRUE TSRMLS_CC);
+	if (FAIL == ret) {
+		DBG_RETURN(FAIL);
+	}
+	stats_header = conn->protocol->m.get_stats_packet(conn->protocol, FALSE TSRMLS_CC);
+	if (!stats_header) {
+		SET_OOM_ERROR(conn->error_info);
+		DBG_RETURN(FAIL);
+	}
+
+	if (FAIL == (ret = PACKET_READ(stats_header, conn))) {
+		DBG_RETURN(FAIL);
+	}
+	/* will be freed by Zend, thus don't use the mnd_ allocator */
+	*message = estrndup(stats_header->message, stats_header->message_len); 
+	*message_len = stats_header->message_len;
+	PACKET_FREE(stats_header);
+
+	DBG_INF(*message);
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::kill */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, kill)(MYSQLND * conn, unsigned int pid TSRMLS_DC)
+{
+	enum_func_status ret;
+	char buff[4];
+
+	DBG_ENTER("mysqlnd_conn::kill");
+	DBG_INF_FMT("conn=%llu pid=%u", conn->thread_id, pid);
+
+	int4store(buff, pid);
+
+	/* If we kill ourselves don't expect OK packet, PROT_LAST will skip it */
+	if (pid != conn->thread_id) {
+		ret = conn->m->simple_command(conn, COM_PROCESS_KILL, buff, 4, PROT_OK_PACKET, FALSE, TRUE TSRMLS_CC);
+		/*
+		  The server sends 0 but libmysql doesn't read it and has established
+		  a protocol of giving back -1. Thus we have to follow it :(
+		*/
+		SET_ERROR_AFF_ROWS(conn);
+	} else if (PASS == (ret = conn->m->simple_command(conn, COM_PROCESS_KILL, buff, 4, PROT_LAST, FALSE, TRUE TSRMLS_CC))) {
+		CONN_SET_STATE(conn, CONN_QUIT_SENT);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::set_charset */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, set_charset)(MYSQLND * const conn, const char * const csname TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	char * query;
+	size_t query_len;
+	const MYSQLND_CHARSET * const charset = mysqlnd_find_charset_name(csname);
+
+	DBG_ENTER("mysqlnd_conn::set_charset");
+	DBG_INF_FMT("conn=%llu cs=%s", conn->thread_id, csname);
+
+	if (!charset) {
+		SET_CLIENT_ERROR(conn->error_info, CR_CANT_FIND_CHARSET, UNKNOWN_SQLSTATE,
+						 "Invalid characterset or character set not supported");
+		DBG_RETURN(FAIL);
+	}
+
+	query_len = spprintf(&query, 0, "SET NAMES %s", csname);
+
+	if (FAIL == conn->m->query(conn, query, query_len TSRMLS_CC)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error executing query");
+	} else if (conn->error_info.error_no) {
+		ret = FAIL;
+	} else {
+		conn->charset = charset;
+	}
+	efree(query); /* allocated by spprintf */
+
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::refresh */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, refresh)(MYSQLND * const conn, uint8_t options TSRMLS_DC)
+{
+	zend_uchar bits[1];
+	DBG_ENTER("mysqlnd_conn::refresh");
+	DBG_INF_FMT("conn=%llu options=%lu", conn->thread_id, options);
+
+	int1store(bits, options);
+
+	DBG_RETURN(conn->m->simple_command(conn, COM_REFRESH, (char *)bits, 1, PROT_OK_PACKET, FALSE, TRUE TSRMLS_CC));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::shutdown */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, shutdown)(MYSQLND * const conn, uint8_t level TSRMLS_DC)
+{
+	zend_uchar bits[1];
+	DBG_ENTER("mysqlnd_conn::shutdown");
+	DBG_INF_FMT("conn=%llu level=%lu", conn->thread_id, level);
+
+	int1store(bits, level);
+
+	DBG_RETURN(conn->m->simple_command(conn, COM_SHUTDOWN, (char *)bits, 1, PROT_OK_PACKET, FALSE, TRUE TSRMLS_CC));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_send_close */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, send_close)(MYSQLND * const conn TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+
+	DBG_ENTER("mysqlnd_send_close");
+	DBG_INF_FMT("conn=%llu conn->net->stream->abstract=%p",
+				conn->thread_id, conn->net->stream? conn->net->stream->abstract:NULL);
+
+	switch (CONN_GET_STATE(conn)) {
+		case CONN_READY:
+			DBG_INF("Connection clean, sending COM_QUIT");
+			if (conn->net->stream) {
+				ret =  conn->m->simple_command(conn, COM_QUIT, NULL, 0, PROT_LAST, TRUE, TRUE TSRMLS_CC);
+			}
+			/* Do nothing */
+			break;
+		case CONN_SENDING_LOAD_DATA:
+			/*
+			  Don't send COM_QUIT if we are in a middle of a LOAD DATA or we
+			  will crash (assert) a debug server.
+			*/
+		case CONN_NEXT_RESULT_PENDING:
+		case CONN_QUERY_SENT:
+		case CONN_FETCHING_DATA:
+			MYSQLND_INC_GLOBAL_STATISTIC(STAT_CLOSE_IN_MIDDLE);
+			DBG_ERR_FMT("Brutally closing connection [%p][%s]", conn, conn->scheme);
+			/*
+			  Do nothing, the connection will be brutally closed
+			  and the server will catch it and free close from its side.
+			*/
+		case CONN_ALLOCED:
+			/*
+			  Allocated but not connected or there was failure when trying
+			  to connect with pre-allocated connect.
+
+			  Fall-through
+			*/
+		case CONN_QUIT_SENT:
+			/* The user has killed its own connection */
+			break;
+	}
+	/*
+	  We hold one reference, and every other object which needs the
+	  connection does increase it by 1.
+	*/
+	CONN_SET_STATE(conn, CONN_QUIT_SENT);
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::close */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, close)(MYSQLND * conn, enum_connection_close_type close_type TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	static enum_mysqlnd_collected_stats
+	close_type_to_stat_map[MYSQLND_CLOSE_LAST] = {
+		STAT_CLOSE_EXPLICIT,
+		STAT_CLOSE_IMPLICIT,
+		STAT_CLOSE_DISCONNECT
+	};
+	enum_mysqlnd_collected_stats statistic = close_type_to_stat_map[close_type];
+
+	DBG_ENTER("mysqlnd_conn::close");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	if (conn->state >= CONN_READY) {
+		MYSQLND_INC_CONN_STATISTIC(conn->stats, statistic);
+		MYSQLND_DEC_CONN_STATISTIC(conn->stats, STAT_OPENED_CONNECTIONS);
+		if (conn->persistent) {
+			MYSQLND_DEC_CONN_STATISTIC(conn->stats, STAT_OPENED_PERSISTENT_CONNECTIONS);
+		}
+	}
+
+	/*
+	  Close now, free_reference will try,
+	  if we are last, but that's not a problem.
+	*/
+	ret = conn->m->send_close(conn TSRMLS_CC);
+
+	ret = conn->m->free_reference(conn TSRMLS_CC);
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::get_reference */
+static MYSQLND *
+MYSQLND_METHOD_PRIVATE(mysqlnd_conn, get_reference)(MYSQLND * const conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::get_reference");
+	++conn->refcount;
+	DBG_INF_FMT("conn=%llu new_refcount=%u", conn->thread_id, conn->refcount);
+	DBG_RETURN(conn);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::free_reference */
+static enum_func_status
+MYSQLND_METHOD_PRIVATE(mysqlnd_conn, free_reference)(MYSQLND * const conn TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	DBG_ENTER("mysqlnd_conn::free_reference");
+	DBG_INF_FMT("conn=%llu old_refcount=%u", conn->thread_id, conn->refcount);
+	if (!(--conn->refcount)) {
+		/*
+		  No multithreading issues as we don't share the connection :)
+		  This will free the object too, of course because references has
+		  reached zero.
+		*/
+		ret = conn->m->send_close(conn TSRMLS_CC);
+		conn->m->dtor(conn TSRMLS_CC);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::get_state */
+static enum mysqlnd_connection_state
+MYSQLND_METHOD_PRIVATE(mysqlnd_conn, get_state)(MYSQLND * const conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::get_state");
+	DBG_RETURN(conn->state);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::set_state */
+static void
+MYSQLND_METHOD_PRIVATE(mysqlnd_conn, set_state)(MYSQLND * const conn, enum mysqlnd_connection_state new_state TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::set_state");
+	DBG_INF_FMT("New state=%u", new_state);
+	conn->state = new_state;
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::field_count */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_conn, field_count)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->field_count;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::insert_id */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_conn, insert_id)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->upsert_status.last_insert_id;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::affected_rows */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_conn, affected_rows)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->upsert_status.affected_rows;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::warning_count */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_conn, warning_count)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->upsert_status.warning_count;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::info */
+static const char *
+MYSQLND_METHOD(mysqlnd_conn, info)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->last_message;
+}
+/* }}} */
+
+#if !defined(MYSQLND_USE_OPTIMISATIONS) || MYSQLND_USE_OPTIMISATIONS == 0
+/* {{{ mysqlnd_get_client_info */
+PHPAPI const char * mysqlnd_get_client_info()
+{
+	return MYSQLND_VERSION;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_get_client_version */
+PHPAPI unsigned int mysqlnd_get_client_version()
+{
+	return MYSQLND_VERSION_ID;
+}
+/* }}} */
+#endif
+
+/* {{{ mysqlnd_conn::get_server_info */
+static const char *
+MYSQLND_METHOD(mysqlnd_conn, get_server_info)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->server_version;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::get_host_info */
+static const char *
+MYSQLND_METHOD(mysqlnd_conn, get_host_info)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->host_info;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::get_proto_info */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_conn, get_proto_info)(const MYSQLND *const conn TSRMLS_DC)
+{
+	return conn->protocol_version;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::charset_name */
+static const char *
+MYSQLND_METHOD(mysqlnd_conn, charset_name)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->charset->name;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::thread_id */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_conn, thread_id)(const MYSQLND * const conn TSRMLS_DC)
+{
+	return conn->thread_id;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::get_server_version */
+static unsigned long
+MYSQLND_METHOD(mysqlnd_conn, get_server_version)(const MYSQLND * const conn TSRMLS_DC)
+{
+	long major, minor, patch;
+	char *p;
+
+	if (!(p = conn->server_version)) {
+		return 0;
+	}
+
+	major = strtol(p, &p, 10);
+	p += 1; /* consume the dot */
+	minor = strtol(p, &p, 10);
+	p += 1; /* consume the dot */
+	patch = strtol(p, &p, 10);
+
+	return (unsigned long)(major * 10000L + (unsigned long)(minor * 100L + patch));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::more_results */
+static zend_bool
+MYSQLND_METHOD(mysqlnd_conn, more_results)(const MYSQLND * const conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::more_results");
+	/* (conn->state == CONN_NEXT_RESULT_PENDING) too */
+	DBG_RETURN(conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS? TRUE:FALSE);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::next_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, next_result)(MYSQLND * const conn TSRMLS_DC)
+{
+	enum_func_status ret;
+
+	DBG_ENTER("mysqlnd_conn::next_result");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	if (CONN_GET_STATE(conn) != CONN_NEXT_RESULT_PENDING) {
+		DBG_RETURN(FAIL);
+	}
+
+	SET_EMPTY_ERROR(conn->error_info);
+	SET_ERROR_AFF_ROWS(conn);
+	/*
+	  We are sure that there is a result set, since conn->state is set accordingly
+	  in mysqlnd_store_result() or mysqlnd_fetch_row_unbuffered()
+	*/
+	if (FAIL == (ret = conn->m->query_read_result_set_header(conn, NULL TSRMLS_CC))) {
+		/*
+		  There can be an error in the middle of a multi-statement, which will cancel the multi-statement.
+		  So there are no more results and we should just return FALSE, error_no has been set
+		*/
+		if (!conn->error_info.error_no) {
+			DBG_ERR_FMT("Serious error. %s::%u", __FILE__, __LINE__);
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Serious error. PID=%d", getpid());
+			CONN_SET_STATE(conn, CONN_QUIT_SENT);
+		} else {
+			DBG_INF_FMT("Error from the server : (%u) %s", conn->error_info.error_no, conn->error_info.error);
+		}
+	}
+	if (ret == PASS && conn->last_query_type == QUERY_UPSERT && conn->upsert_status.affected_rows) {
+		MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn->stats, STAT_ROWS_AFFECTED_NORMAL, conn->upsert_status.affected_rows);
+	}
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_field_type_name */
+PHPAPI const char *mysqlnd_field_type_name(enum mysqlnd_field_types field_type)
+{
+	switch(field_type) {
+		case FIELD_TYPE_STRING:
+		case FIELD_TYPE_VAR_STRING:
+			return "string";
+		case FIELD_TYPE_TINY:
+		case FIELD_TYPE_SHORT:
+		case FIELD_TYPE_LONG:
+		case FIELD_TYPE_LONGLONG:
+		case FIELD_TYPE_INT24:
+			return "int";
+		case FIELD_TYPE_FLOAT:
+		case FIELD_TYPE_DOUBLE:
+		case FIELD_TYPE_DECIMAL:
+		case FIELD_TYPE_NEWDECIMAL:
+			return "real";
+		case FIELD_TYPE_TIMESTAMP:
+			return "timestamp";
+		case FIELD_TYPE_YEAR:
+			return "year";
+		case FIELD_TYPE_DATE:
+		case FIELD_TYPE_NEWDATE:
+			return "date";
+		case FIELD_TYPE_TIME:
+			return "time";
+		case FIELD_TYPE_SET:
+			return "set";
+		case FIELD_TYPE_ENUM:
+			return "enum";
+		case FIELD_TYPE_GEOMETRY:
+			return "geometry";
+		case FIELD_TYPE_DATETIME:
+			return "datetime";
+		case FIELD_TYPE_TINY_BLOB:
+		case FIELD_TYPE_MEDIUM_BLOB:
+		case FIELD_TYPE_LONG_BLOB:
+		case FIELD_TYPE_BLOB:
+			return "blob";
+		case FIELD_TYPE_NULL:
+			return "null";
+		case FIELD_TYPE_BIT:
+			return "bit";
+		default:
+			return "unknown";
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::set_client_option */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, set_client_option)(MYSQLND * const conn,
+												enum mysqlnd_option option,
+												const char * const value
+												TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	DBG_ENTER("mysqlnd_conn::set_client_option");
+	DBG_INF_FMT("conn=%llu option=%u", conn->thread_id, option);
+	switch (option) {
+		case MYSQL_OPT_COMPRESS:
+#ifdef WHEN_SUPPORTED_BY_MYSQLI
+		case MYSQL_OPT_READ_TIMEOUT:
+		case MYSQL_OPT_WRITE_TIMEOUT:
+#endif
+		case MYSQLND_OPT_SSL_KEY:
+		case MYSQLND_OPT_SSL_CERT:
+		case MYSQLND_OPT_SSL_CA:
+		case MYSQLND_OPT_SSL_CAPATH:
+		case MYSQLND_OPT_SSL_CIPHER:
+		case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:
+		case MYSQL_OPT_CONNECT_TIMEOUT:
+		case MYSQLND_OPT_NET_CMD_BUFFER_SIZE:
+		case MYSQLND_OPT_NET_READ_BUFFER_SIZE:
+			ret = conn->net->m.set_client_option(conn->net, option, value TSRMLS_CC);
+			break;
+#if MYSQLND_UNICODE
+		case MYSQLND_OPT_NUMERIC_AND_DATETIME_AS_UNICODE:
+			conn->options.numeric_and_datetime_as_unicode = *(unsigned int*) value;
+			break;
+#endif
+#ifdef MYSQLND_STRING_TO_INT_CONVERSION
+		case MYSQLND_OPT_INT_AND_FLOAT_NATIVE:
+			DBG_INF("MYSQLND_OPT_INT_AND_FLOAT_NATIVE");
+			conn->options.int_and_float_native = *(unsigned int*) value;
+			break;
+#endif
+		case MYSQL_OPT_LOCAL_INFILE:
+			DBG_INF("MYSQL_OPT_LOCAL_INFILE");
+			if (!value || (*(unsigned int*) value) ? 1 : 0) {
+				conn->options.flags |= CLIENT_LOCAL_FILES;
+			} else {
+				conn->options.flags &= ~CLIENT_LOCAL_FILES;
+			}
+			break;
+		case MYSQL_INIT_COMMAND:
+		{
+			char ** new_init_commands;
+			char * new_command;
+			DBG_INF("MYSQL_INIT_COMMAND");
+			DBG_INF_FMT("command=%s", value);
+			/* when num_commands is 0, then realloc will be effectively a malloc call, internally */
+			/* Don't assign to conn->options.init_commands because in case of OOM we will lose the pointer and leak */
+			new_init_commands = mnd_perealloc(conn->options.init_commands, sizeof(char *) * (conn->options.num_commands + 1), conn->persistent);
+			if (!new_init_commands) {
+				goto oom;
+			}
+			conn->options.init_commands = new_init_commands;
+			new_command = mnd_pestrdup(value, conn->persistent);
+			if (!new_command) {
+				goto oom;
+			}
+			conn->options.init_commands[conn->options.num_commands] = new_command;
+			++conn->options.num_commands;
+			break;
+		}
+		case MYSQL_READ_DEFAULT_FILE:
+		case MYSQL_READ_DEFAULT_GROUP:
+#ifdef WHEN_SUPPORTED_BY_MYSQLI
+		case MYSQL_SET_CLIENT_IP:
+		case MYSQL_REPORT_DATA_TRUNCATION:
+#endif
+			/* currently not supported. Todo!! */
+			break;
+		case MYSQL_SET_CHARSET_NAME:
+		{
+			char * new_charset_name = mnd_pestrdup(value, conn->persistent);
+			DBG_INF("MYSQL_SET_CHARSET_NAME");
+			if (!new_charset_name) {
+				goto oom;
+			}
+			if (conn->options.charset_name) {
+				mnd_pefree(conn->options.charset_name, conn->persistent);
+			}
+			conn->options.charset_name = new_charset_name;
+			DBG_INF_FMT("charset=%s", conn->options.charset_name);
+			break;
+		}
+		case MYSQL_OPT_NAMED_PIPE:
+			conn->options.protocol = MYSQL_PROTOCOL_PIPE;
+			break;
+		case MYSQL_OPT_PROTOCOL:
+			if (*(unsigned int*) value < MYSQL_PROTOCOL_LAST) {
+				conn->options.protocol = *(unsigned int*) value;
+			}
+			break;
+#ifdef WHEN_SUPPORTED_BY_MYSQLI
+		case MYSQL_SET_CHARSET_DIR:
+		case MYSQL_OPT_RECONNECT:
+			/* we don't need external character sets, all character sets are
+			   compiled in. For compatibility we just ignore this setting.
+			   Same for protocol, we don't support old protocol */
+		case MYSQL_OPT_USE_REMOTE_CONNECTION:
+		case MYSQL_OPT_USE_EMBEDDED_CONNECTION:
+		case MYSQL_OPT_GUESS_CONNECTION:
+			/* todo: throw an error, we don't support embedded */
+			break;
+#endif
+
+#ifdef WHEN_SUPPORTED_BY_MYSQLI
+		case MYSQL_SHARED_MEMORY_BASE_NAME:
+		case MYSQL_OPT_USE_RESULT:
+		case MYSQL_SECURE_AUTH:
+			/* not sure, todo ? */
+#endif
+		default:
+			ret = FAIL;
+	}
+	DBG_RETURN(ret);
+oom:
+	SET_OOM_ERROR(conn->error_info);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::use_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_conn, use_result)(MYSQLND * const conn TSRMLS_DC)
+{
+	MYSQLND_RES * result;
+
+	DBG_ENTER("mysqlnd_conn::use_result");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	if (!conn->current_result) {
+		DBG_RETURN(NULL);
+	}
+
+	/* Nothing to store for UPSERT/LOAD DATA */
+	if (conn->last_query_type != QUERY_SELECT || CONN_GET_STATE(conn) != CONN_FETCHING_DATA) {
+		SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE,
+						 mysqlnd_out_of_sync);
+		DBG_ERR("Command out of sync");
+		DBG_RETURN(NULL);
+	}
+
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_UNBUFFERED_SETS);
+
+	conn->current_result->conn = conn->m->get_reference(conn TSRMLS_CC);
+	result = conn->current_result->m.use_result(conn->current_result, FALSE TSRMLS_CC);
+
+	if (!result) {
+		conn->current_result->m.free_result(conn->current_result, TRUE TSRMLS_CC);
+	}
+	conn->current_result = NULL;
+
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::store_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_conn, store_result)(MYSQLND * const conn TSRMLS_DC)
+{
+	MYSQLND_RES *result;
+
+	DBG_ENTER("mysqlnd_conn::store_result");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+
+	if (!conn->current_result) {
+		DBG_RETURN(NULL);
+	}
+
+	/* Nothing to store for UPSERT/LOAD DATA*/
+	if (conn->last_query_type != QUERY_SELECT || CONN_GET_STATE(conn) != CONN_FETCHING_DATA) {
+		SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE,
+						 mysqlnd_out_of_sync);
+		DBG_ERR("Command out of sync");
+		DBG_RETURN(NULL);
+	}
+
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_BUFFERED_SETS);
+
+	result = conn->current_result->m.store_result(conn->current_result, conn, FALSE TSRMLS_CC);
+	if (!result) {
+		conn->current_result->m.free_result(conn->current_result, TRUE TSRMLS_CC);
+	}
+	conn->current_result = NULL;
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::get_connection_stats */
+static void
+MYSQLND_METHOD(mysqlnd_conn, get_connection_stats)(const MYSQLND * const conn,
+												   zval *return_value
+												   TSRMLS_DC ZEND_FILE_LINE_DC)
+{
+	DBG_ENTER("mysqlnd_conn::get_connection_stats");
+	DBG_INF_FMT("conn=%llu", conn->thread_id);
+	mysqlnd_fill_stats_hash(conn->stats, mysqlnd_stats_values_names, return_value TSRMLS_CC ZEND_FILE_LINE_CC);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::set_autocommit */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, set_autocommit)(MYSQLND * conn, unsigned int mode TSRMLS_DC)
+{
+	enum_func_status ret;
+	DBG_ENTER("mysqlnd_conn::set_autocommit");
+	ret = conn->m->query(conn, (mode) ? "SET AUTOCOMMIT=1":"SET AUTOCOMMIT=0", sizeof("SET AUTOCOMMIT=1") - 1 TSRMLS_CC);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::tx_commit */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, tx_commit)(MYSQLND * conn TSRMLS_DC)
+{
+	enum_func_status ret;
+	DBG_ENTER("mysqlnd_conn::tx_commit");
+	ret = conn->m->query(conn, "COMMIT", sizeof("COMMIT") - 1 TSRMLS_CC);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn::tx_rollback */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, tx_rollback)(MYSQLND * conn TSRMLS_DC)
+{
+	enum_func_status ret;
+	DBG_ENTER("mysqlnd_conn::tx_rollback");
+	ret = conn->m->query(conn, "ROLLBACK", sizeof("ROLLBACK") - 1 TSRMLS_CC);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+
+MYSQLND_STMT * _mysqlnd_stmt_init(MYSQLND * const conn TSRMLS_DC);
+static enum_func_status MYSQLND_METHOD(mysqlnd_conn, init)(MYSQLND * conn TSRMLS_DC);
+
+static
+MYSQLND_CLASS_METHODS_START(mysqlnd_conn)
+	MYSQLND_METHOD(mysqlnd_conn, init),
+	MYSQLND_METHOD(mysqlnd_conn, connect),
+
+	MYSQLND_METHOD(mysqlnd_conn, escape_string),
+	MYSQLND_METHOD(mysqlnd_conn, set_charset),
+	MYSQLND_METHOD(mysqlnd_conn, query),
+	MYSQLND_METHOD(mysqlnd_conn, send_query),
+	MYSQLND_METHOD(mysqlnd_conn, reap_query),
+	MYSQLND_METHOD(mysqlnd_conn, use_result),
+	MYSQLND_METHOD(mysqlnd_conn, store_result),
+	MYSQLND_METHOD(mysqlnd_conn, next_result),
+	MYSQLND_METHOD(mysqlnd_conn, more_results),
+
+	_mysqlnd_stmt_init,
+
+	MYSQLND_METHOD(mysqlnd_conn, shutdown),
+	MYSQLND_METHOD(mysqlnd_conn, refresh),
+
+	MYSQLND_METHOD(mysqlnd_conn, ping),
+	MYSQLND_METHOD(mysqlnd_conn, kill),
+	MYSQLND_METHOD(mysqlnd_conn, select_db),
+	MYSQLND_METHOD(mysqlnd_conn, dump_debug_info),
+	MYSQLND_METHOD(mysqlnd_conn, change_user),
+
+	MYSQLND_METHOD(mysqlnd_conn, errno),
+	MYSQLND_METHOD(mysqlnd_conn, error),
+	MYSQLND_METHOD(mysqlnd_conn, sqlstate),
+	MYSQLND_METHOD(mysqlnd_conn, thread_id),
+
+	MYSQLND_METHOD(mysqlnd_conn, get_connection_stats),
+
+	MYSQLND_METHOD(mysqlnd_conn, get_server_version),
+	MYSQLND_METHOD(mysqlnd_conn, get_server_info),
+	MYSQLND_METHOD(mysqlnd_conn, statistic),
+	MYSQLND_METHOD(mysqlnd_conn, get_host_info),
+	MYSQLND_METHOD(mysqlnd_conn, get_proto_info),
+	MYSQLND_METHOD(mysqlnd_conn, info),
+	MYSQLND_METHOD(mysqlnd_conn, charset_name),
+	MYSQLND_METHOD(mysqlnd_conn, list_fields),
+	MYSQLND_METHOD(mysqlnd_conn, list_method),
+
+	MYSQLND_METHOD(mysqlnd_conn, insert_id),
+	MYSQLND_METHOD(mysqlnd_conn, affected_rows),
+	MYSQLND_METHOD(mysqlnd_conn, warning_count),
+	MYSQLND_METHOD(mysqlnd_conn, field_count),
+
+	MYSQLND_METHOD(mysqlnd_conn, set_server_option),
+	MYSQLND_METHOD(mysqlnd_conn, set_client_option),
+	MYSQLND_METHOD(mysqlnd_conn, free_contents),
+	MYSQLND_METHOD(mysqlnd_conn, free_options),
+	MYSQLND_METHOD(mysqlnd_conn, close),
+
+	MYSQLND_METHOD_PRIVATE(mysqlnd_conn, dtor),
+
+	mysqlnd_query_read_result_set_header,
+
+	MYSQLND_METHOD_PRIVATE(mysqlnd_conn, get_reference),
+	MYSQLND_METHOD_PRIVATE(mysqlnd_conn, free_reference),
+	MYSQLND_METHOD_PRIVATE(mysqlnd_conn, get_state),
+	MYSQLND_METHOD_PRIVATE(mysqlnd_conn, set_state),
+
+	MYSQLND_METHOD(mysqlnd_conn, simple_command),
+	MYSQLND_METHOD(mysqlnd_conn, simple_command_handle_response),
+	MYSQLND_METHOD(mysqlnd_conn, restart_psession),
+	MYSQLND_METHOD(mysqlnd_conn, end_psession),
+	MYSQLND_METHOD(mysqlnd_conn, send_close),
+
+	MYSQLND_METHOD(mysqlnd_conn, ssl_set),
+	mysqlnd_result_init
+#ifdef AUTOCOMMIT_TX_COMMIT_ROLLBACK
+	,MYSQLND_METHOD(mysqlnd_conn, set_autocommit),
+	MYSQLND_METHOD(mysqlnd_conn, tx_commit),
+	MYSQLND_METHOD(mysqlnd_conn, tx_rollback)
+#endif
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ mysqlnd_conn::init */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_conn, init)(MYSQLND * conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_conn::init");
+	mysqlnd_stats_init(&conn->stats, STAT_LAST);
+	SET_ERROR_AFF_ROWS(conn);
+
+	conn->net = mysqlnd_net_init(conn->persistent TSRMLS_CC);
+	conn->protocol = mysqlnd_protocol_init(conn->persistent TSRMLS_CC);
+
+	DBG_RETURN(conn->net && conn->protocol? PASS:FAIL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_init */
+PHPAPI MYSQLND * _mysqlnd_init(zend_bool persistent TSRMLS_DC)
+{
+	size_t alloc_size = sizeof(MYSQLND) + mysqlnd_plugin_count() * sizeof(void *);
+	MYSQLND *ret;
+
+	DBG_ENTER("mysqlnd_init");
+	DBG_INF_FMT("persistent=%u", persistent);
+	ret = mnd_pecalloc(1, alloc_size, persistent);
+	if (!ret) {
+		DBG_RETURN(NULL);
+	}
+
+	ret->persistent = persistent;
+	ret->m = mysqlnd_conn_methods;
+	CONN_SET_STATE(ret, CONN_ALLOCED);
+	ret->m->get_reference(ret TSRMLS_CC);
+
+	if (PASS != ret->m->init(ret TSRMLS_CC)) {
+		ret->m->dtor(ret TSRMLS_CC);
+		ret = NULL;
+	}
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_library_init */
+PHPAPI void mysqlnd_library_init(TSRMLS_D)
+{
+	if (mysqlnd_library_initted == FALSE) {
+		mysqlnd_library_initted = TRUE;
+		mysqlnd_conn_methods = &MYSQLND_CLASS_METHOD_TABLE_NAME(mysqlnd_conn);
+		_mysqlnd_init_ps_subsystem();
+		/* Should be calloc, as mnd_calloc will reference LOCK_access*/
+		mysqlnd_stats_init(&mysqlnd_global_stats, STAT_LAST);
+	}
+}
+/* }}} */
+
+/* {{{ mysqlnd_conn_get_methods */
+PHPAPI struct st_mysqlnd_conn_methods * mysqlnd_conn_get_methods()
+{
+	return mysqlnd_conn_methods;
+}
+/* }}} */
+
+/* {{{ mysqlnd_conn_set_methods */
+PHPAPI void mysqlnd_conn_set_methods(struct st_mysqlnd_conn_methods *methods)
+{
+	mysqlnd_conn_methods = methods;
+}
+/* }}} */
+
+
+static unsigned int mysqlnd_plugins_counter = 0;
+
+/* {{{ mysqlnd_plugin_register */
+PHPAPI unsigned int mysqlnd_plugin_register()
+{
+	return mysqlnd_plugins_counter++;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_plugin_count */
+PHPAPI unsigned int mysqlnd_plugin_count()
+{
+	return mysqlnd_plugins_counter;
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_plugin_get_plugin_connection_data */
+PHPAPI void ** _mysqlnd_plugin_get_plugin_connection_data(const MYSQLND * conn, unsigned int plugin_id TSRMLS_DC)
+{
+	DBG_ENTER("_mysqlnd_plugin_get_plugin_connection_data");
+	DBG_INF_FMT("plugin_id=%u", plugin_id);
+	if (!conn || plugin_id >= mysqlnd_plugin_count()) {
+		return NULL;
+	}
+	DBG_RETURN((void *)((char *)conn + sizeof(MYSQLND) + plugin_id * sizeof(void *)));
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd.h
@@ -0,0 +1,319 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+/* $Id: 731e5b87ba42146a687c29995d2dfd8b4e40b325 $ */
+
+#ifndef MYSQLND_H
+#define MYSQLND_H
+
+#define MYSQLND_VERSION "mysqlnd 5.0.8-dev - 20102224 - $Id: 731e5b87ba42146a687c29995d2dfd8b4e40b325 $"
+#define MYSQLND_VERSION_ID 50008
+
+/* This forces inlining of some accessor functions */
+#define MYSQLND_USE_OPTIMISATIONS 0
+#define AUTOCOMMIT_TX_COMMIT_ROLLBACK
+
+#define MYSQLND_STRING_TO_INT_CONVERSION
+/*
+  This force mysqlnd to do a single (or more depending on ammount of data)
+  non-blocking read() calls before sending a command to the server. Useful
+  for debugging, if previous function hasn't consumed all the output sent
+  to it - like stmt_send_long_data() error because the data was larger that
+  max_allowed_packet_size, and COM_STMT_SEND_LONG_DATA by protocol doesn't
+  use response packets, thus letting the next command to fail miserably, if
+  the connector implementor is not aware of this deficiency. Should be off
+  on production systems, if of course measured performance degradation is not
+  minimal.
+*/
+#if A0 && PHP_DEBUG
+#define MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND 1
+#endif
+
+#if PHP_DEBUG
+#define MYSQLND_DBG_ENABLED 1
+#else
+#define MYSQLND_DBG_ENABLED 0
+#endif
+
+#if defined(MYSQLND_COMPRESSION_WANTED) && defined(HAVE_ZLIB)
+#define MYSQLND_COMPRESSION_ENABLED 1
+#endif
+
+#ifdef ZTS
+#include "TSRM.h"
+#endif
+
+#include "mysqlnd_portability.h"
+#include "mysqlnd_enum_n_def.h"
+#include "mysqlnd_structs.h"
+
+
+/* Library related */
+PHPAPI void mysqlnd_library_init(TSRMLS_D);
+PHPAPI void mysqlnd_library_end(TSRMLS_D);
+
+PHPAPI unsigned int mysqlnd_plugin_register();
+PHPAPI unsigned int mysqlnd_plugin_count();
+PHPAPI void ** _mysqlnd_plugin_get_plugin_connection_data(const MYSQLND * conn, unsigned int plugin_id TSRMLS_DC);
+#define mysqlnd_plugin_get_plugin_connection_data(c, p_id) _mysqlnd_plugin_get_plugin_connection_data((c), (p_id) TSRMLS_CC)
+
+PHPAPI void ** _mysqlnd_plugin_get_plugin_result_data(const MYSQLND_RES * result, unsigned int plugin_id TSRMLS_DC);
+#define mysqlnd_plugin_get_plugin_result_data(r, p_id) _mysqlnd_plugin_get_plugin_result_data((r), (p_id) TSRMLS_CC)
+
+PHPAPI void ** _mysqlnd_plugin_get_plugin_stmt_data(const MYSQLND_STMT * stmt, unsigned int plugin_id TSRMLS_DC);
+#define mysqlnd_plugin_get_plugin_stmt_data(s, p_id) _mysqlnd_plugin_get_plugin_stmt_data((s), (p_id) TSRMLS_CC)
+
+PHPAPI void ** _mysqlnd_plugin_get_plugin_protocol_data(const MYSQLND_PROTOCOL * protocol, unsigned int plugin_id TSRMLS_DC);
+#define mysqlnd_plugin_get_plugin_protocol_data(p, p_id) _mysqlnd_plugin_get_plugin_protocol_data((p), (p_id) TSRMLS_CC)
+
+
+PHPAPI struct st_mysqlnd_conn_methods * mysqlnd_conn_get_methods();
+PHPAPI void mysqlnd_conn_set_methods(struct st_mysqlnd_conn_methods *methods);
+
+PHPAPI struct st_mysqlnd_stmt_methods * mysqlnd_stmt_get_methods();
+PHPAPI void mysqlnd_stmt_set_methods(struct st_mysqlnd_stmt_methods *methods);
+
+
+#define mysqlnd_restart_psession(conn)	(conn)->m->restart_psession((conn) TSRMLS_CC)
+#define mysqlnd_end_psession(conn)		(conn)->m->end_psession((conn) TSRMLS_CC)
+PHPAPI void mysqlnd_minfo_print_hash(zval *values);
+#define mysqlnd_thread_safe()	TRUE
+
+PHPAPI const MYSQLND_CHARSET * mysqlnd_find_charset_nr(unsigned int charsetno);
+PHPAPI const MYSQLND_CHARSET * mysqlnd_find_charset_name(const char * const charsetname);
+
+
+/* Connect */
+#define mysqlnd_init(persistent) _mysqlnd_init((persistent) TSRMLS_CC)
+PHPAPI MYSQLND * _mysqlnd_init(zend_bool persistent TSRMLS_DC);
+PHPAPI MYSQLND * mysqlnd_connect(MYSQLND *conn,
+						  const char *host, const char *user,
+						  const char *passwd, unsigned int passwd_len,
+						  const char *db, unsigned int db_len,
+						  unsigned int port,
+						  const char *socket_or_pipe,
+						  unsigned int mysql_flags
+						  TSRMLS_DC);
+
+#define mysqlnd_change_user(conn, user, passwd, db, silent)		(conn)->m->change_user((conn), (user), (passwd), (db), (silent) TSRMLS_CC)
+
+#define mysqlnd_debug(x)								_mysqlnd_debug((x) TSRMLS_CC)
+PHPAPI void _mysqlnd_debug(const char *mode TSRMLS_DC);
+
+/* Query */
+#define mysqlnd_fetch_into(result, flags, ret_val, ext)	(result)->m.fetch_into((result), (flags), (ret_val), (ext) TSRMLS_CC ZEND_FILE_LINE_CC)
+#define mysqlnd_fetch_row_c(result)						(result)->m.fetch_row_c((result) TSRMLS_CC)
+#define mysqlnd_fetch_all(result, flags, return_value)	(result)->m.fetch_all((result), (flags), (return_value) TSRMLS_CC ZEND_FILE_LINE_CC)
+#define mysqlnd_result_fetch_field_data(res,offset,ret)	(res)->m.fetch_field_data((res), (offset), (ret) TSRMLS_CC)
+#define mysqlnd_get_connection_stats(conn, values)		(conn)->m->get_statistics((conn),  (values) TSRMLS_CC ZEND_FILE_LINE_CC)
+#define mysqlnd_get_client_stats(values)				_mysqlnd_get_client_stats((values) TSRMLS_CC ZEND_FILE_LINE_CC)
+
+#define mysqlnd_close(conn,is_forced)					(conn)->m->close((conn), (is_forced) TSRMLS_CC)
+#define mysqlnd_query(conn, query_str, query_len)		(conn)->m->query((conn), (query_str), (query_len) TSRMLS_CC)
+#define mysqlnd_async_query(conn, query_str, query_len)	(conn)->m->send_query((conn), (query_str), (query_len) TSRMLS_CC)
+#define mysqlnd_poll(r, err, d_pull,sec,usec,desc_num)	_mysqlnd_poll((r), (err), (d_pull), (sec), (usec), (desc_num) TSRMLS_CC)
+#define mysqlnd_reap_async_query(conn)					(conn)->m->reap_query((conn) TSRMLS_CC)
+#define mysqlnd_unbuffered_skip_result(result)			(result)->m.skip_result((result) TSRMLS_CC)
+
+PHPAPI enum_func_status _mysqlnd_poll(MYSQLND **r_array, MYSQLND **e_array, MYSQLND ***dont_poll, long sec, long usec, uint * desc_num TSRMLS_DC);
+
+#define mysqlnd_use_result(conn)		(conn)->m->use_result((conn) TSRMLS_CC)
+#define mysqlnd_store_result(conn)		(conn)->m->store_result((conn) TSRMLS_CC)
+#define mysqlnd_next_result(conn)		(conn)->m->next_result((conn) TSRMLS_CC)
+#define mysqlnd_more_results(conn)		(conn)->m->more_results((conn) TSRMLS_CC)
+#define mysqlnd_free_result(r,e_or_i)	((MYSQLND_RES*)r)->m.free_result(((MYSQLND_RES*)(r)), (e_or_i) TSRMLS_CC)
+#define mysqlnd_data_seek(result, row)	(result)->m.seek_data((result), (row) TSRMLS_CC)
+
+/* Errors */
+#define mysqlnd_errno(conn)				(conn)->m->get_error_no((conn) TSRMLS_CC)
+#define mysqlnd_error(conn)				(conn)->m->get_error_str((conn) TSRMLS_CC)
+#define mysqlnd_sqlstate(conn)  		(conn)->m->get_sqlstate((conn) TSRMLS_CC)
+
+/* Charset */
+#define mysqlnd_character_set_name(conn) (conn)->m->charset_name((conn) TSRMLS_CC)
+
+/* Simple metadata */
+#define mysqlnd_field_count(conn)		(conn)->m->get_field_count((conn) TSRMLS_CC)
+#define mysqlnd_insert_id(conn)			(conn)->m->get_last_insert_id((conn) TSRMLS_CC)
+#define mysqlnd_affected_rows(conn)		(conn)->m->get_affected_rows((conn) TSRMLS_CC)
+#define mysqlnd_warning_count(conn)		(conn)->m->get_warning_count((conn) TSRMLS_CC)
+#define mysqlnd_info(conn)				(conn)->m->get_last_message((conn) TSRMLS_CC)
+#define mysqlnd_get_server_info(conn)	(conn)->m->get_server_information((conn) TSRMLS_CC)
+#define mysqlnd_get_host_info(conn)		(conn)->m->get_host_information((conn) TSRMLS_CC)
+#define mysqlnd_get_proto_info(conn)	(conn)->m->get_protocol_information((conn) TSRMLS_CC)
+#define mysqlnd_thread_id(conn)			(conn)->m->get_thread_id((conn) TSRMLS_CC)
+
+#define mysqlnd_num_rows(result)		(result)->m.num_rows((result) TSRMLS_CC)
+#define mysqlnd_num_fields(result)		(result)->m.num_fields((result) TSRMLS_CC)
+
+#define mysqlnd_fetch_lengths(result)	_mysqlnd_fetch_lengths((result) TSRMLS_CC)
+PHPAPI unsigned long * _mysqlnd_fetch_lengths(MYSQLND_RES * const result  TSRMLS_DC);
+
+#define mysqlnd_field_seek(result, ofs)			(result)->m.seek_field((result), (ofs) TSRMLS_CC)
+#define mysqlnd_field_tell(result)				(result)->m.field_tell((result) TSRMLS_CC)
+#define mysqlnd_fetch_field(result)				(result)->m.fetch_field((result) TSRMLS_CC)
+#define mysqlnd_fetch_field_direct(result,fnr)	(result)->m.fetch_field_direct((result), (fnr) TSRMLS_CC)
+#define mysqlnd_fetch_fields(result)			(result)->m.fetch_fields((result) TSRMLS_CC)
+
+/* mysqlnd metadata */
+PHPAPI const char *	mysqlnd_get_client_info();
+PHPAPI unsigned int	mysqlnd_get_client_version();
+
+#define mysqlnd_ssl_set(conn, key, cert, ca, capath, cipher) (conn)->m->ssl_set((conn), (key), (cert), (ca), (capath), (cipher) TSRMLS_CC)
+
+/* PS */
+#define mysqlnd_stmt_insert_id(stmt)		(stmt)->m->get_last_insert_id((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_affected_rows(stmt)	(stmt)->m->get_affected_rows((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_num_rows(stmt)			(stmt)->m->get_num_rows((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_param_count(stmt)		(stmt)->m->get_param_count((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_field_count(stmt)		(stmt)->m->get_field_count((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_warning_count(stmt)	(stmt)->m->get_warning_count((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_server_status(stmt)	(stmt)->m->get_server_status((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_errno(stmt)			(stmt)->m->get_error_no((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_error(stmt)			(stmt)->m->get_error_str((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_sqlstate(stmt)			(stmt)->m->get_sqlstate((stmt) TSRMLS_CC)
+
+
+PHPAPI void mysqlnd_efree_param_bind_dtor(MYSQLND_PARAM_BIND * param_bind TSRMLS_DC);
+PHPAPI void mysqlnd_efree_result_bind_dtor(MYSQLND_RESULT_BIND * result_bind TSRMLS_DC);
+PHPAPI void mysqlnd_free_param_bind_dtor(MYSQLND_PARAM_BIND * param_bind TSRMLS_DC);
+PHPAPI void mysqlnd_free_result_bind_dtor(MYSQLND_RESULT_BIND * result_bind TSRMLS_DC);
+
+
+PHPAPI const char * mysqlnd_field_type_name(enum mysqlnd_field_types field_type);
+
+/* LOAD DATA LOCAL */
+PHPAPI void mysqlnd_local_infile_default(MYSQLND *conn);
+PHPAPI void mysqlnd_set_local_infile_handler(MYSQLND * const conn, const char * const funcname);
+
+/* Simple commands */
+#ifdef AUTOCOMMIT_TX_COMMIT_ROLLBACK
+#define mysqlnd_autocommit(conn, mode)		(conn)->m->set_autocommit((conn), (mode) TSRMLS_CC)
+#define mysqlnd_commit(conn)				(conn)->m->tx_commit((conn) TSRMLS_CC)
+#define mysqlnd_rollback(conn)				(conn)->m->tx_rollback((conn) TSRMLS_CC)
+#else
+#define mysqlnd_autocommit(conn, mode)		(conn)->m->query((conn),(mode) ? "SET AUTOCOMMIT=1":"SET AUTOCOMMIT=0", 16 TSRMLS_CC)
+#define mysqlnd_commit(conn)				(conn)->m->query((conn), "COMMIT", sizeof("COMMIT")-1 TSRMLS_CC)
+#define mysqlnd_rollback(conn)				(conn)->m->query((conn), "ROLLBACK", sizeof("ROLLBACK")-1 TSRMLS_CC)
+#endif
+#define mysqlnd_list_dbs(conn, wild)		(conn)->m->list_method((conn), wild? "SHOW DATABASES LIKE %s":"SHOW DATABASES", (wild), NULL TSRMLS_CC)
+#define mysqlnd_list_fields(conn, tab,wild)	(conn)->m->list_fields((conn), (tab), (wild) TSRMLS_CC)
+#define mysqlnd_list_processes(conn)		(conn)->m->list_method((conn), "SHOW PROCESSLIST", NULL, NULL TSRMLS_CC)
+#define mysqlnd_list_tables(conn, wild)		(conn)->m->list_method((conn), wild? "SHOW TABLES LIKE %s":"SHOW TABLES", (wild), NULL TSRMLS_CC)
+#define mysqlnd_dump_debug_info(conn)		(conn)->m->server_dump_debug_information((conn) TSRMLS_CC)
+#define mysqlnd_select_db(conn, db, db_len)	(conn)->m->select_db((conn), (db), (db_len) TSRMLS_CC)
+#define mysqlnd_ping(conn)					(conn)->m->ping((conn) TSRMLS_CC)
+#define mysqlnd_kill(conn, pid)				(conn)->m->kill_connection((conn), (pid) TSRMLS_CC)
+#define mysqlnd_refresh(conn, options)		(conn)->m->refresh_server((conn), (options) TSRMLS_CC)
+#define mysqlnd_shutdown(conn, level)		(conn)->m->shutdown_server((conn), (level) TSRMLS_CC)
+#define mysqlnd_get_server_version(conn)	(conn)->m->get_server_version((conn) TSRMLS_CC)
+#define mysqlnd_set_character_set(conn, cs)	(conn)->m->set_charset((conn), (cs) TSRMLS_CC)
+#define mysqlnd_stat(conn, msg, msg_len)	(conn)->m->get_server_statistics((conn), (msg), (msg_len) TSRMLS_CC)
+#define mysqlnd_options(conn, opt, value)	(conn)->m->set_client_option((conn), (opt), (value) TSRMLS_CC)
+#define mysqlnd_set_server_option(conn, op)	(conn)->m->set_server_option((conn), (op) TSRMLS_CC)
+
+/* Escaping */
+#define mysqlnd_real_escape_string(conn, newstr, escapestr, escapestr_len) \
+		(conn)->m->escape_string((conn), (newstr), (escapestr), (escapestr_len) TSRMLS_CC)
+#define mysqlnd_escape_string(newstr, escapestr, escapestr_len) \
+		mysqlnd_old_escape_string((newstr), (escapestr), (escapestr_len) TSRMLS_CC)
+
+PHPAPI ulong mysqlnd_old_escape_string(char *newstr, const char *escapestr, size_t escapestr_len TSRMLS_DC);
+
+
+/* PS */
+#define mysqlnd_stmt_init(conn)				(conn)->m->stmt_init((conn) TSRMLS_CC)
+#define mysqlnd_stmt_store_result(stmt)		(!mysqlnd_stmt_field_count((stmt)) ? PASS:((stmt)->m->store_result((stmt) TSRMLS_CC)? PASS:FAIL))
+#define mysqlnd_stmt_get_result(stmt)		(stmt)->m->get_result((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_more_results(stmt)		(stmt)->m->more_results((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_next_result(stmt)		(stmt)->m->next_result((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_data_seek(stmt, row)	(stmt)->m->seek_data((stmt), (row) TSRMLS_CC)
+#define mysqlnd_stmt_prepare(stmt, q, qlen)	(stmt)->m->prepare((stmt), (q), (qlen) TSRMLS_CC)
+#define mysqlnd_stmt_execute(stmt) 			(stmt)->m->execute((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_send_long_data(stmt,p,d,l) 	(stmt)->m->send_long_data((stmt), (p), (d), (l) TSRMLS_CC)
+#define mysqlnd_stmt_alloc_param_bind(stmt)			(stmt)->m->alloc_parameter_bind((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_free_param_bind(stmt,bind)		(stmt)->m->free_parameter_bind((stmt), (bind) TSRMLS_CC)
+#define mysqlnd_stmt_bind_param(stmt,bind)			(stmt)->m->bind_parameters((stmt), (bind) TSRMLS_CC)
+#define mysqlnd_stmt_bind_one_param(stmt,n,z,t)		(stmt)->m->bind_one_parameter((stmt), (n), (z), (t) TSRMLS_CC)
+#define mysqlnd_stmt_refresh_bind_param(s)			(s)->m->refresh_bind_param((s) TSRMLS_CC)
+#define mysqlnd_stmt_alloc_result_bind(stmt)		(stmt)->m->alloc_result_bind((stmt) TSRMLS_CC)
+#define mysqlnd_stmt_free_result_bind(stmt,bind)	(stmt)->m->free_result_bind((stmt), (bind) TSRMLS_CC)
+#define mysqlnd_stmt_bind_result(stmt,bind)			(stmt)->m->bind_result((stmt), (bind) TSRMLS_CC)
+#define mysqlnd_stmt_bind_one_result(s,no)			(s)->m->bind_one_result((s), (no) TSRMLS_CC)
+#define mysqlnd_stmt_param_metadata(stmt)			(stmt)->m->get_parameter_metadata((stmt))
+#define mysqlnd_stmt_result_metadata(stmt)			(stmt)->m->get_result_metadata((stmt) TSRMLS_CC)
+
+#define	mysqlnd_stmt_free_result(stmt)		(stmt)->m->free_result((stmt) TSRMLS_CC)
+#define	mysqlnd_stmt_close(stmt, implicit)	(stmt)->m->dtor((stmt), (implicit) TSRMLS_CC)
+#define	mysqlnd_stmt_reset(stmt)			(stmt)->m->reset((stmt) TSRMLS_CC)
+
+
+#define mysqlnd_stmt_attr_get(stmt, attr, value)	(stmt)->m->get_attribute((stmt), (attr), (value) TSRMLS_CC)
+#define mysqlnd_stmt_attr_set(stmt, attr, value)	(stmt)->m->set_attribute((stmt), (attr), (value) TSRMLS_CC)
+
+#define mysqlnd_stmt_fetch(stmt, fetched)	(stmt)->m->fetch((stmt), (fetched) TSRMLS_CC)
+
+
+/* Performance statistics */
+PHPAPI void			_mysqlnd_get_client_stats(zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC);
+
+/* double check the class name to avoid naming conflicts when using these: */
+#define MYSQLND_METHOD(class, method) php_##class##_##method##_pub
+#define MYSQLND_METHOD_PRIVATE(class, method) php_##class##_##method##_priv
+
+ZEND_BEGIN_MODULE_GLOBALS(mysqlnd)
+	zend_bool		collect_statistics;
+	zend_bool		collect_memory_statistics;
+	char*			debug;	/* The actual string */
+	MYSQLND_DEBUG	*dbg;	/* The DBG object */
+	long			net_cmd_buffer_size;
+	long			net_read_buffer_size;
+	long			log_mask;
+	long			net_read_timeout;
+	long			mempool_default_size;
+	long			debug_emalloc_fail_threshold;
+	long			debug_ecalloc_fail_threshold;
+	long			debug_erealloc_fail_threshold;
+	long			debug_malloc_fail_threshold;
+	long			debug_calloc_fail_threshold;
+	long			debug_realloc_fail_threshold;
+ZEND_END_MODULE_GLOBALS(mysqlnd)
+
+PHPAPI ZEND_EXTERN_MODULE_GLOBALS(mysqlnd)
+
+#ifdef ZTS
+#define MYSQLND_G(v) TSRMG(mysqlnd_globals_id, zend_mysqlnd_globals *, v)
+#else
+#define MYSQLND_G(v) (mysqlnd_globals.v)
+#endif
+
+
+PHPAPI void mysqlnd_minfo_print_hash(zval *values);
+
+#endif	/* MYSQLND_H */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_block_alloc.c
@@ -0,0 +1,194 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_block_alloc.h"
+#include "mysqlnd_debug.h"
+#include "mysqlnd_priv.h"
+
+
+/* {{{ mysqlnd_mempool_free_chunk */
+static void
+mysqlnd_mempool_free_chunk(MYSQLND_MEMORY_POOL_CHUNK * chunk TSRMLS_DC)
+{
+	MYSQLND_MEMORY_POOL * pool = chunk->pool;
+	DBG_ENTER("mysqlnd_mempool_free_chunk");
+	if (chunk->from_pool) {
+		/* Try to back-off and guess if this is the last block allocated */
+		if (chunk->ptr == (pool->arena + (pool->arena_size - pool->free_size - chunk->size))) {
+			/*
+				This was the last allocation. Lucky us, we can free
+				a bit of memory from the pool. Next time we will return from the same ptr.
+			*/
+			pool->free_size += chunk->size;
+		}
+		pool->refcount--;
+	} else {
+		mnd_free(chunk->ptr);
+	}
+	mnd_free(chunk);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_mempool_resize_chunk */
+static enum_func_status
+mysqlnd_mempool_resize_chunk(MYSQLND_MEMORY_POOL_CHUNK * chunk, unsigned int size TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_mempool_resize_chunk");
+	if (chunk->from_pool) {
+		MYSQLND_MEMORY_POOL * pool = chunk->pool;
+		/* Try to back-off and guess if this is the last block allocated */
+		if (chunk->ptr == (pool->arena + (pool->arena_size - pool->free_size - chunk->size))) {
+			/*
+				This was the last allocation. Lucky us, we can free
+				a bit of memory from the pool. Next time we will return from the same ptr.
+			*/
+			if ((chunk->size + pool->free_size) < size) {
+				zend_uchar *new_ptr;
+				new_ptr = mnd_malloc(size);
+				if (!new_ptr) {
+					DBG_RETURN(FAIL);
+				}
+				memcpy(new_ptr, chunk->ptr, chunk->size);
+				chunk->ptr = new_ptr;
+				pool->free_size += chunk->size;
+				chunk->size = size;
+				chunk->pool = NULL; /* now we have no pool memory */
+				pool->refcount--;
+			} else {
+				/* If the chunk is > than asked size then free_memory increases, otherwise decreases*/
+				pool->free_size += (chunk->size - size);
+			}
+		} else {
+			/* Not last chunk, if the user asks for less, give it to him */
+			if (chunk->size >= size) {
+				; /* nop */
+			} else {
+				zend_uchar *new_ptr;
+				new_ptr = mnd_malloc(size);
+				if (!new_ptr) {
+					DBG_RETURN(FAIL);
+				}
+				memcpy(new_ptr, chunk->ptr, chunk->size);
+				chunk->ptr = new_ptr;
+				chunk->size = size;
+				chunk->pool = NULL; /* now we have non-pool memory */
+				pool->refcount--;
+			}
+		}
+	} else {
+		zend_uchar *new_ptr = mnd_realloc(chunk->ptr, size);
+		if (!new_ptr) {
+			DBG_RETURN(FAIL);
+		}
+		chunk->ptr = new_ptr;
+	}
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_mempool_get_chunk */
+static
+MYSQLND_MEMORY_POOL_CHUNK * mysqlnd_mempool_get_chunk(MYSQLND_MEMORY_POOL * pool, unsigned int size TSRMLS_DC)
+{
+	MYSQLND_MEMORY_POOL_CHUNK *chunk = NULL;
+	DBG_ENTER("mysqlnd_mempool_get_chunk");
+
+	chunk = mnd_malloc(sizeof(MYSQLND_MEMORY_POOL_CHUNK));
+	if (chunk) {
+		chunk->free_chunk = mysqlnd_mempool_free_chunk;
+		chunk->resize_chunk = mysqlnd_mempool_resize_chunk;
+		chunk->size = size;
+		/*
+		  Should not go over MYSQLND_MAX_PACKET_SIZE, since we
+		  expect non-arena memory in mysqlnd_wireprotocol.c . We
+		  realloc the non-arena memory.
+		*/
+		chunk->pool = pool;
+		if (size > pool->free_size) {
+			chunk->from_pool = FALSE;
+			chunk->ptr = mnd_malloc(size);
+			if (!chunk->ptr) {
+				chunk->free_chunk(chunk TSRMLS_CC);
+				chunk = NULL;
+			}
+		} else {
+			chunk->from_pool = TRUE;
+			++pool->refcount;
+			chunk->ptr = pool->arena + (pool->arena_size - pool->free_size);
+			/* Last step, update free_size */
+			pool->free_size -= size;
+		}
+	}
+	DBG_RETURN(chunk);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_mempool_create */
+PHPAPI MYSQLND_MEMORY_POOL *
+mysqlnd_mempool_create(size_t arena_size TSRMLS_DC)
+{
+	/* We calloc, because we free(). We don't mnd_calloc()  for a reason. */
+	MYSQLND_MEMORY_POOL * ret = mnd_calloc(1, sizeof(MYSQLND_MEMORY_POOL));
+	DBG_ENTER("mysqlnd_mempool_create");
+	if (ret) {
+		ret->get_chunk = mysqlnd_mempool_get_chunk;
+		ret->free_size = ret->arena_size = arena_size ? arena_size : 0;
+		ret->refcount = 0;
+		/* OOM ? */
+		ret->arena = mnd_malloc(ret->arena_size);
+		if (!ret->arena) {
+			mysqlnd_mempool_destroy(ret TSRMLS_CC);
+			ret = NULL;
+		}
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_mempool_destroy */
+PHPAPI void
+mysqlnd_mempool_destroy(MYSQLND_MEMORY_POOL * pool TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_mempool_destroy");
+	/* mnd_free will reference LOCK_access and might crash, depending on the caller...*/
+	mnd_free(pool->arena);
+	mnd_free(pool);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_block_alloc.h
@@ -0,0 +1,39 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_BLOCK_ALLOC_H
+#define MYSQLND_BLOCK_ALLOC_H
+
+PHPAPI MYSQLND_MEMORY_POOL *	mysqlnd_mempool_create(size_t arena_size TSRMLS_DC);
+PHPAPI void 					mysqlnd_mempool_destroy(MYSQLND_MEMORY_POOL * pool TSRMLS_DC);
+
+#endif	/* MYSQLND_BLOCK_ALLOC_H */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_charset.c
@@ -0,0 +1,824 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+#include "php.h"
+#include "php_globals.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_debug.h"
+
+/* {{{ utf8 functions */
+static unsigned int check_mb_utf8mb3_sequence(const char *start, const char *end)
+{
+	zend_uchar	c;
+
+	if (start >= end) {
+		return 0;
+	}
+
+	c = (zend_uchar) start[0];
+
+	if (c < 0x80) {
+		return 1;		/* single byte character */
+	}
+	if (c < 0xC2) {
+		return 0;		/* invalid mb character */
+	}
+	if (c < 0xE0) {
+		if (start + 2 > end) {
+			return 0;	/* too small */
+		}
+		if (!(((zend_uchar)start[1] ^ 0x80) < 0x40)) {
+			return 0;
+		}
+		return 2;
+	}
+	if (c < 0xF0) {
+		if (start + 3 > end) {
+			return 0;	/* too small */
+		}
+		if (!(((zend_uchar)start[1] ^ 0x80) < 0x40 && ((zend_uchar)start[2] ^ 0x80) < 0x40 &&
+			(c >= 0xE1 || (zend_uchar)start[1] >= 0xA0))) {
+			return 0;	/* invalid utf8 character */
+		}
+		return 3;
+	}
+	return 0;
+}
+
+
+static unsigned int check_mb_utf8_sequence(const char *start, const char *end)
+{
+	zend_uchar	c;
+
+	if (start >= end) {
+		return 0;
+	}
+
+	c = (zend_uchar) start[0];
+
+	if (c < 0x80) {
+		return 1;		/* single byte character */
+	}
+	if (c < 0xC2) {
+		return 0;		/* invalid mb character */
+	}
+	if (c < 0xE0) {
+		if (start + 2 > end) {
+			return 0;	/* too small */
+		}
+		if (!(((zend_uchar)start[1] ^ 0x80) < 0x40)) {
+			return 0;
+		}
+		return 2;
+	}
+	if (c < 0xF0) {
+		if (start + 3 > end) {
+			return 0;	/* too small */
+		}
+		if (!(((zend_uchar)start[1] ^ 0x80) < 0x40 && ((zend_uchar)start[2] ^ 0x80) < 0x40 &&
+			(c >= 0xE1 || (zend_uchar)start[1] >= 0xA0))) {
+			return 0;	/* invalid utf8 character */
+		}
+		return 3;
+	}
+	if (c < 0xF5) {
+		if (start + 4 > end) { /* We need 4 characters */
+			return 0;	/* too small */
+		}
+
+		/*
+		  UTF-8 quick four-byte mask:
+		  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+		  Encoding allows to encode U+00010000..U+001FFFFF
+
+		  The maximum character defined in the Unicode standard is U+0010FFFF.
+		  Higher characters U+00110000..U+001FFFFF are not used.
+
+		  11110000.10010000.10xxxxxx.10xxxxxx == F0.90.80.80 == U+00010000 (min)
+		  11110100.10001111.10111111.10111111 == F4.8F.BF.BF == U+0010FFFF (max)
+
+		  Valid codes:
+		  [F0][90..BF][80..BF][80..BF]
+		  [F1][80..BF][80..BF][80..BF]
+		  [F2][80..BF][80..BF][80..BF]
+		  [F3][80..BF][80..BF][80..BF]
+		  [F4][80..8F][80..BF][80..BF]
+		*/
+
+		if (!(((zend_uchar)start[1] ^ 0x80) < 0x40 &&
+			((zend_uchar)start[2] ^ 0x80) < 0x40 &&
+			((zend_uchar)start[3] ^ 0x80) < 0x40 &&
+				(c >= 0xf1 || (zend_uchar)start[1] >= 0x90) &&
+				(c <= 0xf3 || (zend_uchar)start[1] <= 0x8F)))
+		{
+			return 0;	/* invalid utf8 character */
+		}
+		return 4;
+	}
+	return 0;
+}
+
+static unsigned int check_mb_utf8mb3_valid(const char *start, const char *end)
+{
+	unsigned int len = check_mb_utf8mb3_sequence(start, end);
+	return (len > 1)? len:0;
+}
+
+static unsigned int check_mb_utf8_valid(const char *start, const char *end)
+{
+	unsigned int len = check_mb_utf8_sequence(start, end);
+	return (len > 1)? len:0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_utf8mb3(unsigned int utf8)
+{
+	if (utf8 < 0x80) {
+		return 1;		/* single byte character */
+	}
+	if (utf8 < 0xC2) {
+		return 0;		/* invalid multibyte header */
+	}
+	if (utf8 < 0xE0) {
+		return 2;		/* double byte character */
+	}
+	if (utf8 < 0xF0) {
+		return 3;		/* triple byte character */
+	}
+	return 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_utf8(unsigned int utf8)
+{
+	if (utf8 < 0x80) {
+		return 1;		/* single byte character */
+	}
+	if (utf8 < 0xC2) {
+		return 0;		/* invalid multibyte header */
+	}
+	if (utf8 < 0xE0) {
+		return 2;		/* double byte character */
+	}
+	if (utf8 < 0xF0) {
+		return 3;		/* triple byte character */
+	}
+	if (utf8 < 0xF8) {
+		return 4;		/* four byte character */
+	}
+	return 0;
+}
+/* }}} */
+
+
+/* {{{ big5 functions */
+#define valid_big5head(c)	(0xA1 <= (unsigned int)(c) && (unsigned int)(c) <= 0xF9)
+#define valid_big5tail(c)	((0x40 <= (unsigned int)(c) && (unsigned int)(c) <= 0x7E) || \
+							(0xA1 <= (unsigned int)(c) && (unsigned int)(c) <= 0xFE))
+
+#define isbig5code(c,d) (isbig5head(c) && isbig5tail(d))
+
+static unsigned int check_mb_big5(const char *start, const char *end)
+{
+	return (valid_big5head(*(start)) && (end - start) > 1 && valid_big5tail(*(start + 1)) ? 2 : 0);
+}
+
+
+static unsigned int mysqlnd_mbcharlen_big5(unsigned int big5)
+{
+	return (valid_big5head(big5)) ? 2 : 1;
+}
+/* }}} */
+
+
+/* {{{ cp932 functions */
+#define valid_cp932head(c) ((0x81 <= (c) && (c) <= 0x9F) || (0xE0 <= (c) && c <= 0xFC))
+#define valid_cp932tail(c) ((0x40 <= (c) && (c) <= 0x7E) || (0x80 <= (c) && c <= 0xFC))
+
+
+static unsigned int check_mb_cp932(const char *start, const char *end)
+{
+	return (valid_cp932head((zend_uchar)start[0]) && (end - start >  1) &&
+			valid_cp932tail((zend_uchar)start[1])) ? 2 : 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_cp932(unsigned int cp932)
+{
+	return (valid_cp932head((zend_uchar)cp932)) ? 2 : 1;
+}
+/* }}} */
+
+
+/* {{{ euckr functions */
+#define valid_euckr(c)	((0xA1 <= (zend_uchar)(c) && (zend_uchar)(c) <= 0xFE))
+
+static unsigned int check_mb_euckr(const char *start, const char *end)
+{
+	if (end - start <= 1) {
+		return 0;	/* invalid length */
+	}
+	if (*(zend_uchar *)start < 0x80) {
+		return 0;	/* invalid euckr character */
+	}
+	if (valid_euckr(start[1])) {
+		return 2;
+	}
+	return 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_euckr(unsigned int kr)
+{
+	return (valid_euckr(kr)) ? 2 : 1;
+}
+/* }}} */
+
+
+/* {{{ eucjpms functions */
+#define valid_eucjpms(c) 		(((c) & 0xFF) >= 0xA1 && ((c) & 0xFF) <= 0xFE)
+#define valid_eucjpms_kata(c)	(((c) & 0xFF) >= 0xA1 && ((c) & 0xFF) <= 0xDF)
+#define valid_eucjpms_ss2(c)	(((c) & 0xFF) == 0x8E)
+#define valid_eucjpms_ss3(c)	(((c) & 0xFF) == 0x8F)
+
+static unsigned int check_mb_eucjpms(const char *start, const char *end)
+{
+	if (*((zend_uchar *)start) < 0x80) {
+		return 0;	/* invalid eucjpms character */
+	}
+	if (valid_eucjpms(start[0]) && (end - start) > 1 && valid_eucjpms(start[1])) {
+		return 2;
+	}
+	if (valid_eucjpms_ss2(start[0]) && (end - start) > 1 && valid_eucjpms_kata(start[1])) {
+		return 2;
+	}
+	if (valid_eucjpms_ss3(start[0]) && (end - start) > 2 && valid_eucjpms(start[1]) &&
+		valid_eucjpms(start[2])) {
+		return 2;
+	}
+	return 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_eucjpms(unsigned int jpms)
+{
+	if (valid_eucjpms(jpms) || valid_eucjpms_ss2(jpms)) {
+		return 2;
+	}
+	if (valid_eucjpms_ss3(jpms)) {
+		return 3;
+	}
+	return 1;
+}
+/* }}} */
+
+
+/* {{{ gb2312 functions */
+#define valid_gb2312_head(c)	(0xA1 <= (zend_uchar)(c) && (zend_uchar)(c) <= 0xF7)
+#define valid_gb2312_tail(c)	(0xA1 <= (zend_uchar)(c) && (zend_uchar)(c) <= 0xFE)
+
+
+static unsigned int check_mb_gb2312(const char *start, const char *end)
+{
+	return (valid_gb2312_head((unsigned int)start[0]) && end - start > 1 &&
+			valid_gb2312_tail((unsigned int)start[1])) ? 2 : 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_gb2312(unsigned int gb)
+{
+	return (valid_gb2312_head(gb)) ? 2 : 1;
+}
+/* }}} */
+
+
+/* {{{ gbk functions */
+#define valid_gbk_head(c)	(0x81<=(zend_uchar)(c) && (zend_uchar)(c)<=0xFE)
+#define valid_gbk_tail(c)	((0x40<=(zend_uchar)(c) && (zend_uchar)(c)<=0x7E) || (0x80<=(zend_uchar)(c) && (zend_uchar)(c)<=0xFE))
+
+static unsigned int check_mb_gbk(const char *start, const char *end)
+{
+	return (valid_gbk_head(start[0]) && (end) - (start) > 1 && valid_gbk_tail(start[1])) ? 2 : 0;
+}
+
+static unsigned int mysqlnd_mbcharlen_gbk(unsigned int gbk)
+{
+	return (valid_gbk_head(gbk) ? 2 : 1);
+}
+/* }}} */
+
+
+/* {{{  functions */
+#define valid_sjis_head(c)	((0x81 <= (c) && (c) <= 0x9F) || (0xE0 <= (c) && (c) <= 0xFC))
+#define valid_sjis_tail(c)	((0x40 <= (c) && (c) <= 0x7E) || (0x80 <= (c) && (c) <= 0xFC))
+
+
+static unsigned int check_mb_sjis(const char *start, const char *end)
+{
+	return (valid_sjis_head((zend_uchar)start[0]) && (end - start) > 1 && valid_sjis_tail((zend_uchar)start[1])) ? 2 : 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_sjis(unsigned int sjis)
+{
+	return (valid_sjis_head((zend_uchar)sjis)) ? 2 : 1;
+}
+/* }}} */
+
+
+/* {{{ ucs2 functions */
+static unsigned int check_mb_ucs2(const char *start __attribute((unused)), const char *end __attribute((unused)))
+{
+	return 2; /* always 2 */
+}
+
+static unsigned int mysqlnd_mbcharlen_ucs2(unsigned int ucs2 __attribute((unused)))
+{
+	return 2; /* always 2 */
+}
+/* }}} */
+
+
+/* {{{ ujis functions */
+#define valid_ujis(c)     	((0xA1 <= ((c)&0xFF) && ((c)&0xFF) <= 0xFE))
+#define valid_ujis_kata(c)  ((0xA1 <= ((c)&0xFF) && ((c)&0xFF) <= 0xDF))
+#define valid_ujis_ss2(c) 	(((c)&0xFF) == 0x8E)
+#define valid_ujis_ss3(c) 	(((c)&0xFF) == 0x8F)
+
+static unsigned int check_mb_ujis(const char *start, const char *end)
+{
+	if (*(zend_uchar*)start < 0x80) {
+		return 0;	/* invalid ujis character */
+	}
+	if (valid_ujis(*(start)) && valid_ujis(*((start)+1))) {
+		return 2;
+	}
+	if (valid_ujis_ss2(*(start)) && valid_ujis_kata(*((start)+1))) {
+		return 2;
+	}
+	if (valid_ujis_ss3(*(start)) && (end-start) > 2 && valid_ujis(*((start)+1)) && valid_ujis(*((start)+2))) {
+		return 3;
+	}
+	return 0;
+}
+
+
+static unsigned int mysqlnd_mbcharlen_ujis(unsigned int ujis)
+{
+	return (valid_ujis(ujis)? 2: valid_ujis_ss2(ujis)? 2: valid_ujis_ss3(ujis)? 3: 1);
+}
+/* }}} */
+
+
+
+/* {{{ utf16 functions */
+#define UTF16_HIGH_HEAD(x)  ((((zend_uchar) (x)) & 0xFC) == 0xD8)
+#define UTF16_LOW_HEAD(x)   ((((zend_uchar) (x)) & 0xFC) == 0xDC)
+
+static unsigned int check_mb_utf16(const char *start, const char *end)
+{
+	if (start + 2 > end) {
+		return 0;
+	}
+
+	if (UTF16_HIGH_HEAD(*start)) {
+		return (start + 4 <= end) && UTF16_LOW_HEAD(start[2]) ? 4 : 0;
+	}
+
+	if (UTF16_LOW_HEAD(*start)) {
+		return 0;
+	}
+	return 2;
+}
+
+
+static uint mysqlnd_mbcharlen_utf16(unsigned int utf16)
+{
+  return UTF16_HIGH_HEAD(utf16) ? 4 : 2;
+}
+/* }}} */
+
+
+/* {{{ utf32 functions */
+static uint
+check_mb_utf32(const char *start __attribute((unused)), const char *end __attribute((unused)))
+{
+	return 4;
+}
+
+
+static uint
+mysqlnd_mbcharlen_utf32(unsigned int utf32 __attribute((unused)))
+{
+	return 4;
+}
+/* }}} */
+
+/*
+  The server compiles sometimes the full utf-8 (the mb4) as utf8m4, and the old as utf8,
+  for BC reasons. Sometimes, utf8mb4 is just utf8 but the old charsets are utf8mb3.
+  Change easily now, with a macro, could be made compilastion dependable.
+*/
+
+#define UTF8_MB4 "utf8mb4"
+#define UTF8_MB3 "utf8"
+
+/* {{{ mysqlnd_charsets */
+const MYSQLND_CHARSET mysqlnd_charsets[] =
+{
+	{   1, "big5","big5_chinese_ci", 1, 2, "", mysqlnd_mbcharlen_big5, check_mb_big5},
+	{   3, "dec8", "dec8_swedisch_ci", 1, 1, "", NULL, NULL},
+	{   4, "cp850", "cp850_general_ci", 1, 1, "", NULL, NULL},
+	{   6, "hp8", "hp8_english_ci", 1, 1, "", NULL, NULL},
+	{   7, "koi8r", "koi8r_general_ci", 1, 1, "", NULL, NULL},
+	{   8, "latin1", "latin1_swedish_ci", 1, 1, "", NULL, NULL},
+	{   5, "latin1", "latin1_german_ci", 1, 1, "", NULL, NULL}, /* should be after 0x9 because swedish_ci is the default collation */
+	{   9, "latin2", "latin2_general_ci", 1, 1, "", NULL, NULL},
+	{   2, "latin2", "latin2_czech_cs", 1, 1, "", NULL, NULL}, /* should be after 0x9 because general_ci is the default collation */
+	{  10, "swe7", "swe7_swedish_ci", 1, 1, "", NULL, NULL},
+	{  11, "ascii", "ascii_general_ci", 1, 1, "", NULL, NULL},
+	{  12, "ujis", "ujis_japanese_ci", 1, 3, "", mysqlnd_mbcharlen_ujis, check_mb_ujis},
+	{  13, "sjis", "sjis_japanese_ci", 1, 2, "", mysqlnd_mbcharlen_sjis, check_mb_sjis},
+	{  16, "hebrew", "hebrew_general_ci", 1, 1, "", NULL, NULL},
+	{  17, "filename", "filename", 1, 5, "", NULL, NULL},
+	{  18, "tis620", "tis620_thai_ci", 1, 1, "", NULL, NULL},
+	{  19, "euckr", "euckr_korean_ci", 1, 2, "", mysqlnd_mbcharlen_euckr, check_mb_euckr},
+	{  21, "latin2", "latin2_hungarian_ci", 1, 1, "", NULL, NULL},
+	{  27, "latin2", "latin2_croatian_ci", 1, 1, "", NULL, NULL},
+	{  22, "koi8u", "koi8u_general_ci", 1, 1, "", NULL, NULL},
+	{  24, "gb2312", "gb2312_chinese_ci", 1, 2, "", mysqlnd_mbcharlen_gb2312, check_mb_gb2312},
+	{  25, "greek", "greek_general_ci", 1, 1, "", NULL, NULL},
+	{  26, "cp1250", "cp1250_general_ci", 1, 1, "", NULL, NULL},
+	{  28, "gbk", "gbk_chinese_ci", 1, 2, "", mysqlnd_mbcharlen_gbk, check_mb_gbk},
+	{  30, "latin5", "latin5_turkish_ci", 1, 1, "", NULL, NULL},
+	{  31, "latin1", "latin1_german2_ci", 1, 1, "", NULL, NULL},
+	{  15, "latin1", "latin1_danish_ci", 1, 1, "", NULL, NULL},
+	{  32, "armscii8", "armscii8_general_ci", 1, 1, "", NULL, NULL},
+	{  33, UTF8_MB3, UTF8_MB3"_general_ci", 1, 3, "UTF-8 Unicode", mysqlnd_mbcharlen_utf8mb3,  check_mb_utf8mb3_valid},
+	{  35, "ucs2", "ucs2_general_ci", 2, 2, "UCS-2 Unicode", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{  36, "cp866", "cp866_general_ci", 1, 1, "", NULL, NULL},
+	{  37, "keybcs2", "keybcs2_general_ci", 1, 1, "", NULL, NULL},
+	{  38, "macce", "macce_general_ci", 1, 1, "", NULL, NULL},
+	{  39, "macroman", "macroman_general_ci", 1, 1, "", NULL, NULL},
+	{  40, "cp852", "cp852_general_ci", 1, 1, "", NULL, NULL},
+	{  41, "latin7", "latin7_general_ci", 1, 1, "", NULL, NULL},
+	{  20, "latin7", "latin7_estonian_cs", 1, 1, "", NULL, NULL},
+	{  57, "cp1256", "cp1256_general_ci", 1, 1, "", NULL, NULL},
+	{  59, "cp1257", "cp1257_general_ci", 1, 1, "", NULL, NULL},
+	{  63, "binary", "binary", 1, 1, "", NULL, NULL},
+	{  97, "eucjpms", "eucjpms_japanese_ci", 1, 3, "", mysqlnd_mbcharlen_eucjpms, check_mb_eucjpms},
+	{  29, "cp1257", "cp1257_lithunian_ci", 1, 1, "", NULL, NULL},
+	{  31, "latin1", "latin1_german2_ci", 1, 1, "", NULL, NULL},
+	{  34, "cp1250", "cp1250_czech_cs", 1, 1, "", NULL, NULL},
+	{  42, "latin7", "latin7_general_cs", 1, 1, "", NULL, NULL},
+	{  43, "macce", "macce_bin", 1, 1, "", NULL, NULL},
+	{  44, "cp1250", "cp1250_croatian_ci", 1, 1, "", NULL, NULL},
+	{  45, UTF8_MB4, UTF8_MB4"_general_ci", 1, 3, "UTF-8 Unicode", mysqlnd_mbcharlen_utf8,  check_mb_utf8_valid},
+	{  46, UTF8_MB4, UTF8_MB4"_bin", 1, 3, "UTF-8 Unicode", mysqlnd_mbcharlen_utf8,  check_mb_utf8_valid},
+	{  47, "latin1", "latin1_bin", 1, 1, "", NULL, NULL},
+	{  48, "latin1", "latin1_general_ci", 1, 1, "", NULL, NULL},
+	{  49, "latin1", "latin1_general_cs", 1, 1, "", NULL, NULL},
+	{  51, "cp1251", "cp1251_general_ci", 1, 1, "", NULL, NULL},
+	{  14, "cp1251", "cp1251_bulgarian_ci", 1, 1, "", NULL, NULL},
+	{  23, "cp1251", "cp1251_ukrainian_ci", 1, 1, "", NULL, NULL},
+	{  50, "cp1251", "cp1251_bin", 1, 1, "", NULL, NULL},
+	{  52, "cp1251", "cp1251_general_cs", 1, 1, "", NULL, NULL},
+	{  53, "macroman", "macroman_bin", 1, 1, "", NULL, NULL},
+	{  54, "utf16", "utf16_general_ci", 2, 4, "UTF-16 Unicode", mysqlnd_mbcharlen_utf16, check_mb_utf16},
+	{  55, "utf16", "utf16_bin", 2, 4, "UTF-16 Unicode", mysqlnd_mbcharlen_utf16, check_mb_utf16},
+	{  58, "cp1257", "cp1257_bin", 1, 1, "", NULL, NULL},
+#ifdef USED_TO_BE_SO_BEFORE_MYSQL_5_5
+	{  60, "armascii8", "armascii8_bin", 1, 1, "", NULL, NULL},
+#endif
+/*55*/{  60, "utf32", "utf32_general_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*55*/{  61, "utf32", "utf32_bin", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+	{  65, "ascii", "ascii_bin", 1, 1, "", NULL, NULL},
+	{  66, "cp1250", "cp1250_bin", 1, 1, "", NULL, NULL},
+	{  67, "cp1256", "cp1256_bin", 1, 1, "", NULL, NULL},
+	{  68, "cp866", "cp866_bin", 1, 1, "", NULL, NULL},
+	{  69, "dec8", "dec8_bin", 1, 1, "", NULL, NULL},
+	{  70, "greek", "greek_bin", 1, 1, "", NULL, NULL},
+	{  71, "hebew", "hebrew_bin", 1, 1, "", NULL, NULL},
+	{  72, "hp8", "hp8_bin", 1, 1, "", NULL, NULL},
+	{  73, "keybcs2", "keybcs2_bin", 1, 1, "", NULL, NULL},
+	{  74, "koi8r", "koi8r_bin", 1, 1, "", NULL, NULL},
+	{  75, "koi8u", "koi8u_bin", 1, 1, "", NULL, NULL},
+	{  77, "latin2", "latin2_bin", 1, 1, "", NULL, NULL},
+	{  78, "latin5", "latin5_bin", 1, 1, "", NULL, NULL},
+	{  79, "latin7", "latin7_bin", 1, 1, "", NULL, NULL},
+	{  80, "cp850", "cp850_bin", 1, 1, "", NULL, NULL},
+	{  81, "cp852", "cp852_bin", 1, 1, "", NULL, NULL},
+	{  82, "swe7", "swe7_bin", 1, 1, "", NULL, NULL},
+	{  83, UTF8_MB3, UTF8_MB3"_bin", 1, 3, "UTF-8 Unicode", mysqlnd_mbcharlen_utf8mb3,  check_mb_utf8mb3_valid},
+	{  84, "big5", "big5_bin", 1, 2, "", mysqlnd_mbcharlen_big5, check_mb_big5},
+	{  85, "euckr", "euckr_bin", 1, 2, "", mysqlnd_mbcharlen_euckr, check_mb_euckr},
+	{  86, "gb2312", "gb2312_bin", 1, 2, "", mysqlnd_mbcharlen_gb2312, check_mb_gb2312},
+	{  87, "gbk", "gbk_bin", 1, 2, "", mysqlnd_mbcharlen_gbk, check_mb_gbk},
+	{  88, "sjis", "sjis_bin", 1, 2, "", mysqlnd_mbcharlen_sjis, check_mb_sjis},
+	{  89, "tis620", "tis620_bin", 1, 1, "", NULL, NULL},
+	{  90, "ucs2", "ucs2_bin", 2, 2, "UCS-2 Unicode", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{  91, "ujis", "ujis_bin", 1, 3, "", mysqlnd_mbcharlen_ujis, check_mb_ujis},
+	{  92, "geostd8", "geostd8_general_ci", 1, 1, "", NULL, NULL},
+	{  93, "geostd8", "geostd8_bin", 1, 1, "", NULL, NULL},
+	{  94, "latin1", "latin1_spanish_ci", 1, 1, "", NULL, NULL},
+	{  95, "cp932", "cp932_japanese_ci", 1, 2, "", mysqlnd_mbcharlen_cp932, check_mb_cp932},
+	{  96, "cp932", "cp932_bin", 1, 2, "", mysqlnd_mbcharlen_cp932, check_mb_cp932},
+	{  97, "eucjpms", "eucjpms_japanese_ci", 1, 3, "", mysqlnd_mbcharlen_eucjpms, check_mb_eucjpms},
+	{  98, "eucjpms", "eucjpms_bin", 1, 3, "", mysqlnd_mbcharlen_eucjpms, check_mb_eucjpms},
+	{  99, "cp1250", "cp1250_polish_ci", 1, 1, "", NULL, NULL},
+	{ 128, "ucs2", "ucs2_unicode_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 129, "ucs2", "ucs2_icelandic_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 130, "ucs2", "ucs2_latvian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 131, "ucs2", "ucs2_romanian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 132, "ucs2", "ucs2_slovenian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 133, "ucs2", "ucs2_polish_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 134, "ucs2", "ucs2_estonian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 135, "ucs2", "ucs2_spanish_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 136, "ucs2", "ucs2_swedish_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 137, "ucs2", "ucs2_turkish_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 138, "ucs2", "ucs2_czech_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 139, "ucs2", "ucs2_danish_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 140, "ucs2", "ucs2_lithunian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 141, "ucs2", "ucs2_slovak_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 142, "ucs2", "ucs2_spanish2_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 143, "ucs2", "ucs2_roman_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 144, "ucs2", "ucs2_persian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 145, "ucs2", "ucs2_esperanto_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 146, "ucs2", "ucs2_hungarian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 147, "ucs2", "ucs2_sinhala_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 148, "ucs2", "ucs2_german2_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 149, "ucs2", "ucs2_croatian_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 150, "ucs2", "ucs2_unicode_520_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+	{ 151, "ucs2", "ucs2_vietnamese_ci", 2, 2, "", mysqlnd_mbcharlen_ucs2, check_mb_ucs2},
+
+/*56*/{160, "utf32", "utf32_unicode_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{161, "utf32", "utf32_icelandic_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{162, "utf32", "utf32_latvian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{163, "utf32", "utf32_romanian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{164, "utf32", "utf32_slovenian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{165, "utf32", "utf32_polish_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{166, "utf32", "utf32_estonian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{167, "utf32", "utf32_spanish_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{168, "utf32", "utf32_swedish_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{169, "utf32", "utf32_turkish_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{170, "utf32", "utf32_czech_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{171, "utf32", "utf32_danish_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{172, "utf32", "utf32_lithuanian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{173, "utf32", "utf32_slovak_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{174, "utf32", "utf32_spanish2_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{175, "utf32", "utf32_roman_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{176, "utf32", "utf32_persian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{177, "utf32", "utf32_esperanto_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{178, "utf32", "utf32_hungarian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{179, "utf32", "utf32_sinhala_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{180, "utf32", "utf32_german2_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{181, "utf32", "utf32_croatian_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{182, "utf32", "utf32_unicode_520_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+/*56*/{183, "utf32", "utf32_vietnamese_ci", 4, 4, "UTF-32 Unicode", mysqlnd_mbcharlen_utf32, check_mb_utf32},
+
+	{ 192, UTF8_MB3, UTF8_MB3"_general_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 193, UTF8_MB3, UTF8_MB3"_icelandic_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 194, UTF8_MB3, UTF8_MB3"_latvian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3,  check_mb_utf8mb3_valid},
+	{ 195, UTF8_MB3, UTF8_MB3"_romanian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 196, UTF8_MB3, UTF8_MB3"_slovenian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 197, UTF8_MB3, UTF8_MB3"_polish_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 198, UTF8_MB3, UTF8_MB3"_estonian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 199, UTF8_MB3, UTF8_MB3"_spanish_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 200, UTF8_MB3, UTF8_MB3"_swedish_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 201, UTF8_MB3, UTF8_MB3"_turkish_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 202, UTF8_MB3, UTF8_MB3"_czech_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 203, UTF8_MB3, UTF8_MB3"_danish_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid },
+	{ 204, UTF8_MB3, UTF8_MB3"_lithunian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid },
+	{ 205, UTF8_MB3, UTF8_MB3"_slovak_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 206, UTF8_MB3, UTF8_MB3"_spanish2_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 207, UTF8_MB3, UTF8_MB3"_roman_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 208, UTF8_MB3, UTF8_MB3"_persian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 209, UTF8_MB3, UTF8_MB3"_esperanto_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 210, UTF8_MB3, UTF8_MB3"_hungarian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 211, UTF8_MB3, UTF8_MB3"_sinhala_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 211, UTF8_MB3, UTF8_MB3"_german2_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 213, UTF8_MB3, UTF8_MB3"_croatian_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 214, UTF8_MB3, UTF8_MB3"_unicode_520_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+	{ 215, UTF8_MB3, UTF8_MB3"_vietnamese_ci", 1, 3, "", mysqlnd_mbcharlen_utf8mb3, check_mb_utf8mb3_valid},
+
+	{ 224, UTF8_MB4, UTF8_MB4"_unicode_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 225, UTF8_MB4, UTF8_MB4"_icelandic_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 226, UTF8_MB4, UTF8_MB4"_latvian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 227, UTF8_MB4, UTF8_MB4"_romanian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 228, UTF8_MB4, UTF8_MB4"_slovenian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 229, UTF8_MB4, UTF8_MB4"_polish_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 230, UTF8_MB4, UTF8_MB4"_estonian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 231, UTF8_MB4, UTF8_MB4"_spanish_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 232, UTF8_MB4, UTF8_MB4"_swedish_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 233, UTF8_MB4, UTF8_MB4"_turkish_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 234, UTF8_MB4, UTF8_MB4"_czech_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 235, UTF8_MB4, UTF8_MB4"_danish_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 236, UTF8_MB4, UTF8_MB4"_lithuanian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 237, UTF8_MB4, UTF8_MB4"_slovak_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 238, UTF8_MB4, UTF8_MB4"_spanish2_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 239, UTF8_MB4, UTF8_MB4"_roman_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 240, UTF8_MB4, UTF8_MB4"_persian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 241, UTF8_MB4, UTF8_MB4"_esperanto_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 242, UTF8_MB4, UTF8_MB4"_hungarian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 243, UTF8_MB4, UTF8_MB4"_sinhala_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 244, UTF8_MB4, UTF8_MB4"_german2_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 245, UTF8_MB4, UTF8_MB4"_croatian_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 246, UTF8_MB4, UTF8_MB4"_unicode_520_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{ 247, UTF8_MB4, UTF8_MB4"_vietnamese_ci", 1, 4, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+
+	{ 254, UTF8_MB3, UTF8_MB3"_general_cs", 1, 3, "", mysqlnd_mbcharlen_utf8, check_mb_utf8_valid},
+	{   0, NULL, NULL, 0, 0, NULL, NULL, NULL}
+};
+/* }}} */
+
+
+/* {{{ mysqlnd_find_charset_nr */
+PHPAPI const MYSQLND_CHARSET * mysqlnd_find_charset_nr(unsigned int charsetnr)
+{
+	const MYSQLND_CHARSET * c = mysqlnd_charsets;
+
+	do {
+		if (c->nr == charsetnr) {
+			return c;
+		}
+		++c;
+	} while (c[0].nr != 0);
+	return NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_find_charset_name */
+PHPAPI const MYSQLND_CHARSET * mysqlnd_find_charset_name(const char * const name)
+{
+	const MYSQLND_CHARSET *c = mysqlnd_charsets;
+
+	do {
+		if (!strcasecmp(c->name, name)) {
+			return c;
+		}
+		++c;
+	} while (c[0].nr != 0);
+	return NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_cset_escape_quotes */
+PHPAPI ulong mysqlnd_cset_escape_quotes(const MYSQLND_CHARSET * const cset, char *newstr,
+										const char * escapestr, size_t escapestr_len TSRMLS_DC)
+{
+	const char 	*newstr_s = newstr;
+	const char 	*newstr_e = newstr + 2 * escapestr_len;
+	const char 	*end = escapestr + escapestr_len;
+	zend_bool	escape_overflow = FALSE;
+
+	DBG_ENTER("mysqlnd_cset_escape_quotes");
+
+	for (;escapestr < end; escapestr++) {
+		unsigned int len = 0;
+		/* check unicode characters */
+
+		if (cset->char_maxlen > 1 && (len = cset->mb_valid(escapestr, end))) {
+
+			/* check possible overflow */
+			if ((newstr + len) > newstr_e) {
+				escape_overflow = TRUE;
+				break;
+			}
+			/* copy mb char without escaping it */
+			while (len--) {
+				*newstr++ = *escapestr++;
+			}
+			escapestr--;
+			continue;
+		}
+		if (*escapestr == '\'') {
+			if (newstr + 2 > newstr_e) {
+				escape_overflow = TRUE;
+				break;
+			}
+			*newstr++ = '\'';
+			*newstr++ = '\'';
+		} else {
+			if (newstr + 1 > newstr_e) {
+				escape_overflow = TRUE;
+				break;
+			}
+			*newstr++ = *escapestr;
+		}
+	}
+	*newstr = '\0';
+
+	if (escape_overflow) {
+		DBG_RETURN((ulong)~0);
+	}
+	DBG_RETURN((ulong)(newstr - newstr_s));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_cset_escape_slashes */
+PHPAPI ulong mysqlnd_cset_escape_slashes(const MYSQLND_CHARSET * const cset, char *newstr,
+										 const char * escapestr, size_t escapestr_len TSRMLS_DC)
+{
+	const char 	*newstr_s = newstr;
+	const char 	*newstr_e = newstr + 2 * escapestr_len;
+	const char 	*end = escapestr + escapestr_len;
+	zend_bool	escape_overflow = FALSE;
+
+	DBG_ENTER("mysqlnd_cset_escape_slashes");
+	DBG_INF_FMT("charset=%s", cset->name);
+
+	for (;escapestr < end; escapestr++) {
+		char esc = '\0';
+		unsigned int len = 0;
+
+		/* check unicode characters */
+		if (cset->char_maxlen > 1 && (len = cset->mb_valid(escapestr, end))) {
+			/* check possible overflow */
+			if ((newstr + len) > newstr_e) {
+				escape_overflow = TRUE;
+				break;
+			}
+			/* copy mb char without escaping it */
+			while (len--) {
+				*newstr++ = *escapestr++;
+			}
+			escapestr--;
+			continue;
+		}
+		if (cset->char_maxlen > 1 && cset->mb_charlen(*escapestr) > 1) {
+			esc = *escapestr;
+		} else {
+			switch (*escapestr) {
+				case 0:
+					esc = '0';
+					break;
+				case '\n':
+					esc = 'n';
+					break;
+				case '\r':
+					esc = 'r';
+					break;
+				case '\\':
+				case '\'':
+				case '"':
+					esc = *escapestr;
+					break;
+				case '\032':
+					esc = 'Z';
+					break;
+			}
+		}
+		if (esc) {
+			if (newstr + 2 > newstr_e) {
+				escape_overflow = TRUE;
+				break;
+			}
+			/* copy escaped character */
+			*newstr++ = '\\';
+			*newstr++ = esc;
+		} else {
+			if (newstr + 1 > newstr_e) {
+				escape_overflow = TRUE;
+				break;
+			}
+			/* copy non escaped character */
+			*newstr++ = *escapestr;
+		}
+	}
+	*newstr = '\0';
+
+	if (escape_overflow) {
+		DBG_RETURN((ulong)~0);
+	}
+	DBG_RETURN((ulong)(newstr - newstr_s));
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_charset.h
@@ -0,0 +1,39 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+#ifndef MYSQLND_CHARSET_H
+#define MYSQLND_CHARSET_H
+
+PHPAPI ulong mysqlnd_cset_escape_quotes(const MYSQLND_CHARSET * const charset, char *newstr,
+										const char *escapestr, size_t escapestr_len TSRMLS_DC);
+
+PHPAPI ulong mysqlnd_cset_escape_slashes(const MYSQLND_CHARSET * const cset, char *newstr,
+										 const char *escapestr, size_t escapestr_len TSRMLS_DC);
+
+#endif /* MYSQLND_CHARSET_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_debug.c
@@ -0,0 +1,1866 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_debug.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_statistics.h"
+#include "zend_builtin_functions.h"
+
+static const char * const mysqlnd_debug_default_trace_file = "/tmp/mysqlnd.trace";
+
+#ifdef ZTS 
+#define MYSQLND_ZTS(self) TSRMLS_D = (self)->TSRMLS_C
+#else
+#define MYSQLND_ZTS(self)
+#endif
+
+static const char mysqlnd_emalloc_name[]	= "_mysqlnd_emalloc";
+static const char mysqlnd_pemalloc_name[]	= "_mysqlnd_pemalloc";
+static const char mysqlnd_ecalloc_name[]	= "_mysqlnd_ecalloc";
+static const char mysqlnd_pecalloc_name[]	= "_mysqlnd_pecalloc";
+static const char mysqlnd_erealloc_name[]	= "_mysqlnd_erealloc";
+static const char mysqlnd_perealloc_name[]	= "_mysqlnd_perealloc";
+static const char mysqlnd_efree_name[]		= "_mysqlnd_efree";
+static const char mysqlnd_pefree_name[]		= "_mysqlnd_pefree";
+static const char mysqlnd_malloc_name[]		= "_mysqlnd_malloc";
+static const char mysqlnd_calloc_name[]		= "_mysqlnd_calloc";
+static const char mysqlnd_realloc_name[]	= "_mysqlnd_realloc";
+static const char mysqlnd_free_name[]		= "_mysqlnd_free";
+static const char mysqlnd_pestrndup_name[]	= "_mysqlnd_pestrndup";
+static const char mysqlnd_pestrdup_name[]	= "_mysqlnd_pestrdup";
+
+const char * mysqlnd_debug_std_no_trace_funcs[] =
+{
+	mysqlnd_emalloc_name,
+	mysqlnd_ecalloc_name,
+	mysqlnd_efree_name,
+	mysqlnd_erealloc_name,
+	mysqlnd_pemalloc_name,
+	mysqlnd_pecalloc_name,
+	mysqlnd_pefree_name,
+	mysqlnd_perealloc_name,
+	mysqlnd_malloc_name,
+	mysqlnd_calloc_name,
+	mysqlnd_realloc_name,
+	mysqlnd_free_name,
+	mysqlnd_pestrndup_name,
+	mysqlnd_read_header_name,
+	mysqlnd_read_body_name,
+	NULL /* must be always last */
+};
+
+
+/* {{{ mysqlnd_debug::open */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_debug, open)(MYSQLND_DEBUG * self, zend_bool reopen)
+{
+	MYSQLND_ZTS(self);
+
+	if (!self->file_name) {
+		return FAIL;
+	}
+
+	self->stream = php_stream_open_wrapper(self->file_name,
+										   reopen == TRUE || self->flags & MYSQLND_DEBUG_APPEND? "ab":"wb",
+										   REPORT_ERRORS, NULL);
+	return self->stream? PASS:FAIL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_debug::log */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_debug, log)(MYSQLND_DEBUG * self,
+								   unsigned int line, const char * const file,
+								   unsigned int level, const char * type, const char * message)
+{
+	char pipe_buffer[512];
+	enum_func_status ret;
+	int i;
+	char * message_line;
+	unsigned int message_line_len;
+	unsigned int flags = self->flags;
+	char pid_buffer[10], time_buffer[30], file_buffer[200],
+		 line_buffer[6], level_buffer[7];
+	MYSQLND_ZTS(self);
+
+	if (!self->stream && FAIL == self->m->open(self, FALSE)) {
+		return FAIL;
+	}
+
+	if (level == -1) {
+		level = zend_stack_count(&self->call_stack);
+	}
+	i = MIN(level, sizeof(pipe_buffer) / 2  - 1);
+	pipe_buffer[i*2] = '\0';
+	for (;i > 0;i--) {
+		pipe_buffer[i*2 - 1] = ' ';
+		pipe_buffer[i*2 - 2] = '|';
+	}
+
+
+	if (flags & MYSQLND_DEBUG_DUMP_PID) {
+		snprintf(pid_buffer, sizeof(pid_buffer) - 1, "%5u: ", self->pid);
+		pid_buffer[sizeof(pid_buffer) - 1 ] = '\0';
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_TIME) {
+		/* The following from FF's DBUG library, which is in the public domain */
+#if defined(PHP_WIN32)
+		/* FIXME This doesn't give microseconds as in Unix case, and the resolution is
+		in system ticks, 10 ms intervals. See my_getsystime.c for high res */
+		SYSTEMTIME loc_t;
+		GetLocalTime(&loc_t);
+		snprintf(time_buffer, sizeof(time_buffer) - 1,
+				 /* "%04d-%02d-%02d " */
+				 "%02d:%02d:%02d.%06d ",
+				 /*tm_p->tm_year + 1900, tm_p->tm_mon + 1, tm_p->tm_mday,*/
+				 loc_t.wHour, loc_t.wMinute, loc_t.wSecond, loc_t.wMilliseconds);
+		time_buffer[sizeof(time_buffer) - 1 ] = '\0';
+#else
+		struct timeval tv;
+		struct tm *tm_p;
+		if (gettimeofday(&tv, NULL) != -1) {
+			if ((tm_p= localtime((const time_t *)&tv.tv_sec))) {
+				snprintf(time_buffer, sizeof(time_buffer) - 1,
+						 /* "%04d-%02d-%02d " */
+						 "%02d:%02d:%02d.%06d ",
+						 /*tm_p->tm_year + 1900, tm_p->tm_mon + 1, tm_p->tm_mday,*/
+						 tm_p->tm_hour, tm_p->tm_min, tm_p->tm_sec,
+						 (int) (tv.tv_usec));
+				time_buffer[sizeof(time_buffer) - 1 ] = '\0';
+			}
+		}
+#endif
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_FILE) {
+		snprintf(file_buffer, sizeof(file_buffer) - 1, "%14s: ", file);
+		file_buffer[sizeof(file_buffer) - 1 ] = '\0';
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_LINE) {
+		snprintf(line_buffer, sizeof(line_buffer) - 1, "%5u: ", line);
+		line_buffer[sizeof(line_buffer) - 1 ] = '\0';
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_LEVEL) {
+		snprintf(level_buffer, sizeof(level_buffer) - 1, "%4u: ", level);
+		level_buffer[sizeof(level_buffer) - 1 ] = '\0';
+	}
+
+	message_line_len = spprintf(&message_line, 0, "%s%s%s%s%s%s%s%s\n",
+								flags & MYSQLND_DEBUG_DUMP_PID? pid_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_TIME? time_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_FILE? file_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_LINE? line_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_LEVEL? level_buffer:"",
+								pipe_buffer, type? type:"", message);
+
+	ret = php_stream_write(self->stream, message_line, message_line_len)? PASS:FAIL;
+	efree(message_line); /* allocated by spprintf */
+	if (flags & MYSQLND_DEBUG_FLUSH) {
+		self->m->close(self);
+		self->m->open(self, TRUE);
+	}
+	return ret;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_debug::log_va */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_debug, log_va)(MYSQLND_DEBUG *self,
+									  unsigned int line, const char * const file,
+									  unsigned int level, const char * type,
+									  const char *format, ...)
+{
+	char pipe_buffer[512];
+	int i;
+	enum_func_status ret;
+	char * message_line, *buffer;
+	unsigned int message_line_len;
+	va_list args;
+	unsigned int flags = self->flags;
+	char pid_buffer[10], time_buffer[30], file_buffer[200],
+		 line_buffer[6], level_buffer[7];
+	MYSQLND_ZTS(self);
+
+	if (!self->stream && FAIL == self->m->open(self, FALSE)) {
+		return FAIL;
+	}
+
+	if (level == -1) {
+		level = zend_stack_count(&self->call_stack);
+	}
+	i = MIN(level, sizeof(pipe_buffer) / 2  - 1);
+	pipe_buffer[i*2] = '\0';
+	for (;i > 0;i--) {
+		pipe_buffer[i*2 - 1] = ' ';
+		pipe_buffer[i*2 - 2] = '|';
+	}
+
+
+	if (flags & MYSQLND_DEBUG_DUMP_PID) {
+		snprintf(pid_buffer, sizeof(pid_buffer) - 1, "%5u: ", self->pid);
+		pid_buffer[sizeof(pid_buffer) - 1 ] = '\0';
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_TIME) {
+		/* The following from FF's DBUG library, which is in the public domain */
+#if defined(PHP_WIN32)
+		/* FIXME This doesn't give microseconds as in Unix case, and the resolution is
+		in system ticks, 10 ms intervals. See my_getsystime.c for high res */
+		SYSTEMTIME loc_t;
+		GetLocalTime(&loc_t);
+		snprintf(time_buffer, sizeof(time_buffer) - 1,
+				 /* "%04d-%02d-%02d " */
+				 "%02d:%02d:%02d.%06d ",
+				 /*tm_p->tm_year + 1900, tm_p->tm_mon + 1, tm_p->tm_mday,*/
+				 loc_t.wHour, loc_t.wMinute, loc_t.wSecond, loc_t.wMilliseconds);
+		time_buffer[sizeof(time_buffer) - 1 ] = '\0';
+#else
+		struct timeval tv;
+		struct tm *tm_p;
+		if (gettimeofday(&tv, NULL) != -1) {
+			if ((tm_p= localtime((const time_t *)&tv.tv_sec))) {
+				snprintf(time_buffer, sizeof(time_buffer) - 1,
+						 /* "%04d-%02d-%02d " */
+						 "%02d:%02d:%02d.%06d ",
+						 /*tm_p->tm_year + 1900, tm_p->tm_mon + 1, tm_p->tm_mday,*/
+						 tm_p->tm_hour, tm_p->tm_min, tm_p->tm_sec,
+						 (int) (tv.tv_usec));
+				time_buffer[sizeof(time_buffer) - 1 ] = '\0';
+			}
+		}
+#endif
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_FILE) {
+		snprintf(file_buffer, sizeof(file_buffer) - 1, "%14s: ", file);
+		file_buffer[sizeof(file_buffer) - 1 ] = '\0';
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_LINE) {
+		snprintf(line_buffer, sizeof(line_buffer) - 1, "%5u: ", line);
+		line_buffer[sizeof(line_buffer) - 1 ] = '\0';
+	}
+	if (flags & MYSQLND_DEBUG_DUMP_LEVEL) {
+		snprintf(level_buffer, sizeof(level_buffer) - 1, "%4u: ", level);
+		level_buffer[sizeof(level_buffer) - 1 ] = '\0';
+	}
+
+
+	va_start(args, format);
+	vspprintf(&buffer, 0, format, args);
+	va_end(args);
+
+	message_line_len = spprintf(&message_line, 0, "%s%s%s%s%s%s%s%s\n",
+								flags & MYSQLND_DEBUG_DUMP_PID? pid_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_TIME? time_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_FILE? file_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_LINE? line_buffer:"",
+								flags & MYSQLND_DEBUG_DUMP_LEVEL? level_buffer:"",
+								pipe_buffer, type? type:"", buffer);
+	efree(buffer);
+	ret = php_stream_write(self->stream, message_line, message_line_len)? PASS:FAIL;
+	efree(message_line); /* allocated by spprintf */
+
+	if (flags & MYSQLND_DEBUG_FLUSH) {
+		self->m->close(self);
+		self->m->open(self, TRUE);
+	}
+	return ret;
+}
+/* }}} */
+
+
+/* FALSE - The DBG_ calls won't be traced, TRUE - will be traced */
+/* {{{ mysqlnd_debug::func_enter */
+static zend_bool
+MYSQLND_METHOD(mysqlnd_debug, func_enter)(MYSQLND_DEBUG * self,
+										  unsigned int line, const char * const file,
+										  const char * const func_name, unsigned int func_name_len)
+{
+	if ((self->flags & MYSQLND_DEBUG_DUMP_TRACE) == 0 || self->file_name == NULL) {
+		return FALSE;
+	}
+	if ((uint) zend_stack_count(&self->call_stack) >= self->nest_level_limit) {
+		return FALSE;
+	}
+
+	if ((self->flags & MYSQLND_DEBUG_TRACE_MEMORY_CALLS) == 0 && self->skip_functions) {
+		const char ** p = self->skip_functions;
+		while (*p) {
+			if (*p == func_name) {
+				zend_stack_push(&self->call_stack, "", sizeof(""));
+#ifndef MYSQLND_PROFILING_DISABLED
+				if (self->flags & MYSQLND_DEBUG_PROFILE_CALLS) {
+					uint64_t some_time = 0;
+					zend_stack_push(&self->call_time_stack, &some_time, sizeof(some_time));
+				}
+#endif
+				return FALSE;
+			}
+			p++;
+		}
+	}
+
+	zend_stack_push(&self->call_stack, func_name, func_name_len + 1);
+#ifndef MYSQLND_PROFILING_DISABLED
+	if (self->flags & MYSQLND_DEBUG_PROFILE_CALLS) {
+		uint64_t some_time = 0;
+		zend_stack_push(&self->call_time_stack, &some_time, sizeof(some_time));
+	}
+#endif
+
+	if (zend_hash_num_elements(&self->not_filtered_functions) &&
+		0 == zend_hash_exists(&self->not_filtered_functions, func_name, strlen(func_name) + 1))
+	{
+		return FALSE;
+	}
+
+	self->m->log_va(self, line, file, zend_stack_count(&self->call_stack) - 1, NULL, ">%s", func_name);
+	return TRUE;
+}
+/* }}} */
+
+#ifndef MYSQLND_PROFILING_DISABLED
+struct st_mysqlnd_dbg_function_profile {
+	uint64_t calls;
+	uint64_t min_own;
+	uint64_t max_own;
+	uint64_t avg_own;
+	uint64_t own_underporm_calls;
+	uint64_t min_in_calls;
+	uint64_t max_in_calls;
+	uint64_t avg_in_calls;
+	uint64_t in_calls_underporm_calls;
+	uint64_t min_total;
+	uint64_t max_total;
+	uint64_t avg_total;	
+	uint64_t total_underporm_calls;
+};
+#define PROFILE_UNDERPERFORM_THRESHOLD 10
+#endif
+
+/* {{{ mysqlnd_debug::func_leave */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_debug, func_leave)(MYSQLND_DEBUG * self, unsigned int line, const char * const file, uint64_t call_time)
+{
+	char *func_name;
+	uint64_t * parent_non_own_time_ptr = NULL, * mine_non_own_time_ptr = NULL;
+	uint64_t mine_non_own_time = 0;
+	zend_bool profile_calls = self->flags & MYSQLND_DEBUG_PROFILE_CALLS? TRUE:FALSE;
+
+	if ((self->flags & MYSQLND_DEBUG_DUMP_TRACE) == 0 || self->file_name == NULL) {
+		return PASS;
+	}
+	if ((uint) zend_stack_count(&self->call_stack) >= self->nest_level_limit) {
+		return PASS;
+	}
+
+	zend_stack_top(&self->call_stack, (void **)&func_name);
+
+#ifndef MYSQLND_PROFILING_DISABLED
+	if (profile_calls) {
+		zend_stack_top(&self->call_time_stack, (void **)&mine_non_own_time_ptr);
+		mine_non_own_time = *mine_non_own_time_ptr;
+		zend_stack_del_top(&self->call_time_stack); /* callee - removing ourselves */
+	}
+#endif
+
+	if (func_name[0] == '\0') {
+		; /* don't log that function */
+	} else if (!zend_hash_num_elements(&self->not_filtered_functions) ||
+			   1 == zend_hash_exists(&self->not_filtered_functions, func_name, strlen(func_name) + 1))
+	{
+#ifndef MYSQLND_PROFILING_DISABLED
+		if (FALSE == profile_calls) {
+#endif
+			self->m->log_va(self, line, file, zend_stack_count(&self->call_stack) - 1, NULL, "<%s", func_name);
+
+#ifndef MYSQLND_PROFILING_DISABLED
+		} else {
+			struct st_mysqlnd_dbg_function_profile f_profile_stack = {0};
+			struct st_mysqlnd_dbg_function_profile * f_profile = NULL;
+			uint64_t own_time = call_time - mine_non_own_time;
+			uint func_name_len = strlen(func_name);
+
+			self->m->log_va(self, line, file, zend_stack_count(&self->call_stack) - 1, NULL, "<%s (total=%u own=%u in_calls=%u)",
+						func_name, (unsigned int) call_time, (unsigned int) own_time, (unsigned int) mine_non_own_time
+					);
+
+			if (SUCCESS == zend_hash_find(&self->function_profiles, func_name, func_name_len + 1, (void **) &f_profile)) {
+				/* found */
+					if (f_profile) {
+					if (mine_non_own_time < f_profile->min_in_calls) {
+						f_profile->min_in_calls = mine_non_own_time;
+					} else if (mine_non_own_time > f_profile->max_in_calls) {
+						f_profile->max_in_calls = mine_non_own_time;
+					}
+					f_profile->avg_in_calls = (f_profile->avg_in_calls * f_profile->calls + mine_non_own_time) / (f_profile->calls + 1);
+
+					if (own_time < f_profile->min_own) {
+						f_profile->min_own = own_time;
+					} else if (own_time > f_profile->max_own) {
+						f_profile->max_own = own_time;
+					}
+					f_profile->avg_own = (f_profile->avg_own * f_profile->calls + own_time) / (f_profile->calls + 1);
+
+					if (call_time < f_profile->min_total) {
+						f_profile->min_total = call_time;
+					} else if (call_time > f_profile->max_total) {
+						f_profile->max_total = call_time;
+					}
+					f_profile->avg_total = (f_profile->avg_total * f_profile->calls + call_time) / (f_profile->calls + 1);
+
+					++f_profile->calls;
+					if (f_profile->calls > PROFILE_UNDERPERFORM_THRESHOLD) {
+						if (f_profile->avg_in_calls < mine_non_own_time) {
+							f_profile->in_calls_underporm_calls++;
+						}
+						if (f_profile->avg_own < own_time) {
+							f_profile->own_underporm_calls++;
+						}
+						if (f_profile->avg_total < call_time) {
+							f_profile->total_underporm_calls++;
+						}
+					}
+				}
+			} else {
+				/* add */
+				f_profile = &f_profile_stack;
+				f_profile->min_in_calls = f_profile->max_in_calls = f_profile->avg_in_calls = mine_non_own_time;
+				f_profile->min_total = f_profile->max_total = f_profile->avg_total = call_time;
+				f_profile->min_own = f_profile->max_own = f_profile->avg_own = own_time;
+				f_profile->calls = 1;
+				zend_hash_add(&self->function_profiles, func_name, func_name_len+1, f_profile, sizeof(struct st_mysqlnd_dbg_function_profile), NULL);
+			}
+			if ((uint) zend_stack_count(&self->call_time_stack)) {
+				uint64_t parent_non_own_time = 0;
+
+				zend_stack_top(&self->call_time_stack, (void **)&parent_non_own_time_ptr);
+				parent_non_own_time = *parent_non_own_time_ptr;
+				parent_non_own_time += call_time;
+				zend_stack_del_top(&self->call_time_stack); /* the caller */
+				zend_stack_push(&self->call_time_stack, &parent_non_own_time, sizeof(parent_non_own_time)); /* add back the caller */
+			}
+		}
+#endif
+	}
+
+	return zend_stack_del_top(&self->call_stack) == SUCCESS? PASS:FAIL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_debug::close */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_debug, close)(MYSQLND_DEBUG * self)
+{
+	MYSQLND_ZTS(self);
+	if (self->stream) {
+#ifndef MYSQLND_PROFILING_DISABLED
+		if (!(self->flags & MYSQLND_DEBUG_FLUSH) && (self->flags & MYSQLND_DEBUG_PROFILE_CALLS)) {
+			struct st_mysqlnd_dbg_function_profile * f_profile;
+			HashPosition pos_values;
+
+			self->m->log_va(self, __LINE__, __FILE__, 0, "info : ",	
+					"number of functions: %d", zend_hash_num_elements(&self->function_profiles));
+			zend_hash_internal_pointer_reset_ex(&self->function_profiles, &pos_values);
+			while (zend_hash_get_current_data_ex(&self->function_profiles, (void **) &f_profile, &pos_values) == SUCCESS) {
+				char	*string_key = NULL;
+				uint	string_key_len;
+				ulong	num_key;
+
+				zend_hash_get_current_key_ex(&self->function_profiles, &string_key, &string_key_len, &num_key, 0, &pos_values);
+
+				self->m->log_va(self, __LINE__, __FILE__, -1, "info : ",
+						"%-40s\tcalls=%5llu  own_slow=%5llu  in_calls_slow=%5llu  total_slow=%5llu"
+						"   min_own=%5llu  max_own=%7llu  avg_own=%7llu   "
+						"   min_in_calls=%5llu  max_in_calls=%7llu  avg_in_calls=%7llu"
+						"   min_total=%5llu  max_total=%7llu  avg_total=%7llu"
+						,string_key
+						,(uint64_t) f_profile->calls
+						,(uint64_t) f_profile->own_underporm_calls
+						,(uint64_t) f_profile->in_calls_underporm_calls
+						,(uint64_t) f_profile->total_underporm_calls
+						
+						,(uint64_t) f_profile->min_own
+						,(uint64_t) f_profile->max_own
+						,(uint64_t) f_profile->avg_own
+						,(uint64_t) f_profile->min_in_calls
+						,(uint64_t) f_profile->max_in_calls
+						,(uint64_t) f_profile->avg_in_calls
+						,(uint64_t) f_profile->min_total
+						,(uint64_t) f_profile->max_total
+						,(uint64_t) f_profile->avg_total
+						);
+				zend_hash_move_forward_ex(&self->function_profiles, &pos_values);
+			}
+		}
+#endif	
+
+		php_stream_free(self->stream, PHP_STREAM_FREE_CLOSE);
+		self->stream = NULL;
+	}
+	/* no DBG_RETURN please */
+	return PASS;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res_meta::free */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_debug, free)(MYSQLND_DEBUG * self)
+{
+	if (self->file_name && self->file_name != mysqlnd_debug_default_trace_file) {
+		efree(self->file_name);
+		self->file_name = NULL;
+	}
+	zend_stack_destroy(&self->call_stack);
+	zend_stack_destroy(&self->call_time_stack);
+	zend_hash_destroy(&self->not_filtered_functions);
+	zend_hash_destroy(&self->function_profiles);
+	efree(self);
+	return PASS;
+}
+/* }}} */
+
+enum mysqlnd_debug_parser_state
+{
+	PARSER_WAIT_MODIFIER,
+	PARSER_WAIT_COLON,
+	PARSER_WAIT_VALUE
+};
+
+
+/* {{{ mysqlnd_res_meta::set_mode */
+static void
+MYSQLND_METHOD(mysqlnd_debug, set_mode)(MYSQLND_DEBUG * self, const char * const mode)
+{
+	unsigned int mode_len = strlen(mode), i;
+	enum mysqlnd_debug_parser_state state = PARSER_WAIT_MODIFIER;
+
+	self->flags = 0;
+	self->nest_level_limit = 0;
+	if (self->file_name && self->file_name != mysqlnd_debug_default_trace_file) {
+		efree(self->file_name);
+		self->file_name = NULL;
+	}
+	if (zend_hash_num_elements(&self->not_filtered_functions)) {
+		zend_hash_destroy(&self->not_filtered_functions);
+		zend_hash_init(&self->not_filtered_functions, 0, NULL, NULL, 0);
+	}
+
+	for (i = 0; i < mode_len; i++) {
+		switch (mode[i]) {
+			case 'O':
+			case 'A':
+				self->flags |= MYSQLND_DEBUG_FLUSH;
+			case 'a':
+			case 'o':
+				if (mode[i] == 'a' || mode[i] == 'A') {
+					self->flags |= MYSQLND_DEBUG_APPEND;
+				}
+				if (i + 1 < mode_len && mode[i+1] == ',') {
+					unsigned int j = i + 2;
+#ifdef PHP_WIN32
+					if (i+4 < mode_len && mode[i+3] == ':' && (mode[i+4] == '\\' || mode[i+5] == '/')) {
+						j = i + 5;
+					}
+#endif
+					while (j < mode_len) {
+						if (mode[j] == ':') {
+							break;
+						}
+						j++;
+					}
+					if (j > i + 2) {
+						self->file_name = estrndup(mode + i + 2, j - i - 2);
+					}
+					i = j;
+				} else {
+					if (!self->file_name)
+						self->file_name = (char *) mysqlnd_debug_default_trace_file;
+				}
+				state = PARSER_WAIT_COLON;
+				break;
+			case ':':
+#if 0
+				if (state != PARSER_WAIT_COLON) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Consecutive semicolons at position %u", i);
+				}
+#endif
+				state = PARSER_WAIT_MODIFIER;
+				break;
+			case 'f': /* limit output to these functions */
+				if (i + 1 < mode_len && mode[i+1] == ',') {
+					unsigned int j = i + 2;
+					i++;
+					while (j < mode_len) {
+						if (mode[j] == ':') {
+							/* function names with :: */
+							if ((j + 1 < mode_len) && mode[j+1] == ':') {
+								j += 2;
+								continue;
+							}
+						}
+						if (mode[j] == ',' || mode[j] == ':') {
+							if (j > i + 2) {
+								char func_name[1024];
+								unsigned int func_name_len = MIN(sizeof(func_name) - 1, j - i - 1);
+								memcpy(func_name, mode + i + 1, func_name_len);
+								func_name[func_name_len] = '\0'; 
+
+								zend_hash_add_empty_element(&self->not_filtered_functions,
+															func_name, func_name_len + 1);
+								i = j;
+							}
+							if (mode[j] == ':') {
+								break;
+							}
+						}
+						j++;
+					}
+					i = j;
+				} else {
+#if 0
+					php_error_docref(NULL TSRMLS_CC, E_WARNING,
+									 "Expected list of functions for '%c' found none", mode[i]);
+#endif
+				}
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'D':
+			case 'd':
+			case 'g':
+			case 'p':
+				/* unsupported */
+				if ((i + 1) < mode_len && mode[i+1] == ',') {
+					i+= 2;
+					while (i < mode_len) {
+						if (mode[i] == ':') {
+							break;
+						}
+						i++;
+					}
+				}
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'F':
+				self->flags |= MYSQLND_DEBUG_DUMP_FILE;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'i':
+				self->flags |= MYSQLND_DEBUG_DUMP_PID;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'L':
+				self->flags |= MYSQLND_DEBUG_DUMP_LINE;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'n':
+				self->flags |= MYSQLND_DEBUG_DUMP_LEVEL;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 't':
+				if (mode[i+1] == ',') {
+					unsigned int j = i + 2;
+					while (j < mode_len) {
+						if (mode[j] == ':') {
+							break;
+						}
+						j++;
+					}
+					if (j > i + 2) {
+						char *value_str = estrndup(mode + i + 2, j - i - 2);
+						self->nest_level_limit = atoi(value_str);
+						efree(value_str);
+					}
+					i = j;
+				} else {
+					self->nest_level_limit = 200; /* default value for FF DBUG */
+				}
+				self->flags |= MYSQLND_DEBUG_DUMP_TRACE;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'T':
+				self->flags |= MYSQLND_DEBUG_DUMP_TIME;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'N':
+			case 'P':
+			case 'r':
+			case 'S':
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'm': /* mysqlnd extension - trace memory functions */
+				self->flags |= MYSQLND_DEBUG_TRACE_MEMORY_CALLS;
+				state = PARSER_WAIT_COLON;
+				break;
+			case 'x': /* mysqlnd extension - profile calls */
+				self->flags |= MYSQLND_DEBUG_PROFILE_CALLS;
+				state = PARSER_WAIT_COLON;
+				break;				
+			default:
+				if (state == PARSER_WAIT_MODIFIER) {
+#if 0
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unrecognized format '%c'", mode[i]);
+#endif
+					if (i+1 < mode_len && mode[i+1] == ',') {
+						i+= 2;
+						while (i < mode_len) {
+							if (mode[i] == ':') {
+								break;
+							}
+							i++;
+						}
+					}
+					state = PARSER_WAIT_COLON;
+				} else if (state == PARSER_WAIT_COLON) {
+#if 0
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Colon expected, '%c' found", mode[i]);
+#endif
+				}
+				break;
+		}
+	}
+}
+/* }}} */
+
+MYSQLND_CLASS_METHODS_START(mysqlnd_debug)
+	MYSQLND_METHOD(mysqlnd_debug, open),
+	MYSQLND_METHOD(mysqlnd_debug, set_mode),
+	MYSQLND_METHOD(mysqlnd_debug, log),
+	MYSQLND_METHOD(mysqlnd_debug, log_va),
+	MYSQLND_METHOD(mysqlnd_debug, func_enter),
+	MYSQLND_METHOD(mysqlnd_debug, func_leave),
+	MYSQLND_METHOD(mysqlnd_debug, close),
+	MYSQLND_METHOD(mysqlnd_debug, free),
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ mysqlnd_debug_init */
+PHPAPI MYSQLND_DEBUG *
+mysqlnd_debug_init(const char * skip_functions[] TSRMLS_DC)
+{
+	MYSQLND_DEBUG *ret = ecalloc(1, sizeof(MYSQLND_DEBUG));
+#ifdef ZTS
+	ret->TSRMLS_C = TSRMLS_C;
+#endif
+	ret->nest_level_limit = 0;
+	ret->pid = getpid();
+	zend_stack_init(&ret->call_stack);
+	zend_stack_init(&ret->call_time_stack);
+	zend_hash_init(&ret->not_filtered_functions, 0, NULL, NULL, 0);
+	zend_hash_init(&ret->function_profiles, 0, NULL, NULL, 0);
+
+	ret->m = & mysqlnd_mysqlnd_debug_methods;
+	ret->skip_functions = skip_functions;
+
+	return ret;
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_debug */
+PHPAPI void _mysqlnd_debug(const char * mode TSRMLS_DC)
+{
+#ifdef PHP_DEBUG
+	MYSQLND_DEBUG *dbg = MYSQLND_G(dbg);
+	if (!dbg) {
+		MYSQLND_G(dbg) = dbg = mysqlnd_debug_init(mysqlnd_debug_std_no_trace_funcs TSRMLS_CC);
+		if (!dbg) {
+			return;
+		}
+	}
+
+	dbg->m->close(dbg);
+	dbg->m->set_mode(dbg, mode);
+	while (zend_stack_count(&dbg->call_stack)) {
+		zend_stack_del_top(&dbg->call_stack);
+	}
+	while (zend_stack_count(&dbg->call_time_stack)) {
+		zend_stack_del_top(&dbg->call_time_stack);
+	}
+#endif
+}
+/* }}} */
+
+
+#if ZEND_DEBUG
+#else
+#define __zend_filename "/unknown/unknown"
+#define __zend_lineno   0
+#endif
+
+#define REAL_SIZE(s) (collect_memory_statistics? (s) + sizeof(size_t) : (s))
+#define REAL_PTR(p) (collect_memory_statistics && (p)? (((char *)(p)) - sizeof(size_t)) : (p))
+#define FAKE_PTR(p) (collect_memory_statistics && (p)? (((char *)(p)) + sizeof(size_t)) : (p))
+
+/* {{{ _mysqlnd_emalloc */
+void * _mysqlnd_emalloc(size_t size MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = &MYSQLND_G(debug_emalloc_fail_threshold);
+	DBG_ENTER(mysqlnd_emalloc_name);
+
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = emalloc(REAL_SIZE(size));
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("size=%lu ptr=%p", size, ret);
+
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_EMALLOC_COUNT, 1, STAT_MEM_EMALLOC_AMOUNT, size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_pemalloc */
+void * _mysqlnd_pemalloc(size_t size, zend_bool persistent MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = persistent? &MYSQLND_G(debug_malloc_fail_threshold):&MYSQLND_G(debug_emalloc_fail_threshold);
+	DBG_ENTER(mysqlnd_pemalloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = pemalloc(REAL_SIZE(size), persistent);
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("size=%lu ptr=%p persistent=%u", size, ret, persistent);
+
+	if (ret && collect_memory_statistics) {
+		enum mysqlnd_collected_stats s1 = persistent? STAT_MEM_MALLOC_COUNT:STAT_MEM_EMALLOC_COUNT;
+		enum mysqlnd_collected_stats s2 = persistent? STAT_MEM_MALLOC_AMOUNT:STAT_MEM_EMALLOC_AMOUNT;
+		*(size_t *) ret = size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(s1, 1, s2, size);
+	}
+
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_ecalloc */
+void * _mysqlnd_ecalloc(unsigned int nmemb, size_t size MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = &MYSQLND_G(debug_ecalloc_fail_threshold);
+	DBG_ENTER(mysqlnd_ecalloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("before: %lu", zend_memory_usage(FALSE TSRMLS_CC));
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = ecalloc(nmemb, REAL_SIZE(size));
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("after : %lu", zend_memory_usage(FALSE TSRMLS_CC));
+	DBG_INF_FMT("size=%lu ptr=%p", size, ret);
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_ECALLOC_COUNT, 1, STAT_MEM_ECALLOC_AMOUNT, size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_pecalloc */
+void * _mysqlnd_pecalloc(unsigned int nmemb, size_t size, zend_bool persistent MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = persistent? &MYSQLND_G(debug_calloc_fail_threshold):&MYSQLND_G(debug_ecalloc_fail_threshold);
+	DBG_ENTER(mysqlnd_pecalloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = pecalloc(nmemb, REAL_SIZE(size), persistent);
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("size=%lu ptr=%p", size, ret);
+
+	if (ret && collect_memory_statistics) {
+		enum mysqlnd_collected_stats s1 = persistent? STAT_MEM_CALLOC_COUNT:STAT_MEM_ECALLOC_COUNT;
+		enum mysqlnd_collected_stats s2 = persistent? STAT_MEM_CALLOC_AMOUNT:STAT_MEM_ECALLOC_AMOUNT;
+		*(size_t *) ret = size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(s1, 1, s2, size);
+	}
+
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_erealloc */
+void * _mysqlnd_erealloc(void *ptr, size_t new_size MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	size_t old_size = collect_memory_statistics && ptr? *(size_t *) (((char*)ptr) - sizeof(size_t)) : 0;
+	long * threshold = &MYSQLND_G(debug_erealloc_fail_threshold);
+	DBG_ENTER(mysqlnd_erealloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p old_size=%lu, new_size=%lu", ptr, old_size, new_size); 
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = erealloc(REAL_PTR(ptr), REAL_SIZE(new_size));
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("new_ptr=%p", (char*)ret);
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = new_size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_EREALLOC_COUNT, 1, STAT_MEM_EREALLOC_AMOUNT, new_size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_perealloc */
+void * _mysqlnd_perealloc(void *ptr, size_t new_size, zend_bool persistent MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	size_t old_size = collect_memory_statistics && ptr? *(size_t *) (((char*)ptr) - sizeof(size_t)) : 0;
+	long * threshold = persistent? &MYSQLND_G(debug_realloc_fail_threshold):&MYSQLND_G(debug_erealloc_fail_threshold);
+	DBG_ENTER(mysqlnd_perealloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p old_size=%lu new_size=%lu persistent=%u", ptr, old_size, new_size, persistent); 
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = perealloc(REAL_PTR(ptr), REAL_SIZE(new_size), persistent);
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("new_ptr=%p", (char*)ret);
+
+	if (ret && collect_memory_statistics) {
+		enum mysqlnd_collected_stats s1 = persistent? STAT_MEM_REALLOC_COUNT:STAT_MEM_EREALLOC_COUNT;
+		enum mysqlnd_collected_stats s2 = persistent? STAT_MEM_REALLOC_AMOUNT:STAT_MEM_EREALLOC_AMOUNT;
+		*(size_t *) ret = new_size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(s1, 1, s2, new_size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_efree */
+void _mysqlnd_efree(void *ptr MYSQLND_MEM_D)
+{
+	size_t free_amount = 0;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	DBG_ENTER(mysqlnd_efree_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p", ptr); 
+
+	if (ptr) {
+		if (collect_memory_statistics) {
+			free_amount = *(size_t *)(((char*)ptr) - sizeof(size_t));
+			DBG_INF_FMT("ptr=%p size=%u", ((char*)ptr) - sizeof(size_t), (unsigned int) free_amount);
+		}
+		efree(REAL_PTR(ptr));
+	}
+
+	if (collect_memory_statistics) {
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_EFREE_COUNT, 1, STAT_MEM_EFREE_AMOUNT, free_amount);
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_pefree */
+void _mysqlnd_pefree(void *ptr, zend_bool persistent MYSQLND_MEM_D)
+{
+	size_t free_amount = 0;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	DBG_ENTER(mysqlnd_pefree_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p persistent=%u", ptr, persistent); 
+
+	if (ptr) {
+		if (collect_memory_statistics) {
+			free_amount = *(size_t *)(((char*)ptr) - sizeof(size_t));
+			DBG_INF_FMT("ptr=%p size=%u", ((char*)ptr) - sizeof(size_t), (unsigned int) free_amount);
+		}
+		pefree(REAL_PTR(ptr), persistent);
+	}
+
+	if (collect_memory_statistics) {
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(persistent? STAT_MEM_FREE_COUNT:STAT_MEM_EFREE_COUNT, 1,
+											  persistent? STAT_MEM_FREE_AMOUNT:STAT_MEM_EFREE_AMOUNT, free_amount);
+	}
+	DBG_VOID_RETURN;
+}
+
+
+/* {{{ _mysqlnd_malloc */
+void * _mysqlnd_malloc(size_t size MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = &MYSQLND_G(debug_malloc_fail_threshold);
+	DBG_ENTER(mysqlnd_malloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = malloc(REAL_SIZE(size));
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("size=%lu ptr=%p", size, ret);
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_MALLOC_COUNT, 1, STAT_MEM_MALLOC_AMOUNT, size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_calloc */
+void * _mysqlnd_calloc(unsigned int nmemb, size_t size MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = &MYSQLND_G(debug_calloc_fail_threshold);
+	DBG_ENTER(mysqlnd_calloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = calloc(nmemb, REAL_SIZE(size));
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("size=%lu ptr=%p", size, ret);
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_CALLOC_COUNT, 1, STAT_MEM_CALLOC_AMOUNT, size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_realloc */
+void * _mysqlnd_realloc(void *ptr, size_t new_size MYSQLND_MEM_D)
+{
+	void *ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	long * threshold = &MYSQLND_G(debug_realloc_fail_threshold);
+	DBG_ENTER(mysqlnd_realloc_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p new_size=%lu ", new_size, ptr); 
+	DBG_INF_FMT("before: %lu", zend_memory_usage(TRUE TSRMLS_CC));
+
+#ifdef PHP_DEBUG
+	/* -1 is also "true" */
+	if (*threshold) {
+#endif
+		ret = realloc(REAL_PTR(ptr), REAL_SIZE(new_size));
+#ifdef PHP_DEBUG
+		--*threshold;
+	} else if (*threshold == 0) {
+		ret = NULL;
+	}
+#endif
+
+	DBG_INF_FMT("new_ptr=%p", (char*)ret);
+
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = new_size;
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_REALLOC_COUNT, 1, STAT_MEM_REALLOC_AMOUNT, new_size);
+	}
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_free */
+void _mysqlnd_free(void *ptr MYSQLND_MEM_D)
+{
+	size_t free_amount = 0;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	DBG_ENTER(mysqlnd_free_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p", ptr); 
+
+	if (ptr) {
+		if (collect_memory_statistics) {
+			free_amount = *(size_t *)(((char*)ptr) - sizeof(size_t));
+			DBG_INF_FMT("ptr=%p size=%u", ((char*)ptr) - sizeof(size_t), (unsigned int) free_amount);
+		}
+		free(REAL_PTR(ptr));
+	}
+
+	if (collect_memory_statistics) {
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_MEM_FREE_COUNT, 1, STAT_MEM_FREE_AMOUNT, free_amount);
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+#define SMART_STR_START_SIZE 2048
+#define SMART_STR_PREALLOC 512
+#include "ext/standard/php_smart_str.h"
+
+
+/* {{{ _mysqlnd_pestrndup */
+char * _mysqlnd_pestrndup(const char * const ptr, size_t length, zend_bool persistent MYSQLND_MEM_D)
+{
+	char * ret;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	DBG_ENTER(mysqlnd_pestrndup_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p", ptr); 
+
+	ret = pemalloc(REAL_SIZE(length) + 1, persistent);
+	{
+		size_t l = length;
+		char * p = (char *) ptr;
+		char * dest = (char *) FAKE_PTR(ret);
+		while (*p && l--) {
+			*dest++ = *p++;
+		}
+		*dest = '\0';
+	}
+
+	if (collect_memory_statistics) {
+		*(size_t *) ret = length;
+		MYSQLND_INC_GLOBAL_STATISTIC(persistent? STAT_MEM_STRNDUP_COUNT : STAT_MEM_ESTRNDUP_COUNT);
+	}
+
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_pestrdup */
+char * _mysqlnd_pestrdup(const char * const ptr, zend_bool persistent MYSQLND_MEM_D)
+{
+	char * ret;
+	smart_str tmp_str = {0, 0, 0};
+	const char * p = ptr;
+	zend_bool collect_memory_statistics = MYSQLND_G(collect_memory_statistics);
+	DBG_ENTER(mysqlnd_pestrdup_name);
+	DBG_INF_FMT("file=%-15s line=%4d", strrchr(__zend_filename, PHP_DIR_SEPARATOR) + 1, __zend_lineno);
+	DBG_INF_FMT("ptr=%p", ptr);
+	do {
+		smart_str_appendc(&tmp_str, *p);
+	} while (*p++);
+
+	ret = pemalloc(tmp_str.len + sizeof(size_t), persistent);
+	memcpy(FAKE_PTR(ret), tmp_str.c, tmp_str.len);
+
+	if (ret && collect_memory_statistics) {
+		*(size_t *) ret = tmp_str.len;
+		MYSQLND_INC_GLOBAL_STATISTIC(persistent? STAT_MEM_STRDUP_COUNT : STAT_MEM_ESTRDUP_COUNT);
+	}
+	smart_str_free(&tmp_str);
+
+	DBG_RETURN(FAKE_PTR(ret));
+}
+/* }}} */
+
+#define MYSQLND_DEBUG_MEMORY 1
+
+#if MYSQLND_DEBUG_MEMORY == 0
+
+/* {{{ mysqlnd_zend_mm_emalloc */
+static void * mysqlnd_zend_mm_emalloc(size_t size MYSQLND_MEM_D)
+{
+	return emalloc(size);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_pemalloc */
+static void * mysqlnd_zend_mm_pemalloc(size_t size, zend_bool persistent MYSQLND_MEM_D)
+{
+	return pemalloc(size, persistent);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_ecalloc */
+static void * mysqlnd_zend_mm_ecalloc(unsigned int nmemb, size_t size MYSQLND_MEM_D)
+{
+	return ecalloc(nmemb, size);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_pecalloc */
+static void * mysqlnd_zend_mm_pecalloc(unsigned int nmemb, size_t size, zend_bool persistent MYSQLND_MEM_D)
+{
+	return pecalloc(nmemb, size, persistent);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_erealloc */
+static void * mysqlnd_zend_mm_erealloc(void *ptr, size_t new_size MYSQLND_MEM_D)
+{
+	return erealloc(ptr, new_size);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_perealloc */
+static void * mysqlnd_zend_mm_perealloc(void *ptr, size_t new_size, zend_bool persistent MYSQLND_MEM_D)
+{
+	return perealloc(ptr, new_size, persistent);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_efree */
+static void mysqlnd_zend_mm_efree(void * ptr MYSQLND_MEM_D)
+{
+	efree(ptr);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_pefree */
+static void mysqlnd_zend_mm_pefree(void * ptr, zend_bool persistent MYSQLND_MEM_D)
+{
+	pefree(ptr, persistent);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_malloc */
+static void * mysqlnd_zend_mm_malloc(size_t size MYSQLND_MEM_D)
+{
+	return malloc(size);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_calloc */
+static void * mysqlnd_zend_mm_calloc(unsigned int nmemb, size_t size MYSQLND_MEM_D)
+{
+	return calloc(nmemb, size);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_realloc */
+static void * mysqlnd_zend_mm_realloc(void * ptr, size_t new_size MYSQLND_MEM_D)
+{
+	return realloc(ptr, new_size);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_free */
+static void mysqlnd_zend_mm_free(void * ptr MYSQLND_MEM_D)
+{
+	free(ptr);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_pestrndup */
+static char * mysqlnd_zend_mm_pestrndup(const char * const ptr, size_t length, zend_bool persistent MYSQLND_MEM_D)
+{
+	return pestrndup(ptr, length, persistent);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_zend_mm_pestrdup */
+static char * mysqlnd_zend_mm_pestrdup(const char * const ptr, zend_bool persistent MYSQLND_MEM_D)
+{
+	return pestrdup(ptr, persistent);
+}
+/* }}} */
+
+#endif
+
+
+PHPAPI struct st_mysqlnd_allocator_methods mysqlnd_allocator = 
+{
+#if MYSQLND_DEBUG_MEMORY
+	_mysqlnd_emalloc,
+	_mysqlnd_pemalloc,
+	_mysqlnd_ecalloc,
+	_mysqlnd_pecalloc,
+	_mysqlnd_erealloc,
+	_mysqlnd_perealloc,
+	_mysqlnd_efree,
+	_mysqlnd_pefree,
+	_mysqlnd_malloc,
+	_mysqlnd_calloc,
+	_mysqlnd_realloc,
+	_mysqlnd_free,
+	_mysqlnd_pestrndup,
+	_mysqlnd_pestrdup
+#else
+	mysqlnd_zend_mm_emalloc,
+	mysqlnd_zend_mm_pemalloc,
+	mysqlnd_zend_mm_ecalloc,
+	mysqlnd_zend_mm_pecalloc,
+	mysqlnd_zend_mm_erealloc,
+	mysqlnd_zend_mm_perealloc,
+	mysqlnd_zend_mm_efree,
+	mysqlnd_zend_mm_pefree,
+	mysqlnd_zend_mm_malloc,
+	mysqlnd_zend_mm_calloc,
+	mysqlnd_zend_mm_realloc,
+	mysqlnd_zend_mm_free,
+	mysqlnd_zend_mm_pestrndup,
+	mysqlnd_zend_mm_pestrdup
+#endif
+};
+
+
+
+/* Follows code borrowed from zend_builtin_functions.c because the functions there are static */
+
+#if MYSQLND_UNICODE
+/* {{{ gettraceasstring() macros */
+#define TRACE_APPEND_CHR(chr)                                            \
+	*str = (char*)erealloc(*str, *len + 1 + 1);                          \
+	(*str)[(*len)++] = chr
+
+#define TRACE_APPEND_STRL(val, vallen)                                   \
+	{                                                                    \
+		int l = vallen;                                                  \
+		*str = (char*)erealloc(*str, *len + l + 1);                      \
+		memcpy((*str) + *len, val, l);                                   \
+		*len += l;                                                       \
+	}
+
+#define TRACE_APPEND_USTRL(val, vallen) \
+	{ \
+		zval tmp, copy; \
+		int use_copy; \
+		ZVAL_UNICODEL(&tmp, val, vallen, 1); \
+		zend_make_printable_zval(&tmp, &copy, &use_copy); \
+		TRACE_APPEND_STRL(Z_STRVAL(copy), Z_STRLEN(copy)); \
+		zval_dtor(&copy); \
+		zval_dtor(&tmp); \
+	}
+
+#define TRACE_APPEND_ZVAL(zv) \
+	if (Z_TYPE_P((zv)) == IS_UNICODE) { \
+		zval copy; \
+		int use_copy; \
+		zend_make_printable_zval((zv), &copy, &use_copy); \
+		TRACE_APPEND_STRL(Z_STRVAL(copy), Z_STRLEN(copy)); \
+		zval_dtor(&copy); \
+	} else { \
+		TRACE_APPEND_STRL(Z_STRVAL_P((zv)), Z_STRLEN_P((zv))); \
+	}
+
+#define TRACE_APPEND_STR(val)                                            \
+	TRACE_APPEND_STRL(val, sizeof(val)-1)
+
+#define TRACE_APPEND_KEY(key)                                            \
+	if (zend_ascii_hash_find(ht, key, sizeof(key), (void**)&tmp) == SUCCESS) { \
+		if (Z_TYPE_PP(tmp) == IS_UNICODE) { \
+			zval copy; \
+			int use_copy; \
+			zend_make_printable_zval(*tmp, &copy, &use_copy); \
+			TRACE_APPEND_STRL(Z_STRVAL(copy), Z_STRLEN(copy)); \
+			zval_dtor(&copy); \
+		} else { \
+		TRACE_APPEND_STRL(Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));           \
+		} \
+	}
+/* }}} */
+
+/* {{{ mysqlnd_build_trace_args */
+static int mysqlnd_build_trace_args(zval **arg TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)
+{
+	char **str;
+	int *len;
+
+	str = va_arg(args, char**);
+	len = va_arg(args, int*);
+
+	/* the trivial way would be to do:
+	 * conver_to_string_ex(arg);
+	 * append it and kill the now tmp arg.
+	 * but that could cause some E_NOTICE and also damn long lines.
+	 */
+
+	switch (Z_TYPE_PP(arg)) {
+		case IS_NULL:
+			TRACE_APPEND_STR("NULL, ");
+			break;
+		case IS_STRING: {
+			int l_added;
+			TRACE_APPEND_CHR('\'');
+			if (Z_STRLEN_PP(arg) > 15) {
+				TRACE_APPEND_STRL(Z_STRVAL_PP(arg), 15);
+				TRACE_APPEND_STR("...', ");
+				l_added = 15 + 6 + 1; /* +1 because of while (--l_added) */
+			} else {
+				l_added = Z_STRLEN_PP(arg);
+				TRACE_APPEND_STRL(Z_STRVAL_PP(arg), l_added);
+				TRACE_APPEND_STR("', ");
+				l_added += 3 + 1;
+			}
+			while (--l_added) {
+				if ((unsigned char)(*str)[*len - l_added] < 32) {
+					(*str)[*len - l_added] = '?';
+				}
+			}
+			break;
+		}
+		case IS_UNICODE: {
+			int l_added;
+
+			/*
+			 * We do not want to apply current error mode here, since
+			 * zend_make_printable_zval() uses output encoding converter.
+			 * Temporarily set output encoding converter to escape offending
+			 * chars with \uXXXX notation.
+			 */
+			zend_set_converter_error_mode(ZEND_U_CONVERTER(UG(output_encoding_conv)), ZEND_FROM_UNICODE, ZEND_CONV_ERROR_ESCAPE_JAVA);
+			TRACE_APPEND_CHR('\'');
+			if (Z_USTRLEN_PP(arg) > 15) {
+				TRACE_APPEND_USTRL(Z_USTRVAL_PP(arg), 15);
+				TRACE_APPEND_STR("...', ");
+				l_added = 15 + 6 + 1; /* +1 because of while (--l_added) */
+			} else {
+				l_added = Z_USTRLEN_PP(arg);
+				TRACE_APPEND_USTRL(Z_USTRVAL_PP(arg), l_added);
+				TRACE_APPEND_STR("', ");
+				l_added += 3 + 1;
+			}
+			/*
+			 * Reset output encoding converter error mode.
+			 */
+			zend_set_converter_error_mode(ZEND_U_CONVERTER(UG(output_encoding_conv)), ZEND_FROM_UNICODE, UG(from_error_mode));
+			while (--l_added) {
+				if ((unsigned char)(*str)[*len - l_added] < 32) {
+					(*str)[*len - l_added] = '?';
+				}
+			}
+			break;
+		}
+		case IS_BOOL:
+			if (Z_LVAL_PP(arg)) {
+				TRACE_APPEND_STR("true, ");
+			} else {
+				TRACE_APPEND_STR("false, ");
+			}
+			break;
+		case IS_RESOURCE:
+			TRACE_APPEND_STR("Resource id #");
+			/* break; */
+		case IS_LONG: {
+			long lval = Z_LVAL_PP(arg);
+			char s_tmp[MAX_LENGTH_OF_LONG + 1];
+			int l_tmp = zend_sprintf(s_tmp, "%ld", lval);  /* SAFE */
+			TRACE_APPEND_STRL(s_tmp, l_tmp);
+			TRACE_APPEND_STR(", ");
+			break;
+		}
+		case IS_DOUBLE: {
+			double dval = Z_DVAL_PP(arg);
+			char *s_tmp;
+			int l_tmp;
+
+			s_tmp = emalloc(MAX_LENGTH_OF_DOUBLE + EG(precision) + 1);
+			l_tmp = zend_sprintf(s_tmp, "%.*G", (int) EG(precision), dval);  /* SAFE */
+			TRACE_APPEND_STRL(s_tmp, l_tmp);
+			/* %G already handles removing trailing zeros from the fractional part, yay */
+			efree(s_tmp);
+			TRACE_APPEND_STR(", ");
+			break;
+		}
+		case IS_ARRAY:
+			TRACE_APPEND_STR("Array, ");
+			break;
+		case IS_OBJECT: {
+			zval tmp;
+			zstr class_name;
+			zend_uint class_name_len;
+			int dup;
+
+			TRACE_APPEND_STR("Object(");
+
+			dup = zend_get_object_classname(*arg, &class_name, &class_name_len TSRMLS_CC);
+
+			ZVAL_UNICODEL(&tmp, class_name.u, class_name_len, 1);
+			convert_to_string_with_converter(&tmp, ZEND_U_CONVERTER(UG(output_encoding_conv)));
+			TRACE_APPEND_STRL(Z_STRVAL(tmp), Z_STRLEN(tmp));
+			zval_dtor(&tmp);
+
+			if(!dup) {
+				efree(class_name.v);
+			}
+
+			TRACE_APPEND_STR("), ");
+			break;
+		}
+		default:
+			break;
+	}
+	return ZEND_HASH_APPLY_KEEP;
+}
+/* }}} */
+
+
+static int mysqlnd_build_trace_string(zval **frame TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
+{
+	char *s_tmp, **str;
+	int *len, *num;
+	long line;
+	HashTable *ht = Z_ARRVAL_PP(frame);
+	zval **file, **tmp;
+	uint * level;
+
+	level = va_arg(args, uint *);
+	str = va_arg(args, char**);
+	len = va_arg(args, int*);
+	num = va_arg(args, int*);
+
+	if (!*level) {
+		return ZEND_HASH_APPLY_KEEP;
+	}
+	--*level;
+
+	s_tmp = emalloc(1 + MAX_LENGTH_OF_LONG + 1 + 1);
+	sprintf(s_tmp, "#%d ", (*num)++);
+	TRACE_APPEND_STRL(s_tmp, strlen(s_tmp));
+	efree(s_tmp);
+	if (zend_ascii_hash_find(ht, "file", sizeof("file"), (void**)&file) == SUCCESS) {
+		if (zend_ascii_hash_find(ht, "line", sizeof("line"), (void**)&tmp) == SUCCESS) {
+			line = Z_LVAL_PP(tmp);
+		} else {
+			line = 0;
+		}
+		TRACE_APPEND_ZVAL(*file);
+		s_tmp = emalloc(MAX_LENGTH_OF_LONG + 2 + 1);
+		sprintf(s_tmp, "(%ld): ", line);
+		TRACE_APPEND_STRL(s_tmp, strlen(s_tmp));
+		efree(s_tmp);
+	} else {
+		TRACE_APPEND_STR("[internal function]: ");
+	}
+	TRACE_APPEND_KEY("class");
+	TRACE_APPEND_KEY("type");
+	TRACE_APPEND_KEY("function");
+	TRACE_APPEND_CHR('(');
+	if (zend_ascii_hash_find(ht, "args", sizeof("args"), (void**)&tmp) == SUCCESS) {
+		int last_len = *len;
+		zend_hash_apply_with_arguments(Z_ARRVAL_PP(tmp) TSRMLS_CC, (apply_func_args_t)mysqlnd_build_trace_args, 2, str, len);
+		if (last_len != *len) {
+			*len -= 2; /* remove last ', ' */
+		}
+	}
+	TRACE_APPEND_STR(")\n");
+	return ZEND_HASH_APPLY_KEEP;
+}
+/* }}} */
+
+
+#else /* PHP 5*/
+
+
+/* {{{ gettraceasstring() macros */
+#define TRACE_APPEND_CHR(chr)                                            \
+	*str = (char*)erealloc(*str, *len + 1 + 1);                          \
+	(*str)[(*len)++] = chr
+
+#define TRACE_APPEND_STRL(val, vallen)                                   \
+	{                                                                    \
+		int l = vallen;                                                  \
+		*str = (char*)erealloc(*str, *len + l + 1);                      \
+		memcpy((*str) + *len, val, l);                                   \
+		*len += l;                                                       \
+	}
+
+#define TRACE_APPEND_STR(val)                                            \
+	TRACE_APPEND_STRL(val, sizeof(val)-1)
+
+#define TRACE_APPEND_KEY(key)                                            \
+	if (zend_hash_find(ht, key, sizeof(key), (void**)&tmp) == SUCCESS) { \
+	    TRACE_APPEND_STRL(Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));           \
+	}
+
+/* }}} */
+
+
+static int mysqlnd_build_trace_args(zval **arg TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
+{
+	char **str;
+	int *len;
+
+	str = va_arg(args, char**);
+	len = va_arg(args, int*);
+
+	/* the trivial way would be to do:
+	 * conver_to_string_ex(arg);
+	 * append it and kill the now tmp arg.
+	 * but that could cause some E_NOTICE and also damn long lines.
+	 */
+
+	switch (Z_TYPE_PP(arg)) {
+		case IS_NULL:
+			TRACE_APPEND_STR("NULL, ");
+			break;
+		case IS_STRING: {
+			int l_added;
+			TRACE_APPEND_CHR('\'');
+			if (Z_STRLEN_PP(arg) > 15) {
+				TRACE_APPEND_STRL(Z_STRVAL_PP(arg), 15);
+				TRACE_APPEND_STR("...', ");
+				l_added = 15 + 6 + 1; /* +1 because of while (--l_added) */
+			} else {
+				l_added = Z_STRLEN_PP(arg);
+				TRACE_APPEND_STRL(Z_STRVAL_PP(arg), l_added);
+				TRACE_APPEND_STR("', ");
+				l_added += 3 + 1;
+			}
+			while (--l_added) {
+				if ((*str)[*len - l_added] < 32) {
+					(*str)[*len - l_added] = '?';
+				}
+			}
+			break;
+		}
+		case IS_BOOL:
+			if (Z_LVAL_PP(arg)) {
+				TRACE_APPEND_STR("true, ");
+			} else {
+				TRACE_APPEND_STR("false, ");
+			}
+			break;
+		case IS_RESOURCE:
+			TRACE_APPEND_STR("Resource id #");
+			/* break; */
+		case IS_LONG: {
+			long lval = Z_LVAL_PP(arg);
+			char s_tmp[MAX_LENGTH_OF_LONG + 1];
+			int l_tmp = zend_sprintf(s_tmp, "%ld", lval);  /* SAFE */
+			TRACE_APPEND_STRL(s_tmp, l_tmp);
+			TRACE_APPEND_STR(", ");
+			break;
+		}
+		case IS_DOUBLE: {
+			double dval = Z_DVAL_PP(arg);
+			char *s_tmp;
+			int l_tmp;
+
+			s_tmp = emalloc(MAX_LENGTH_OF_DOUBLE + EG(precision) + 1);
+			l_tmp = zend_sprintf(s_tmp, "%.*G", (int) EG(precision), dval);  /* SAFE */
+			TRACE_APPEND_STRL(s_tmp, l_tmp);
+			/* %G already handles removing trailing zeros from the fractional part, yay */
+			efree(s_tmp);
+			TRACE_APPEND_STR(", ");
+			break;
+		}
+		case IS_ARRAY:
+			TRACE_APPEND_STR("Array, ");
+			break;
+		case IS_OBJECT: {
+			char *class_name;
+			zend_uint class_name_len;
+			int dupl;
+
+			TRACE_APPEND_STR("Object(");
+
+			dupl = zend_get_object_classname(*arg, &class_name, &class_name_len TSRMLS_CC);
+
+			TRACE_APPEND_STRL(class_name, class_name_len);
+			if (!dupl) {
+				efree(class_name);
+			}
+
+			TRACE_APPEND_STR("), ");
+			break;
+		}
+		default:
+			break;
+	}
+	return ZEND_HASH_APPLY_KEEP;
+}
+/* }}} */
+
+static int mysqlnd_build_trace_string(zval **frame TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
+{
+	char *s_tmp, **str;
+	int *len, *num;
+	long line;
+	HashTable *ht = Z_ARRVAL_PP(frame);
+	zval **file, **tmp;
+	uint * level;
+
+	level = va_arg(args, uint *);
+	str = va_arg(args, char**);
+	len = va_arg(args, int*);
+	num = va_arg(args, int*);
+
+	if (!*level) {
+		return ZEND_HASH_APPLY_KEEP;
+	}
+	--*level;
+
+	s_tmp = emalloc(1 + MAX_LENGTH_OF_LONG + 1 + 1);
+	sprintf(s_tmp, "#%d ", (*num)++);
+	TRACE_APPEND_STRL(s_tmp, strlen(s_tmp));
+	efree(s_tmp);
+	if (zend_hash_find(ht, "file", sizeof("file"), (void**)&file) == SUCCESS) {
+		if (zend_hash_find(ht, "line", sizeof("line"), (void**)&tmp) == SUCCESS) {
+			line = Z_LVAL_PP(tmp);
+		} else {
+			line = 0;
+		}
+		s_tmp = emalloc(Z_STRLEN_PP(file) + MAX_LENGTH_OF_LONG + 4 + 1);
+		sprintf(s_tmp, "%s(%ld): ", Z_STRVAL_PP(file), line);
+		TRACE_APPEND_STRL(s_tmp, strlen(s_tmp));
+		efree(s_tmp);
+	} else {
+		TRACE_APPEND_STR("[internal function]: ");
+	}
+	TRACE_APPEND_KEY("class");
+	TRACE_APPEND_KEY("type");
+	TRACE_APPEND_KEY("function");
+	TRACE_APPEND_CHR('(');
+	if (zend_hash_find(ht, "args", sizeof("args"), (void**)&tmp) == SUCCESS) {
+		int last_len = *len;
+		zend_hash_apply_with_arguments(Z_ARRVAL_PP(tmp) TSRMLS_CC, (apply_func_args_t)mysqlnd_build_trace_args, 2, str, len);
+		if (last_len != *len) {
+			*len -= 2; /* remove last ', ' */
+		}
+	}
+	TRACE_APPEND_STR(")\n");
+	return ZEND_HASH_APPLY_KEEP;
+}
+/* }}} */
+#endif
+
+
+PHPAPI char * mysqlnd_get_backtrace(uint max_levels, size_t * length TSRMLS_DC)
+{
+	zval *trace;
+	char *res = estrdup(""), **str = &res, *s_tmp;
+	int res_len = 0, *len = &res_len, num = 0;
+	if (max_levels == 0) {
+		max_levels = 99999;
+	}
+
+	MAKE_STD_ZVAL(trace);
+	zend_fetch_debug_backtrace(trace, 0, 0 TSRMLS_CC);
+
+	zend_hash_apply_with_arguments(Z_ARRVAL_P(trace) TSRMLS_CC, (apply_func_args_t)mysqlnd_build_trace_string, 4, &max_levels, str, len, &num);
+	zval_ptr_dtor(&trace);
+
+	if (max_levels) {
+		s_tmp = emalloc(1 + MAX_LENGTH_OF_LONG + 7 + 1);
+		sprintf(s_tmp, "#%d {main}", num);
+		TRACE_APPEND_STRL(s_tmp, strlen(s_tmp));
+		efree(s_tmp);
+	}
+
+	res[res_len] = '\0';
+	*length = res_len;
+
+	return res;
+}
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_debug.h
@@ -0,0 +1,240 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_DEBUG_H
+#define MYSQLND_DEBUG_H
+
+#include "zend_stack.h"
+
+struct st_mysqlnd_debug_methods
+{
+	enum_func_status (*open)(MYSQLND_DEBUG * self, zend_bool reopen);
+	void			 (*set_mode)(MYSQLND_DEBUG * self, const char * const mode);
+	enum_func_status (*log)(MYSQLND_DEBUG * self, unsigned int line, const char * const file,
+							unsigned int level, const char * type, const char *message);
+	enum_func_status (*log_va)(MYSQLND_DEBUG * self, unsigned int line, const char * const file,
+							   unsigned int level, const char * type, const char *format, ...);
+	zend_bool (*func_enter)(MYSQLND_DEBUG * self, unsigned int line, const char * const file,
+							const char * const func_name, unsigned int func_name_len);
+	enum_func_status (*func_leave)(MYSQLND_DEBUG * self, unsigned int line, const char * const file, uint64_t call_time);
+	enum_func_status (*close)(MYSQLND_DEBUG * self);
+	enum_func_status (*free_handle)(MYSQLND_DEBUG * self);
+};
+
+
+struct st_mysqlnd_debug
+{
+	php_stream	*stream;
+#ifdef ZTS
+	TSRMLS_D;
+#endif
+	unsigned int flags;
+	unsigned int nest_level_limit;
+	int pid;
+	char * file_name;
+	zend_stack call_stack;
+	zend_stack call_time_stack;	
+	HashTable not_filtered_functions;
+	HashTable function_profiles;
+	struct st_mysqlnd_debug_methods *m;
+	const char ** skip_functions;
+};
+
+PHPAPI extern const char * mysqlnd_debug_std_no_trace_funcs[];
+
+PHPAPI MYSQLND_DEBUG * mysqlnd_debug_init(const char * skip_functions[] TSRMLS_DC);
+
+PHPAPI char *	mysqlnd_get_backtrace(uint max_levels, size_t * length TSRMLS_DC);
+
+#if defined(__GNUC__) || (defined(_MSC_VER) && (_MSC_VER >= 1400))
+#ifdef PHP_WIN32
+#include "win32/time.h"
+#elif defined(NETWARE)
+#include <sys/timeval.h>
+#include <sys/time.h>
+#else
+#include <sys/time.h>
+#endif
+
+#ifndef MYSQLND_PROFILING_DISABLED
+#define DBG_PROFILE_TIMEVAL_TO_DOUBLE(tp)	((tp.tv_sec * 1000000LL)+ tp.tv_usec)
+#define DBG_PROFILE_START_TIME()		gettimeofday(&__dbg_prof_tp, NULL); __dbg_prof_start = DBG_PROFILE_TIMEVAL_TO_DOUBLE(__dbg_prof_tp);
+#define DBG_PROFILE_END_TIME(duration)	gettimeofday(&__dbg_prof_tp, NULL); (duration) = (DBG_PROFILE_TIMEVAL_TO_DOUBLE(__dbg_prof_tp) - __dbg_prof_start);
+#else
+#define DBG_PROFILE_TIMEVAL_TO_DOUBLE(tp)
+#define DBG_PROFILE_START_TIME()
+#define DBG_PROFILE_END_TIME(duration)
+#endif
+
+#define DBG_INF_EX(dbg_obj, msg)		do { if (dbg_skip_trace == FALSE) (dbg_obj)->m->log((dbg_obj), __LINE__, __FILE__, -1, "info : ", (msg)); } while (0)
+#define DBG_ERR_EX(dbg_obj, msg)		do { if (dbg_skip_trace == FALSE) (dbg_obj)->m->log((dbg_obj), __LINE__, __FILE__, -1, "error: ", (msg)); } while (0)
+#define DBG_INF_FMT_EX(dbg_obj, ...)	do { if (dbg_skip_trace == FALSE) (dbg_obj)->m->log_va((dbg_obj), __LINE__, __FILE__, -1, "info : ", __VA_ARGS__); } while (0)
+#define DBG_ERR_FMT_EX(dbg_obj, ...)	do { if (dbg_skip_trace == FALSE) (dbg_obj)->m->log_va((dbg_obj), __LINE__, __FILE__, -1, "error: ", __VA_ARGS__); } while (0)
+
+#define DBG_BLOCK_ENTER_EX(dbg_obj, block_name) \
+		{ \
+			DBG_ENTER_EX(dbg_obj, (block_name));
+
+#define DBG_BLOCK_LEAVE_EX(dbg_obj) \
+			DBG_LEAVE_EX((dbg_obj), ;) \
+		} \
+	
+
+#define DBG_ENTER_EX(dbg_obj, func_name) \
+					struct timeval __dbg_prof_tp = {0}; \
+					uint64_t __dbg_prof_start = 0; /* initialization is needed */ \
+					zend_bool dbg_skip_trace = TRUE; \
+					if ((dbg_obj)) { \
+						dbg_skip_trace = !(dbg_obj)->m->func_enter((dbg_obj), __LINE__, __FILE__, func_name, strlen(func_name)); \
+					} \
+					do { \
+						if ((dbg_obj) && (dbg_obj)->flags & MYSQLND_DEBUG_PROFILE_CALLS) { \
+							DBG_PROFILE_START_TIME(); \
+						} \
+					} while (0); 
+
+#define DBG_LEAVE_EX(dbg_obj, leave)	\
+			do {\
+				if ((dbg_obj)) { \
+					uint64_t this_call_duration = 0; \
+					if ((dbg_obj)->flags & MYSQLND_DEBUG_PROFILE_CALLS) { \
+						DBG_PROFILE_END_TIME(this_call_duration); \
+					} \
+					(dbg_obj)->m->func_leave((dbg_obj), __LINE__, __FILE__, this_call_duration); \
+				} \
+				leave \
+			} while (0);
+
+#define DBG_RETURN_EX(dbg_obj, value) DBG_LEAVE_EX(dbg_obj, return (value);)
+
+#define DBG_VOID_RETURN_EX(dbg_obj) DBG_LEAVE_EX(dbg_obj, return;)
+
+
+
+#else
+static inline void DBG_INF_EX(MYSQLND_DEBUG * dbg_obj, const char * const msg) {}
+static inline void DBG_ERR_EX(MYSQLND_DEBUG * dbg_obj, const char * const msg) {}
+static inline void DBG_INF_FMT_EX(MYSQLND_DEBUG * dbg_obj, ...) {}
+static inline void DBG_ERR_FMT_EX(MYSQLND_DEBUG * dbg_obj, ...) {}
+static inline void DBG_ENTER_EX(MYSQLND_DEBUG * dbg_obj, const char * const func_name) {}
+#define DBG_BLOCK_ENTER(bname)			{
+#define DBG_RETURN_EX(dbg_obj, value)	return (value)
+#define DBG_VOID_RETURN_EX(dbg_obj)		return
+#define DBG_BLOCK_LEAVE_EX(dbg_obj)		}
+
+#endif /* defined(__GNUC__) || (defined(_MSC_VER) && (_MSC_VER >= 1400)) */
+
+#if MYSQLND_DBG_ENABLED == 1
+
+#define DBG_INF(msg)		DBG_INF_EX(MYSQLND_G(dbg), (msg))
+#define DBG_ERR(msg)		DBG_ERR_EX(MYSQLND_G(dbg), (msg))
+#define DBG_INF_FMT(...)	DBG_INF_FMT_EX(MYSQLND_G(dbg), __VA_ARGS__)
+#define DBG_ERR_FMT(...)	DBG_ERR_FMT_EX(MYSQLND_G(dbg), __VA_ARGS__)
+
+#define DBG_ENTER(func_name)	DBG_ENTER_EX(MYSQLND_G(dbg), (func_name))
+#define DBG_BLOCK_ENTER(bname)	DBG_BLOCK_ENTER_EX(MYSQLND_G(dbg), (bname))
+#define DBG_RETURN(value)		DBG_RETURN_EX(MYSQLND_G(dbg), (value))
+#define DBG_VOID_RETURN			DBG_VOID_RETURN_EX(MYSQLND_G(dbg))
+#define DBG_BLOCK_LEAVE			DBG_BLOCK_LEAVE_EX(MYSQLND_G(dbg))
+
+#elif MYSQLND_DBG_ENABLED == 0
+
+
+
+static inline void DBG_INF(const char * const msg) {}
+static inline void DBG_ERR(const char * const msg) {}
+static inline void DBG_INF_FMT(const char * const format, ...) {}
+static inline void DBG_ERR_FMT(const char * const format, ...) {}
+static inline void DBG_ENTER(const char * const func_name) {}
+#define DBG_BLOCK_ENTER(bname)	{
+#define DBG_RETURN(value)		return (value)
+#define DBG_VOID_RETURN			return
+#define DBG_BLOCK_LEAVE			}
+
+#endif
+
+
+#define MYSQLND_MEM_D	TSRMLS_DC ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC
+#define MYSQLND_MEM_C	TSRMLS_CC ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC
+
+struct st_mysqlnd_allocator_methods
+{
+	void *	(*m_emalloc)(size_t size MYSQLND_MEM_D);
+	void *	(*m_pemalloc)(size_t size, zend_bool persistent MYSQLND_MEM_D);
+	void *	(*m_ecalloc)(unsigned int nmemb, size_t size MYSQLND_MEM_D);
+	void *	(*m_pecalloc)(unsigned int nmemb, size_t size, zend_bool persistent MYSQLND_MEM_D);
+	void *	(*m_erealloc)(void *ptr, size_t new_size MYSQLND_MEM_D);
+	void *	(*m_perealloc)(void *ptr, size_t new_size, zend_bool persistent MYSQLND_MEM_D);
+	void	(*m_efree)(void *ptr MYSQLND_MEM_D);
+	void	(*m_pefree)(void *ptr, zend_bool persistent MYSQLND_MEM_D);
+	void *	(*m_malloc)(size_t size MYSQLND_MEM_D);
+	void *	(*m_calloc)(unsigned int nmemb, size_t size MYSQLND_MEM_D);
+	void *	(*m_realloc)(void *ptr, size_t new_size MYSQLND_MEM_D);
+	void	(*m_free)(void *ptr MYSQLND_MEM_D);
+	char *	(*m_pestrndup)(const char * const ptr, size_t size, zend_bool persistent MYSQLND_MEM_D);
+	char *	(*m_pestrdup)(const char * const ptr, zend_bool persistent MYSQLND_MEM_D);
+};
+
+PHPAPI extern struct st_mysqlnd_allocator_methods mysqlnd_allocator;
+
+
+PHPAPI void *	_mysqlnd_emalloc(size_t size MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_pemalloc(size_t size, zend_bool persistent MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_ecalloc(unsigned int nmemb, size_t size MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_pecalloc(unsigned int nmemb, size_t size, zend_bool persistent MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_erealloc(void *ptr, size_t new_size MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_perealloc(void *ptr, size_t new_size, zend_bool persistent MYSQLND_MEM_D);
+PHPAPI void		_mysqlnd_efree(void *ptr MYSQLND_MEM_D);
+PHPAPI void		_mysqlnd_pefree(void *ptr, zend_bool persistent MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_malloc(size_t size MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_calloc(unsigned int nmemb, size_t size MYSQLND_MEM_D);
+PHPAPI void *	_mysqlnd_realloc(void *ptr, size_t new_size MYSQLND_MEM_D);
+PHPAPI void		_mysqlnd_free(void *ptr MYSQLND_MEM_D);
+PHPAPI char *	_mysqlnd_pestrndup(const char * const ptr, size_t size, zend_bool persistent MYSQLND_MEM_D);
+PHPAPI char *	_mysqlnd_pestrdup(const char * const ptr, zend_bool persistent MYSQLND_MEM_D);
+
+
+#define mnd_emalloc(size)				mysqlnd_allocator.m_emalloc((size) MYSQLND_MEM_C)
+#define mnd_pemalloc(size, pers)		mysqlnd_allocator.m_pemalloc((size), (pers) MYSQLND_MEM_C)
+#define mnd_ecalloc(nmemb, size)		mysqlnd_allocator.m_ecalloc((nmemb), (size) MYSQLND_MEM_C)
+#define mnd_pecalloc(nmemb, size, p)	mysqlnd_allocator.m_pecalloc((nmemb), (size), (p) MYSQLND_MEM_C)
+#define mnd_erealloc(ptr, new_size)		mysqlnd_allocator.m_erealloc((ptr), (new_size) MYSQLND_MEM_C)
+#define mnd_perealloc(ptr, new_size, p)	mysqlnd_allocator.m_perealloc((ptr), (new_size), (p) MYSQLND_MEM_C)
+#define mnd_efree(ptr)					mysqlnd_allocator.m_efree((ptr) MYSQLND_MEM_C)
+#define mnd_pefree(ptr, pers)			mysqlnd_allocator.m_pefree((ptr), (pers) MYSQLND_MEM_C)
+#define mnd_malloc(size)				mysqlnd_allocator.m_malloc((size) MYSQLND_MEM_C)
+#define mnd_calloc(nmemb, size)			mysqlnd_allocator.m_calloc((nmemb), (size) MYSQLND_MEM_C)
+#define mnd_realloc(ptr, new_size)		mysqlnd_allocator.m_realloc((ptr), (new_size) MYSQLND_MEM_C)
+#define mnd_free(ptr)					mysqlnd_allocator.m_free((ptr) MYSQLND_MEM_C)
+#define mnd_pestrndup(ptr, size, pers)	mysqlnd_allocator.m_pestrndup((ptr), (size), (pers) MYSQLND_MEM_C)
+#define mnd_pestrdup(ptr, pers)			mysqlnd_allocator.m_pestrdup((ptr), (pers) MYSQLND_MEM_C)
+
+#endif /* MYSQLND_DEBUG_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_enum_n_def.h
@@ -0,0 +1,591 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#ifndef MYSQLND_ENUM_N_DEF_H
+#define MYSQLND_ENUM_N_DEF_H
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+
+#define MYSQLND_MIN_COMPRESS_LEN 0
+
+#define MYSQLND_MAX_PACKET_SIZE (256L*256L*256L-1)
+
+#define MYSQLND_ERRMSG_SIZE			512
+#define MYSQLND_SQLSTATE_LENGTH		5
+#define MYSQLND_SQLSTATE_NULL		"00000"
+
+#define MYSQLND_MAX_ALLOWED_USER_LEN	252		/* 63 char * 4byte . MySQL supports now only 16 char, but let it be forward compatible */
+#define MYSQLND_MAX_ALLOWED_DB_LEN		1024	/* 256 char * 4byte. MySQL supports now only 64 char in the tables, but on the FS could be different. Forward compatible. */
+
+#define MYSQLND_NET_CMD_BUFFER_MIN_SIZE			4096
+#define MYSQLND_NET_CMD_BUFFER_MIN_SIZE_STR		"4096"
+
+#define SERVER_STATUS_IN_TRANS					1	/* Transaction has started */
+#define SERVER_STATUS_AUTOCOMMIT				2	/* Server in auto_commit mode */
+#define SERVER_MORE_RESULTS_EXISTS				8	/* Multi query - next query exists */
+#define SERVER_QUERY_NO_GOOD_INDEX_USED	16
+#define SERVER_QUERY_NO_INDEX_USED		32
+/*
+  The server was able to fulfill the clients request and opened a
+  read-only non-scrollable cursor for a query. This flag comes
+  in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands.
+*/
+#define SERVER_STATUS_CURSOR_EXISTS				64
+/*
+  This flag is sent when a read-only cursor is exhausted, in reply to
+  COM_STMT_FETCH command.
+*/
+#define SERVER_STATUS_LAST_ROW_SENT				128
+#define SERVER_STATUS_DB_DROPPED				256 /* A database was dropped */
+#define SERVER_STATUS_NO_BACKSLASH_ESCAPES		512
+#define SERVER_QUERY_WAS_SLOW					2048
+#define SERVER_PS_OUT_PARAMS            		4096
+
+#define MYSQLND_NO_DATA			100
+#define MYSQLND_DATA_TRUNCATED	101
+
+#define SHA1_MAX_LENGTH 20
+#define SCRAMBLE_LENGTH 20
+#define SCRAMBLE_LENGTH_323 8
+
+#define CLIENT_LONG_PASSWORD		1		/* new more secure passwords */
+#define CLIENT_FOUND_ROWS			2		/* Found instead of affected rows */
+#define CLIENT_LONG_FLAG			4		/* Get all column flags */
+#define CLIENT_CONNECT_WITH_DB		8		/* One can specify db on connect */
+#define CLIENT_NO_SCHEMA			16		/* Don't allow database.table.column */
+#define CLIENT_COMPRESS				32		/* Can use compression protocol */
+#define CLIENT_ODBC					64		/* Odbc client */
+#define CLIENT_LOCAL_FILES			128		/* Can use LOAD DATA LOCAL */
+#define CLIENT_IGNORE_SPACE			256		/* Ignore spaces before '(' */
+#define CLIENT_PROTOCOL_41			512		/* New 4.1 protocol */
+#define CLIENT_INTERACTIVE			1024	/* This is an interactive client */
+#define CLIENT_SSL					2048	/* Switch to SSL after handshake */
+#define CLIENT_IGNORE_SIGPIPE		4096	/* IGNORE sigpipes */
+#define CLIENT_TRANSACTIONS			8192	/* Client knows about transactions */
+#define CLIENT_RESERVED				16384	/* Old flag for 4.1 protocol */
+#define CLIENT_SECURE_CONNECTION	32768	/* New 4.1 authentication */
+#define CLIENT_MULTI_STATEMENTS		(1UL << 16) /* Enable/disable multi-stmt support */
+#define CLIENT_MULTI_RESULTS		(1UL << 17) /* Enable/disable multi-results */
+#define CLIENT_PS_MULTI_RESULTS		(1UL << 18) /* Multi-results in PS-protocol */
+#define CLIENT_PLUGIN_AUTH			(1UL << 19) /* Client supports plugin authentication */
+
+#define CLIENT_SSL_VERIFY_SERVER_CERT (1UL << 30)
+
+
+#define MYSQLND_NET_FLAG_USE_COMPRESSION 1
+
+typedef enum mysqlnd_extension
+{
+	MYSQLND_MYSQL = 0,
+	MYSQLND_MYSQLI
+} enum_mysqlnd_extension;
+
+enum
+{
+	MYSQLND_FETCH_ASSOC = 1,
+	MYSQLND_FETCH_NUM = 2,
+	MYSQLND_FETCH_BOTH = 1|2
+};
+
+/* Follow libmysql convention */
+typedef enum func_status
+{
+	PASS = 0,
+	FAIL = 1
+} enum_func_status;
+
+typedef enum mysqlnd_query_type
+{
+	QUERY_UPSERT,
+	QUERY_SELECT,
+	QUERY_LOAD_LOCAL
+} enum_mysqlnd_query_type;
+
+typedef enum mysqlnd_res_type
+{
+	MYSQLND_RES_NORMAL = 1,
+	MYSQLND_RES_PS_BUF,
+	MYSQLND_RES_PS_UNBUF
+} enum_mysqlnd_res_type;
+
+typedef enum mysqlnd_option
+{
+	MYSQL_OPT_CONNECT_TIMEOUT,
+	MYSQL_OPT_COMPRESS,
+	MYSQL_OPT_NAMED_PIPE,
+	MYSQL_INIT_COMMAND,
+	MYSQL_READ_DEFAULT_FILE,
+	MYSQL_READ_DEFAULT_GROUP,
+	MYSQL_SET_CHARSET_DIR,
+	MYSQL_SET_CHARSET_NAME,
+	MYSQL_OPT_LOCAL_INFILE,
+	MYSQL_OPT_PROTOCOL,
+	MYSQL_SHARED_MEMORY_BASE_NAME,
+	MYSQL_OPT_READ_TIMEOUT,
+	MYSQL_OPT_WRITE_TIMEOUT,
+	MYSQL_OPT_USE_RESULT,
+	MYSQL_OPT_USE_REMOTE_CONNECTION,
+	MYSQL_OPT_USE_EMBEDDED_CONNECTION,
+	MYSQL_OPT_GUESS_CONNECTION,
+	MYSQL_SET_CLIENT_IP,
+	MYSQL_SECURE_AUTH,
+	MYSQL_REPORT_DATA_TRUNCATION,
+	MYSQL_OPT_RECONNECT,
+	MYSQL_OPT_SSL_VERIFY_SERVER_CERT,
+	MYSQL_PLUGIN_DIR,
+	MYSQL_DEFAULT_AUTH,
+#if MYSQLND_UNICODE
+	MYSQLND_OPT_NUMERIC_AND_DATETIME_AS_UNICODE = 200,
+#endif
+#ifdef MYSQLND_STRING_TO_INT_CONVERSION
+	MYSQLND_OPT_INT_AND_FLOAT_NATIVE = 201,
+#endif
+	MYSQLND_OPT_NET_CMD_BUFFER_SIZE = 202,
+	MYSQLND_OPT_NET_READ_BUFFER_SIZE = 203,
+	MYSQLND_OPT_SSL_KEY = 204,
+	MYSQLND_OPT_SSL_CERT = 205,
+	MYSQLND_OPT_SSL_CA = 206,
+	MYSQLND_OPT_SSL_CAPATH = 207,
+	MYSQLND_OPT_SSL_CIPHER = 208,
+	MYSQLND_OPT_SSL_PASSPHRASE = 209
+} enum_mysqlnd_option;
+
+typedef enum mysqlnd_protocol_type
+{
+	MYSQL_PROTOCOL_DEFAULT = 0,
+	MYSQL_PROTOCOL_TCP,		/* all, supported */
+	MYSQL_PROTOCOL_SOCKET,	/* unix, supported */
+	MYSQL_PROTOCOL_PIPE,	/* win32, not-supported */
+	MYSQL_PROTOCOL_MEMORY,	/* win32, not-supported */
+	MYSQL_PROTOCOL_LAST
+} enum_mysqlnd_protocol_type;
+
+typedef enum mysqlnd_field_types
+{
+	MYSQL_TYPE_DECIMAL,
+	MYSQL_TYPE_TINY,
+	MYSQL_TYPE_SHORT,
+	MYSQL_TYPE_LONG,
+	MYSQL_TYPE_FLOAT,
+	MYSQL_TYPE_DOUBLE,
+	MYSQL_TYPE_NULL,
+	MYSQL_TYPE_TIMESTAMP,
+	MYSQL_TYPE_LONGLONG,
+	MYSQL_TYPE_INT24,
+	MYSQL_TYPE_DATE,
+	MYSQL_TYPE_TIME,
+	MYSQL_TYPE_DATETIME,
+	MYSQL_TYPE_YEAR,
+	MYSQL_TYPE_NEWDATE,
+	MYSQL_TYPE_VARCHAR,
+	MYSQL_TYPE_BIT,
+	MYSQL_TYPE_NEWDECIMAL=246,
+	MYSQL_TYPE_ENUM=247,
+	MYSQL_TYPE_SET=248,
+	MYSQL_TYPE_TINY_BLOB=249,
+	MYSQL_TYPE_MEDIUM_BLOB=250,
+	MYSQL_TYPE_LONG_BLOB=251,
+	MYSQL_TYPE_BLOB=252,
+	MYSQL_TYPE_VAR_STRING=253,
+	MYSQL_TYPE_STRING=254,
+	MYSQL_TYPE_GEOMETRY=255
+} enum_mysqlnd_field_types;
+
+/* Please update this if there is a new type after MYSQL_TYPE_GEOMETRY */
+#define MYSQL_TYPE_LAST		MYSQL_TYPE_GEOMETRY
+
+
+typedef enum mysqlnd_server_option
+{
+	MYSQL_OPTION_MULTI_STATEMENTS_ON,
+	MYSQL_OPTION_MULTI_STATEMENTS_OFF
+} enum_mysqlnd_server_option;
+
+
+#define FIELD_TYPE_DECIMAL		MYSQL_TYPE_DECIMAL
+#define FIELD_TYPE_NEWDECIMAL	MYSQL_TYPE_NEWDECIMAL
+#define FIELD_TYPE_TINY			MYSQL_TYPE_TINY
+#define FIELD_TYPE_SHORT		MYSQL_TYPE_SHORT
+#define FIELD_TYPE_LONG			MYSQL_TYPE_LONG
+#define FIELD_TYPE_FLOAT		MYSQL_TYPE_FLOAT
+#define FIELD_TYPE_DOUBLE		MYSQL_TYPE_DOUBLE
+#define FIELD_TYPE_NULL			MYSQL_TYPE_NULL
+#define FIELD_TYPE_TIMESTAMP	MYSQL_TYPE_TIMESTAMP
+#define FIELD_TYPE_LONGLONG		MYSQL_TYPE_LONGLONG
+#define FIELD_TYPE_INT24		MYSQL_TYPE_INT24
+#define FIELD_TYPE_DATE			MYSQL_TYPE_DATE
+#define FIELD_TYPE_TIME			MYSQL_TYPE_TIME
+#define FIELD_TYPE_DATETIME		MYSQL_TYPE_DATETIME
+#define FIELD_TYPE_YEAR			MYSQL_TYPE_YEAR
+#define FIELD_TYPE_NEWDATE		MYSQL_TYPE_NEWDATE
+#define FIELD_TYPE_ENUM			MYSQL_TYPE_ENUM
+#define FIELD_TYPE_SET			MYSQL_TYPE_SET
+#define FIELD_TYPE_TINY_BLOB	MYSQL_TYPE_TINY_BLOB
+#define FIELD_TYPE_MEDIUM_BLOB	MYSQL_TYPE_MEDIUM_BLOB
+#define FIELD_TYPE_LONG_BLOB	MYSQL_TYPE_LONG_BLOB
+#define FIELD_TYPE_BLOB			MYSQL_TYPE_BLOB
+#define FIELD_TYPE_VAR_STRING	MYSQL_TYPE_VAR_STRING
+#define FIELD_TYPE_STRING		MYSQL_TYPE_STRING
+#define FIELD_TYPE_CHAR			MYSQL_TYPE_TINY
+#define FIELD_TYPE_INTERVAL		MYSQL_TYPE_ENUM
+#define FIELD_TYPE_GEOMETRY		MYSQL_TYPE_GEOMETRY
+#define FIELD_TYPE_BIT			MYSQL_TYPE_BIT
+
+#define NOT_NULL_FLAG			    1
+#define PRI_KEY_FLAG			    2
+#define UNIQUE_KEY_FLAG			    4
+#define MULTIPLE_KEY_FLAG		    8
+#define BLOB_FLAG				   16
+#define UNSIGNED_FLAG			   32
+#define ZEROFILL_FLAG			   64
+#define BINARY_FLAG				  128
+#define ENUM_FLAG				  256
+#define AUTO_INCREMENT_FLAG		  512
+#define TIMESTAMP_FLAG			 1024
+#define SET_FLAG				 2048
+#define NO_DEFAULT_VALUE_FLAG	 4096
+#define ON_UPDATE_NOW_FLAG		 8192
+#define PART_KEY_FLAG			16384
+#define GROUP_FLAG				32768
+#define NUM_FLAG				32768
+
+#define IS_PRI_KEY(n)	((n) & PRI_KEY_FLAG)
+#define IS_NOT_NULL(n)	((n) & NOT_NULL_FLAG)
+#define IS_BLOB(n)		((n) & BLOB_FLAG)
+#define IS_NUM(t)		((t) <= FIELD_TYPE_INT24 || (t) == FIELD_TYPE_YEAR || (t) == FIELD_TYPE_NEWDECIMAL)
+
+
+/* see mysqlnd_charset.c for more information */
+#define MYSQLND_BINARY_CHARSET_NR	63
+
+
+/*
+		/-----> CONN_CLOSE  <---------------\
+		|           ^                         \
+		|           |                         \
+	CONN_READY -> CONN_QUERY_SENT -> CONN_FETCHING_DATA
+		^                                      |
+		\-------------------------------------/
+*/
+typedef enum mysqlnd_connection_state
+{
+	CONN_ALLOCED = 0,
+	CONN_READY,
+	CONN_QUERY_SENT,
+	CONN_SENDING_LOAD_DATA,
+	CONN_FETCHING_DATA,
+	CONN_NEXT_RESULT_PENDING,
+	CONN_QUIT_SENT /* object is "destroyed" at this stage */
+} enum_mysqlnd_connection_state;
+
+
+typedef enum mysqlnd_stmt_state
+{
+	MYSQLND_STMT_INITTED = 0,
+	MYSQLND_STMT_PREPARED,
+	MYSQLND_STMT_EXECUTED,
+	MYSQLND_STMT_WAITING_USE_OR_STORE,
+	MYSQLND_STMT_USE_OR_STORE_CALLED,
+	MYSQLND_STMT_USER_FETCHING /* fetch_row_buff or fetch_row_unbuf */
+} enum_mysqlnd_stmt_state;
+
+
+typedef enum param_bind_flags
+{
+	MYSQLND_PARAM_BIND_BLOB_USED = 1
+} enum_param_bind_flags;
+
+
+/* PS */
+enum mysqlnd_stmt_attr
+{
+	STMT_ATTR_UPDATE_MAX_LENGTH,
+	STMT_ATTR_CURSOR_TYPE,
+	STMT_ATTR_PREFETCH_ROWS
+};
+
+enum myslqnd_cursor_type
+{
+	CURSOR_TYPE_NO_CURSOR= 0,
+	CURSOR_TYPE_READ_ONLY= 1,
+	CURSOR_TYPE_FOR_UPDATE= 2,
+	CURSOR_TYPE_SCROLLABLE= 4
+};
+
+typedef enum mysqlnd_connection_close_type
+{
+	MYSQLND_CLOSE_EXPLICIT = 0,
+	MYSQLND_CLOSE_IMPLICIT,
+	MYSQLND_CLOSE_DISCONNECTED,
+	MYSQLND_CLOSE_LAST	/* for checking, should always be last */
+} enum_connection_close_type;
+
+
+typedef enum mysqlnd_collected_stats
+{
+	STAT_BYTES_SENT,
+	STAT_BYTES_RECEIVED,
+	STAT_PACKETS_SENT,
+	STAT_PACKETS_RECEIVED,
+	STAT_PROTOCOL_OVERHEAD_IN,
+	STAT_PROTOCOL_OVERHEAD_OUT,
+	STAT_BYTES_RECEIVED_OK,
+	STAT_BYTES_RECEIVED_EOF,
+	STAT_BYTES_RECEIVED_RSET_HEADER,
+	STAT_BYTES_RECEIVED_RSET_FIELD_META,
+	STAT_BYTES_RECEIVED_RSET_ROW,
+	STAT_BYTES_RECEIVED_PREPARE_RESPONSE,
+	STAT_BYTES_RECEIVED_CHANGE_USER,
+	STAT_PACKETS_SENT_CMD,
+	STAT_PACKETS_RECEIVED_OK,
+	STAT_PACKETS_RECEIVED_EOF,
+	STAT_PACKETS_RECEIVED_RSET_HEADER,
+	STAT_PACKETS_RECEIVED_RSET_FIELD_META,
+	STAT_PACKETS_RECEIVED_RSET_ROW,
+	STAT_PACKETS_RECEIVED_PREPARE_RESPONSE,
+	STAT_PACKETS_RECEIVED_CHANGE_USER,
+	STAT_RSET_QUERY,
+	STAT_NON_RSET_QUERY,
+	STAT_NO_INDEX_USED,
+	STAT_BAD_INDEX_USED,
+	STAT_QUERY_WAS_SLOW,
+	STAT_BUFFERED_SETS,
+	STAT_UNBUFFERED_SETS,
+	STAT_PS_BUFFERED_SETS,
+	STAT_PS_UNBUFFERED_SETS,
+	STAT_FLUSHED_NORMAL_SETS,
+	STAT_FLUSHED_PS_SETS,
+	STAT_PS_PREPARED_NEVER_EXECUTED,
+	STAT_PS_PREPARED_ONCE_USED,
+	STAT_ROWS_FETCHED_FROM_SERVER_NORMAL,
+	STAT_ROWS_FETCHED_FROM_SERVER_PS,
+	STAT_ROWS_BUFFERED_FROM_CLIENT_NORMAL,
+	STAT_ROWS_BUFFERED_FROM_CLIENT_PS,
+	STAT_ROWS_FETCHED_FROM_CLIENT_NORMAL_BUF,
+	STAT_ROWS_FETCHED_FROM_CLIENT_NORMAL_UNBUF,
+	STAT_ROWS_FETCHED_FROM_CLIENT_PS_BUF,
+	STAT_ROWS_FETCHED_FROM_CLIENT_PS_UNBUF,
+	STAT_ROWS_FETCHED_FROM_CLIENT_PS_CURSOR,
+	STAT_ROWS_AFFECTED_NORMAL,
+	STAT_ROWS_AFFECTED_PS,
+	STAT_ROWS_SKIPPED_NORMAL,
+	STAT_ROWS_SKIPPED_PS,
+	STAT_COPY_ON_WRITE_SAVED,
+	STAT_COPY_ON_WRITE_PERFORMED,
+	STAT_CMD_BUFFER_TOO_SMALL,
+	STAT_CONNECT_SUCCESS,
+	STAT_CONNECT_FAILURE,
+	STAT_CONNECT_REUSED,
+	STAT_RECONNECT,
+	STAT_PCONNECT_SUCCESS,
+	STAT_OPENED_CONNECTIONS,
+	STAT_OPENED_PERSISTENT_CONNECTIONS,
+	STAT_CLOSE_EXPLICIT,
+	STAT_CLOSE_IMPLICIT,
+	STAT_CLOSE_DISCONNECT,
+	STAT_CLOSE_IN_MIDDLE,
+	STAT_FREE_RESULT_EXPLICIT,
+	STAT_FREE_RESULT_IMPLICIT,
+	STAT_STMT_CLOSE_EXPLICIT,
+	STAT_STMT_CLOSE_IMPLICIT,
+	STAT_MEM_EMALLOC_COUNT,
+	STAT_MEM_EMALLOC_AMOUNT,
+	STAT_MEM_ECALLOC_COUNT,
+	STAT_MEM_ECALLOC_AMOUNT,
+	STAT_MEM_EREALLOC_COUNT,
+	STAT_MEM_EREALLOC_AMOUNT,
+	STAT_MEM_EFREE_COUNT,
+	STAT_MEM_EFREE_AMOUNT,
+	STAT_MEM_MALLOC_COUNT,
+	STAT_MEM_MALLOC_AMOUNT,
+	STAT_MEM_CALLOC_COUNT,
+	STAT_MEM_CALLOC_AMOUNT,
+	STAT_MEM_REALLOC_COUNT,
+	STAT_MEM_REALLOC_AMOUNT,
+	STAT_MEM_FREE_COUNT,
+	STAT_MEM_FREE_AMOUNT,
+	STAT_MEM_ESTRNDUP_COUNT,
+	STAT_MEM_STRNDUP_COUNT,
+	STAT_MEM_ESTRDUP_COUNT,
+	STAT_MEM_STRDUP_COUNT,
+	STAT_TEXT_TYPE_FETCHED_NULL,
+	STAT_TEXT_TYPE_FETCHED_BIT,
+	STAT_TEXT_TYPE_FETCHED_INT8,
+	STAT_TEXT_TYPE_FETCHED_INT16,
+	STAT_TEXT_TYPE_FETCHED_INT24,
+	STAT_TEXT_TYPE_FETCHED_INT32,
+	STAT_TEXT_TYPE_FETCHED_INT64,
+	STAT_TEXT_TYPE_FETCHED_DECIMAL,
+	STAT_TEXT_TYPE_FETCHED_FLOAT,
+	STAT_TEXT_TYPE_FETCHED_DOUBLE,
+	STAT_TEXT_TYPE_FETCHED_DATE,
+	STAT_TEXT_TYPE_FETCHED_YEAR,
+	STAT_TEXT_TYPE_FETCHED_TIME,
+	STAT_TEXT_TYPE_FETCHED_DATETIME,
+	STAT_TEXT_TYPE_FETCHED_TIMESTAMP,
+	STAT_TEXT_TYPE_FETCHED_STRING,
+	STAT_TEXT_TYPE_FETCHED_BLOB,
+	STAT_TEXT_TYPE_FETCHED_ENUM,
+	STAT_TEXT_TYPE_FETCHED_SET,
+	STAT_TEXT_TYPE_FETCHED_GEOMETRY,
+	STAT_TEXT_TYPE_FETCHED_OTHER,
+	STAT_BINARY_TYPE_FETCHED_NULL,
+	STAT_BINARY_TYPE_FETCHED_BIT,
+	STAT_BINARY_TYPE_FETCHED_INT8,
+	STAT_BINARY_TYPE_FETCHED_INT16,
+	STAT_BINARY_TYPE_FETCHED_INT24,
+	STAT_BINARY_TYPE_FETCHED_INT32,
+	STAT_BINARY_TYPE_FETCHED_INT64,
+	STAT_BINARY_TYPE_FETCHED_DECIMAL,
+	STAT_BINARY_TYPE_FETCHED_FLOAT,
+	STAT_BINARY_TYPE_FETCHED_DOUBLE,
+	STAT_BINARY_TYPE_FETCHED_DATE,
+	STAT_BINARY_TYPE_FETCHED_YEAR,
+	STAT_BINARY_TYPE_FETCHED_TIME,
+	STAT_BINARY_TYPE_FETCHED_DATETIME,
+	STAT_BINARY_TYPE_FETCHED_TIMESTAMP,
+	STAT_BINARY_TYPE_FETCHED_STRING,
+	STAT_BINARY_TYPE_FETCHED_BLOB,
+	STAT_BINARY_TYPE_FETCHED_ENUM,
+	STAT_BINARY_TYPE_FETCHED_SET,
+	STAT_BINARY_TYPE_FETCHED_GEOMETRY,
+	STAT_BINARY_TYPE_FETCHED_OTHER,
+	STAT_INIT_COMMAND_EXECUTED_COUNT,
+	STAT_INIT_COMMAND_FAILED_COUNT,
+	STAT_COM_QUIT,
+	STAT_COM_INIT_DB,
+	STAT_COM_QUERY,
+	STAT_COM_FIELD_LIST,
+	STAT_COM_CREATE_DB,
+	STAT_COM_DROP_DB,
+	STAT_COM_REFRESH,
+	STAT_COM_SHUTDOWN,
+	STAT_COM_STATISTICS,
+	STAT_COM_PROCESS_INFO,
+	STAT_COM_CONNECT,
+	STAT_COM_PROCESS_KILL,
+	STAT_COM_DEBUG,
+	STAT_COM_PING,
+	STAT_COM_TIME,
+	STAT_COM_DELAYED_INSERT,
+	STAT_COM_CHANGE_USER,
+	STAT_COM_BINLOG_DUMP,
+	STAT_COM_TABLE_DUMP,
+	STAT_COM_CONNECT_OUT,
+	STAT_COM_REGISTER_SLAVE,
+	STAT_COM_STMT_PREPARE,
+	STAT_COM_STMT_EXECUTE,
+	STAT_COM_STMT_SEND_LONG_DATA,
+	STAT_COM_STMT_CLOSE,
+	STAT_COM_STMT_RESET,
+	STAT_COM_SET_OPTION,
+	STAT_COM_STMT_FETCH,
+	STAT_COM_DAEMON,
+	STAT_BYTES_RECEIVED_PURE_DATA_TEXT,
+	STAT_BYTES_RECEIVED_PURE_DATA_PS,
+	STAT_LAST /* Should be always the last */
+} enum_mysqlnd_collected_stats;
+
+
+/* Enums */
+enum mysqlnd_packet_type
+{
+	PROT_GREET_PACKET= 0,
+	PROT_AUTH_PACKET,
+	PROT_OK_PACKET,
+	PROT_EOF_PACKET,
+	PROT_CMD_PACKET,
+	PROT_RSET_HEADER_PACKET,
+	PROT_RSET_FLD_PACKET,
+	PROT_ROW_PACKET,
+	PROT_STATS_PACKET,
+	PROT_PREPARE_RESP_PACKET,
+	PROT_CHG_USER_RESP_PACKET,
+	PROT_LAST /* should always be last */
+};
+
+
+enum php_mysqlnd_server_command
+{
+	COM_SLEEP = 0,
+	COM_QUIT,
+	COM_INIT_DB,
+	COM_QUERY,
+	COM_FIELD_LIST,
+	COM_CREATE_DB,
+	COM_DROP_DB,
+	COM_REFRESH,
+	COM_SHUTDOWN,
+	COM_STATISTICS,
+	COM_PROCESS_INFO,
+	COM_CONNECT,
+	COM_PROCESS_KILL,
+	COM_DEBUG,
+	COM_PING,
+	COM_TIME = 15,
+	COM_DELAYED_INSERT,
+	COM_CHANGE_USER,
+	COM_BINLOG_DUMP,
+	COM_TABLE_DUMP,
+	COM_CONNECT_OUT = 20,
+	COM_REGISTER_SLAVE,
+	COM_STMT_PREPARE = 22,
+	COM_STMT_EXECUTE = 23,
+	COM_STMT_SEND_LONG_DATA = 24,
+	COM_STMT_CLOSE = 25,
+	COM_STMT_RESET = 26,
+	COM_SET_OPTION = 27,
+	COM_STMT_FETCH = 28,
+	COM_DAEMON,
+	COM_END
+};
+
+
+#define MYSQLND_DEFAULT_PREFETCH_ROWS (ulong) 1
+
+#define MYSQLND_REFRESH_GRANT		1	/* Refresh grant tables */
+#define MYSQLND_REFRESH_LOG			2	/* Start on new log file */
+#define MYSQLND_REFRESH_TABLES		4	/* close all tables */
+#define MYSQLND_REFRESH_HOSTS		8	/* Flush host cache */
+#define MYSQLND_REFRESH_STATUS		16	/* Flush status variables */
+#define MYSQLND_REFRESH_THREADS		32	/* Flush thread cache */
+#define MYSQLND_REFRESH_SLAVE		64	/* Reset master info and restart slave */
+#define MYSQLND_REFRESH_MASTER		128	/* Remove all bin logs in the index */
+#define MYSQLND_REFRESH_BACKUP_LOG	0x200000L
+
+#endif	/* MYSQLND_ENUM_N_DEF_H */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_libmysql_compat.h
@@ -0,0 +1,135 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+
+*/
+
+#ifndef MYSQLND_LIBMYSQL_COMPAT_H
+#define MYSQLND_LIBMYSQL_COMPAT_H
+
+/* Global types and definitions*/
+#define MYSQL_NO_DATA			MYSQLND_NO_DATA
+#define MYSQL_DATA_TRUNCATED	MYSQLND_DATA_TRUNCATED
+#define MYSQL_STMT				MYSQLND_STMT
+#define MYSQL_FIELD				MYSQLND_FIELD
+#define MYSQL_RES				MYSQLND_RES
+#define MYSQL_ROW				MYSQLND_ROW_C
+#define MYSQL					MYSQLND
+#define my_bool					zend_bool
+#define my_ulonglong			uint64_t
+
+#define MYSQL_VERSION_ID		MYSQLND_VERSION_ID
+#define MYSQL_SERVER_VERSION	MYSQLND_VERSION
+#define MYSQL_ERRMSG_SIZE		MYSQLND_ERRMSG_SIZE
+#define SQLSTATE_LENGTH			MYSQLND_SQLSTATE_LENGTH
+
+/* functions */
+#define mysql_affected_rows(r)			mysqlnd_affected_rows((r))
+#define mysql_autocommit(r,m)			mysqlnd_autocommit((r),(m))
+#define mysql_change_user(r,a,b,c)		mysqlnd_change_user((r), (a), (b), (c), FALSE)
+#define mysql_character_set_name(c)		mysqlnd_character_set_name((c))
+#define mysql_close(r)					mysqlnd_close((r), MYSQLND_CLOSE_EXPLICIT)
+#define mysql_commit(r)					mysqlnd_commit((r))
+#define mysql_data_seek(r,o)			mysqlnd_data_seek((r),(o))
+#define mysql_debug(x)					mysqlnd_debug((x))
+#define mysql_dump_debug_info(r)		mysqlnd_dump_debug_info((r))
+#define mysql_errno(r)					mysqlnd_errno((r))
+#define mysql_error(r)					mysqlnd_error((r))
+#define mysql_escape_string(a,b,c)		mysqlnd_escape_string((a), (b), (c))
+#define mysql_fetch_field(r)			mysqlnd_fetch_field((r))
+#define mysql_fetch_field_direct(r,o)	mysqlnd_fetch_field_direct((r), (o))
+#define mysql_fetch_fields(r)			mysqlnd_fetch_fields((r))
+#define mysql_fetch_lengths(r)			mysqlnd_fetch_lengths((r))
+#define mysql_fetch_row(r)				mysqlnd_fetch_row_c((r))
+#define mysql_field_count(r)			mysqlnd_field_count((r))
+#define mysql_field_seek(r,o)			mysqlnd_field_seek((r), (o))
+#define mysql_field_tell(r)				mysqlnd_field_tell((r))
+#define mysql_init(a)					mysqlnd_init((a))
+#define mysql_insert_id(r)				mysqlnd_insert_id((r))
+#define mysql_kill(r,n)					mysqlnd_kill((r), (n))
+#define mysql_list_dbs(c, wild)			mysqlnd_list_dbs((c), (wild))
+#define mysql_list_fields(c, tab, wild)	mysqlnd_list_fields((c), (tab), (wild))
+#define mysql_list_processes(c)			mysqlnd_list_processes((c))
+#define mysql_list_tables(c, wild)		mysqlnd_list_tables((c), (wild))
+#define mysql_more_results(r)			mysqlnd_more_results((r))
+#define mysql_next_result(r)			mysqlnd_next_result((r))
+#define mysql_num_fields(r)				mysqlnd_num_fields((r))
+#define mysql_num_rows(r)				mysqlnd_num_rows((r))
+#define mysql_ping(r)					mysqlnd_ping((r))
+#define mysql_real_escape_string(r,a,b,c) mysqlnd_real_escape_string((r), (a), (b), (c))
+#define mysql_real_query(r,a,b)			mysqlnd_query((r), (a), (b))
+#define mysql_refresh(conn, options)	mysqlnd_refresh((conn), (options))
+#define mysql_rollback(r)				mysqlnd_rollback((r))
+#define mysql_select_db(r,a)			mysqlnd_select_db((r), (a) ,strlen((a)))
+#define mysql_set_server_option(r,o)	mysqlnd_set_server_option((r), (o))
+#define mysql_set_character_set(r,a)	mysqlnd_set_character_set((r), (a))
+#define mysql_sqlstate(r)				mysqlnd_sqlstate((r))
+#define mysql_ssl_set(c,key,cert,ca,capath,cipher)	mysqlnd_ssl_set((c), (key), (cert), (ca), (capath), (cipher))
+#define mysql_stmt_affected_rows(s)		mysqlnd_stmt_affected_rows((s))
+#define mysql_stmt_field_count(s)		mysqlnd_stmt_field_count((s))
+#define mysql_stmt_param_count(s)		mysqlnd_stmt_param_count((s))
+#define mysql_stmt_num_rows(s)			mysqlnd_stmt_num_rows((s))
+#define mysql_stmt_insert_id(s)			mysqlnd_stmt_insert_id((s))
+#define mysql_stmt_close(s)				mysqlnd_stmt_close((s))
+#define mysql_stmt_bind_param(s,b)		mysqlnd_stmt_bind_param((s), (b))
+#define mysql_stmt_bind_result(s,b)		mysqlnd_stmt_bind_result((s), (b))
+#define mysql_stmt_errno(s)				mysqlnd_stmt_errno((s))
+#define mysql_stmt_error(s)				mysqlnd_stmt_error((s))
+#define mysql_stmt_sqlstate(s)			mysqlnd_stmt_sqlstate((s))
+#define mysql_stmt_prepare(s,q,l)		mysqlnd_stmt_prepare((s), (q), (l))
+#define mysql_stmt_execute(s)			mysqlnd_stmt_execute((s))
+#define mysql_stmt_reset(s)				mysqlnd_stmt_reset((s))
+#define mysql_stmt_store_result(s)		mysqlnd_stmt_store_result((s))
+#define mysql_stmt_free_result(s)		mysqlnd_stmt_free_result((s))
+#define mysql_stmt_data_seek(s,r)		mysqlnd_stmt_data_seek((s), (r))
+#define mysql_stmt_send_long_data(s,p,d,l) mysqlnd_stmt_send_long_data((s), (p), (d), (l))
+#define mysql_stmt_attr_get(s,a,v)		mysqlnd_stmt_attr_get((s), (a), (v))
+#define mysql_stmt_attr_set(s,a,v)		mysqlnd_stmt_attr_set((s), (a), (v))
+#define mysql_stmt_param_metadata(s)	mysqlnd_stmt_param_metadata((s))
+#define mysql_stmt_result_metadata(s)	mysqlnd_stmt_result_metadata((s))
+#define mysql_stmt_next_result(s)		mysqlnd_stmt_next_result((s))
+#define mysql_stmt_more_results(s)		mysqlnd_stmt_more_results((s))
+#define mysql_thread_safe()				mysqlnd_thread_safe()
+#define mysql_info(r)					mysqlnd_info((r))
+#define mysql_options(r,a,b)			mysqlnd_options((r), (a), (b))
+#define mysql_stmt_init(r)				mysqlnd_stmt_init((r))
+#define mysql_free_result(r)			mysqlnd_free_result((r), FALSE)
+#define mysql_store_result(r)			mysqlnd_store_result((r))
+#define mysql_use_result(r)				mysqlnd_use_result((r))
+#define mysql_async_store_result(r)		mysqlnd_async_store_result((r))
+#define mysql_thread_id(r)				mysqlnd_thread_id((r))
+#define mysql_get_client_info()			mysqlnd_get_client_info()
+#define mysql_get_client_version()		mysqlnd_get_client_version()
+#define mysql_get_host_info(r)			mysqlnd_get_host_info((r))
+#define mysql_get_proto_info(r)			mysqlnd_get_proto_info((r))
+#define mysql_get_server_info(r)		mysqlnd_get_server_info((r))
+#define mysql_get_server_version(r)		mysqlnd_get_server_version((r))
+#define mysql_warning_count(r)			mysqlnd_warning_count((r))
+#define mysql_eof(r)					(((r)->unbuf && (r)->unbuf->eof_reached) || (r)->stored_data)
+
+#define REFRESH_GRANT		MYSQLND_REFRESH_GRANT
+#define REFRESH_LOG			MYSQLND_REFRESH_LOG
+#define REFRESH_TABLES		MYSQLND_REFRESH_TABLES
+#define REFRESH_HOSTS		MYSQLND_REFRESH_HOSTS
+#define REFRESH_STATUS		MYSQLND_REFRESH_STATUS
+#define REFRESH_THREADS		MYSQLND_REFRESH_THREADS
+#define REFRESH_SLAVE		MYSQLND_REFRESH_SLAVE
+#define REFRESH_MASTER		MYSQLND_REFRESH_MASTER
+#define REFRESH_BACKUP_LOG	MYSQLND_REFRESH_BACKUP_LOG
+
+#endif /* MYSQLND_LIBMYSQL_COMPAT_H */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_loaddata.c
@@ -0,0 +1,262 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+#include "php.h"
+#include "php_globals.h"
+#include "mysqlnd.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_debug.h"
+
+
+#define ALLOC_CALLBACK_ARGS(a, b, c)\
+if (c) {\
+	a = (zval ***)safe_emalloc(c, sizeof(zval **), 0);\
+	for (i = b; i < c; i++) {\
+		a[i] = mnd_emalloc(sizeof(zval *));\
+		MAKE_STD_ZVAL(*a[i]);\
+	}\
+}
+
+#define FREE_CALLBACK_ARGS(a, b, c)\
+if (a) {\
+	for (i = b; i < c; i++) {\
+		zval_ptr_dtor(a[i]);\
+		mnd_efree(a[i]);\
+	}\
+	mnd_efree(a);\
+}
+
+/* {{{ mysqlnd_local_infile_init */
+static
+int mysqlnd_local_infile_init(void **ptr, char *filename, void **userdata TSRMLS_DC)
+{
+	MYSQLND_INFILE_INFO	*info;
+	php_stream_context	*context = NULL;
+
+	DBG_ENTER("mysqlnd_local_infile_init");
+
+	info = ((MYSQLND_INFILE_INFO *)mnd_ecalloc(1, sizeof(MYSQLND_INFILE_INFO)));
+	if (!info) {
+		DBG_RETURN(1);
+	}
+
+	*ptr = info;
+
+	/* check open_basedir */
+	if (PG(open_basedir)) {
+		if (php_check_open_basedir_ex(filename, 0 TSRMLS_CC) == -1) {
+			strcpy(info->error_msg, "open_basedir restriction in effect. Unable to open file");
+			info->error_no = CR_UNKNOWN_ERROR;
+			DBG_RETURN(1);
+		}
+	}
+
+	info->filename = filename;
+	info->fd = php_stream_open_wrapper_ex((char *)filename, "r", 0, NULL, context);
+
+	if (info->fd == NULL) {
+		snprintf((char *)info->error_msg, sizeof(info->error_msg), "Can't find file '%-.64s'.", filename);
+		info->error_no = MYSQLND_EE_FILENOTFOUND;
+		DBG_RETURN(1);
+	}
+
+	DBG_RETURN(0);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_local_infile_read */
+static
+int mysqlnd_local_infile_read(void *ptr, char *buf, unsigned int buf_len TSRMLS_DC)
+{
+	MYSQLND_INFILE_INFO	*info = (MYSQLND_INFILE_INFO *)ptr;
+	int count;
+
+	DBG_ENTER("mysqlnd_local_infile_read");
+
+	count = (int)php_stream_read(info->fd, buf, buf_len);
+
+	if (count < 0) {
+		strcpy(info->error_msg, "Error reading file");
+		info->error_no = CR_UNKNOWN_ERROR;
+	}
+
+	DBG_RETURN(count);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_local_infile_error */
+static
+int	mysqlnd_local_infile_error(void *ptr, char *error_buf, unsigned int error_buf_len TSRMLS_DC)
+{
+	MYSQLND_INFILE_INFO	*info = (MYSQLND_INFILE_INFO *)ptr;
+
+	DBG_ENTER("mysqlnd_local_infile_error");
+
+	if (info) {
+		strlcpy(error_buf, info->error_msg, error_buf_len);
+		DBG_INF_FMT("have info, %d", info->error_no);
+		DBG_RETURN(info->error_no);
+	}
+
+	strlcpy(error_buf, "Unknown error", error_buf_len);
+	DBG_INF_FMT("no info, %d", CR_UNKNOWN_ERROR);
+	DBG_RETURN(CR_UNKNOWN_ERROR);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_local_infile_end */
+static
+void mysqlnd_local_infile_end(void *ptr TSRMLS_DC)
+{
+	MYSQLND_INFILE_INFO	*info = (MYSQLND_INFILE_INFO *)ptr;
+
+	if (info) {
+		/* php_stream_close segfaults on NULL */
+		if (info->fd) {
+			php_stream_close(info->fd);
+			info->fd = NULL;
+		}
+		mnd_efree(info);
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_local_infile_default */
+PHPAPI void mysqlnd_local_infile_default(MYSQLND *conn)
+{
+	conn->infile.local_infile_init = mysqlnd_local_infile_init;
+	conn->infile.local_infile_read = mysqlnd_local_infile_read;
+	conn->infile.local_infile_error = mysqlnd_local_infile_error;
+	conn->infile.local_infile_end = mysqlnd_local_infile_end;
+}
+/* }}} */
+
+/* {{{ mysqlnd_set_local_infile_handler */
+PHPAPI void mysqlnd_set_local_infile_handler(MYSQLND * const conn, const char * const funcname)
+{
+	if (!conn->infile.callback) {
+		MAKE_STD_ZVAL(conn->infile.callback);
+	} else {
+		zval_dtor(conn->infile.callback);
+	}
+	ZVAL_STRING(conn->infile.callback, (char*) funcname, 1);
+}
+/* }}} */
+
+
+static const char *lost_conn = "Lost connection to MySQL server during LOAD DATA of local file";
+
+
+/* {{{ mysqlnd_handle_local_infile */
+enum_func_status
+mysqlnd_handle_local_infile(MYSQLND *conn, const char *filename, zend_bool *is_warning TSRMLS_DC)
+{
+	char				*buf = NULL;
+	char				empty_packet[MYSQLND_HEADER_SIZE];
+	enum_func_status	result = FAIL;
+	unsigned int		buflen = 4096;
+	void				*info = NULL;
+	int					bufsize;
+	size_t				ret;
+	MYSQLND_INFILE		infile;
+
+	DBG_ENTER("mysqlnd_handle_local_infile");
+
+	if (!(conn->options.flags & CLIENT_LOCAL_FILES)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "LOAD DATA LOCAL INFILE forbidden");
+		/* write empty packet to server */
+		ret = conn->net->m.send(conn, empty_packet, 0 TSRMLS_CC);
+		*is_warning = TRUE;
+		goto infile_error;
+	}
+
+	infile = conn->infile;
+	/* allocate buffer for reading data */
+	buf = (char *)mnd_ecalloc(1, buflen);
+
+	*is_warning = FALSE;
+
+	/* init handler: allocate read buffer and open file */
+	if (infile.local_infile_init(&info, (char *)filename, conn->infile.userdata TSRMLS_CC)) {
+		*is_warning = TRUE;
+		/* error occured */
+		strcpy(conn->error_info.sqlstate, UNKNOWN_SQLSTATE);
+		conn->error_info.error_no =
+				infile.local_infile_error(info, conn->error_info.error, sizeof(conn->error_info.error) TSRMLS_CC);
+		/* write empty packet to server */
+		ret = conn->net->m.send(conn, empty_packet, 0 TSRMLS_CC);
+		goto infile_error;
+	}
+
+	/* read data */
+	while ((bufsize = infile.local_infile_read (info, buf + MYSQLND_HEADER_SIZE, buflen - MYSQLND_HEADER_SIZE TSRMLS_CC)) > 0) {
+		if ((ret = conn->net->m.send(conn, buf, bufsize TSRMLS_CC)) == 0) {
+			DBG_ERR_FMT("Error during read : %d %s %s", CR_SERVER_LOST, UNKNOWN_SQLSTATE, lost_conn);
+			SET_CLIENT_ERROR(conn->error_info, CR_SERVER_LOST, UNKNOWN_SQLSTATE, lost_conn);
+			goto infile_error;
+		}
+	}
+
+	/* send empty packet for eof */
+	if ((ret = conn->net->m.send(conn, empty_packet, 0 TSRMLS_CC)) == 0) {
+		SET_CLIENT_ERROR(conn->error_info, CR_SERVER_LOST, UNKNOWN_SQLSTATE, lost_conn);
+		goto infile_error;
+	}
+
+	/* error during read occured */
+	if (bufsize < 0) {
+		*is_warning = TRUE;
+		DBG_ERR_FMT("Bufsize < 0, warning,  %d %s %s", CR_SERVER_LOST, UNKNOWN_SQLSTATE, lost_conn);
+		strcpy(conn->error_info.sqlstate, UNKNOWN_SQLSTATE);
+		conn->error_info.error_no =
+				infile.local_infile_error(info, conn->error_info.error, sizeof(conn->error_info.error) TSRMLS_CC);
+		goto infile_error;
+	}
+
+	result = PASS;
+
+infile_error:
+	/* get response from server and update upsert values */
+	if (FAIL == conn->m->simple_command_handle_response(conn, PROT_OK_PACKET, FALSE, COM_QUERY, FALSE TSRMLS_CC)) {
+		result = FAIL;
+	}
+
+	(*conn->infile.local_infile_end)(info TSRMLS_CC);
+	if (buf) {
+		mnd_efree(buf);
+	}
+	DBG_INF_FMT("%s", result == PASS? "PASS":"FAIL");
+	DBG_RETURN(result);
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_net.c
@@ -0,0 +1,978 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+#include "php.h"
+#include "php_globals.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_statistics.h"
+#include "mysqlnd_debug.h"
+#include "ext/standard/sha1.h"
+#include "php_network.h"
+#include "zend_ini.h"
+#ifdef MYSQLND_COMPRESSION_ENABLED
+#include <zlib.h>
+#endif
+
+#ifndef PHP_WIN32
+#include <netinet/tcp.h>
+#else
+#include <winsock.h>
+#endif
+
+
+/* {{{ mysqlnd_set_sock_no_delay */
+static int
+mysqlnd_set_sock_no_delay(php_stream * stream TSRMLS_DC)
+{
+
+	int socketd = ((php_netstream_data_t*)stream->abstract)->socket;
+	int ret = SUCCESS;
+	int flag = 1;
+	int result = setsockopt(socketd, IPPROTO_TCP,  TCP_NODELAY, (char *) &flag, sizeof(int));
+
+	DBG_ENTER("mysqlnd_set_sock_no_delay");
+
+	if (result == -1) {
+		ret = FAILURE;
+	}
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::network_read */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, network_read)(MYSQLND * conn, zend_uchar * buffer, size_t count TSRMLS_DC)
+{
+	enum_func_status return_value = PASS;
+	size_t to_read = count, ret;
+	size_t old_chunk_size = conn->net->stream->chunk_size;
+	DBG_ENTER("mysqlnd_net::network_read");
+	DBG_INF_FMT("count=%u", count);
+	conn->net->stream->chunk_size = MIN(to_read, conn->net->options.net_read_buffer_size);
+	while (to_read) {
+		if (!(ret = php_stream_read(conn->net->stream, (char *) buffer, to_read))) {
+			DBG_ERR_FMT("Error while reading header from socket");
+			return_value = FAIL;
+			break;
+		}
+		buffer += ret;
+		to_read -= ret;
+	}
+	MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn->stats, STAT_BYTES_RECEIVED, count - to_read);
+	conn->net->stream->chunk_size = old_chunk_size;
+	DBG_RETURN(return_value);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::network_write */
+static size_t
+MYSQLND_METHOD(mysqlnd_net, network_write)(MYSQLND * const conn, const zend_uchar * const buf, size_t count TSRMLS_DC)
+{
+	size_t ret;
+	DBG_ENTER("mysqlnd_net::network_write");
+	ret = php_stream_write(conn->net->stream, (char *)buf, count);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+
+/* {{{ mysqlnd_net::connect */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, connect)(MYSQLND_NET * net, const char * const scheme, size_t scheme_len, zend_bool persistent, char **errstr, int * errcode TSRMLS_DC)
+{
+#if PHP_API_VERSION < 20100412
+	unsigned int streams_options = ENFORCE_SAFE_MODE;
+#else
+	unsigned int streams_options = 0;
+#endif
+	unsigned int streams_flags = STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT;
+	char * hashed_details = NULL;
+	int hashed_details_len = 0;
+	struct timeval tv;
+	DBG_ENTER("mysqlnd_net::connect");
+
+	if (persistent) {
+		hashed_details_len = spprintf(&hashed_details, 0, "%p", net);
+		DBG_INF_FMT("hashed_details=%s", hashed_details);
+	}
+
+	net->packet_no = net->compressed_envelope_packet_no = 0;
+
+	if (net->stream) {
+		/* close before opening a new one */
+		DBG_INF_FMT("Freeing stream. abstract=%p", net->stream->abstract);
+		if (net->persistent) {
+			php_stream_free(net->stream, PHP_STREAM_FREE_CLOSE_PERSISTENT | PHP_STREAM_FREE_RSRC_DTOR);
+		} else {
+			php_stream_free(net->stream, PHP_STREAM_FREE_CLOSE);
+		}
+		net->stream = NULL;
+	}
+
+	if (net->options.timeout_connect) {
+		tv.tv_sec = net->options.timeout_connect;
+		tv.tv_usec = 0;
+	}
+
+	DBG_INF_FMT("calling php_stream_xport_create");
+	net->stream = php_stream_xport_create(scheme, scheme_len, streams_options, streams_flags,
+										  hashed_details, (net->options.timeout_connect) ? &tv : NULL,
+										  NULL /*ctx*/, errstr, errcode);
+
+	if (*errstr || !net->stream) {
+		if (hashed_details) {
+			efree(hashed_details); /* allocated by spprintf */
+		}
+		*errcode = CR_CONNECTION_ERROR;
+		DBG_RETURN(FAIL);
+	}
+
+	if (hashed_details) {
+		/*
+		  If persistent, the streams register it in EG(persistent_list).
+		  This is unwanted. ext/mysql or ext/mysqli are responsible to clean,
+		  whatever they have to.
+		*/
+		zend_rsrc_list_entry *le;
+
+		if (zend_hash_find(&EG(persistent_list), hashed_details, hashed_details_len + 1, (void*) &le) == SUCCESS) {
+			/*
+			  in_free will let streams code skip destructing - big HACK,
+			  but STREAMS suck big time regarding persistent streams.
+			  Just not compatible for extensions that need persistency.
+			*/
+			net->stream->in_free = 1;
+			zend_hash_del(&EG(persistent_list), hashed_details, hashed_details_len + 1);
+			net->stream->in_free = 0;
+		}
+#if ZEND_DEBUG
+		/* Shut-up the streams, they don't know what they are doing */
+		net->stream->__exposed = 1;
+#endif
+		efree(hashed_details);
+	}
+	/*
+	  Streams are not meant for C extensions! Thus we need a hack. Every connected stream will
+	  be registered as resource (in EG(regular_list). So far, so good. However, it won't be
+	  unregistered till the script ends. So, we need to take care of that.
+	*/
+	net->stream->in_free = 1;
+	zend_hash_index_del(&EG(regular_list), net->stream->rsrc_id);
+	net->stream->in_free = 0;
+
+	if (!net->options.timeout_read) {
+		/* should always happen because read_timeout cannot be set via API */
+		net->options.timeout_read = (unsigned int) MYSQLND_G(net_read_timeout);
+	}
+	if (net->options.timeout_read) {
+		DBG_INF_FMT("setting %u as PHP_STREAM_OPTION_READ_TIMEOUT", net->options.timeout_read);
+		tv.tv_sec = net->options.timeout_read;
+		tv.tv_usec = 0;
+		php_stream_set_option(net->stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &tv);
+	}
+
+	if (!memcmp(scheme, "tcp://", sizeof("tcp://") - 1)) {
+		/* TCP -> Set TCP_NODELAY */
+		mysqlnd_set_sock_no_delay(net->stream TSRMLS_CC);
+	}
+
+	{
+		unsigned int buf_size = MYSQLND_G(net_read_buffer_size); /* this is long, cast to unsigned int*/
+		net->m.set_client_option(net, MYSQLND_OPT_NET_READ_BUFFER_SIZE, (char *)&buf_size TSRMLS_CC);
+	}
+
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* We assume that MYSQLND_HEADER_SIZE is 4 bytes !! */
+#define COPY_HEADER(T,A)  do { \
+		*(((char *)(T)))   = *(((char *)(A)));\
+		*(((char *)(T))+1) = *(((char *)(A))+1);\
+		*(((char *)(T))+2) = *(((char *)(A))+2);\
+		*(((char *)(T))+3) = *(((char *)(A))+3); } while (0)
+#define STORE_HEADER_SIZE(safe_storage, buffer)  COPY_HEADER((safe_storage), (buffer))
+#define RESTORE_HEADER_SIZE(buffer, safe_storage) STORE_HEADER_SIZE((safe_storage), (buffer))
+
+/* {{{ mysqlnd_net::send */
+/*
+  IMPORTANT : It's expected that buf has place in the beginning for MYSQLND_HEADER_SIZE !!!!
+			  This is done for performance reasons in the caller of this function.
+			  Otherwise we will have to do send two TCP packets, or do new alloc and memcpy.
+			  Neither are quick, thus the clients of this function are obligated to do
+			  what they are asked for.
+
+  `count` is actually the length of the payload data. Thus :
+  count + MYSQLND_HEADER_SIZE = sizeof(buf) (not the pointer but the actual buffer)
+*/
+size_t
+MYSQLND_METHOD(mysqlnd_net, send)(MYSQLND * const conn, char * const buf, size_t count TSRMLS_DC)
+{
+	zend_uchar safe_buf[((MYSQLND_HEADER_SIZE) + (sizeof(zend_uchar)) - 1) / (sizeof(zend_uchar))];
+	zend_uchar *safe_storage = safe_buf;
+	MYSQLND_NET *net = conn->net;
+	size_t old_chunk_size = net->stream->chunk_size;
+	size_t ret, packets_sent = 1;
+	size_t left = count;
+	zend_uchar *p = (zend_uchar *) buf;
+	zend_uchar * compress_buf = NULL;
+	size_t to_be_sent;
+
+	DBG_ENTER("mysqlnd_net::send");
+	DBG_INF_FMT("conn=%llu count=%lu compression=%u", conn->thread_id, count, net->compressed);
+
+	net->stream->chunk_size = MYSQLND_MAX_PACKET_SIZE;
+
+	if (net->compressed == TRUE) {
+		size_t comp_buf_size = MYSQLND_HEADER_SIZE + COMPRESSED_HEADER_SIZE + MYSQLND_HEADER_SIZE + MIN(left, MYSQLND_MAX_PACKET_SIZE);
+		DBG_INF_FMT("compress_buf_size="MYSQLND_SZ_T_SPEC, comp_buf_size);
+		compress_buf = mnd_emalloc(comp_buf_size);
+	}
+
+	do {
+		to_be_sent = MIN(left, MYSQLND_MAX_PACKET_SIZE);
+#ifdef MYSQLND_COMPRESSION_ENABLED
+		if (net->compressed == TRUE) {
+			/* here we need to compress the data and then write it, first comes the compressed header */
+			size_t tmp_complen = to_be_sent;
+			size_t payload_size;
+			zend_uchar * uncompressed_payload = p; /* should include the header */
+
+			STORE_HEADER_SIZE(safe_storage, uncompressed_payload);
+			int3store(uncompressed_payload, to_be_sent);
+			int1store(uncompressed_payload + 3, net->packet_no);
+			if (PASS == net->m.encode((compress_buf + COMPRESSED_HEADER_SIZE + MYSQLND_HEADER_SIZE), &tmp_complen,
+									   uncompressed_payload, to_be_sent + MYSQLND_HEADER_SIZE TSRMLS_CC))
+			{
+				int3store(compress_buf + MYSQLND_HEADER_SIZE, to_be_sent + MYSQLND_HEADER_SIZE);
+				payload_size = tmp_complen;
+			} else {
+				int3store(compress_buf + MYSQLND_HEADER_SIZE, 0);
+				memcpy(compress_buf + MYSQLND_HEADER_SIZE + COMPRESSED_HEADER_SIZE, uncompressed_payload, to_be_sent + MYSQLND_HEADER_SIZE);
+				payload_size = to_be_sent + MYSQLND_HEADER_SIZE;
+			}
+			RESTORE_HEADER_SIZE(uncompressed_payload, safe_storage);
+
+			int3store(compress_buf, payload_size);
+			int1store(compress_buf + 3, net->packet_no);
+			DBG_INF_FMT("writing "MYSQLND_SZ_T_SPEC" bytes to the network", payload_size + MYSQLND_HEADER_SIZE + COMPRESSED_HEADER_SIZE);
+			ret = conn->net->m.network_write(conn, compress_buf, payload_size + MYSQLND_HEADER_SIZE + COMPRESSED_HEADER_SIZE TSRMLS_CC);
+			net->compressed_envelope_packet_no++;
+  #if WHEN_WE_NEED_TO_CHECK_WHETHER_COMPRESSION_WORKS_CORRECTLY
+			if (res == Z_OK) {
+				size_t decompressed_size = left + MYSQLND_HEADER_SIZE;
+				zend_uchar * decompressed_data = mnd_malloc(decompressed_size);
+				int error = net->m.decode(decompressed_data, decompressed_size,
+										  compress_buf + MYSQLND_HEADER_SIZE + COMPRESSED_HEADER_SIZE, payload_size);
+				if (error == Z_OK) {
+					int i;
+					DBG_INF("success decompressing");
+					for (i = 0 ; i < decompressed_size; i++) {
+						if (i && (i % 30 == 0)) {
+							printf("\n\t\t");
+						}
+						printf("%.2X ", (int)*((char*)&(decompressed_data[i])));
+						DBG_INF_FMT("%.2X ", (int)*((char*)&(decompressed_data[i])));
+					}
+				} else {
+					DBG_INF("error decompressing");
+				}
+				mnd_free(decompressed_data);
+			}
+  #endif /* WHEN_WE_NEED_TO_CHECK_WHETHER_COMPRESSION_WORKS_CORRECTLY */
+		} else
+#endif /* MYSQLND_COMPRESSION_ENABLED */
+		{
+			DBG_INF("no compression");
+			STORE_HEADER_SIZE(safe_storage, p);
+			int3store(p, to_be_sent);
+			int1store(p + 3, net->packet_no);
+			ret = conn->net->m.network_write(conn, p, to_be_sent + MYSQLND_HEADER_SIZE TSRMLS_CC);
+			RESTORE_HEADER_SIZE(p, safe_storage);
+			net->compressed_envelope_packet_no++;
+		}
+		net->packet_no++;
+
+		p += to_be_sent;
+		left -= to_be_sent;
+		packets_sent++;
+		/*
+		  if left is 0 then there is nothing more to send, but if the last packet was exactly 
+		  with the size MYSQLND_MAX_PACKET_SIZE we need to send additional packet, which has
+		  empty payload. Thus if left == 0 we check for to_be_sent being the max size. If it is
+		  indeed it then loop once more, then to_be_sent will become 0, left will stay 0. Empty
+		  packet will be sent and this loop will end.
+		*/
+	} while (ret && (left > 0 || to_be_sent == MYSQLND_MAX_PACKET_SIZE));
+
+	DBG_INF_FMT("packet_size="MYSQLND_SZ_T_SPEC" packet_no=%u", left, net->packet_no);
+	/* Even for zero size payload we have to send a packet */
+	if (!ret) {
+		DBG_ERR_FMT("Can't %u send bytes", count);
+		conn->state = CONN_QUIT_SENT;
+		SET_CLIENT_ERROR(conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
+	}
+
+	MYSQLND_INC_CONN_STATISTIC_W_VALUE3(conn->stats,
+			STAT_BYTES_SENT, count + packets_sent * MYSQLND_HEADER_SIZE,
+			STAT_PROTOCOL_OVERHEAD_OUT, packets_sent * MYSQLND_HEADER_SIZE,
+			STAT_PACKETS_SENT, packets_sent);
+
+	net->stream->chunk_size = old_chunk_size;
+	if (compress_buf) {
+		mnd_efree(compress_buf);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+#ifdef MYSQLND_COMPRESSION_ENABLED
+/* {{{ php_mysqlnd_read_buffer_is_empty */
+static zend_bool
+php_mysqlnd_read_buffer_is_empty(MYSQLND_READ_BUFFER * buffer)
+{
+	return buffer->len? FALSE:TRUE;
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_read_buffer_read */
+static void
+php_mysqlnd_read_buffer_read(MYSQLND_READ_BUFFER * buffer, size_t count, zend_uchar * dest)
+{
+	if (buffer->len >= count) {
+		memcpy(dest, buffer->data + buffer->offset, count);
+		buffer->offset += count;
+		buffer->len -= count;
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_read_buffer_bytes_left */
+static size_t
+php_mysqlnd_read_buffer_bytes_left(MYSQLND_READ_BUFFER * buffer)
+{
+	return buffer->len;
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_read_buffer_free */
+static void
+php_mysqlnd_read_buffer_free(MYSQLND_READ_BUFFER ** buffer TSRMLS_DC)
+{
+	DBG_ENTER("php_mysqlnd_read_buffer_free");
+	if (*buffer) {
+		mnd_efree((*buffer)->data);
+		mnd_efree(*buffer);
+		*buffer = NULL;
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_create_read_buffer */
+static MYSQLND_READ_BUFFER *
+mysqlnd_create_read_buffer(size_t count TSRMLS_DC)
+{
+	MYSQLND_READ_BUFFER * ret = mnd_emalloc(sizeof(MYSQLND_READ_BUFFER));
+	DBG_ENTER("mysqlnd_create_read_buffer");
+	ret->is_empty = php_mysqlnd_read_buffer_is_empty;
+	ret->read = php_mysqlnd_read_buffer_read;
+	ret->bytes_left = php_mysqlnd_read_buffer_bytes_left;
+	ret->free_buffer = php_mysqlnd_read_buffer_free;
+	ret->data = mnd_emalloc(count);
+	ret->size = ret->len = count;
+	ret->offset = 0;
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_read_compressed_packet_from_stream_and_fill_read_buffer */
+static enum_func_status
+mysqlnd_read_compressed_packet_from_stream_and_fill_read_buffer(MYSQLND * conn, size_t net_payload_size TSRMLS_DC)
+{
+	MYSQLND_NET * net = conn->net;
+	size_t decompressed_size;
+	enum_func_status ret = PASS;
+	zend_uchar * compressed_data = NULL;
+	zend_uchar comp_header[COMPRESSED_HEADER_SIZE];
+	DBG_ENTER("mysqlnd_read_compressed_packet_from_stream_and_fill_read_buffer");
+
+	/* Read the compressed header */
+	if (FAIL == conn->net->m.network_read(conn, comp_header, COMPRESSED_HEADER_SIZE TSRMLS_CC)) {
+		DBG_RETURN(FAIL);
+	}
+	decompressed_size = uint3korr(comp_header);
+
+	/* When decompressed_size is 0, then the data is not compressed, and we have wasted 3 bytes */
+	/* we need to decompress the data */
+
+	if (decompressed_size) {
+		compressed_data = mnd_emalloc(net_payload_size);
+		if (FAIL == conn->net->m.network_read(conn, compressed_data, net_payload_size TSRMLS_CC)) {
+			ret = FAIL;
+			goto end;
+		}
+		net->uncompressed_data = mysqlnd_create_read_buffer(decompressed_size TSRMLS_CC);
+		ret = net->m.decode(net->uncompressed_data->data, decompressed_size, compressed_data, net_payload_size TSRMLS_CC);
+		if (ret == FAIL) {
+			goto end;
+		}
+	} else {
+		DBG_INF_FMT("The server decided not to compress the data. Our job is easy. Copying %u bytes", net_payload_size);
+		net->uncompressed_data = mysqlnd_create_read_buffer(net_payload_size TSRMLS_CC);
+		if (FAIL == conn->net->m.network_read(conn, net->uncompressed_data->data, net_payload_size TSRMLS_CC)) {
+			ret = FAIL;
+			goto end;
+		}
+	}
+end:
+	if (compressed_data) {
+		mnd_efree(compressed_data);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+#endif /* MYSQLND_COMPRESSION_ENABLED */
+
+
+/* {{{ mysqlnd_net::decode */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, decode)(zend_uchar * uncompressed_data, size_t uncompressed_data_len,
+									const zend_uchar * const compressed_data, size_t compressed_data_len TSRMLS_DC)
+{
+#ifdef MYSQLND_COMPRESSION_ENABLED
+	int error;
+	uLongf tmp_complen = uncompressed_data_len;
+	DBG_ENTER("mysqlnd_net::decode");
+	error = uncompress(uncompressed_data, &tmp_complen, compressed_data, compressed_data_len);
+
+	DBG_INF_FMT("compressed data: decomp_len=%lu compressed_size="MYSQLND_SZ_T_SPEC, tmp_complen, compressed_data_len);
+	if (error != Z_OK) {
+		DBG_INF_FMT("decompression NOT successful. error=%d Z_OK=%d Z_BUF_ERROR=%d Z_MEM_ERROR=%d", error, Z_OK, Z_BUF_ERROR, Z_MEM_ERROR);
+	}
+	DBG_RETURN(error == Z_OK? PASS:FAIL);
+#else
+	DBG_ENTER("mysqlnd_net::decode");
+	DBG_RETURN(FAIL);
+#endif
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::encode */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, encode)(zend_uchar * compress_buffer, size_t * compress_buffer_len,
+									const zend_uchar * const uncompressed_data, size_t uncompressed_data_len TSRMLS_DC)
+{
+#ifdef MYSQLND_COMPRESSION_ENABLED
+	int error;
+	uLongf tmp_complen = *compress_buffer_len;
+	DBG_ENTER("mysqlnd_net::encode");
+	error = compress(compress_buffer, &tmp_complen, uncompressed_data, uncompressed_data_len);
+
+	if (error != Z_OK) {
+		DBG_INF_FMT("compression NOT successful. error=%d Z_OK=%d Z_BUF_ERROR=%d Z_MEM_ERROR=%d", error, Z_OK, Z_BUF_ERROR, Z_MEM_ERROR);
+	} else {
+		*compress_buffer_len = tmp_complen;
+		DBG_INF_FMT("compression successful. compressed size=%lu", tmp_complen);
+	}
+	
+	DBG_RETURN(error == Z_OK? PASS:FAIL);
+#else
+	DBG_ENTER("mysqlnd_net::encode");
+	DBG_RETURN(FAIL);
+#endif
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::receive */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, receive)(MYSQLND * conn, zend_uchar * buffer, size_t count TSRMLS_DC)
+{
+	size_t to_read = count;
+	zend_uchar * p = buffer;
+	MYSQLND_NET * net = conn->net;
+
+	DBG_ENTER("mysqlnd_net::receive");
+#ifdef MYSQLND_COMPRESSION_ENABLED
+	if (net->compressed) {
+		if (net->uncompressed_data) {
+			size_t to_read_from_buffer = MIN(net->uncompressed_data->bytes_left(net->uncompressed_data), to_read);
+			DBG_INF_FMT("reading %u from uncompressed_data buffer", to_read_from_buffer);
+			if (to_read_from_buffer) {
+				net->uncompressed_data->read(net->uncompressed_data, to_read_from_buffer, (zend_uchar *) p);
+				p += to_read_from_buffer;
+				to_read -= to_read_from_buffer;
+			}
+			DBG_INF_FMT("left %u to read", to_read);
+			if (TRUE == net->uncompressed_data->is_empty(net->uncompressed_data)) {
+				/* Everything was consumed. This should never happen here, but for security */
+				net->uncompressed_data->free_buffer(&net->uncompressed_data TSRMLS_CC);
+			}
+		}
+		if (to_read) {
+			zend_uchar net_header[MYSQLND_HEADER_SIZE];
+			size_t net_payload_size;
+			zend_uchar packet_no;
+
+			if (FAIL == net->m.network_read(conn, net_header, MYSQLND_HEADER_SIZE TSRMLS_CC)) {
+				DBG_RETURN(FAIL);
+			}
+			net_payload_size = uint3korr(net_header);
+			packet_no = uint1korr(net_header + 3);
+			if (net->compressed_envelope_packet_no != packet_no) {
+				DBG_ERR_FMT("Transport level: packets out of order. Expected %u received %u. Packet size="MYSQLND_SZ_T_SPEC,
+							net->compressed_envelope_packet_no, packet_no, net_payload_size);
+
+				php_error(E_WARNING, "Packets out of order. Expected %u received %u. Packet size="MYSQLND_SZ_T_SPEC,
+						  net->compressed_envelope_packet_no, packet_no, net_payload_size);
+				DBG_RETURN(FAIL);
+			}
+			net->compressed_envelope_packet_no++;
+#ifdef MYSQLND_DUMP_HEADER_N_BODY
+			DBG_INF_FMT("HEADER: hwd_packet_no=%u size=%3u", packet_no, (unsigned long) net_payload_size);
+#endif
+			/* Now let's read from the wire, decompress it and fill the read buffer */
+			mysqlnd_read_compressed_packet_from_stream_and_fill_read_buffer(conn, net_payload_size TSRMLS_CC);
+
+			/*
+			  Now a bit of recursion - read from the read buffer,
+			  if the data which we have just read from the wire
+			  is not enough, then the recursive call will try to
+			  satisfy it until it is satisfied.
+			*/
+			DBG_RETURN(net->m.receive(conn, p, to_read TSRMLS_CC));
+		}
+		DBG_RETURN(PASS);
+	}
+#endif /* MYSQLND_COMPRESSION_ENABLED */
+	DBG_RETURN(net->m.network_read(conn, p, to_read TSRMLS_CC));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::set_client_option */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, set_client_option)(MYSQLND_NET * const net, enum mysqlnd_option option, const char * const value TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_net::set_client_option");
+	DBG_INF_FMT("option=%u", option);
+	switch (option) {
+		case MYSQLND_OPT_NET_CMD_BUFFER_SIZE:
+			DBG_INF("MYSQLND_OPT_NET_CMD_BUFFER_SIZE");
+			if (*(unsigned int*) value < MYSQLND_NET_CMD_BUFFER_MIN_SIZE) {
+				DBG_RETURN(FAIL);
+			}
+			net->cmd_buffer.length = *(unsigned int*) value;
+			DBG_INF_FMT("new_length=%u", net->cmd_buffer.length);
+			if (!net->cmd_buffer.buffer) {
+				net->cmd_buffer.buffer = mnd_pemalloc(net->cmd_buffer.length, net->persistent);
+			} else {
+				net->cmd_buffer.buffer = mnd_perealloc(net->cmd_buffer.buffer, net->cmd_buffer.length, net->persistent);
+			}
+			break;
+		case MYSQLND_OPT_NET_READ_BUFFER_SIZE:
+			DBG_INF("MYSQLND_OPT_NET_READ_BUFFER_SIZE");
+			net->options.net_read_buffer_size = *(unsigned int*) value;
+			DBG_INF_FMT("new_length=%u", net->options.net_read_buffer_size);
+			break;
+		case MYSQL_OPT_CONNECT_TIMEOUT:
+			DBG_INF("MYSQL_OPT_CONNECT_TIMEOUT");
+			net->options.timeout_connect = *(unsigned int*) value;
+			break;
+		case MYSQLND_OPT_SSL_KEY:
+			{
+				zend_bool pers = net->persistent;
+				if (net->options.ssl_key) {
+					mnd_pefree(net->options.ssl_key, pers);
+				}
+				net->options.ssl_key = value? mnd_pestrdup(value, pers) : NULL;
+				break;
+			}
+		case MYSQLND_OPT_SSL_CERT:
+			{
+				zend_bool pers = net->persistent;
+				if (net->options.ssl_cert) {
+					mnd_pefree(net->options.ssl_cert, pers);
+				}
+				net->options.ssl_cert = value? mnd_pestrdup(value, pers) : NULL;
+				break;
+			}
+		case MYSQLND_OPT_SSL_CA:
+			{
+				zend_bool pers = net->persistent;
+				if (net->options.ssl_ca) {
+					mnd_pefree(net->options.ssl_ca, pers);
+				}
+				net->options.ssl_ca = value? mnd_pestrdup(value, pers) : NULL;
+				break;
+			}
+		case MYSQLND_OPT_SSL_CAPATH:
+			{
+				zend_bool pers = net->persistent;
+				if (net->options.ssl_capath) {
+					mnd_pefree(net->options.ssl_capath, pers);
+				}
+				net->options.ssl_capath = value? mnd_pestrdup(value, pers) : NULL;
+				break;
+			}
+		case MYSQLND_OPT_SSL_CIPHER:
+			{
+				zend_bool pers = net->persistent;
+				if (net->options.ssl_cipher) {
+					mnd_pefree(net->options.ssl_cipher, pers);
+				}
+				net->options.ssl_cipher = value? mnd_pestrdup(value, pers) : NULL;
+				break;
+			}
+		case MYSQLND_OPT_SSL_PASSPHRASE:
+			{
+				zend_bool pers = net->persistent;
+				if (net->options.ssl_passphrase) {
+					mnd_pefree(net->options.ssl_passphrase, pers);
+				}
+				net->options.ssl_passphrase = value? mnd_pestrdup(value, pers) : NULL;
+				break;
+			}
+		case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:
+			net->options.ssl_verify_peer = value? ((*(zend_bool *)value)? TRUE:FALSE): FALSE;
+			break;
+#ifdef WHEN_SUPPORTED_BY_MYSQLI
+		case MYSQL_OPT_READ_TIMEOUT:
+			DBG_INF("MYSQL_OPT_READ_TIMEOUT");
+			net->options.timeout_read = *(unsigned int*) value;
+			break;
+		case MYSQL_OPT_WRITE_TIMEOUT:
+			DBG_INF("MYSQL_OPT_WRITE_TIMEOUT");
+			net->options.timeout_write = *(unsigned int*) value;
+			break;
+#endif
+		case MYSQL_OPT_COMPRESS:
+			net->options.flags |= MYSQLND_NET_FLAG_USE_COMPRESSION;
+			break;
+		default:
+			DBG_RETURN(FAIL);
+	}
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+/* {{{ mysqlnd_net::consume_uneaten_data */
+size_t 
+MYSQLND_METHOD(mysqlnd_net, consume_uneaten_data)(MYSQLND_NET * const net, enum php_mysqlnd_server_command cmd TSRMLS_DC)
+{
+#ifdef MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND
+	/*
+	  Switch to non-blocking mode and try to consume something from
+	  the line, if possible, then continue. This saves us from looking for
+	  the actuall place where out-of-order packets have been sent.
+	  If someone is completely sure that everything is fine, he can switch it
+	  off.
+	*/
+	char tmp_buf[256];
+	size_t skipped_bytes = 0;
+	int opt = PHP_STREAM_OPTION_BLOCKING;
+	int was_blocked = net->stream->ops->set_option(net->stream, opt, 0, NULL TSRMLS_CC);
+
+	DBG_ENTER("mysqlnd_net::consume_uneaten_data");
+
+	if (PHP_STREAM_OPTION_RETURN_ERR != was_blocked) {
+		/* Do a read of 1 byte */
+		int bytes_consumed;
+
+		do {
+			skipped_bytes += (bytes_consumed = php_stream_read(net->stream, tmp_buf, sizeof(tmp_buf)));
+		} while (bytes_consumed == sizeof(tmp_buf));
+
+		if (was_blocked) {
+			net->stream->ops->set_option(net->stream, opt, 1, NULL TSRMLS_CC);
+		}
+
+		if (bytes_consumed) {
+			DBG_ERR_FMT("Skipped %u bytes. Last command %s hasn't consumed all the output from the server",
+						bytes_consumed, mysqlnd_command_to_text[net->last_command]);
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Skipped %u bytes. Last command %s hasn't "
+							 "consumed all the output from the server",
+							 bytes_consumed, mysqlnd_command_to_text[net->last_command]);
+		}
+	}
+	net->last_command = cmd;
+
+	DBG_RETURN(skipped_bytes);
+#else
+	return 0;
+#endif
+}
+/* }}} */
+
+/*
+  in libmyusql, if cert and !key then key=cert
+*/
+/* {{{ mysqlnd_net::enable_ssl */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, enable_ssl)(MYSQLND_NET * const net TSRMLS_DC)
+{
+#ifdef MYSQLND_SSL_SUPPORTED
+	php_stream_context *context = php_stream_context_alloc();
+	DBG_ENTER("mysqlnd_net::enable_ssl");
+	if (!context) {
+		DBG_RETURN(FAIL);
+	}
+
+	if (net->options.ssl_key) {
+		zval key_zval;
+		ZVAL_STRING(&key_zval, net->options.ssl_key, 0);
+		DBG_INF("key");
+		php_stream_context_set_option(context, "ssl", "local_pk", &key_zval);
+	}
+	if (net->options.ssl_verify_peer) {
+		zval verify_peer_zval;
+		ZVAL_TRUE(&verify_peer_zval);
+		DBG_INF("verify peer");
+		php_stream_context_set_option(context, "ssl", "verify_peer", &verify_peer_zval);
+	}
+	if (net->options.ssl_cert) {
+		zval cert_zval;
+		ZVAL_STRING(&cert_zval, net->options.ssl_cert, 0);
+		DBG_INF_FMT("local_cert=%s", net->options.ssl_cert);
+		php_stream_context_set_option(context, "ssl", "local_cert", &cert_zval);
+		if (!net->options.ssl_key) {
+			php_stream_context_set_option(context, "ssl", "local_pk", &cert_zval);
+		}
+	}
+	if (net->options.ssl_ca) {
+		zval cafile_zval;
+		ZVAL_STRING(&cafile_zval, net->options.ssl_ca, 0);
+		DBG_INF_FMT("cafile=%s", net->options.ssl_ca);
+		php_stream_context_set_option(context, "ssl", "cafile", &cafile_zval);
+	}
+	if (net->options.ssl_capath) {
+		zval capath_zval;
+		ZVAL_STRING(&capath_zval, net->options.ssl_capath, 0);
+		DBG_INF_FMT("capath=%s", net->options.ssl_capath);
+		php_stream_context_set_option(context, "ssl", "cafile", &capath_zval);
+	}
+	if (net->options.ssl_passphrase) {
+		zval passphrase_zval;
+		ZVAL_STRING(&passphrase_zval, net->options.ssl_passphrase, 0);
+		php_stream_context_set_option(context, "ssl", "passphrase", &passphrase_zval);
+	}
+	if (net->options.ssl_cipher) {
+		zval cipher_zval;
+		ZVAL_STRING(&cipher_zval, net->options.ssl_cipher, 0);
+		DBG_INF_FMT("ciphers=%s", net->options.ssl_cipher);
+		php_stream_context_set_option(context, "ssl", "ciphers", &cipher_zval);
+	}
+	php_stream_context_set(net->stream, context);
+	if (php_stream_xport_crypto_setup(net->stream, STREAM_CRYPTO_METHOD_TLS_CLIENT, NULL TSRMLS_CC) < 0 ||
+	    php_stream_xport_crypto_enable(net->stream, 1 TSRMLS_CC) < 0)
+	{
+		DBG_ERR("Cannot connect to MySQL by using SSL");
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot connect to MySQL by using SSL");
+		DBG_RETURN(FAIL);
+	}
+	/*
+	  get rid of the context. we are persistent and if this is a real pconn used by mysql/mysqli,
+	  then the context would not survive cleaning of EG(regular_list), where it is registered, as a
+	  resource. What happens is that after this destruction any use of the network will mean usage
+	  of the context, which means usage of already freed memory, bad. Actually we don't need this
+	  context anymore after we have enabled SSL on the connection. Thus it is very simple, we remove it.
+	*/
+	php_stream_context_set(net->stream, NULL);
+
+	if (net->options.timeout_read) {
+		struct timeval tv;
+		DBG_INF_FMT("setting %u as PHP_STREAM_OPTION_READ_TIMEOUT", net->options.timeout_read);
+		tv.tv_sec = net->options.timeout_read;
+		tv.tv_usec = 0;
+		php_stream_set_option(net->stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &tv);
+	}
+
+	DBG_RETURN(PASS);
+#else
+	DBG_ENTER("mysqlnd_net::enable_ssl");
+	DBG_RETURN(PASS);
+#endif
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::disable_ssl */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_net, disable_ssl)(MYSQLND_NET * const net TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_net::disable_ssl");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net::set_client_option */
+static void
+MYSQLND_METHOD(mysqlnd_net, free_contents)(MYSQLND_NET * net TSRMLS_DC)
+{
+	zend_bool pers = net->persistent;
+	DBG_ENTER("mysqlnd_net::free_contents");
+
+#ifdef MYSQLND_COMPRESSION_ENABLED
+	if (net->uncompressed_data) {
+		net->uncompressed_data->free_buffer(&net->uncompressed_data TSRMLS_CC);
+	}
+#endif
+	if (net->options.ssl_key) {
+		mnd_pefree(net->options.ssl_key, pers);
+		net->options.ssl_key = NULL;
+	}
+	if (net->options.ssl_cert) {
+		mnd_pefree(net->options.ssl_cert, pers);
+		net->options.ssl_cert = NULL;
+	}
+	if (net->options.ssl_ca) {
+		mnd_pefree(net->options.ssl_ca, pers);
+		net->options.ssl_ca = NULL;
+	}
+	if (net->options.ssl_capath) {
+		mnd_pefree(net->options.ssl_capath, pers);
+		net->options.ssl_capath = NULL;
+	}
+	if (net->options.ssl_cipher) {
+		mnd_pefree(net->options.ssl_cipher, pers);
+		net->options.ssl_cipher = NULL;
+	}
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+static 
+MYSQLND_CLASS_METHODS_START(mysqlnd_net)
+	MYSQLND_METHOD(mysqlnd_net, connect),
+	MYSQLND_METHOD(mysqlnd_net, send),
+	MYSQLND_METHOD(mysqlnd_net, receive),
+	MYSQLND_METHOD(mysqlnd_net, set_client_option),
+	MYSQLND_METHOD(mysqlnd_net, network_read),
+	MYSQLND_METHOD(mysqlnd_net, network_write),
+	MYSQLND_METHOD(mysqlnd_net, decode),
+	MYSQLND_METHOD(mysqlnd_net, encode),
+	MYSQLND_METHOD(mysqlnd_net, consume_uneaten_data),
+	MYSQLND_METHOD(mysqlnd_net, free_contents),
+	MYSQLND_METHOD(mysqlnd_net, enable_ssl),
+	MYSQLND_METHOD(mysqlnd_net, disable_ssl)
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ mysqlnd_net_init */
+PHPAPI MYSQLND_NET *
+mysqlnd_net_init(zend_bool persistent TSRMLS_DC)
+{
+	size_t alloc_size = sizeof(MYSQLND_NET) + mysqlnd_plugin_count() * sizeof(void *);
+	MYSQLND_NET * net = mnd_pecalloc(1, alloc_size, persistent);
+
+	DBG_ENTER("mysqlnd_net_init");
+	DBG_INF_FMT("persistent=%u", persistent);
+	if (net) {
+		net->persistent = persistent;
+		net->m = mysqlnd_mysqlnd_net_methods;
+
+		{
+			unsigned int buf_size = MYSQLND_G(net_cmd_buffer_size); /* this is long, cast to unsigned int*/
+			net->m.set_client_option(net, MYSQLND_OPT_NET_CMD_BUFFER_SIZE, (char *) &buf_size TSRMLS_CC);
+		}
+	}
+	DBG_RETURN(net);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net_free */
+PHPAPI void
+mysqlnd_net_free(MYSQLND_NET * const net TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_net_free");
+
+	if (net) {
+		zend_bool pers = net->persistent;
+
+		net->m.free_contents(net TSRMLS_CC);
+		if (net->cmd_buffer.buffer) {
+			DBG_INF("Freeing cmd buffer");
+			mnd_pefree(net->cmd_buffer.buffer, pers);
+			net->cmd_buffer.buffer = NULL;
+		}
+		if (net->stream) {
+			DBG_INF_FMT("Freeing stream. abstract=%p", net->stream->abstract);
+			if (pers) {
+				php_stream_free(net->stream, PHP_STREAM_FREE_CLOSE_PERSISTENT | PHP_STREAM_FREE_RSRC_DTOR);
+			} else {
+				php_stream_free(net->stream, PHP_STREAM_FREE_CLOSE);
+			}
+			net->stream = NULL;
+		}
+		mnd_pefree(net, pers);
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_plugin_get_plugin_net_data */
+PHPAPI void ** _mysqlnd_plugin_get_plugin_net_data(const MYSQLND_NET * net, unsigned int plugin_id TSRMLS_DC)
+{
+	DBG_ENTER("_mysqlnd_plugin_get_plugin_net_data");
+	DBG_INF_FMT("plugin_id=%u", plugin_id);
+	if (!net || plugin_id >= mysqlnd_plugin_count()) {
+		return NULL;
+	}
+	DBG_RETURN((void *)((char *)net + sizeof(MYSQLND_NET) + plugin_id * sizeof(void *)));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_net_get_methods */
+PHPAPI struct st_mysqlnd_net_methods *
+mysqlnd_net_get_methods()
+{
+	return &mysqlnd_mysqlnd_net_methods;
+}
+/* }}} */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_net.h
@@ -0,0 +1,40 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id: mysqlnd_wireprotocol.h 291983 2009-12-11 11:58:57Z andrey $ */
+
+#ifndef MYSQLND_NET_H
+#define MYSQLND_NET_H
+
+PHPAPI MYSQLND_NET * mysqlnd_net_init(zend_bool persistent TSRMLS_DC);
+PHPAPI void mysqlnd_net_free(MYSQLND_NET * const net TSRMLS_DC);
+
+PHPAPI struct st_mysqlnd_net_methods * mysqlnd_net_get_methods();
+
+#endif /* MYSQLND_NET_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_portability.h
@@ -0,0 +1,506 @@
+/* Copyright Abandoned 1996 TCX DataKonsult AB & Monty Program KB & Detron HB 
+This file is public domain and comes with NO WARRANTY of any kind */
+
+/*
+  Parts of the original, which are not applicable to mysqlnd have been removed.
+  
+  With small modifications, mostly casting but adding few more macros by
+  Andrey Hristov <andrey@mysql.com> . The additions are in the public domain and
+  were added to improve the header file, to get it more consistent.
+*/
+
+#ifndef MYSQLND_PORTABILITY_H
+#define MYSQLND_PORTABILITY_H
+
+
+
+/* Comes from global.h as OFFSET, renamed to STRUCT_OFFSET */
+#define STRUCT_OFFSET(t, f)   ((size_t)(char *)&((t *)0)->f)
+
+#ifndef __attribute
+#if !defined(__GNUC__)
+#define __attribute(A)
+#endif
+#endif
+
+#ifdef __CYGWIN__
+/* We use a Unix API, so pretend it's not Windows */
+#undef WIN
+#undef WIN32
+#undef _WIN
+#undef _WIN32
+#undef _WIN64
+#undef __WIN__
+#undef __WIN32__
+#endif /* __CYGWIN__ */
+
+#if defined(_WIN32) || defined(_WIN64) || defined(__WIN32__) || defined(WIN32)
+#  include "ext/mysqlnd/config-win.h"
+#else 
+#  include <ext/mysqlnd/php_mysqlnd_config.h>
+#endif /* _WIN32... */
+
+#if __STDC_VERSION__ < 199901L && !defined(atoll)
+  /* "inline" is a keyword */
+  #define atoll atol
+#endif
+
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)
+#define _LONG_LONG 1        /* For AIX string library */
+#endif
+
+
+/* Go around some bugs in different OS and compilers */
+#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)
+#include <sys/stream.h>        /* HPUX 10.20 defines ulong here. UGLY !!! */
+#define HAVE_ULONG
+#endif
+
+
+#if SIZEOF_LONG_LONG > 4
+#define HAVE_LONG_LONG 1
+#endif
+
+
+/* Typdefs for easyier portability */
+#ifndef HAVE_INT8_T
+#ifndef HAVE_INT8
+typedef signed char int8_t;			/* Signed integer >= 8    bits */
+#else
+typedef int8 int8_t;				/* Signed integer >= 8    bits */
+#endif
+#endif
+
+#ifndef HAVE_UINT8_T
+#ifndef HAVE_UINT8
+typedef unsigned char uint8_t;		/* Unsigned integer >= 8    bits */
+#else
+typedef uint8 uint8_t;				/* Signed integer >= 8    bits */
+#endif
+#endif
+
+#ifndef HAVE_INT16_T
+#ifndef HAVE_INT16
+typedef signed short int16_t;		/* Signed integer >= 16 bits */
+#else
+typedef int16 int16_t;				/* Signed integer >= 16 bits */
+#endif
+#endif
+
+#ifndef HAVE_UINT16_T
+#ifndef HAVE_UINT16
+typedef unsigned short uint16_t;		/* Signed integer >= 16 bits */
+#else
+typedef uint16 uint16_t;			/* Signed integer >= 16 bits */
+#endif
+#endif
+
+
+#ifndef HAVE_INT32_T
+#ifdef HAVE_INT32
+typedef int32 int32_t;
+#elif SIZEOF_INT == 4
+typedef signed int int32_t;
+#elif SIZEOF_LONG == 4
+typedef signed long int32_t;
+#else
+error "Neither int nor long is of 4 bytes width"
+#endif
+#endif /* HAVE_INT32_T */
+
+#ifndef HAVE_UINT32_T
+#ifdef HAVE_UINT32
+typedef uint32 uint32_t;
+#elif SIZEOF_INT == 4
+typedef unsigned int uint32_t;
+#elif SIZEOF_LONG == 4
+typedef unsigned long uint32_t;
+#else
+#error "Neither int nor long is of 4 bytes width"
+#endif
+#endif /* HAVE_UINT32_T */
+
+#ifndef HAVE_INT64_T
+#ifdef HAVE_INT64
+typedef int64 int64_t;
+#elif SIZEOF_INT == 8
+typedef signed int int64_t;
+#elif SIZEOF_LONG == 8
+typedef signed long int64_t;
+#elif SIZEOF_LONG_LONG == 8
+#ifdef PHP_WIN32
+typedef __int64 int64_t;
+#else
+typedef signed long long int64_t;
+#endif
+#else
+#error "Neither int nor long nor long long is of 8 bytes width"
+#endif
+#endif /* HAVE_INT64_T */
+
+#ifndef HAVE_UINT64_T
+#ifdef HAVE_UINT64
+typedef uint64 uint64_t;
+#elif SIZEOF_INT == 8
+typedef unsigned int uint64_t;
+#elif SIZEOF_LONG == 8
+typedef unsigned long uint64_t;
+#elif SIZEOF_LONG_LONG == 8
+#ifdef PHP_WIN32
+typedef unsigned __int64 uint64_t;
+#else
+typedef unsigned long long uint64_t;
+#endif
+#else
+#error "Neither int nor long nor long long is of 8 bytes width"
+#endif
+#endif /* HAVE_INT64_T */
+
+
+#ifdef PHP_WIN32
+#define MYSQLND_LLU_SPEC "%I64u"
+#define MYSQLND_LL_SPEC "%I64d"
+#define MYSQLND_SZ_T_SPEC "%Id"
+#ifndef L64
+#define L64(x) x##i64
+#endif
+#else
+
+#if __i386__
+#define MYSQLND_LL_SPEC	"%lli"
+#define MYSQLND_LLU_SPEC "%llu"
+#endif
+
+#if __ia64__
+#define MYSQLND_LL_SPEC	"%li"
+#define MYSQLND_LLU_SPEC "%lu"
+#endif
+
+#if __powerpc64__ || __ppc64__
+#define MYSQLND_LL_SPEC	"%li"
+#define MYSQLND_LLU_SPEC "%lu"
+#endif
+
+#if (__powerpc__ || __ppc__ ) && !(__powerpc64__ || __ppc64__)
+#define MYSQLND_LL_SPEC	"%lli"
+#define MYSQLND_LLU_SPEC "%llu"
+#endif
+
+#if __x86_64__
+#define MYSQLND_LL_SPEC	"%li"
+#define MYSQLND_LLU_SPEC "%lu"
+#endif
+
+#if __s390x__
+#define MYSQLND_LL_SPEC	"%li"
+#define MYSQLND_LLU_SPEC "%lu"
+#endif
+
+#if __s390__ && !__s390x__
+#define MYSQLND_LL_SPEC	"%lli"
+#define MYSQLND_LLU_SPEC "%llu"
+#endif
+
+#ifdef _AIX
+#define MYSQLND_LL_SPEC "%lli"
+#define MYSQLND_LLU_SPEC "%llu"
+#endif
+
+#ifndef MYSQLND_LL_SPEC
+  #if SIZEOF_LONG == 8
+    #define MYSQLND_LL_SPEC "%li"
+  #elif SIZEOF_LONG == 4
+    #define MYSQLND_LL_SPEC "%lli"
+  #endif
+#endif
+
+#ifndef MYSQLND_LLU_SPEC
+  #if SIZEOF_LONG == 8
+    #define MYSQLND_LLU_SPEC "%lu"
+  #elif SIZEOF_LONG == 4
+    #define MYSQLND_LLU_SPEC "%llu"
+   #endif
+#endif /* MYSQLND_LLU_SPEC*/
+
+
+#define MYSQLND_SZ_T_SPEC "%zd"
+#ifndef L64
+#define L64(x) x##LL
+#endif
+#endif
+
+
+#define int1store(T,A)	do { *((int8_t*) (T)) = (A); } while(0)
+#define uint1korr(A)	(*(((uint8_t*)(A))))
+
+/* Bit values are sent in reverted order of bytes, compared to normal !!! */
+#define bit_uint2korr(A) ((uint16_t) (((uint16_t) (((unsigned char*) (A))[1])) +\
+                                   ((uint16_t) (((unsigned char*) (A))[0]) << 8)))
+#define bit_uint3korr(A) ((uint32_t) (((uint32_t) (((unsigned char*) (A))[2])) +\
+                                   (((uint32_t) (((unsigned char*) (A))[1])) << 8) +\
+                                   (((uint32_t) (((unsigned char*) (A))[0])) << 16)))
+#define bit_uint4korr(A) ((uint32_t) (((uint32_t) (((unsigned char*) (A))[3])) +\
+                                   (((uint32_t) (((unsigned char*) (A))[2])) << 8) +\
+                                   (((uint32_t) (((unsigned char*) (A))[1])) << 16) +\
+                                   (((uint32_t) (((unsigned char*) (A))[0])) << 24)))
+#define bit_uint5korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[4])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[3])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[2])) << 16) +\
+                                   (((uint32_t) (((unsigned char*) (A))[1])) << 24)) +\
+                                    (((uint64_t) (((unsigned char*) (A))[0])) << 32))
+#define bit_uint6korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[5])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[4])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[3])) << 16) +\
+                                    (((uint32_t) (((unsigned char*) (A))[2])) << 24)) +\
+                        (((uint64_t) (((uint32_t) (((unsigned char*) (A))[1])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[0]) << 8)))) <<\
+                                     32))
+#define bit_uint7korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[6])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[5])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[4])) << 16) +\
+                                   (((uint32_t) (((unsigned char*) (A))[3])) << 24)) +\
+                        (((uint64_t) (((uint32_t) (((unsigned char*) (A))[2])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[1])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[0])) << 16))) <<\
+                                     32))
+#define bit_uint8korr(A) ((uint64_t)(((uint32_t) (((unsigned char*) (A))[7])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[6])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[5])) << 16) +\
+                                    (((uint32_t) (((unsigned char*) (A))[4])) << 24)) +\
+                        (((uint64_t) (((uint32_t) (((unsigned char*) (A))[3])) +\
+                                    (((uint32_t) (((unsigned char*) (A))[2])) << 8) +\
+                                    (((uint32_t) (((unsigned char*) (A))[1])) << 16) +\
+                                    (((uint32_t) (((unsigned char*) (A))[0])) << 24))) <<\
+                                    32))
+
+
+/*
+** Define-funktions for reading and storing in machine independent format
+**  (low byte first)
+*/
+
+/* Optimized store functions for Intel x86, non-valid for WIN64. __i386__ is GCC */
+#if defined(__i386__) && !defined(_WIN64)
+#define sint2korr(A)    (*((int16_t *) (A)))
+#define sint3korr(A)    ((int32_t) ((((zend_uchar) (A)[2]) & 128) ? \
+                   (((uint32_t) 255L << 24) | \
+                   (((uint32_t) (zend_uchar) (A)[2]) << 16) |\
+                   (((uint32_t) (zend_uchar) (A)[1]) << 8) | \
+                    ((uint32_t) (zend_uchar) (A)[0])) : \
+                   (((uint32_t) (zend_uchar) (A)[2]) << 16) |\
+                   (((uint32_t) (zend_uchar) (A)[1]) << 8) | \
+                    ((uint32_t) (zend_uchar) (A)[0])))
+#define sint4korr(A)  (*((long *) (A)))
+
+#define uint2korr(A)  (*((uint16_t *) (A)))
+#define uint3korr(A)  (uint32_t) (((uint32_t) ((zend_uchar) (A)[0])) +\
+                               (((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
+                               (((uint32_t) ((zend_uchar) (A)[2])) << 16))
+#define uint4korr(A)  (*((unsigned long *) (A)))
+
+
+
+#define uint8korr(A)    (*((uint64_t *) (A)))
+#define sint8korr(A)    (*((int64_t *) (A)))
+#define int2store(T,A)    *((uint16_t*) (T))= (uint16_t) (A)
+#define int3store(T,A)   { \
+                  *(T)=  (zend_uchar) ((A));\
+                  *(T+1)=(zend_uchar) (((uint32_t) (A) >> 8));\
+                  *(T+2)=(zend_uchar) (((A) >> 16)); }
+#define int4store(T,A)    *((long *) (T))= (long) (A)
+#define int5store(T,A)    { \
+              *((zend_uchar *)(T))= (zend_uchar)((A));\
+              *(((zend_uchar *)(T))+1)=(zend_uchar) (((A) >> 8));\
+              *(((zend_uchar *)(T))+2)=(zend_uchar) (((A) >> 16));\
+              *(((zend_uchar *)(T))+3)=(zend_uchar) (((A) >> 24)); \
+              *(((zend_uchar *)(T))+4)=(zend_uchar) (((A) >> 32)); }
+
+/* From Andrey Hristov, based on int5store() */
+#define int6store(T,A)    { \
+              *(((zend_uchar *)(T)))= (zend_uchar)((A));\
+              *(((zend_uchar *)(T))+1))=(zend_uchar) (((A) >> 8));\
+              *(((zend_uchar *)(T))+2))=(zend_uchar) (((A) >> 16));\
+              *(((zend_uchar *)(T))+3))=(zend_uchar) (((A) >> 24)); \
+              *(((zend_uchar *)(T))+4))=(zend_uchar) (((A) >> 32)); \
+              *(((zend_uchar *)(T))+5))=(zend_uchar) (((A) >> 40)); }
+
+#define int8store(T,A)    *((uint64_t *) (T))= (uint64_t) (A)
+
+typedef union {
+  double v;
+  long m[2];
+} float8get_union;
+#define float8get(V,M)    { ((float8get_union *)&(V))->m[0] = *((long*) (M)); \
+                            ((float8get_union *)&(V))->m[1] = *(((long*) (M))+1); }
+#define float8store(T,V) { *((long *) (T))     = ((float8get_union *)&(V))->m[0]; \
+                           *(((long *) (T))+1) = ((float8get_union *)&(V))->m[1]; }
+#define float4get(V,M)	{ *((float *) &(V)) = *((float*) (M)); }
+/* From Andrey Hristov based on float8get */
+#define floatget(V,M)    memcpy((char*) &(V),(char*) (M),sizeof(float))
+#endif /* __i386__ */ 
+
+
+/* If we haven't defined sint2korr, which is because the platform is not x86 or it's WIN64 */
+#ifndef sint2korr
+#define sint2korr(A)    (int16_t) (((int16_t) ((zend_uchar) (A)[0])) +\
+                                 ((int16_t) ((int16_t) (A)[1]) << 8))
+#define sint3korr(A)    ((int32_t) ((((zend_uchar) (A)[2]) & 128) ? \
+                  (((uint32_t) 255L << 24) | \
+                  (((uint32_t) (zend_uchar) (A)[2]) << 16) |\
+                  (((uint32_t) (zend_uchar) (A)[1]) << 8) | \
+                   ((uint32_t) (zend_uchar) (A)[0])) : \
+                  (((uint32_t) (zend_uchar) (A)[2]) << 16) |\
+                  (((uint32_t) (zend_uchar) (A)[1]) << 8) | \
+                  ((uint32_t) (zend_uchar) (A)[0])))
+#define sint4korr(A)  (int32_t) (((int32_t) ((zend_uchar) (A)[0])) +\
+                              (((int32_t) ((zend_uchar) (A)[1]) << 8)) +\
+                              (((int32_t) ((zend_uchar) (A)[2]) << 16)) +\
+                              (((int32_t) ((int16_t) (A)[3]) << 24)))
+
+#define sint8korr(A)  (int64_t) uint8korr(A)
+#define uint2korr(A)  (uint16_t) (((uint16_t) ((zend_uchar) (A)[0])) +\
+                               ((uint16_t) ((zend_uchar) (A)[1]) << 8))
+#define uint3korr(A)  (uint32_t) (((uint32_t) ((zend_uchar) (A)[0])) +\
+                               (((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
+                               (((uint32_t) ((zend_uchar) (A)[2])) << 16))
+#define uint4korr(A)  (uint32_t) (((uint32_t) ((zend_uchar) (A)[0])) +\
+                               (((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
+                               (((uint32_t) ((zend_uchar) (A)[2])) << 16) +\
+                               (((uint32_t) ((zend_uchar) (A)[3])) << 24))
+
+#define uint8korr(A)	((uint64_t)(((uint32_t) ((zend_uchar) (A)[0])) +\
+									(((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
+									(((uint32_t) ((zend_uchar) (A)[2])) << 16) +\
+									(((uint32_t) ((zend_uchar) (A)[3])) << 24)) +\
+									(((uint64_t) (((uint32_t) ((zend_uchar) (A)[4])) +\
+									(((uint32_t) ((zend_uchar) (A)[5])) << 8) +\
+									(((uint32_t) ((zend_uchar) (A)[6])) << 16) +\
+									(((uint32_t) ((zend_uchar) (A)[7])) << 24))) << 32))
+
+
+#define int2store(T,A)  do { uint32_t def_temp= (uint32_t) (A) ;\
+                  *((zend_uchar*) (T))  =  (zend_uchar)(def_temp); \
+                  *((zend_uchar*) (T+1)) = (zend_uchar)((def_temp >> 8)); } while (0)
+#define int3store(T,A)  do { /*lint -save -e734 */\
+                  *(((char *)(T)))   = (char) ((A));\
+                  *(((char *)(T))+1) = (char) (((A) >> 8));\
+                  *(((char *)(T))+2) = (char) (((A) >> 16)); \
+                  /*lint -restore */} while (0)
+#define int4store(T,A)  do { \
+                  *(((char *)(T)))   = (char) ((A));\
+                  *(((char *)(T))+1) = (char) (((A) >> 8));\
+                  *(((char *)(T))+2) = (char) (((A) >> 16));\
+                  *(((char *)(T))+3) = (char) (((A) >> 24)); } while (0)
+#define int5store(T,A)  do { \
+                  *(((char *)(T)))   = (char)((A));\
+                  *(((char *)(T))+1) = (char)(((A) >> 8));\
+                  *(((char *)(T))+2) = (char)(((A) >> 16));\
+                  *(((char *)(T))+3) = (char)(((A) >> 24)); \
+                  *(((char *)(T))+4) = (char)(((A) >> 32)); } while (0)
+/* Based on int5store() from Andrey Hristov */
+#define int6store(T,A)  do { \
+                  *(((char *)(T)))   = (char)((A));\
+                  *(((char *)(T))+1) = (char)(((A) >> 8));\
+                  *(((char *)(T))+2) = (char)(((A) >> 16));\
+                  *(((char *)(T))+3) = (char)(((A) >> 24)); \
+                  *(((char *)(T))+4) = (char)(((A) >> 32)); \
+                  *(((char *)(T))+5) = (char)(((A) >> 40)); } while (0)
+#define int8store(T,A)        { uint32_t def_temp= (uint32_t) (A), def_temp2= (uint32_t) ((A) >> 32); \
+                  int4store((T),def_temp); \
+                  int4store((T+4),def_temp2); \
+                }
+#ifdef WORDS_BIGENDIAN
+#define float4get(V,M)   do { float def_temp;\
+                          ((char*) &def_temp)[0] = (M)[3];\
+                          ((char*) &def_temp)[1] = (M)[2];\
+                          ((char*) &def_temp)[2] = (M)[1];\
+                          ((char*) &def_temp)[3] = (M)[0];\
+                          (V)=def_temp; } while (0)
+#define float8store(T,V)  do { \
+                           *(((char *)(T)))   = (char) ((char *) &(V))[7];\
+                           *(((char *)(T))+1) = (char) ((char *) &(V))[6];\
+                           *(((char *)(T))+2) = (char) ((char *) &(V))[5];\
+                           *(((char *)(T))+3) = (char) ((char *) &(V))[4];\
+                           *(((char *)(T))+4) = (char) ((char *) &(V))[3];\
+                           *(((char *)(T))+5) = (char) ((char *) &(V))[2];\
+                           *(((char *)(T))+6) = (char) ((char *) &(V))[1];\
+                           *(((char *)(T))+7) = (char) ((char *) &(V))[0]; } while (0)
+
+#define float8get(V,M)   do { double def_temp;\
+                          ((char*) &def_temp)[0] = (M)[7];\
+                          ((char*) &def_temp)[1] = (M)[6];\
+                          ((char*) &def_temp)[2] = (M)[5];\
+                          ((char*) &def_temp)[3] = (M)[4];\
+                          ((char*) &def_temp)[4] = (M)[3];\
+                          ((char*) &def_temp)[5] = (M)[2];\
+                          ((char*) &def_temp)[6] = (M)[1];\
+                          ((char*) &def_temp)[7] = (M)[0];\
+                          (V) = def_temp; \
+                         } while (0)
+#else
+#define float4get(V,M)   memcpy((char*) &(V),(char*) (M),sizeof(float))
+
+#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)
+#define float8store(T,V)  do { \
+                         *(((char *)(T)))= ((char *) &(V))[4];\
+                         *(((char *)(T))+1)=(char) ((char *) &(V))[5];\
+                         *(((char *)(T))+2)=(char) ((char *) &(V))[6];\
+                         *(((char *)(T))+3)=(char) ((char *) &(V))[7];\
+                         *(((char *)(T))+4)=(char) ((char *) &(V))[0];\
+                         *(((char *)(T))+5)=(char) ((char *) &(V))[1];\
+                         *(((char *)(T))+6)=(char) ((char *) &(V))[2];\
+                         *(((char *)(T))+7)=(char) ((char *) &(V))[3];} while (0)
+#define float8get(V,M) do { double def_temp;\
+                         ((char*) &def_temp)[0]=(M)[4];\
+                         ((char*) &def_temp)[1]=(M)[5];\
+                         ((char*) &def_temp)[2]=(M)[6];\
+                         ((char*) &def_temp)[3]=(M)[7];\
+                         ((char*) &def_temp)[4]=(M)[0];\
+                         ((char*) &def_temp)[5]=(M)[1];\
+                         ((char*) &def_temp)[6]=(M)[2];\
+                         ((char*) &def_temp)[7]=(M)[3];\
+                         (V) = def_temp; } while (0)
+#endif /* __FLOAT_WORD_ORDER */
+
+#endif /* WORDS_BIGENDIAN */
+
+#endif /* sint2korr */
+/* To here if the platform is not x86 or it's WIN64 */
+
+
+/* Define-funktions for reading and storing in machine format from/to
+   short/long to/from some place in memory V should be a (not
+   register) variable, M is a pointer to byte */
+
+#ifndef float8get
+
+#ifdef WORDS_BIGENDIAN
+#define float8get(V,M)		memcpy((char*) &(V),(char*)  (M), sizeof(double))
+#define float8store(T,V)	memcpy((char*)  (T),(char*) &(V), sizeof(double))
+#else
+#define float8get(V,M)    memcpy((char*) &(V),(char*) (M),sizeof(double))
+#define float8store(T,V)  memcpy((char*) (T),(char*) &(V),sizeof(double))
+#endif /* WORDS_BIGENDIAN */
+
+#endif /* float8get */
+
+#endif /* MYSQLND_PORTABILITY_H */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_priv.h
@@ -0,0 +1,194 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_PRIV_H
+#define MYSQLND_PRIV_H
+
+#ifndef Z_ADDREF_P
+/* PHP 5.2, old GC */
+#define Z_ADDREF_P(pz)				(++(pz)->refcount)
+#define Z_DELREF_P(pz)				(--(pz)->refcount)
+#define Z_REFCOUNT_P(pz)			((pz)->refcount)
+#define Z_SET_REFCOUNT_P(pz, rc)	((pz)->refcount = rc)
+#define Z_REFCOUNT_PP(ppz)			Z_REFCOUNT_P(*(ppz))
+#define Z_DELREF_PP(ppz)			Z_DELREF_P(*(ppz))
+#endif
+
+#if PHP_MAJOR_VERSION >= 6
+#define MYSQLND_UNICODE 1
+#else
+#define MYSQLND_UNICODE 0
+#endif
+
+#ifdef ZTS
+#include "TSRM.h"
+#endif
+
+#ifndef pestrndup
+#define pestrndup(s, length, persistent) ((persistent)?zend_strndup((s),(length)):estrndup((s),(length)))
+#endif
+
+#define MYSQLND_CLASS_METHOD_TABLE_NAME(class) mysqlnd_##class##_methods
+#define MYSQLND_CLASS_METHODS_START(class)	struct st_##class##_methods MYSQLND_CLASS_METHOD_TABLE_NAME(class) = {
+#define MYSQLND_CLASS_METHODS_END			}
+
+#if MYSQLND_UNICODE
+#define mysqlnd_array_init(arg, field_count) \
+{ \
+	ALLOC_HASHTABLE_REL(Z_ARRVAL_P(arg));\
+	zend_u_hash_init(Z_ARRVAL_P(arg), (field_count), NULL, ZVAL_PTR_DTOR, 0, 0);\
+	Z_TYPE_P(arg) = IS_ARRAY;\
+}
+#else
+#define mysqlnd_array_init(arg, field_count) \
+{ \
+	ALLOC_HASHTABLE_REL(Z_ARRVAL_P(arg));\
+	zend_hash_init(Z_ARRVAL_P(arg), (field_count), NULL, ZVAL_PTR_DTOR, 0); \
+	Z_TYPE_P(arg) = IS_ARRAY;\
+}
+#endif
+
+
+#define MYSQLND_DEBUG_DUMP_TIME				1
+#define MYSQLND_DEBUG_DUMP_TRACE			2
+#define MYSQLND_DEBUG_DUMP_PID				4
+#define MYSQLND_DEBUG_DUMP_LINE				8
+#define MYSQLND_DEBUG_DUMP_FILE				16
+#define MYSQLND_DEBUG_DUMP_LEVEL			32
+#define MYSQLND_DEBUG_APPEND				64
+#define MYSQLND_DEBUG_FLUSH					128
+#define MYSQLND_DEBUG_TRACE_MEMORY_CALLS	256
+#define MYSQLND_DEBUG_PROFILE_CALLS			512
+
+
+/* Client Error codes */
+#define CR_UNKNOWN_ERROR		2000
+#define CR_CONNECTION_ERROR		2002
+#define CR_SERVER_GONE_ERROR	2006
+#define CR_OUT_OF_MEMORY		2008
+#define CR_SERVER_LOST			2013
+#define CR_COMMANDS_OUT_OF_SYNC	2014
+#define CR_CANT_FIND_CHARSET	2019
+#define CR_MALFORMED_PACKET		2027
+#define CR_NOT_IMPLEMENTED		2054
+#define CR_NO_PREPARE_STMT		2030
+#define CR_PARAMS_NOT_BOUND		2031
+#define CR_INVALID_PARAMETER_NO	2034
+#define CR_INVALID_BUFFER_USE	2035
+
+#define MYSQLND_EE_FILENOTFOUND	 7890
+
+#define UNKNOWN_SQLSTATE		"HY000"
+
+#define MAX_CHARSET_LEN			32
+
+
+#define SET_ERROR_AFF_ROWS(s)	(s)->upsert_status.affected_rows = (uint64_t) ~0
+
+/* Error handling */
+#define SET_NEW_MESSAGE(buf, buf_len, message, len, persistent) \
+	{\
+		if ((buf)) { \
+			mnd_pefree((buf), (persistent)); \
+		} \
+		if ((message)) { \
+			(buf) = mnd_pestrndup((message), (len), (persistent)); \
+		} else { \
+			(buf) = NULL; \
+		} \
+		(buf_len) = (len); \
+	}
+
+#define SET_EMPTY_MESSAGE(buf, buf_len, persistent) \
+	{\
+		if ((buf)) { \
+			mnd_pefree((buf), (persistent)); \
+			(buf) = NULL; \
+		} \
+		(buf_len) = 0; \
+	}
+
+
+#define SET_EMPTY_ERROR(error_info) \
+	{ \
+		(error_info).error_no = 0; \
+		(error_info).error[0] = '\0'; \
+		strlcpy((error_info).sqlstate, "00000", sizeof((error_info).sqlstate)); \
+	}
+
+#define SET_CLIENT_ERROR(error_info, a, b, c) \
+	{ \
+		(error_info).error_no = (a); \
+		strlcpy((error_info).sqlstate, (b), sizeof((error_info).sqlstate)); \
+		strlcpy((error_info).error, (c), sizeof((error_info).error)); \
+	}
+
+#define SET_OOM_ERROR(error_info) SET_CLIENT_ERROR((error_info), CR_OUT_OF_MEMORY, UNKNOWN_SQLSTATE, mysqlnd_out_of_memory)
+
+
+#define SET_STMT_ERROR(stmt, a, b, c)	SET_CLIENT_ERROR((stmt)->error_info, a, b, c)
+
+#define CONN_GET_STATE(c)		(c)->m->get_state((c) TSRMLS_CC)
+#define CONN_SET_STATE(c, s)	(c)->m->set_state((c), (s) TSRMLS_CC)
+
+/* PS stuff */
+typedef void (*ps_field_fetch_func)(zval *zv, const MYSQLND_FIELD * const field,
+									unsigned int pack_len, zend_uchar **row,
+									zend_bool everything_as_unicode TSRMLS_DC);
+struct st_mysqlnd_perm_bind {
+	ps_field_fetch_func func;
+	/* should be signed int */
+	int					pack_len;
+	unsigned int		php_type;
+	zend_bool			is_possibly_blob;
+	zend_bool			can_ret_as_str_in_uni;
+};
+
+extern struct st_mysqlnd_perm_bind mysqlnd_ps_fetch_functions[MYSQL_TYPE_LAST + 1];
+
+PHPAPI extern const char * const mysqlnd_old_passwd;
+PHPAPI extern const char * const mysqlnd_out_of_sync;
+PHPAPI extern const char * const mysqlnd_server_gone;
+PHPAPI extern const char * const mysqlnd_out_of_memory;
+
+enum_func_status mysqlnd_handle_local_infile(MYSQLND *conn, const char *filename, zend_bool *is_warning TSRMLS_DC);
+
+
+
+void _mysqlnd_init_ps_subsystem();/* This one is private, mysqlnd_library_init() will call it */
+void _mysqlnd_init_ps_fetch_subsystem();
+
+void ps_fetch_from_1_to_8_bytes(zval *zv, const MYSQLND_FIELD * const field,
+								unsigned int pack_len, zend_uchar **row, zend_bool as_unicode,
+								unsigned int byte_count TSRMLS_DC);
+
+#endif	/* MYSQLND_PRIV_H */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_ps.c
@@ -0,0 +1,2446 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_result.h"
+#include "mysqlnd_result_meta.h"
+#include "mysqlnd_statistics.h"
+#include "mysqlnd_debug.h"
+#include "mysqlnd_block_alloc.h"
+
+
+#define MYSQLND_SILENT
+
+
+const char * const mysqlnd_not_bound_as_blob = "Can't send long data for non-string/non-binary data types";
+const char * const mysqlnd_stmt_not_prepared = "Statement not prepared";
+
+static struct st_mysqlnd_stmt_methods *mysqlnd_stmt_methods;
+
+/* Exported by mysqlnd_ps_codec.c */
+enum_func_status mysqlnd_stmt_execute_generate_request(MYSQLND_STMT * const s, zend_uchar ** request, size_t *request_len, zend_bool * free_buffer TSRMLS_DC);
+
+enum_func_status mysqlnd_stmt_fetch_row_buffered(MYSQLND_RES *result, void *param,
+												unsigned int flags,
+												zend_bool *fetched_anything TSRMLS_DC);
+
+enum_func_status mysqlnd_fetch_stmt_row_cursor(MYSQLND_RES *result, void *param,
+											   unsigned int flags,
+											   zend_bool *fetched_anything TSRMLS_DC);
+
+static void mysqlnd_stmt_separate_result_bind(MYSQLND_STMT * const stmt TSRMLS_DC);
+static void mysqlnd_stmt_separate_one_result_bind(MYSQLND_STMT * const stmt, unsigned int param_no TSRMLS_DC);
+
+/* {{{ mysqlnd_stmt::store_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_stmt, store_result)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	enum_func_status ret;
+	MYSQLND * conn;
+	MYSQLND_RES * result;
+	zend_bool to_cache = FALSE;
+
+	DBG_ENTER("mysqlnd_stmt::store_result");
+	if (!stmt || !stmt->conn || !stmt->result) {
+		DBG_RETURN(NULL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	conn = stmt->conn;
+
+	/* be compliant with libmysql - NULL will turn */
+	if (!stmt->field_count) {
+		DBG_RETURN(NULL);
+	}
+
+	if (stmt->cursor_exists) {
+		/* Silently convert buffered to unbuffered, for now */
+		DBG_RETURN(s->m->use_result(s TSRMLS_CC));
+	}
+
+	/* Nothing to store for UPSERT/LOAD DATA*/
+	if (CONN_GET_STATE(conn) != CONN_FETCHING_DATA ||
+		stmt->state != MYSQLND_STMT_WAITING_USE_OR_STORE)
+	{
+		SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC,
+						 UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_RETURN(NULL);
+	}
+
+	stmt->default_rset_handler = s->m->store_result;
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_PS_BUFFERED_SETS);
+
+	result = stmt->result;
+	result->type			= MYSQLND_RES_PS_BUF;
+	result->m.fetch_row		= mysqlnd_stmt_fetch_row_buffered;
+	result->m.fetch_lengths	= NULL;/* makes no sense */
+
+	result->result_set_memory_pool = mysqlnd_mempool_create(MYSQLND_G(mempool_default_size) TSRMLS_CC);
+
+	ret = result->m.store_result_fetch_data(conn, result, result->meta, TRUE, to_cache TSRMLS_CC);
+
+	if (PASS == ret) {
+		/* libmysql API docs say it should be so for SELECT statements */
+		stmt->upsert_status.affected_rows = stmt->result->stored_data->row_count;
+
+		stmt->state = MYSQLND_STMT_USE_OR_STORE_CALLED;
+	} else {
+		conn->error_info = result->stored_data->error_info;
+		stmt->result->m.free_result_contents(stmt->result TSRMLS_CC);
+		mnd_efree(stmt->result);
+		stmt->result = NULL;
+		stmt->state = MYSQLND_STMT_PREPARED;
+	}
+
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::get_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_stmt, get_result)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND * conn;
+	MYSQLND_RES *result;
+
+	DBG_ENTER("mysqlnd_stmt::get_result");
+	if (!stmt || !stmt->conn || !stmt->result) {
+		DBG_RETURN(NULL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	conn = stmt->conn;
+
+	/* be compliant with libmysql - NULL will turn */
+	if (!stmt->field_count) {
+		DBG_RETURN(NULL);
+	}
+
+	if (stmt->cursor_exists) {
+		/* Silently convert buffered to unbuffered, for now */
+		DBG_RETURN(s->m->use_result(s TSRMLS_CC));
+	}
+
+	/* Nothing to store for UPSERT/LOAD DATA*/
+	if (CONN_GET_STATE(conn) != CONN_FETCHING_DATA || stmt->state != MYSQLND_STMT_WAITING_USE_OR_STORE) {
+		SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC,
+						 UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_RETURN(NULL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_BUFFERED_SETS);
+
+	do {
+		result = conn->m->result_init(stmt->result->field_count, stmt->persistent TSRMLS_CC);
+		if (!result) {
+			SET_OOM_ERROR(stmt->conn->error_info);
+			break;
+		}
+
+		result->meta = stmt->result->meta->m->clone_metadata(stmt->result->meta, FALSE TSRMLS_CC);
+		if (!result->meta) {
+			SET_OOM_ERROR(stmt->conn->error_info);
+			break;
+		}
+
+		if ((result = result->m.store_result(result, conn, TRUE TSRMLS_CC))) {
+			stmt->upsert_status.affected_rows = result->stored_data->row_count;
+			stmt->state = MYSQLND_STMT_PREPARED;
+			result->type = MYSQLND_RES_PS_BUF;
+		} else {
+			stmt->error_info = conn->error_info;
+			stmt->state = MYSQLND_STMT_PREPARED;
+			break;
+		}
+		DBG_RETURN(result);
+	} while (0);
+
+	if (result) {
+		result->m.free_result(result, TRUE TSRMLS_CC);
+	}
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::more_results */
+static zend_bool
+MYSQLND_METHOD(mysqlnd_stmt, more_results)(const MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::more_results");
+	/* (conn->state == CONN_NEXT_RESULT_PENDING) too */
+	DBG_RETURN((stmt && stmt->conn && (stmt->conn->upsert_status.server_status &
+							   SERVER_MORE_RESULTS_EXISTS))?
+									TRUE:
+									FALSE);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::next_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, next_result)(MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND * conn;
+
+	DBG_ENTER("mysqlnd_stmt::next_result");
+	if (!stmt || !stmt->conn || !stmt->result) {
+		DBG_RETURN(FAIL);
+	}
+	conn = stmt->conn;
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	if (CONN_GET_STATE(conn) != CONN_NEXT_RESULT_PENDING || !(conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS)) {
+		DBG_RETURN(FAIL);
+	}
+
+	DBG_INF_FMT("server_status=%u cursor=%u", stmt->upsert_status.server_status, stmt->upsert_status.server_status & SERVER_STATUS_CURSOR_EXISTS);
+	DBG_INF_FMT("server_status=%u cursor=%u", conn->upsert_status.server_status, conn->upsert_status.server_status & SERVER_STATUS_CURSOR_EXISTS);
+
+	/* Free space for next result */
+	s->m->free_stmt_content(s TSRMLS_CC);
+	{
+		enum_func_status ret = s->m->parse_execute_response(s TSRMLS_CC);
+		DBG_RETURN(ret);
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_skip_metadata */
+static enum_func_status
+mysqlnd_stmt_skip_metadata(MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	/* Follows parameter metadata, we have just to skip it, as libmysql does */
+	unsigned int i = 0;
+	enum_func_status ret = FAIL;
+	MYSQLND_PACKET_RES_FIELD * field_packet;
+
+	DBG_ENTER("mysqlnd_stmt_skip_metadata");
+	if (!stmt || !stmt->conn || !stmt->conn->protocol) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	field_packet = stmt->conn->protocol->m.get_result_field_packet(stmt->conn->protocol, FALSE TSRMLS_CC);
+	if (!field_packet) {
+		SET_OOM_ERROR(stmt->error_info);
+		SET_OOM_ERROR(stmt->conn->error_info);
+	} else {
+		ret = PASS;
+		field_packet->skip_parsing = TRUE;
+		for (;i < stmt->param_count; i++) {
+			if (FAIL == PACKET_READ(field_packet, stmt->conn)) {
+				ret = FAIL;
+				break;
+			}
+		}
+		PACKET_FREE(field_packet);
+	}
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_read_prepare_response */
+static enum_func_status
+mysqlnd_stmt_read_prepare_response(MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_PACKET_PREPARE_RESPONSE * prepare_resp;
+	enum_func_status ret = FAIL;
+
+	DBG_ENTER("mysqlnd_stmt_read_prepare_response");
+	if (!stmt || !stmt->conn || !stmt->conn->protocol) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	prepare_resp = stmt->conn->protocol->m.get_prepare_response_packet(stmt->conn->protocol, FALSE TSRMLS_CC);
+	if (!prepare_resp) {
+		SET_OOM_ERROR(stmt->error_info);
+		SET_OOM_ERROR(stmt->conn->error_info);
+		goto done;
+	}
+
+	if (FAIL == PACKET_READ(prepare_resp, stmt->conn)) {
+		goto done;
+	}
+
+	if (0xFF == prepare_resp->error_code) {
+		stmt->error_info = stmt->conn->error_info = prepare_resp->error_info;
+		goto done;
+	}
+	ret = PASS;
+	stmt->stmt_id = prepare_resp->stmt_id;
+	stmt->warning_count = stmt->conn->upsert_status.warning_count = prepare_resp->warning_count;
+	stmt->field_count = stmt->conn->field_count = prepare_resp->field_count;
+	stmt->param_count = prepare_resp->param_count;
+done:
+	PACKET_FREE(prepare_resp);
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_prepare_read_eof */
+static enum_func_status
+mysqlnd_stmt_prepare_read_eof(MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_PACKET_EOF * fields_eof;
+	enum_func_status ret = FAIL;
+
+	DBG_ENTER("mysqlnd_stmt_prepare_read_eof");
+	if (!stmt || !stmt->conn || !stmt->conn->protocol) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	fields_eof = stmt->conn->protocol->m.get_eof_packet(stmt->conn->protocol, FALSE TSRMLS_CC);
+	if (!fields_eof) {
+		SET_OOM_ERROR(stmt->error_info);
+		SET_OOM_ERROR(stmt->conn->error_info);
+	} else {
+		if (FAIL == (ret = PACKET_READ(fields_eof, stmt->conn))) {
+			if (stmt->result) {
+				stmt->result->m.free_result_contents(stmt->result TSRMLS_CC);
+				mnd_efree(stmt->result);
+				memset(stmt, 0, sizeof(MYSQLND_STMT_DATA));
+				stmt->state = MYSQLND_STMT_INITTED;
+			}
+		} else {
+			stmt->upsert_status.server_status = fields_eof->server_status;
+			stmt->upsert_status.warning_count = fields_eof->warning_count;
+			stmt->state = MYSQLND_STMT_PREPARED;
+		}
+		PACKET_FREE(fields_eof);
+	}
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::prepare */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, prepare)(MYSQLND_STMT * const s, const char * const query, unsigned int query_len TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_STMT * s_to_prepare = s;
+	MYSQLND_STMT_DATA * stmt_to_prepare = stmt;
+
+	DBG_ENTER("mysqlnd_stmt::prepare");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	SET_ERROR_AFF_ROWS(stmt);
+	SET_ERROR_AFF_ROWS(stmt->conn);
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->state > MYSQLND_STMT_INITTED) {
+		/* See if we have to clean the wire */
+		if (stmt->state == MYSQLND_STMT_WAITING_USE_OR_STORE) {
+			/* Do implicit use_result and then flush the result */
+			stmt->default_rset_handler = s->m->use_result;
+			stmt->default_rset_handler(s TSRMLS_CC);
+		}
+		/* No 'else' here please :) */
+		if (stmt->state > MYSQLND_STMT_WAITING_USE_OR_STORE && stmt->result) {
+			stmt->result->m.skip_result(stmt->result TSRMLS_CC);
+		}
+		/*
+		  Create a new test statement, which we will prepare, but if anything
+		  fails, we will scrap it.
+		*/
+		s_to_prepare = stmt->conn->m->stmt_init(stmt->conn TSRMLS_CC);
+		if (!s_to_prepare) {
+			goto fail;
+		}
+		stmt_to_prepare = s_to_prepare->data;
+	}
+
+	if (FAIL == stmt_to_prepare->conn->m->simple_command(stmt_to_prepare->conn, COM_STMT_PREPARE, query, query_len, PROT_LAST, FALSE, TRUE TSRMLS_CC) ||
+		FAIL == mysqlnd_stmt_read_prepare_response(s_to_prepare TSRMLS_CC))
+	{
+		goto fail;
+	}
+
+	if (stmt_to_prepare->param_count) {
+		if (FAIL == mysqlnd_stmt_skip_metadata(s_to_prepare TSRMLS_CC) ||
+			FAIL == mysqlnd_stmt_prepare_read_eof(s_to_prepare TSRMLS_CC))
+		{
+			goto fail;
+		}
+	}
+
+	/*
+	  Read metadata only if there is actual result set.
+	  Beware that SHOW statements bypass the PS framework and thus they send
+	  no metadata at prepare.
+	*/
+	if (stmt_to_prepare->field_count) {
+		MYSQLND_RES * result = stmt->conn->m->result_init(stmt_to_prepare->field_count, stmt_to_prepare->persistent TSRMLS_CC);
+		if (!result) {
+			SET_OOM_ERROR(stmt->conn->error_info);
+			goto fail;
+		}
+		/* Allocate the result now as it is needed for the reading of metadata */
+		stmt_to_prepare->result = result; 
+
+		result->conn = stmt_to_prepare->conn->m->get_reference(stmt_to_prepare->conn TSRMLS_CC);
+
+		result->type = MYSQLND_RES_PS_BUF;
+
+		if (FAIL == result->m.read_result_metadata(result, stmt_to_prepare->conn TSRMLS_CC) ||
+			FAIL == mysqlnd_stmt_prepare_read_eof(s_to_prepare TSRMLS_CC))
+		{
+			goto fail;
+		}
+	}
+
+	if (stmt_to_prepare != stmt) {
+		/* swap */
+		size_t real_size = sizeof(MYSQLND_STMT) + mysqlnd_plugin_count() * sizeof(void *);
+		char * tmp_swap = mnd_malloc(real_size);
+		memcpy(tmp_swap, s, real_size);
+		memcpy(s, s_to_prepare, real_size);
+		memcpy(s_to_prepare, tmp_swap, real_size);
+		mnd_free(tmp_swap);
+		{
+			MYSQLND_STMT_DATA * tmp_swap_data = stmt_to_prepare;
+			stmt_to_prepare = stmt;
+			stmt = tmp_swap_data;
+		}
+		s_to_prepare->m->dtor(s_to_prepare, TRUE TSRMLS_CC);
+	}
+	stmt->state = MYSQLND_STMT_PREPARED;
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+
+fail:
+	if (stmt_to_prepare != stmt && s_to_prepare) {
+		s_to_prepare->m->dtor(s_to_prepare, TRUE TSRMLS_CC);
+	}
+	stmt->state = MYSQLND_STMT_INITTED;
+
+	DBG_INF("FAIL");
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_execute_parse_response */
+static enum_func_status
+mysqlnd_stmt_execute_parse_response(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	enum_func_status ret;
+	MYSQLND	* conn;
+
+	DBG_ENTER("mysqlnd_stmt_execute_parse_response");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	conn = stmt->conn;
+	CONN_SET_STATE(conn, CONN_QUERY_SENT);
+
+	ret = mysqlnd_query_read_result_set_header(stmt->conn, s TSRMLS_CC);
+	if (ret == FAIL) {
+		stmt->error_info = conn->error_info;
+		stmt->upsert_status.affected_rows = conn->upsert_status.affected_rows;
+		if (CONN_GET_STATE(conn) == CONN_QUIT_SENT) {
+			/* close the statement here, the connection has been closed */
+		}
+		stmt->state = MYSQLND_STMT_PREPARED;
+		stmt->send_types_to_server = 1;
+	} else {
+		/*
+		  stmt->send_types_to_server has already been set to 0 in
+		  mysqlnd_stmt_execute_generate_request / mysqlnd_stmt_execute_store_params
+		  In case there is a situation in which binding was done for integer and the
+		  value is > LONG_MAX or < LONG_MIN, there is string conversion and we have
+		  to resend the types. Next execution will also need to resend the type.
+		*/
+		SET_EMPTY_ERROR(stmt->error_info);
+		SET_EMPTY_ERROR(stmt->conn->error_info);
+		stmt->upsert_status = conn->upsert_status;
+		stmt->state = MYSQLND_STMT_EXECUTED;
+		if (conn->last_query_type == QUERY_UPSERT || conn->last_query_type == QUERY_LOAD_LOCAL) {
+			DBG_INF("PASS");
+			DBG_RETURN(PASS);
+		}
+
+		stmt->result->type = MYSQLND_RES_PS_BUF;
+		if (!stmt->result->conn) {
+			/*
+			  For SHOW we don't create (bypasses PS in server)
+			  a result set at prepare and thus a connection was missing
+			*/
+			stmt->result->conn = stmt->conn->m->get_reference(stmt->conn TSRMLS_CC);
+		}
+
+		/* Update stmt->field_count as SHOW sets it to 0 at prepare */
+		stmt->field_count = stmt->result->field_count = conn->field_count;
+		stmt->result->lengths = NULL;
+		if (stmt->field_count) {
+			stmt->state = MYSQLND_STMT_WAITING_USE_OR_STORE;
+			/*
+			  We need to set this because the user might not call
+			  use_result() or store_result() and we should be able to scrap the
+			  data on the line, if he just decides to close the statement.
+			*/
+			DBG_INF_FMT("server_status=%u cursor=%u", stmt->upsert_status.server_status,
+						stmt->upsert_status.server_status & SERVER_STATUS_CURSOR_EXISTS);
+
+			if (stmt->upsert_status.server_status & SERVER_STATUS_CURSOR_EXISTS) {
+				DBG_INF("cursor exists");
+				stmt->cursor_exists = TRUE;
+				CONN_SET_STATE(conn, CONN_READY);
+				/* Only cursor read */
+				stmt->default_rset_handler = s->m->use_result;
+				DBG_INF("use_result");
+			} else if (stmt->flags & CURSOR_TYPE_READ_ONLY) {
+				DBG_INF("asked for cursor but got none");
+				/*
+				  We have asked for CURSOR but got no cursor, because the condition
+				  above is not fulfilled. Then...
+
+				  This is a single-row result set, a result set with no rows, EXPLAIN,
+				  SHOW VARIABLES, or some other command which either a) bypasses the
+				  cursors framework in the server and writes rows directly to the
+				  network or b) is more efficient if all (few) result set rows are
+				  precached on client and server's resources are freed.
+				*/
+				/* preferred is buffered read */
+				stmt->default_rset_handler = s->m->store_result;
+				DBG_INF("store_result");
+			} else {
+				DBG_INF("no cursor");
+				/* preferred is unbuffered read */
+				stmt->default_rset_handler = s->m->use_result;
+				DBG_INF("use_result");
+			}
+		}
+	}
+#ifndef MYSQLND_DONT_SKIP_OUT_PARAMS_RESULTSET
+	if (stmt->upsert_status.server_status & SERVER_PS_OUT_PARAMS) {
+		s->m->free_stmt_content(s TSRMLS_CC);
+		DBG_INF("PS OUT Variable RSet, skipping");
+		/* OUT params result set. Skip for now to retain compatibility */
+		ret = mysqlnd_stmt_execute_parse_response(s TSRMLS_CC);
+	}
+#endif
+
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::execute */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, execute)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	enum_func_status ret;
+	MYSQLND *	conn;
+	zend_uchar *request = NULL;
+	size_t		request_len;
+	zend_bool	free_request;
+
+	DBG_ENTER("mysqlnd_stmt::execute");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	conn = stmt->conn;
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	SET_ERROR_AFF_ROWS(stmt);
+	SET_ERROR_AFF_ROWS(stmt->conn);
+
+	if (stmt->result && stmt->state >= MYSQLND_STMT_PREPARED && stmt->field_count) {
+		/*
+		  We don need to copy the data from the buffers which we will clean.
+		  Because it has already been copied. See
+		  #ifndef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+		*/
+#ifdef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+		if (stmt->result_bind &&
+			stmt->result_zvals_separated_once == TRUE && 
+			stmt->state >= MYSQLND_STMT_USER_FETCHING)
+		{
+			/*
+			  We need to copy the data from the buffers which we will clean.
+			  The bound variables point to them only if the user has started
+			  to fetch data (MYSQLND_STMT_USER_FETCHING).
+			  We need to check 'result_zvals_separated_once' or we will leak
+			  in the following scenario
+			  prepare("select 1 from dual");
+			  execute();
+			  fetch(); <-- no binding, but that's not a problem
+			  bind_result();
+			  execute(); <-- here we will leak because we separate without need
+			*/
+			unsigned int i;
+			for (i = 0; i < stmt->field_count; i++) {
+				if (stmt->result_bind[i].bound == TRUE) {
+					zval_copy_ctor(stmt->result_bind[i].zv);
+				}
+			}
+		}
+#endif
+
+		/*
+		  If right after execute() we have to call the appropriate
+		  use_result() or store_result() and clean.
+		*/
+		if (stmt->state == MYSQLND_STMT_WAITING_USE_OR_STORE) {
+			DBG_INF("fetching result set header");
+			/* Do implicit use_result and then flush the result */
+			stmt->default_rset_handler = s->m->use_result;
+			stmt->default_rset_handler(s TSRMLS_CC);
+		}
+
+		if (stmt->state > MYSQLND_STMT_WAITING_USE_OR_STORE) {
+			DBG_INF("skipping result");
+			/* Flush if anything is left and unbuffered set */
+			stmt->result->m.skip_result(stmt->result TSRMLS_CC);
+		}
+
+		if (stmt->state > MYSQLND_STMT_PREPARED) {
+			/* As the buffers have been freed, we should go back to PREPARED */
+			stmt->state = MYSQLND_STMT_PREPARED;
+		}
+
+		/*
+		  Executed, but the user hasn't started to fetch
+		  This will clean also the metadata, but after the EXECUTE call we will
+		  have it again.
+		*/
+		stmt->result->m.free_result_buffers(stmt->result TSRMLS_CC);
+	} else if (stmt->state < MYSQLND_STMT_PREPARED) {
+		/* Only initted - error */
+		SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE,
+						 mysqlnd_out_of_sync);
+		SET_STMT_ERROR(stmt, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_INF("FAIL");
+		DBG_RETURN(FAIL);
+	}
+
+	if (stmt->param_count) {
+		unsigned int i, not_bound = 0;
+		if (!stmt->param_bind) {
+			SET_STMT_ERROR(stmt, CR_PARAMS_NOT_BOUND, UNKNOWN_SQLSTATE,
+							 "No data supplied for parameters in prepared statement");
+			DBG_INF("FAIL");
+			DBG_RETURN(FAIL);
+		}
+		for (i = 0; i < stmt->param_count; i++) {
+			if (stmt->param_bind[i].zv == NULL) {
+				not_bound++;
+			}
+		}
+		if (not_bound) {
+			char * msg;
+			spprintf(&msg, 0, "No data supplied for %u parameter%s in prepared statement",
+					 not_bound, not_bound>1 ?"s":"");
+			SET_STMT_ERROR(stmt, CR_PARAMS_NOT_BOUND, UNKNOWN_SQLSTATE, msg);
+			if (msg) {
+				efree(msg); /* allocated by spprintf */
+			}
+			DBG_INF("FAIL");
+			DBG_RETURN(FAIL);
+		}
+	}
+	ret = s->m->generate_execute_request(s, &request, &request_len, &free_request TSRMLS_CC);
+	if (ret == PASS) {
+		/* support for buffer types should be added here ! */
+		ret = stmt->conn->m->simple_command(stmt->conn, COM_STMT_EXECUTE, (char *)request, request_len,
+											PROT_LAST /* we will handle the response packet*/,
+											FALSE, FALSE TSRMLS_CC);
+	} else {
+		SET_STMT_ERROR(stmt, CR_UNKNOWN_ERROR, UNKNOWN_SQLSTATE, "Couldn't generate the request. Possibly OOM.");
+	}
+
+	if (free_request) {
+		mnd_efree(request);
+	}
+
+	if (ret == FAIL) {
+		stmt->error_info = conn->error_info;
+		DBG_INF("FAIL");
+		DBG_RETURN(FAIL);
+	}
+	stmt->execute_count++;
+
+	ret = s->m->parse_execute_response(s TSRMLS_CC);
+
+	DBG_INF_FMT("server_status=%u cursor=%u", stmt->upsert_status.server_status, stmt->upsert_status.server_status & SERVER_STATUS_CURSOR_EXISTS);
+
+	if (ret == PASS && conn->last_query_type == QUERY_UPSERT && stmt->upsert_status.affected_rows) {
+		MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn->stats, STAT_ROWS_AFFECTED_PS, stmt->upsert_status.affected_rows);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_fetch_row_buffered */
+enum_func_status
+mysqlnd_stmt_fetch_row_buffered(MYSQLND_RES *result, void *param, unsigned int flags, zend_bool *fetched_anything TSRMLS_DC)
+{
+	MYSQLND_STMT * s = (MYSQLND_STMT *) param;
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_RES_BUFFERED *set = result->stored_data;
+	unsigned int field_count = result->meta->field_count;
+
+	DBG_ENTER("mysqlnd_stmt_fetch_row_buffered");
+	*fetched_anything = FALSE;
+	DBG_INF_FMT("stmt=%lu", stmt != NULL ? stmt->stmt_id : 0L);
+
+	/* If we haven't read everything */
+	if (set->data_cursor &&
+		(set->data_cursor - set->data) < (set->row_count * field_count))
+	{
+		/* The user could have skipped binding - don't crash*/
+		if (stmt->result_bind) {
+			unsigned int i;
+			MYSQLND_RES_METADATA * meta = result->meta;
+			zval **current_row = set->data_cursor;
+
+			if (NULL == current_row[0]) {
+				uint64_t row_num = (set->data_cursor - set->data) / field_count;
+				enum_func_status rc = result->m.row_decoder(set->row_buffers[row_num],
+												current_row,
+												meta->field_count,
+												meta->fields,
+												result->stored_data->persistent,
+												result->conn->options.numeric_and_datetime_as_unicode,
+												result->conn->options.int_and_float_native,
+												result->conn->stats TSRMLS_CC);
+				if (PASS != rc) {
+					DBG_RETURN(FAIL);
+				}
+				set->initialized_rows++;
+				if (stmt->update_max_length) {
+					for (i = 0; i < result->field_count; i++) {
+						/*
+						  NULL fields are 0 length, 0 is not more than 0
+						  String of zero size, definitely can't be the next max_length.
+						  Thus for NULL and zero-length we are quite efficient.
+						*/
+						if (Z_TYPE_P(current_row[i]) >= IS_STRING) {
+							unsigned long len = Z_STRLEN_P(current_row[i]);
+							if (meta->fields[i].max_length < len) {
+								meta->fields[i].max_length = len;
+							}
+						}
+					}
+				}
+			}
+
+			for (i = 0; i < result->field_count; i++) {
+				/* Clean what we copied last time */
+#ifndef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+				if (stmt->result_bind[i].zv) {
+					zval_dtor(stmt->result_bind[i].zv);
+				}
+#endif
+				/* copy the type */
+				if (stmt->result_bind[i].bound == TRUE) {
+					DBG_INF_FMT("i=%u type=%u", i, Z_TYPE_P(current_row[i]));
+					if (Z_TYPE_P(current_row[i]) != IS_NULL) {
+						/*
+						  Copy the value.
+						  Pre-condition is that the zvals in the result_bind buffer
+						  have been  ZVAL_NULL()-ed or to another simple type
+						  (int, double, bool but not string). Because of the reference
+						  counting the user can't delete the strings the variables point to.
+						*/
+
+						Z_TYPE_P(stmt->result_bind[i].zv) = Z_TYPE_P(current_row[i]);
+						stmt->result_bind[i].zv->value = current_row[i]->value;
+#ifndef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+						zval_copy_ctor(stmt->result_bind[i].zv);
+#endif
+					} else {
+						ZVAL_NULL(stmt->result_bind[i].zv);
+					}
+				}
+			}
+		}
+		set->data_cursor += field_count;
+		*fetched_anything = TRUE;
+		/* buffered result sets don't have a connection */
+		MYSQLND_INC_GLOBAL_STATISTIC(STAT_ROWS_FETCHED_FROM_CLIENT_PS_BUF);
+		DBG_INF("row fetched");
+	} else {
+		set->data_cursor = NULL;
+		DBG_INF("no more data");
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_fetch_row_unbuffered */
+static enum_func_status
+mysqlnd_stmt_fetch_row_unbuffered(MYSQLND_RES *result, void *param, unsigned int flags, zend_bool *fetched_anything TSRMLS_DC)
+{
+	enum_func_status ret;
+	MYSQLND_STMT * s = (MYSQLND_STMT *) param;
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_PACKET_ROW * row_packet;
+
+	DBG_ENTER("mysqlnd_stmt_fetch_row_unbuffered");
+
+	*fetched_anything = FALSE;
+
+	if (result->unbuf->eof_reached) {
+		/* No more rows obviously */
+		DBG_INF("eof reached");
+		DBG_RETURN(PASS);
+	}
+	if (CONN_GET_STATE(result->conn) != CONN_FETCHING_DATA) {
+		SET_CLIENT_ERROR(result->conn->error_info, CR_COMMANDS_OUT_OF_SYNC,
+						 UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_ERR("command out of sync");
+		DBG_RETURN(FAIL);
+	}
+	if (!(row_packet = result->row_packet)) {
+		DBG_RETURN(FAIL);
+	}
+
+	/* Let the row packet fill our buffer and skip additional malloc + memcpy */
+	row_packet->skip_extraction = stmt && stmt->result_bind? FALSE:TRUE;
+
+	/*
+	  If we skip rows (stmt == NULL || stmt->result_bind == NULL) we have to
+	  result->m.unbuffered_free_last_data() before it. The function returns always true.
+	*/
+	if (PASS == (ret = PACKET_READ(row_packet, result->conn)) && !row_packet->eof) {
+		unsigned int i, field_count = result->field_count;
+
+		if (!row_packet->skip_extraction) {
+			result->m.unbuffered_free_last_data(result TSRMLS_CC);
+
+			DBG_INF("extracting data");
+			result->unbuf->last_row_data = row_packet->fields;
+			result->unbuf->last_row_buffer = row_packet->row_buffer;
+			row_packet->fields = NULL;
+			row_packet->row_buffer = NULL;
+
+			if (PASS != result->m.row_decoder(result->unbuf->last_row_buffer,
+									result->unbuf->last_row_data,
+									row_packet->field_count,
+									row_packet->fields_metadata,
+									FALSE,
+									result->conn->options.numeric_and_datetime_as_unicode,
+									result->conn->options.int_and_float_native,
+									result->conn->stats TSRMLS_CC))
+			{
+				DBG_RETURN(FAIL);
+			}
+
+			for (i = 0; i < field_count; i++) {
+				if (stmt->result_bind[i].bound == TRUE) {
+					zval *data = result->unbuf->last_row_data[i];
+					/*
+					  stmt->result_bind[i].zv has been already destructed
+					  in result->m.unbuffered_free_last_data()
+					*/
+#ifndef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+					zval_dtor(stmt->result_bind[i].zv);
+#endif
+					if (IS_NULL != (Z_TYPE_P(stmt->result_bind[i].zv) = Z_TYPE_P(data)) ) {
+						if (
+							(Z_TYPE_P(data) == IS_STRING
+#if MYSQLND_UNICODE
+							|| Z_TYPE_P(data) == IS_UNICODE
+#endif
+							)
+							 && (result->meta->fields[i].max_length < (unsigned long) Z_STRLEN_P(data)))
+						{
+							result->meta->fields[i].max_length = Z_STRLEN_P(data);
+						}
+						stmt->result_bind[i].zv->value = data->value;
+						/* copied data, thus also the ownership. Thus null data */
+						ZVAL_NULL(data);
+					}
+				}
+			}
+			MYSQLND_INC_CONN_STATISTIC(stmt->conn->stats, STAT_ROWS_FETCHED_FROM_CLIENT_PS_UNBUF);
+		} else {
+			DBG_INF("skipping extraction");
+			/*
+			  Data has been allocated and usually result->m.unbuffered_free_last_data()
+			  frees it but we can't call this function as it will cause problems with
+			  the bound variables. Thus we need to do part of what it does or Zend will
+			  report leaks.
+			*/
+			row_packet->row_buffer->free_chunk(row_packet->row_buffer TSRMLS_CC);
+			row_packet->row_buffer = NULL;
+		}
+
+		result->unbuf->row_count++;
+		*fetched_anything = TRUE;
+	} else if (ret == FAIL) {
+		if (row_packet->error_info.error_no) {
+			stmt->conn->error_info = row_packet->error_info; 
+			stmt->error_info = row_packet->error_info; 
+		}
+		CONN_SET_STATE(result->conn, CONN_READY);
+		result->unbuf->eof_reached = TRUE; /* so next time we won't get an error */
+	} else if (row_packet->eof) {
+		DBG_INF("EOF");
+		/* Mark the connection as usable again */
+		result->unbuf->eof_reached = TRUE;
+		result->conn->upsert_status.warning_count = row_packet->warning_count;
+		result->conn->upsert_status.server_status = row_packet->server_status;
+		/*
+		  result->row_packet will be cleaned when
+		  destroying the result object
+		*/
+		if (result->conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS) {
+			CONN_SET_STATE(result->conn, CONN_NEXT_RESULT_PENDING);
+		} else {
+			CONN_SET_STATE(result->conn, CONN_READY);
+		}
+	}
+
+	DBG_INF_FMT("ret=%s fetched_anything=%u", ret == PASS? "PASS":"FAIL", *fetched_anything);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::use_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_stmt, use_result)(MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_RES *result;
+	MYSQLND * conn;
+
+	DBG_ENTER("mysqlnd_stmt::use_result");
+	if (!stmt || !stmt->conn || !stmt->result) {
+		DBG_RETURN(NULL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	conn = stmt->conn;
+
+	if (!stmt->field_count ||
+		(!stmt->cursor_exists && CONN_GET_STATE(conn) != CONN_FETCHING_DATA) ||
+		(stmt->cursor_exists && CONN_GET_STATE(conn) != CONN_READY) ||
+		(stmt->state != MYSQLND_STMT_WAITING_USE_OR_STORE))
+	{
+		SET_CLIENT_ERROR(conn->error_info, CR_COMMANDS_OUT_OF_SYNC,
+						 UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_ERR("command out of sync");
+		DBG_RETURN(NULL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+
+	MYSQLND_INC_CONN_STATISTIC(stmt->conn->stats, STAT_PS_UNBUFFERED_SETS);
+	result = stmt->result;
+
+	DBG_INF_FMT("%scursor exists", stmt->cursor_exists? "":"no ");
+	result->m.use_result(stmt->result, TRUE TSRMLS_CC);
+	result->m.fetch_row	= stmt->cursor_exists? mysqlnd_fetch_stmt_row_cursor:
+											   mysqlnd_stmt_fetch_row_unbuffered;
+	stmt->state = MYSQLND_STMT_USE_OR_STORE_CALLED;
+
+	DBG_INF_FMT("%p", result);
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+#define STMT_ID_LENGTH 4
+
+/* {{{ mysqlnd_fetch_row_cursor */
+enum_func_status
+mysqlnd_fetch_stmt_row_cursor(MYSQLND_RES *result, void *param, unsigned int flags, zend_bool *fetched_anything TSRMLS_DC)
+{
+	enum_func_status ret;
+	MYSQLND_STMT * s = (MYSQLND_STMT *) param;
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	zend_uchar buf[STMT_ID_LENGTH /* statement id */ + 4 /* number of rows to fetch */];
+	MYSQLND_PACKET_ROW * row_packet;
+
+	DBG_ENTER("mysqlnd_fetch_stmt_row_cursor");
+
+	if (!stmt || !stmt->conn || !result || !result->conn || !result->unbuf) {
+		DBG_ERR("no statement");
+		DBG_RETURN(FAIL);
+	}
+
+	DBG_INF_FMT("stmt=%lu flags=%u", stmt->stmt_id, flags);
+
+	if (stmt->state < MYSQLND_STMT_USER_FETCHING) {
+		/* Only initted - error */
+		SET_CLIENT_ERROR(stmt->conn->error_info, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE,
+						mysqlnd_out_of_sync);
+		DBG_ERR("command out of sync");
+		DBG_RETURN(FAIL);
+	}
+	if (!(row_packet = result->row_packet)) {
+		DBG_RETURN(FAIL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	int4store(buf, stmt->stmt_id);
+	int4store(buf + STMT_ID_LENGTH, 1); /* for now fetch only one row */
+
+	if (FAIL == stmt->conn->m->simple_command(stmt->conn, COM_STMT_FETCH, (char *)buf, sizeof(buf),
+											  PROT_LAST /* we will handle the response packet*/,
+											  FALSE, TRUE TSRMLS_CC)) {
+		stmt->error_info = stmt->conn->error_info;
+		DBG_RETURN(FAIL);
+	}
+
+	row_packet->skip_extraction = stmt->result_bind? FALSE:TRUE;
+
+	if (PASS == (ret = PACKET_READ(row_packet, result->conn)) && !row_packet->eof) {
+		unsigned int i, field_count = result->field_count;
+
+		DBG_INF_FMT("skip_extraction=%u", row_packet->skip_extraction); 
+		if (!row_packet->skip_extraction) {
+			result->m.unbuffered_free_last_data(result TSRMLS_CC);
+
+			DBG_INF("extracting data");
+			result->unbuf->last_row_data = row_packet->fields;
+			result->unbuf->last_row_buffer = row_packet->row_buffer;
+			row_packet->fields = NULL;
+			row_packet->row_buffer = NULL;
+
+			if (PASS != result->m.row_decoder(result->unbuf->last_row_buffer,
+									  result->unbuf->last_row_data,
+									  row_packet->field_count,
+									  row_packet->fields_metadata,
+									  FALSE,
+									  result->conn->options.numeric_and_datetime_as_unicode,
+									  result->conn->options.int_and_float_native,
+									  result->conn->stats TSRMLS_CC))
+			{
+				DBG_RETURN(FAIL);						  
+			}
+
+			/* If no result bind, do nothing. We consumed the data */
+			for (i = 0; i < field_count; i++) {
+				if (stmt->result_bind[i].bound == TRUE) {
+					zval *data = result->unbuf->last_row_data[i];
+					/*
+					  stmt->result_bind[i].zv has been already destructed
+					  in result->m.unbuffered_free_last_data()
+					*/
+#ifndef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+					zval_dtor(stmt->result_bind[i].zv);
+#endif
+					DBG_INF_FMT("i=%u bound_var=%p type=%u refc=%u", i, stmt->result_bind[i].zv,
+								Z_TYPE_P(data), Z_REFCOUNT_P(stmt->result_bind[i].zv));
+					if (IS_NULL != (Z_TYPE_P(stmt->result_bind[i].zv) = Z_TYPE_P(data))) {
+						if ((Z_TYPE_P(data) == IS_STRING
+#if MYSQLND_UNICODE
+							|| Z_TYPE_P(data) == IS_UNICODE
+#endif
+							)
+							 && (result->meta->fields[i].max_length < (unsigned long) Z_STRLEN_P(data)))
+						{
+							result->meta->fields[i].max_length = Z_STRLEN_P(data);
+						}
+						stmt->result_bind[i].zv->value = data->value;
+						/* copied data, thus also the ownership. Thus null data */
+						ZVAL_NULL(data);
+					}
+				}
+			}
+		} else {
+			DBG_INF("skipping extraction");
+			/*
+			  Data has been allocated and usually result->m.unbuffered_free_last_data()
+			  frees it but we can't call this function as it will cause problems with
+			  the bound variables. Thus we need to do part of what it does or Zend will
+			  report leaks.
+			*/
+			row_packet->row_buffer->free_chunk(row_packet->row_buffer TSRMLS_CC);
+			row_packet->row_buffer = NULL;
+		}
+		/* We asked for one row, the next one should be EOF, eat it */
+		ret = PACKET_READ(row_packet, result->conn);
+		if (row_packet->row_buffer) {
+			row_packet->row_buffer->free_chunk(row_packet->row_buffer TSRMLS_CC);
+			row_packet->row_buffer = NULL;
+		}
+		MYSQLND_INC_CONN_STATISTIC(stmt->conn->stats, STAT_ROWS_FETCHED_FROM_CLIENT_PS_CURSOR);
+
+		result->unbuf->row_count++;
+		*fetched_anything = TRUE;
+	} else {
+		*fetched_anything = FALSE;
+
+		stmt->upsert_status.warning_count =
+			stmt->conn->upsert_status.warning_count =
+				row_packet->warning_count;
+
+		stmt->upsert_status.server_status = 
+			stmt->conn->upsert_status.server_status =
+				row_packet->server_status;
+
+		result->unbuf->eof_reached = row_packet->eof;
+	}
+	stmt->upsert_status.warning_count =
+		stmt->conn->upsert_status.warning_count =
+			row_packet->warning_count;
+	stmt->upsert_status.server_status = 
+		stmt->conn->upsert_status.server_status =
+			row_packet->server_status;
+
+	DBG_INF_FMT("ret=%s fetched=%u server_status=%u warnings=%u eof=%u",
+				ret == PASS? "PASS":"FAIL", *fetched_anything,
+				row_packet->server_status, row_packet->warning_count,
+				result->unbuf->eof_reached);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::fetch */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, fetch)(MYSQLND_STMT * const s, zend_bool * const fetched_anything TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	enum_func_status ret;
+	DBG_ENTER("mysqlnd_stmt::fetch");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	if (!stmt->result ||
+		stmt->state < MYSQLND_STMT_WAITING_USE_OR_STORE) {
+		SET_STMT_ERROR(stmt, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+
+		DBG_ERR("command out of sync");
+		DBG_RETURN(FAIL);
+	} else if (stmt->state == MYSQLND_STMT_WAITING_USE_OR_STORE) {
+		/* Execute only once. We have to free the previous contents of user's bound vars */
+
+		stmt->default_rset_handler(s TSRMLS_CC);
+	}
+	stmt->state = MYSQLND_STMT_USER_FETCHING;
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	DBG_INF_FMT("result_bind=%p separated_once=%u", stmt->result_bind, stmt->result_zvals_separated_once);
+	/*
+	  The user might have not bound any variables for result.
+	  Do the binding once she does it.
+	*/
+	if (stmt->result_bind && !stmt->result_zvals_separated_once) {
+		unsigned int i;
+		/*
+		  mysqlnd_stmt_store_result() has been called free the bind
+		  variables to prevent leaking of their previous content.
+		*/
+		for (i = 0; i < stmt->result->field_count; i++) {
+			if (stmt->result_bind[i].bound == TRUE) {
+				zval_dtor(stmt->result_bind[i].zv);
+				ZVAL_NULL(stmt->result_bind[i].zv);
+			}
+		}
+		stmt->result_zvals_separated_once = TRUE;
+	}
+
+	ret = stmt->result->m.fetch_row(stmt->result, (void*)s, 0, fetched_anything TSRMLS_CC);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::reset */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, reset)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	enum_func_status ret = PASS;
+	zend_uchar cmd_buf[STMT_ID_LENGTH /* statement id */];
+
+	DBG_ENTER("mysqlnd_stmt::reset");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->stmt_id) {
+		MYSQLND * conn = stmt->conn;
+		if (stmt->param_bind) {
+			unsigned int i;
+			DBG_INF("resetting long data");
+			/* Reset Long Data */
+			for (i = 0; i < stmt->param_count; i++) {
+				if (stmt->param_bind[i].flags & MYSQLND_PARAM_BIND_BLOB_USED) {
+					stmt->param_bind[i].flags &= ~MYSQLND_PARAM_BIND_BLOB_USED;
+				}
+			}
+		}
+
+		/*
+		  If the user decided to close the statement right after execute()
+		  We have to call the appropriate use_result() or store_result() and
+		  clean.
+		*/
+		do {
+			if (stmt->state == MYSQLND_STMT_WAITING_USE_OR_STORE) {
+				DBG_INF("fetching result set header");
+				stmt->default_rset_handler(s TSRMLS_CC);
+				stmt->state = MYSQLND_STMT_USER_FETCHING;
+			}
+
+			if (stmt->result) {
+				DBG_INF("skipping result");
+				stmt->result->m.skip_result(stmt->result TSRMLS_CC);
+			}
+		} while (mysqlnd_stmt_more_results(s) && mysqlnd_stmt_next_result(s) == PASS);
+
+		/*
+		  Don't free now, let the result be usable. When the stmt will again be
+		  executed then the result set will be cleaned, the bound variables will
+		  be separated before that.
+		*/
+
+		int4store(cmd_buf, stmt->stmt_id);
+		if (CONN_GET_STATE(conn) == CONN_READY &&
+			FAIL == (ret = conn->m->simple_command(conn, COM_STMT_RESET, (char *)cmd_buf,
+												  sizeof(cmd_buf), PROT_OK_PACKET,
+												  FALSE, TRUE TSRMLS_CC))) {
+			stmt->error_info = conn->error_info;
+		}
+		stmt->upsert_status = conn->upsert_status;
+	}
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::send_long_data */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, send_long_data)(MYSQLND_STMT * const s, unsigned int param_no,
+							 				 const char * const data, unsigned long length TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	enum_func_status ret = FAIL;
+	MYSQLND * conn;
+	zend_uchar *cmd_buf;
+	enum php_mysqlnd_server_command cmd = COM_STMT_SEND_LONG_DATA;
+
+	DBG_ENTER("mysqlnd_stmt::send_long_data");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu param_no=%u data_len=%lu", stmt->stmt_id, param_no, length);
+
+	conn = stmt->conn;
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->state < MYSQLND_STMT_PREPARED) {
+		SET_STMT_ERROR(stmt, CR_NO_PREPARE_STMT, UNKNOWN_SQLSTATE, mysqlnd_stmt_not_prepared);
+		DBG_ERR("not prepared");
+		DBG_RETURN(FAIL);
+	}
+	if (!stmt->param_bind) {
+		SET_STMT_ERROR(stmt, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_ERR("command out of sync");
+		DBG_RETURN(FAIL);
+	}
+
+	if (param_no >= stmt->param_count) {
+		SET_STMT_ERROR(stmt, CR_INVALID_PARAMETER_NO, UNKNOWN_SQLSTATE, "Invalid parameter number");
+		DBG_ERR("invalid param_no");
+		DBG_RETURN(FAIL);
+	}
+	if (stmt->param_bind[param_no].type != MYSQL_TYPE_LONG_BLOB) {
+		SET_STMT_ERROR(stmt, CR_INVALID_BUFFER_USE, UNKNOWN_SQLSTATE, mysqlnd_not_bound_as_blob);
+		DBG_ERR("param_no is not of a blob type");
+		DBG_RETURN(FAIL);
+	}
+
+	/*
+	  XXX:	Unfortunately we have to allocate additional buffer to be able the
+			additional data, which is like a header inside the payload.
+			This should be optimised, but it will be a pervasive change, so
+			conn->m->simple_command() will accept not a buffer, but actually MYSQLND_STRING*
+			terminated by NULL, to send. If the strings are not big, we can collapse them
+			on the buffer every connection has, but otherwise we will just send them
+			one by one to the wire.
+	*/
+
+	if (CONN_GET_STATE(conn) == CONN_READY) {
+		size_t packet_len;
+		cmd_buf = mnd_emalloc(packet_len = STMT_ID_LENGTH + 2 + length);
+		if (cmd_buf) {
+			stmt->param_bind[param_no].flags |= MYSQLND_PARAM_BIND_BLOB_USED;
+
+			int4store(cmd_buf, stmt->stmt_id);
+			int2store(cmd_buf + STMT_ID_LENGTH, param_no);
+			memcpy(cmd_buf + STMT_ID_LENGTH + 2, data, length);
+
+			/* COM_STMT_SEND_LONG_DATA doesn't send an OK packet*/
+			ret = conn->m->simple_command(conn, cmd, (char *)cmd_buf, packet_len, PROT_LAST , FALSE, TRUE TSRMLS_CC);
+			mnd_efree(cmd_buf);
+			if (FAIL == ret) {
+				stmt->error_info = conn->error_info;
+			}
+		} else {
+			ret = FAIL;
+			SET_OOM_ERROR(stmt->error_info);
+			SET_OOM_ERROR(conn->error_info);
+		}
+		/*
+		  Cover protocol error: COM_STMT_SEND_LONG_DATA was designed to be quick and not
+		  sent response packets. According to documentation the only way to get an error
+		  is to have out-of-memory on the server-side. However, that's not true, as if
+		  max_allowed_packet_size is smaller than the chunk being sent to the server, the
+		  latter will complain with an error message. However, normally we don't expect
+		  an error message, thus we continue. When sending the next command, which expects
+		  response we will read the unexpected data and error message will look weird.
+		  Therefore we do non-blocking read to clean the line, if there is a need.
+		  Nevertheless, there is a built-in protection when sending a command packet, that
+		  checks if the line is clear - useful for debug purposes and to be switched off
+		  in release builds.
+
+		  Maybe we can make it automatic by checking what's the value of
+		  max_allowed_packet_size on the server and resending the data.
+		*/
+#ifdef MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND
+#if HAVE_USLEEP && !defined(PHP_WIN32)
+		usleep(120000);
+#endif
+		if ((packet_len = conn->net->m.consume_uneaten_data(conn->net, cmd TSRMLS_CC))) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "There was an error "
+							 "while sending long data. Probably max_allowed_packet_size "
+							 "is smaller than the data. You have to increase it or send "
+							 "smaller chunks of data. Answer was "MYSQLND_SZ_T_SPEC" bytes long.", packet_len);
+			SET_STMT_ERROR(stmt, CR_CONNECTION_ERROR, UNKNOWN_SQLSTATE,
+							"Server responded to COM_STMT_SEND_LONG_DATA.");
+			ret = FAIL;
+		}
+#endif
+	}
+
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::bind_parameters */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, bind_parameters)(MYSQLND_STMT * const s, MYSQLND_PARAM_BIND * const param_bind TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::bind_param");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu param_count=%u", stmt->stmt_id, stmt->param_count);
+
+	if (stmt->state < MYSQLND_STMT_PREPARED) {
+		SET_STMT_ERROR(stmt, CR_NO_PREPARE_STMT, UNKNOWN_SQLSTATE, mysqlnd_stmt_not_prepared);
+		DBG_ERR("not prepared");
+		if (param_bind) {
+			s->m->free_parameter_bind(s, param_bind TSRMLS_CC);
+		}
+		DBG_RETURN(FAIL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->param_count) {
+		unsigned int i = 0;
+
+		if (!param_bind) {
+			SET_STMT_ERROR(stmt, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE, "Re-binding (still) not supported");
+			DBG_ERR("Re-binding (still) not supported");
+			DBG_RETURN(FAIL);
+		} else if (stmt->param_bind) {
+			DBG_INF("Binding");
+			/*
+			  There is already result bound.
+			  Forbid for now re-binding!!
+			*/
+			for (i = 0; i < stmt->param_count; i++) {
+				/*
+				  We may have the last reference, then call zval_ptr_dtor()
+				  or we may leak memory.
+				  Switching from bind_one_parameter to bind_parameters may result in zv being NULL
+				*/
+				if (stmt->param_bind[i].zv) {
+					zval_ptr_dtor(&stmt->param_bind[i].zv);
+				}
+			}
+			if (stmt->param_bind != param_bind) {
+				s->m->free_parameter_bind(s, stmt->param_bind TSRMLS_CC);
+			}
+		}
+
+		stmt->param_bind = param_bind;
+		for (i = 0; i < stmt->param_count; i++) {
+			/* The client will use stmt_send_long_data */
+			DBG_INF_FMT("%u is of type %u", i, stmt->param_bind[i].type);
+			/* Prevent from freeing */
+			/* Don't update is_ref, or we will leak during conversion */
+			Z_ADDREF_P(stmt->param_bind[i].zv);
+			stmt->param_bind[i].flags = 0;
+			if (stmt->param_bind[i].type == MYSQL_TYPE_LONG_BLOB) {
+				stmt->param_bind[i].flags &= ~MYSQLND_PARAM_BIND_BLOB_USED;
+			}
+		}
+		stmt->send_types_to_server = 1;
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::bind_one_parameter */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, bind_one_parameter)(MYSQLND_STMT * const s, unsigned int param_no,
+												 zval * const zv, zend_uchar type TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::bind_one_parameter");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu param_no=%u param_count=%u type=%u",
+				stmt->stmt_id, param_no, stmt->param_count, type);
+
+	if (stmt->state < MYSQLND_STMT_PREPARED) {
+		SET_STMT_ERROR(stmt, CR_NO_PREPARE_STMT, UNKNOWN_SQLSTATE, mysqlnd_stmt_not_prepared);
+		DBG_ERR("not prepared");
+		DBG_RETURN(FAIL);
+	}
+
+	if (param_no >= stmt->param_count) {
+		SET_STMT_ERROR(stmt, CR_INVALID_PARAMETER_NO, UNKNOWN_SQLSTATE, "Invalid parameter number");
+		DBG_ERR("invalid param_no");
+		DBG_RETURN(FAIL);
+	}
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->param_count) {
+		if (!stmt->param_bind) {
+			stmt->param_bind = mnd_pecalloc(stmt->param_count, sizeof(MYSQLND_PARAM_BIND), stmt->persistent);
+			if (!stmt->param_bind) {
+				DBG_RETURN(FAIL);
+			}
+		}
+
+		/* Prevent from freeing */
+		/* Don't update is_ref, or we will leak during conversion */
+		Z_ADDREF_P(zv);
+		DBG_INF("Binding");
+		/* Release what we had, if we had */
+		if (stmt->param_bind[param_no].zv) {
+			zval_ptr_dtor(&stmt->param_bind[param_no].zv);
+		}
+		if (type == MYSQL_TYPE_LONG_BLOB) {
+			/* The client will use stmt_send_long_data */
+			stmt->param_bind[param_no].flags &= ~MYSQLND_PARAM_BIND_BLOB_USED;
+		}
+		stmt->param_bind[param_no].zv = zv;
+		stmt->param_bind[param_no].type = type;
+
+		stmt->send_types_to_server = 1;
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::refresh_bind_param */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, refresh_bind_param)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::refresh_bind_param");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu param_count=%u", stmt->stmt_id, stmt->param_count);
+
+	if (stmt->state < MYSQLND_STMT_PREPARED) {
+		SET_STMT_ERROR(stmt, CR_NO_PREPARE_STMT, UNKNOWN_SQLSTATE, mysqlnd_stmt_not_prepared);
+		DBG_ERR("not prepared");
+		DBG_RETURN(FAIL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->param_count) {
+		stmt->send_types_to_server = 1;
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::bind_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, bind_result)(MYSQLND_STMT * const s,
+										  MYSQLND_RESULT_BIND * const result_bind TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::bind_result");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu field_count=%u", stmt->stmt_id, stmt->field_count);
+
+	if (stmt->state < MYSQLND_STMT_PREPARED) {
+		SET_STMT_ERROR(stmt, CR_NO_PREPARE_STMT, UNKNOWN_SQLSTATE, mysqlnd_stmt_not_prepared);
+		if (result_bind) {
+			s->m->free_result_bind(s, result_bind TSRMLS_CC);
+		}
+		DBG_ERR("not prepared");
+		DBG_RETURN(FAIL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->field_count) {
+		unsigned int i = 0;
+
+		if (!result_bind) {
+			DBG_ERR("no result bind passed");
+			DBG_RETURN(FAIL);
+		}
+
+		mysqlnd_stmt_separate_result_bind(s TSRMLS_CC);
+		stmt->result_zvals_separated_once = FALSE;
+		stmt->result_bind = result_bind;
+		for (i = 0; i < stmt->field_count; i++) {
+			/* Prevent from freeing */
+			Z_ADDREF_P(stmt->result_bind[i].zv);
+			DBG_INF_FMT("ref of %p = %u", stmt->result_bind[i].zv, Z_REFCOUNT_P(stmt->result_bind[i].zv));
+			/*
+			  Don't update is_ref !!! it's not our job
+			  Otherwise either 009.phpt or mysqli_stmt_bind_result.phpt
+			  will fail.
+			*/
+			stmt->result_bind[i].bound = TRUE;
+		}
+	} else if (result_bind) {
+		s->m->free_result_bind(s, result_bind TSRMLS_CC);
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::bind_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, bind_one_result)(MYSQLND_STMT * const s, unsigned int param_no TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::bind_result");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu field_count=%u", stmt->stmt_id, stmt->field_count);
+
+	if (stmt->state < MYSQLND_STMT_PREPARED) {
+		SET_STMT_ERROR(stmt, CR_NO_PREPARE_STMT, UNKNOWN_SQLSTATE, mysqlnd_stmt_not_prepared);
+		DBG_ERR("not prepared");
+		DBG_RETURN(FAIL);
+	}
+
+	if (param_no >= stmt->field_count) {
+		SET_STMT_ERROR(stmt, CR_INVALID_PARAMETER_NO, UNKNOWN_SQLSTATE, "Invalid parameter number");
+		DBG_ERR("invalid param_no");
+		DBG_RETURN(FAIL);
+	}
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	if (stmt->field_count) {
+		mysqlnd_stmt_separate_one_result_bind(s, param_no TSRMLS_CC);
+		/* Guaranteed is that stmt->result_bind is NULL */
+		if (!stmt->result_bind) {
+			stmt->result_bind = mnd_pecalloc(stmt->field_count, sizeof(MYSQLND_RESULT_BIND), stmt->persistent);
+		} else {
+			stmt->result_bind = mnd_perealloc(stmt->result_bind, stmt->field_count * sizeof(MYSQLND_RESULT_BIND), stmt->persistent);
+		}
+		if (!stmt->result_bind) {
+			DBG_RETURN(FAIL);
+		}
+		ALLOC_INIT_ZVAL(stmt->result_bind[param_no].zv);
+		/*
+		  Don't update is_ref !!! it's not our job
+		  Otherwise either 009.phpt or mysqli_stmt_bind_result.phpt
+		  will fail.
+		*/
+		stmt->result_bind[param_no].bound = TRUE;
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::insert_id */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_stmt, insert_id)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->upsert_status.last_insert_id : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::affected_rows */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_stmt, affected_rows)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->upsert_status.affected_rows : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::num_rows */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_stmt, num_rows)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt && stmt->result? mysqlnd_num_rows(stmt->result):0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::warning_count */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_stmt, warning_count)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->upsert_status.warning_count : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::server_status */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_stmt, server_status)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->upsert_status.server_status : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::field_count */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_stmt, field_count)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->field_count : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::param_count */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_stmt, param_count)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->param_count : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::errno */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_stmt, errno)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->error_info.error_no : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::error */
+static const char *
+MYSQLND_METHOD(mysqlnd_stmt, error)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt? stmt->error_info.error : 0;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::sqlstate */
+static const char *
+MYSQLND_METHOD(mysqlnd_stmt, sqlstate)(const MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt && stmt->error_info.sqlstate[0] ? stmt->error_info.sqlstate:MYSQLND_SQLSTATE_NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::data_seek */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, data_seek)(const MYSQLND_STMT * const s, uint64_t row TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	return stmt && stmt->result? stmt->result->m.seek_data(stmt->result, row TSRMLS_CC) : FAIL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::param_metadata */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_stmt, param_metadata)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	if (!stmt || !stmt->param_count) {
+		return NULL;
+	}
+	return NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::result_metadata */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_stmt, result_metadata)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND_RES *result;
+
+	DBG_ENTER("mysqlnd_stmt::result_metadata");
+	if (!stmt) {
+		DBG_RETURN(NULL);
+	}
+	DBG_INF_FMT("stmt=%u field_count=%u", stmt->stmt_id, stmt->field_count);
+
+	if (!stmt->field_count || !stmt->conn || !stmt->result || !stmt->result->meta) {
+		DBG_INF("NULL");
+		DBG_RETURN(NULL);
+	}
+
+	if (stmt->update_max_length && stmt->result->stored_data) {
+		/* stored result, we have to update the max_length before we clone the meta data :( */
+		stmt->result->m.initialize_result_set_rest(stmt->result TSRMLS_CC);
+	}
+	/*
+	  TODO: This implementation is kind of a hack,
+			find a better way to do it. In different functions I have put
+			fuses to check for result->m.fetch_row() being NULL. This should
+			be handled in a better way.
+
+	  In the meantime we don't need a zval cache reference for this fake
+	  result set, so we don't get one.
+	*/
+	do {
+		result = stmt->conn->m->result_init(stmt->field_count, stmt->persistent TSRMLS_CC);
+		if (!result) {
+			break;
+		}
+		result->type = MYSQLND_RES_NORMAL;
+		result->m.fetch_row = result->m.fetch_row_normal_unbuffered;
+		result->unbuf = mnd_ecalloc(1, sizeof(MYSQLND_RES_UNBUFFERED));
+		if (!result->unbuf) {
+			break;
+		}
+		result->unbuf->eof_reached = TRUE;
+		result->meta = stmt->result->meta->m->clone_metadata(stmt->result->meta, FALSE TSRMLS_CC);
+		if (!result->meta) {
+			break;
+		}
+
+		DBG_INF_FMT("result=%p", result);
+		DBG_RETURN(result);
+	} while (0);
+
+	SET_OOM_ERROR(stmt->conn->error_info);
+	if (result) {
+		result->m.free_result(result, TRUE TSRMLS_CC);
+	}
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::attr_set */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, attr_set)(MYSQLND_STMT * const s,
+									   enum mysqlnd_stmt_attr attr_type,
+									   const void * const value TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::attr_set");
+	if (!stmt) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu attr_type=%u", stmt->stmt_id, attr_type);
+
+	switch (attr_type) {
+		case STMT_ATTR_UPDATE_MAX_LENGTH:{
+			zend_uchar bval = *(zend_uchar *) value;
+			/*
+			  XXX : libmysql uses my_bool, but mysqli uses ulong as storage on the stack
+			  and mysqlnd won't be used out of the scope of PHP -> use ulong.
+			*/
+			stmt->update_max_length = bval? TRUE:FALSE;
+			break;
+		}
+		case STMT_ATTR_CURSOR_TYPE: {
+			unsigned int ival = *(unsigned int *) value;
+			if (ival > (unsigned long) CURSOR_TYPE_READ_ONLY) {
+				SET_STMT_ERROR(stmt, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE, "Not implemented");
+				DBG_INF("FAIL");
+				DBG_RETURN(FAIL);
+			}
+			stmt->flags = ival;
+			break;
+		}
+		case STMT_ATTR_PREFETCH_ROWS: {
+			unsigned int ival = *(unsigned int *) value;
+			if (ival == 0) {
+				ival = MYSQLND_DEFAULT_PREFETCH_ROWS;
+			} else if (ival > 1) {
+				SET_STMT_ERROR(stmt, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE, "Not implemented");
+				DBG_INF("FAIL");
+				DBG_RETURN(FAIL);
+			}
+			stmt->prefetch_rows = ival;
+			break;
+		}
+		default:
+			SET_STMT_ERROR(stmt, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE, "Not implemented");
+			DBG_RETURN(FAIL);
+	}
+	DBG_INF("PASS");
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::attr_get */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, attr_get)(const MYSQLND_STMT * const s,
+									   enum mysqlnd_stmt_attr attr_type,
+									   void * const value TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::attr_set");
+	if (!stmt) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu attr_type=%u", stmt->stmt_id, attr_type);
+
+	switch (attr_type) {
+		case STMT_ATTR_UPDATE_MAX_LENGTH:
+			*(zend_bool *) value= stmt->update_max_length;
+			break;
+		case STMT_ATTR_CURSOR_TYPE:
+			*(unsigned long *) value= stmt->flags;
+			break;
+		case STMT_ATTR_PREFETCH_ROWS:
+			*(unsigned long *) value= stmt->prefetch_rows;
+			break;
+		default:
+			DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("value=%lu", value);
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+/* free_result() doesn't actually free stmt->result but only the buffers */
+/* {{{ mysqlnd_stmt::free_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, free_result)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::free_result");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	if (!stmt->result) {
+		DBG_INF("no result");
+		DBG_RETURN(PASS);
+	}
+
+	/*
+	  If right after execute() we have to call the appropriate
+	  use_result() or store_result() and clean.
+	*/
+	if (stmt->state == MYSQLND_STMT_WAITING_USE_OR_STORE) {
+		DBG_INF("fetching result set header");
+		/* Do implicit use_result and then flush the result */
+		stmt->default_rset_handler = s->m->use_result;
+		stmt->default_rset_handler(s TSRMLS_CC);
+	}
+
+	if (stmt->state > MYSQLND_STMT_WAITING_USE_OR_STORE) {
+		DBG_INF("skipping result");
+		/* Flush if anything is left and unbuffered set */
+		stmt->result->m.skip_result(stmt->result TSRMLS_CC);
+		/*
+		  Separate the bound variables, which point to the result set, then
+		  destroy the set.
+		*/
+		mysqlnd_stmt_separate_result_bind(s TSRMLS_CC);
+
+		/* Now we can destroy the result set */
+		stmt->result->m.free_result_buffers(stmt->result TSRMLS_CC);
+	}
+
+	if (stmt->state > MYSQLND_STMT_PREPARED) {
+		/* As the buffers have been freed, we should go back to PREPARED */
+		stmt->state = MYSQLND_STMT_PREPARED;
+	}
+
+	/* Line is free! */
+	CONN_SET_STATE(stmt->conn, CONN_READY);
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_separate_result_bind */
+static void
+mysqlnd_stmt_separate_result_bind(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	unsigned int i;
+
+	DBG_ENTER("mysqlnd_stmt_separate_result_bind");
+	if (!stmt) {
+		DBG_VOID_RETURN;
+	}
+	DBG_INF_FMT("stmt=%lu result_bind=%p field_count=%u",
+				stmt->stmt_id, stmt->result_bind, stmt->field_count);
+
+	if (!stmt->result_bind) {
+		DBG_VOID_RETURN;
+	}
+
+	/*
+	  Because only the bound variables can point to our internal buffers, then
+	  separate or free only them. Free is possible because the user could have
+	  lost reference.
+	*/
+	for (i = 0; i < stmt->field_count; i++) {
+		/* Let's try with no cache */
+		if (stmt->result_bind[i].bound == TRUE) {
+			DBG_INF_FMT("%u has refcount=%u", i, Z_REFCOUNT_P(stmt->result_bind[i].zv));
+			/*
+			  We have to separate the actual zval value of the bound
+			  variable from our allocated zvals or we will face double-free
+			*/
+			if (Z_REFCOUNT_P(stmt->result_bind[i].zv) > 1) {
+#ifdef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+				zval_copy_ctor(stmt->result_bind[i].zv);
+#endif
+				zval_ptr_dtor(&stmt->result_bind[i].zv);
+			} else {
+				/*
+				  If it is a string, what is pointed will be freed
+				  later in free_result(). We need to remove the variable to
+				  which the user has lost reference.
+				*/
+#ifdef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+				ZVAL_NULL(stmt->result_bind[i].zv);
+#endif
+				zval_ptr_dtor(&stmt->result_bind[i].zv);
+			}
+		}
+	}
+	s->m->free_result_bind(s, stmt->result_bind TSRMLS_CC);
+	stmt->result_bind = NULL;
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_separate_one_result_bind */
+static void
+mysqlnd_stmt_separate_one_result_bind(MYSQLND_STMT * const s, unsigned int param_no TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt_separate_one_result_bind");
+	if (!stmt) {
+		DBG_VOID_RETURN;
+	}
+	DBG_INF_FMT("stmt=%lu result_bind=%p field_count=%u param_no=%u",
+				stmt->stmt_id, stmt->result_bind, stmt->field_count, param_no);
+
+	if (!stmt->result_bind) {
+		DBG_VOID_RETURN;
+	}
+
+	/*
+	  Because only the bound variables can point to our internal buffers, then
+	  separate or free only them. Free is possible because the user could have
+	  lost reference.
+	*/
+	/* Let's try with no cache */
+	if (stmt->result_bind[param_no].bound == TRUE) {
+		DBG_INF_FMT("%u has refcount=%u", param_no, Z_REFCOUNT_P(stmt->result_bind[param_no].zv));
+		/*
+		  We have to separate the actual zval value of the bound
+		  variable from our allocated zvals or we will face double-free
+		*/
+		if (Z_REFCOUNT_P(stmt->result_bind[param_no].zv) > 1) {
+#ifdef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+			zval_copy_ctor(stmt->result_bind[param_no].zv);
+#endif
+			zval_ptr_dtor(&stmt->result_bind[param_no].zv);
+		} else {
+			/*
+			  If it is a string, what is pointed will be freed
+			  later in free_result(). We need to remove the variable to
+			  which the user has lost reference.
+			*/
+#ifdef WE_DONT_COPY_IN_BUFFERED_AND_UNBUFFERED_BECAUSEOF_IS_REF
+			ZVAL_NULL(stmt->result_bind[param_no].zv);
+#endif
+			zval_ptr_dtor(&stmt->result_bind[param_no].zv);
+		}
+	}
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::free_stmt_content */
+static void
+MYSQLND_METHOD(mysqlnd_stmt, free_stmt_content)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::free_stmt_content");
+	if (!stmt) {
+		DBG_VOID_RETURN;
+	}
+	DBG_INF_FMT("stmt=%lu param_bind=%p param_count=%u",
+				stmt->stmt_id, stmt->param_bind, stmt->param_count);
+
+	/* Destroy the input bind */
+	if (stmt->param_bind) {
+		unsigned int i;
+		/*
+		  Because only the bound variables can point to our internal buffers, then
+		  separate or free only them. Free is possible because the user could have
+		  lost reference.
+		*/
+		for (i = 0; i < stmt->param_count; i++) {
+			/*
+			  If bind_one_parameter was used, but not everything was
+			  bound and nothing was fetched, then some `zv` could be NULL
+			*/
+			if (stmt->param_bind[i].zv) {
+				zval_ptr_dtor(&stmt->param_bind[i].zv);
+			}
+		}
+		s->m->free_parameter_bind(s, stmt->param_bind TSRMLS_CC);
+		stmt->param_bind = NULL;
+	}
+
+	/*
+	  First separate the bound variables, which point to the result set, then
+	  destroy the set.
+	*/
+	mysqlnd_stmt_separate_result_bind(s TSRMLS_CC);
+	/* Not every statement has a result set attached */
+	if (stmt->result) {
+		stmt->result->m.free_result_internal(stmt->result TSRMLS_CC);
+		stmt->result = NULL;
+	}
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::net_close */
+static enum_func_status
+MYSQLND_METHOD_PRIVATE(mysqlnd_stmt, net_close)(MYSQLND_STMT * const s, zend_bool implicit TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	MYSQLND * conn;
+	zend_uchar cmd_buf[STMT_ID_LENGTH /* statement id */];
+	enum_mysqlnd_collected_stats statistic = STAT_LAST;
+
+	DBG_ENTER("mysqlnd_stmt::net_close");
+	if (!stmt || !stmt->conn) {
+		DBG_RETURN(FAIL);
+	}
+	DBG_INF_FMT("stmt=%lu", stmt->stmt_id);
+
+	conn = stmt->conn;
+
+	SET_EMPTY_ERROR(stmt->error_info);
+	SET_EMPTY_ERROR(stmt->conn->error_info);
+
+	/*
+	  If the user decided to close the statement right after execute()
+	  We have to call the appropriate use_result() or store_result() and
+	  clean.
+	*/
+	do {
+		DBG_INF_FMT("stmt->state=%u", stmt->state);
+		if (stmt->state == MYSQLND_STMT_WAITING_USE_OR_STORE) {
+			DBG_INF("fetching result set header");
+			stmt->default_rset_handler(s TSRMLS_CC);
+			stmt->state = MYSQLND_STMT_USER_FETCHING;
+		}
+
+		/* unbuffered set not fetched to the end ? Clean the line */
+		if (stmt->result) {
+			DBG_INF("skipping result");
+			stmt->result->m.skip_result(stmt->result TSRMLS_CC);
+		}
+	} while (mysqlnd_stmt_more_results(s) && mysqlnd_stmt_next_result(s) == PASS);
+	/*
+	  After this point we are allowed to free the result set,
+	  as we have cleaned the line
+	*/
+	if (stmt->stmt_id) {
+		MYSQLND_INC_GLOBAL_STATISTIC(implicit == TRUE?	STAT_FREE_RESULT_IMPLICIT:
+														STAT_FREE_RESULT_EXPLICIT);
+
+		int4store(cmd_buf, stmt->stmt_id);
+		if (CONN_GET_STATE(conn) == CONN_READY &&
+			FAIL == conn->m->simple_command(conn, COM_STMT_CLOSE, (char *)cmd_buf, sizeof(cmd_buf),
+										   PROT_LAST /* COM_STMT_CLOSE doesn't send an OK packet*/,
+										   FALSE, TRUE TSRMLS_CC)) {
+			stmt->error_info = conn->error_info;
+			DBG_RETURN(FAIL);
+		}
+	}
+	switch (stmt->execute_count) {
+		case 0:
+			statistic = STAT_PS_PREPARED_NEVER_EXECUTED;
+			break;
+		case 1:
+			statistic = STAT_PS_PREPARED_ONCE_USED;
+			break;
+		default:
+			break;
+	}
+	if (statistic != STAT_LAST) {
+		MYSQLND_INC_CONN_STATISTIC(conn->stats, statistic);
+	}
+
+	if (stmt->execute_cmd_buffer.buffer) {
+		mnd_pefree(stmt->execute_cmd_buffer.buffer, stmt->persistent);
+		stmt->execute_cmd_buffer.buffer = NULL;
+	}
+
+	s->m->free_stmt_content(s TSRMLS_CC);
+
+	if (stmt->conn) {
+		stmt->conn->m->free_reference(stmt->conn TSRMLS_CC);
+		stmt->conn = NULL;
+	}
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+/* {{{ mysqlnd_stmt::dtor */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_stmt, dtor)(MYSQLND_STMT * const s, zend_bool implicit TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = (s != NULL) ? s->data:NULL;
+	enum_func_status ret = FAIL;
+	zend_bool persistent = (s != NULL) ? s->persistent : 0;
+
+	DBG_ENTER("mysqlnd_stmt::dtor");
+	if (stmt) {
+
+		DBG_INF_FMT("stmt=%p", stmt);
+
+		MYSQLND_INC_GLOBAL_STATISTIC(implicit == TRUE?	STAT_STMT_CLOSE_IMPLICIT:
+														STAT_STMT_CLOSE_EXPLICIT);
+
+		ret = s->m->net_close(s, implicit TSRMLS_CC);
+		mnd_pefree(stmt, persistent);
+	}
+	mnd_pefree(s, persistent);
+
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::alloc_param_bind */
+static MYSQLND_PARAM_BIND *
+MYSQLND_METHOD(mysqlnd_stmt, alloc_param_bind)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::alloc_param_bind");
+	if (!stmt) {
+		DBG_RETURN(NULL);
+	}
+	DBG_RETURN(mnd_pecalloc(stmt->param_count, sizeof(MYSQLND_PARAM_BIND), stmt->persistent));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::alloc_result_bind */
+static MYSQLND_RESULT_BIND *
+MYSQLND_METHOD(mysqlnd_stmt, alloc_result_bind)(MYSQLND_STMT * const s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	DBG_ENTER("mysqlnd_stmt::alloc_result_bind");
+	if (!stmt) {
+		DBG_RETURN(NULL);
+	}
+	DBG_RETURN(mnd_pecalloc(stmt->field_count, sizeof(MYSQLND_RESULT_BIND), stmt->persistent));
+}
+/* }}} */
+
+
+/* {{{ param_bind::free_parameter_bind */
+PHPAPI void
+MYSQLND_METHOD(mysqlnd_stmt, free_parameter_bind)(MYSQLND_STMT * const s, MYSQLND_PARAM_BIND * param_bind TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	if (stmt) {
+		mnd_pefree(param_bind, stmt->persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt::free_result_bind */
+PHPAPI void
+MYSQLND_METHOD(mysqlnd_stmt, free_result_bind)(MYSQLND_STMT * const s, MYSQLND_RESULT_BIND * result_bind TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s? s->data:NULL;
+	if (stmt) {
+		mnd_pefree(result_bind, stmt->persistent);
+	}
+}
+/* }}} */
+
+
+
+MYSQLND_CLASS_METHODS_START(mysqlnd_stmt)
+	MYSQLND_METHOD(mysqlnd_stmt, prepare),
+	MYSQLND_METHOD(mysqlnd_stmt, execute),
+	MYSQLND_METHOD(mysqlnd_stmt, use_result),
+	MYSQLND_METHOD(mysqlnd_stmt, store_result),
+	MYSQLND_METHOD(mysqlnd_stmt, get_result),
+	MYSQLND_METHOD(mysqlnd_stmt, more_results),
+	MYSQLND_METHOD(mysqlnd_stmt, next_result),
+	MYSQLND_METHOD(mysqlnd_stmt, free_result),
+	MYSQLND_METHOD(mysqlnd_stmt, data_seek),
+	MYSQLND_METHOD(mysqlnd_stmt, reset),
+	MYSQLND_METHOD_PRIVATE(mysqlnd_stmt, net_close),
+	MYSQLND_METHOD(mysqlnd_stmt, dtor),
+
+	MYSQLND_METHOD(mysqlnd_stmt, fetch),
+
+	MYSQLND_METHOD(mysqlnd_stmt, bind_parameters),
+	MYSQLND_METHOD(mysqlnd_stmt, bind_one_parameter),
+	MYSQLND_METHOD(mysqlnd_stmt, refresh_bind_param),
+	MYSQLND_METHOD(mysqlnd_stmt, bind_result),
+	MYSQLND_METHOD(mysqlnd_stmt, bind_one_result),
+	MYSQLND_METHOD(mysqlnd_stmt, send_long_data),
+	MYSQLND_METHOD(mysqlnd_stmt, param_metadata),
+	MYSQLND_METHOD(mysqlnd_stmt, result_metadata),
+
+	MYSQLND_METHOD(mysqlnd_stmt, insert_id),
+	MYSQLND_METHOD(mysqlnd_stmt, affected_rows),
+	MYSQLND_METHOD(mysqlnd_stmt, num_rows),
+
+	MYSQLND_METHOD(mysqlnd_stmt, param_count),
+	MYSQLND_METHOD(mysqlnd_stmt, field_count),
+	MYSQLND_METHOD(mysqlnd_stmt, warning_count),
+
+	MYSQLND_METHOD(mysqlnd_stmt, errno),
+	MYSQLND_METHOD(mysqlnd_stmt, error),
+	MYSQLND_METHOD(mysqlnd_stmt, sqlstate),
+
+	MYSQLND_METHOD(mysqlnd_stmt, attr_get),
+	MYSQLND_METHOD(mysqlnd_stmt, attr_set),
+
+
+	MYSQLND_METHOD(mysqlnd_stmt, alloc_param_bind),
+	MYSQLND_METHOD(mysqlnd_stmt, alloc_result_bind),
+	MYSQLND_METHOD(mysqlnd_stmt, free_parameter_bind),
+	MYSQLND_METHOD(mysqlnd_stmt, free_result_bind),
+	MYSQLND_METHOD(mysqlnd_stmt, server_status),
+	mysqlnd_stmt_execute_generate_request,
+	mysqlnd_stmt_execute_parse_response,
+	MYSQLND_METHOD(mysqlnd_stmt, free_stmt_content)
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ _mysqlnd_stmt_init */
+MYSQLND_STMT * _mysqlnd_stmt_init(MYSQLND * const conn TSRMLS_DC)
+{
+	size_t alloc_size = sizeof(MYSQLND_STMT) + mysqlnd_plugin_count() * sizeof(void *);
+	MYSQLND_STMT * ret = mnd_pecalloc(1, alloc_size, conn->persistent);
+	MYSQLND_STMT_DATA * stmt = NULL;
+
+	DBG_ENTER("_mysqlnd_stmt_init");
+	do {
+		if (!ret) {
+			break;
+		}
+		ret->m = mysqlnd_stmt_methods;
+		ret->persistent = conn->persistent;
+
+		stmt = ret->data = mnd_pecalloc(1, sizeof(MYSQLND_STMT_DATA), conn->persistent);
+		DBG_INF_FMT("stmt=%p", stmt);
+		if (!stmt) {
+			break;
+		}
+		stmt->persistent = conn->persistent;
+		stmt->state = MYSQLND_STMT_INITTED;
+		stmt->execute_cmd_buffer.length = 4096;
+		stmt->execute_cmd_buffer.buffer = mnd_pemalloc(stmt->execute_cmd_buffer.length, stmt->persistent);
+		if (!stmt->execute_cmd_buffer.buffer) {
+			break;
+		}
+
+		stmt->prefetch_rows = MYSQLND_DEFAULT_PREFETCH_ROWS;
+		/*
+		  Mark that we reference the connection, thus it won't be
+		  be destructed till there is open statements. The last statement
+		  or normal query result will close it then.
+		*/
+		stmt->conn = conn->m->get_reference(conn TSRMLS_CC);
+
+		DBG_RETURN(ret);
+	} while (0);
+
+	SET_OOM_ERROR(conn->error_info);
+	if (ret) {
+		ret->m->dtor(ret, TRUE TSRMLS_CC);
+		ret = NULL;
+	}
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_plugin_get_plugin_stmt_data */
+PHPAPI void ** _mysqlnd_plugin_get_plugin_stmt_data(const MYSQLND_STMT * stmt, unsigned int plugin_id TSRMLS_DC)
+{
+	DBG_ENTER("_mysqlnd_plugin_get_plugin_stmt_data");
+	DBG_INF_FMT("plugin_id=%u", plugin_id);
+	if (!stmt || plugin_id >= mysqlnd_plugin_count()) {
+		return NULL;
+	}
+	DBG_RETURN((void *)((char *)stmt + sizeof(MYSQLND_STMT) + plugin_id * sizeof(void *)));
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_init_ps_subsystem */
+void _mysqlnd_init_ps_subsystem()
+{
+	mysqlnd_stmt_methods = &MYSQLND_CLASS_METHOD_TABLE_NAME(mysqlnd_stmt);
+	_mysqlnd_init_ps_fetch_subsystem();
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn_get_methods */
+PHPAPI struct st_mysqlnd_stmt_methods * mysqlnd_stmt_get_methods()
+{
+	return mysqlnd_stmt_methods;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_conn_set_methods */
+PHPAPI void mysqlnd_stmt_set_methods(struct st_mysqlnd_stmt_methods *methods)
+{
+	mysqlnd_stmt_methods = methods;
+}
+/* }}} */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_ps_codec.c
@@ -0,0 +1,965 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_debug.h"
+
+#define MYSQLND_SILENT
+
+
+enum mysqlnd_timestamp_type
+{
+  MYSQLND_TIMESTAMP_NONE= -2,
+  MYSQLND_TIMESTAMP_ERROR= -1,
+  MYSQLND_TIMESTAMP_DATE= 0,
+  MYSQLND_TIMESTAMP_DATETIME= 1,
+  MYSQLND_TIMESTAMP_TIME= 2
+};
+
+
+struct st_mysqlnd_time
+{
+  unsigned int  year, month, day, hour, minute, second;
+  unsigned long second_part;
+  zend_bool     neg;
+  enum mysqlnd_timestamp_type time_type;
+};
+
+
+struct st_mysqlnd_perm_bind mysqlnd_ps_fetch_functions[MYSQL_TYPE_LAST + 1];
+
+#define MYSQLND_PS_SKIP_RESULT_W_LEN	-1
+#define MYSQLND_PS_SKIP_RESULT_STR		-2
+
+/* {{{ ps_fetch_from_1_to_8_bytes */
+void ps_fetch_from_1_to_8_bytes(zval *zv, const MYSQLND_FIELD * const field,
+								unsigned int pack_len, zend_uchar **row, zend_bool as_unicode,
+								unsigned int byte_count TSRMLS_DC)
+{
+	char tmp[22];
+	size_t tmp_len = 0;
+	zend_bool is_bit = field->type == MYSQL_TYPE_BIT;
+	DBG_ENTER("ps_fetch_from_1_to_8_bytes");
+	DBG_INF_FMT("zv=%p byte_count=%u", zv, byte_count);
+	if (field->flags & UNSIGNED_FLAG) {
+		uint64_t uval = 0;
+
+		switch (byte_count) {
+			case 8:uval = is_bit? (uint64_t) bit_uint8korr(*row):(uint64_t) uint8korr(*row);break;
+			case 7:uval = bit_uint7korr(*row);break;
+			case 6:uval = bit_uint6korr(*row);break;
+			case 5:uval = bit_uint5korr(*row);break;
+			case 4:uval = is_bit? (uint64_t) bit_uint4korr(*row):(uint64_t) uint4korr(*row);break;
+			case 3:uval = is_bit? (uint64_t) bit_uint3korr(*row):(uint64_t) uint3korr(*row);break;
+			case 2:uval = is_bit? (uint64_t) bit_uint2korr(*row):(uint64_t) uint2korr(*row);break;
+			case 1:uval = (uint64_t) uint1korr(*row);break;
+		}
+
+#if SIZEOF_LONG==4
+		if (uval > INT_MAX) {
+			DBG_INF("stringify");
+			tmp_len = sprintf((char *)&tmp, MYSQLND_LLU_SPEC, uval);
+		} else 
+#endif /* #if SIZEOF_LONG==4 */
+		{
+			if (byte_count < 8 || uval <= L64(9223372036854775807)) {
+				ZVAL_LONG(zv, (long) uval); /* the cast is safe, we are in the range */
+			} else {
+				DBG_INF("stringify");
+				tmp_len = sprintf((char *)&tmp, MYSQLND_LLU_SPEC, uval);
+			}
+		}
+	} else {
+		/* SIGNED */
+		int64_t lval = 0;
+		switch (byte_count) {
+			case 8:lval = (int64_t) sint8korr(*row);break;
+			/*
+			  7, 6 and 5 are not possible.
+			  BIT is only unsigned, thus only uint5|6|7 macroses exist
+			*/
+			case 4:lval = (int64_t) sint4korr(*row);break;
+			case 3:lval = (int64_t) sint3korr(*row);break;
+			case 2:lval = (int64_t) sint2korr(*row);break;
+			case 1:lval = (int64_t) *(int8_t*)*row;break;
+		}
+
+#if SIZEOF_LONG==4
+		if ((L64(2147483647) < (int64_t) lval) || (L64(-2147483648) > (int64_t) lval)) {
+			DBG_INF("stringify");
+			tmp_len = sprintf((char *)&tmp, MYSQLND_LL_SPEC, lval);
+		} else
+#endif /* SIZEOF */
+		{
+			ZVAL_LONG(zv, (long) lval); /* the cast is safe, we are in the range */
+		}
+	}
+
+	if (tmp_len) {
+#if MYSQLND_UNICODE
+		if (as_unicode) {
+			DBG_INF("stringify");
+			ZVAL_UTF8_STRINGL(zv, tmp, tmp_len, ZSTR_DUPLICATE);
+		} else
+#endif
+		{
+			DBG_INF("stringify");
+			ZVAL_STRINGL(zv, tmp, tmp_len, 1);
+		}
+	}
+	(*row)+= byte_count;
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_null */
+static
+void ps_fetch_null(zval *zv, const MYSQLND_FIELD * const field,
+				   unsigned int pack_len, zend_uchar **row,
+				   zend_bool as_unicode TSRMLS_DC)
+{
+	ZVAL_NULL(zv);
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_int8 */
+static
+void ps_fetch_int8(zval *zv, const MYSQLND_FIELD * const field,
+				   unsigned int pack_len, zend_uchar **row,
+				   zend_bool as_unicode TSRMLS_DC)
+{
+	ps_fetch_from_1_to_8_bytes(zv, field, pack_len, row, as_unicode, 1 TSRMLS_CC);
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_int16 */
+static
+void ps_fetch_int16(zval *zv, const MYSQLND_FIELD * const field,
+					unsigned int pack_len, zend_uchar **row,
+					zend_bool as_unicode TSRMLS_DC)
+{
+	ps_fetch_from_1_to_8_bytes(zv, field, pack_len, row, as_unicode, 2 TSRMLS_CC);
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_int32 */
+static
+void ps_fetch_int32(zval *zv, const MYSQLND_FIELD * const field,
+					unsigned int pack_len, zend_uchar **row,
+					zend_bool as_unicode TSRMLS_DC)
+{
+	ps_fetch_from_1_to_8_bytes(zv, field, pack_len, row, as_unicode, 4 TSRMLS_CC);
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_int64 */
+static
+void ps_fetch_int64(zval *zv, const MYSQLND_FIELD * const field,
+					unsigned int pack_len, zend_uchar **row,
+					zend_bool as_unicode TSRMLS_DC)
+{
+	ps_fetch_from_1_to_8_bytes(zv, field, pack_len, row, as_unicode, 8 TSRMLS_CC);
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_float */
+static
+void ps_fetch_float(zval *zv, const MYSQLND_FIELD * const field,
+					unsigned int pack_len, zend_uchar **row,
+					zend_bool as_unicode TSRMLS_DC)
+{
+	float value;
+	DBG_ENTER("ps_fetch_float");
+	float4get(value, *row);
+	ZVAL_DOUBLE(zv, value);
+	(*row)+= 4;
+	DBG_INF_FMT("value=%f", value);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_double */
+static
+void ps_fetch_double(zval *zv, const MYSQLND_FIELD * const field,
+					unsigned int pack_len, zend_uchar **row,
+					zend_bool as_unicode TSRMLS_DC)
+{
+	double value;
+	DBG_ENTER("ps_fetch_double");
+	float8get(value, *row);
+	ZVAL_DOUBLE(zv, value);
+	(*row)+= 8;
+	DBG_INF_FMT("value=%f", value);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_time */
+static
+void ps_fetch_time(zval *zv, const MYSQLND_FIELD * const field,
+				   unsigned int pack_len, zend_uchar **row,
+				   zend_bool as_unicode TSRMLS_DC)
+{
+	struct st_mysqlnd_time t;
+	unsigned int length; /* First byte encodes the length*/
+	char * value;
+	DBG_ENTER("ps_fetch_time");
+
+	if ((length = php_mysqlnd_net_field_length(row))) {
+		zend_uchar *to= *row;
+
+		t.time_type = MYSQLND_TIMESTAMP_TIME;
+		t.neg			= (zend_bool) to[0];
+
+		t.day			= (unsigned long) sint4korr(to+1);
+		t.hour			= (unsigned int) to[5];
+		t.minute		= (unsigned int) to[6];
+		t.second		= (unsigned int) to[7];
+		t.second_part	= (length > 8) ? (unsigned long) sint4korr(to+8) : 0;
+		t.year			= t.month= 0;
+		if (t.day) {
+			/* Convert days to hours at once */
+			t.hour += t.day*24;
+			t.day	= 0;
+		}
+
+		(*row) += length;
+	} else {
+		memset(&t, 0, sizeof(t));
+		t.time_type = MYSQLND_TIMESTAMP_TIME;
+	}
+
+	/*
+	  QQ : How to make this unicode without copying two times the buffer -
+	  Unicode equivalent of spprintf?
+	*/
+	length = spprintf(&value, 0, "%s%02u:%02u:%02u", (t.neg ? "-" : ""), t.hour, t.minute, t.second);
+
+	DBG_INF_FMT("%s", value);
+#if MYSQLND_UNICODE
+	if (!as_unicode) {
+#endif
+		ZVAL_STRINGL(zv, value, length, 1);
+		efree(value);  /* allocated by spprintf */
+#if MYSQLND_UNICODE
+	} else {
+		ZVAL_UTF8_STRINGL(zv, value, length, ZSTR_AUTOFREE);
+	}
+#endif
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_date */
+static
+void ps_fetch_date(zval *zv, const MYSQLND_FIELD * const field,
+				   unsigned int pack_len, zend_uchar **row,
+				   zend_bool as_unicode TSRMLS_DC)
+{
+	struct st_mysqlnd_time t = {0};
+	unsigned int length; /* First byte encodes the length*/
+	char * value;
+	DBG_ENTER("ps_fetch_date");
+
+	if ((length = php_mysqlnd_net_field_length(row))) {
+		zend_uchar *to= *row;
+
+		t.time_type= MYSQLND_TIMESTAMP_DATE;
+		t.neg= 0;
+
+		t.second_part = t.hour = t.minute = t.second = 0;
+
+		t.year	= (unsigned int) sint2korr(to);
+		t.month = (unsigned int) to[2];
+		t.day	= (unsigned int) to[3];
+
+		(*row)+= length;
+	} else {
+		memset(&t, 0, sizeof(t));
+		t.time_type = MYSQLND_TIMESTAMP_DATE;
+	}
+
+	/*
+	  QQ : How to make this unicode without copying two times the buffer -
+	  Unicode equivalent of spprintf?
+	*/
+	length = spprintf(&value, 0, "%04u-%02u-%02u", t.year, t.month, t.day);
+
+	DBG_INF_FMT("%s", value);
+#if MYSQLND_UNICODE
+	if (!as_unicode) {
+#endif
+		ZVAL_STRINGL(zv, value, length, 1);
+		efree(value); /* allocated by spprintf */
+#if MYSQLND_UNICODE
+	} else {
+		ZVAL_UTF8_STRINGL(zv, value, length, ZSTR_AUTOFREE);
+	}
+#endif
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_datetime */
+static
+void ps_fetch_datetime(zval *zv, const MYSQLND_FIELD * const field,
+					   unsigned int pack_len, zend_uchar **row,
+					   zend_bool as_unicode TSRMLS_DC)
+{
+	struct st_mysqlnd_time t;
+	unsigned int length; /* First byte encodes the length*/
+	char * value;
+	DBG_ENTER("ps_fetch_datetime");
+
+	if ((length = php_mysqlnd_net_field_length(row))) {
+		zend_uchar *to= *row;
+
+		t.time_type = MYSQLND_TIMESTAMP_DATETIME;
+		t.neg	 = 0;
+
+		t.year	 = (unsigned int) sint2korr(to);
+		t.month = (unsigned int) to[2];
+		t.day	 = (unsigned int) to[3];
+
+		if (length > 4) {
+			t.hour	 = (unsigned int) to[4];
+			t.minute = (unsigned int) to[5];
+			t.second = (unsigned int) to[6];
+		} else {
+			t.hour = t.minute = t.second= 0;
+		}
+		t.second_part = (length > 7) ? (unsigned long) sint4korr(to+7) : 0;
+
+		(*row)+= length;
+	} else {
+		memset(&t, 0, sizeof(t));
+		t.time_type = MYSQLND_TIMESTAMP_DATETIME;
+	}
+
+	/*
+	  QQ : How to make this unicode without copying two times the buffer -
+	  Unicode equivalent of spprintf?
+	*/
+	length = spprintf(&value, 0, "%04u-%02u-%02u %02u:%02u:%02u",
+					  t.year, t.month, t.day, t.hour, t.minute, t.second);
+
+	DBG_INF_FMT("%s", value);
+#if MYSQLND_UNICODE
+	if (!as_unicode) {
+#endif
+		ZVAL_STRINGL(zv, value, length, 1);
+		efree(value); /* allocated by spprintf */
+#if MYSQLND_UNICODE
+	} else {
+		ZVAL_UTF8_STRINGL(zv, to, length, ZSTR_AUTOFREE);
+	}
+#endif
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_string */
+static
+void ps_fetch_string(zval *zv, const MYSQLND_FIELD * const field,
+					 unsigned int pack_len, zend_uchar **row,
+					 zend_bool as_unicode TSRMLS_DC)
+{
+	/*
+	  For now just copy, before we make it possible
+	  to write \0 to the row buffer
+	*/
+	unsigned long length = php_mysqlnd_net_field_length(row);
+	DBG_ENTER("ps_fetch_string");
+	DBG_INF_FMT("len = %lu", length);
+#if MYSQLND_UNICODE
+	if (field->charsetnr == MYSQLND_BINARY_CHARSET_NR) {
+		DBG_INF("Binary charset");
+		ZVAL_STRINGL(zv, (char *)*row, length, 1);
+	} else {
+		DBG_INF_FMT("copying from the row buffer");
+		ZVAL_UTF8_STRINGL(zv, (char*)*row, length, ZSTR_DUPLICATE);
+	}
+#else
+	DBG_INF("copying from the row buffer");
+	ZVAL_STRINGL(zv, (char *)*row, length, 1);
+#endif
+
+	(*row) += length;
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ ps_fetch_bit */
+static
+void ps_fetch_bit(zval *zv, const MYSQLND_FIELD * const field,
+				  unsigned int pack_len, zend_uchar **row,
+				  zend_bool as_unicode TSRMLS_DC)
+{
+	unsigned long length= php_mysqlnd_net_field_length(row);
+	ps_fetch_from_1_to_8_bytes(zv, field, pack_len, row, as_unicode, length TSRMLS_CC);
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_init_ps_fetch_subsystem */
+void _mysqlnd_init_ps_fetch_subsystem()
+{
+	memset(mysqlnd_ps_fetch_functions, 0, sizeof(mysqlnd_ps_fetch_functions));
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NULL].func		= ps_fetch_null;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NULL].pack_len	= 0;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NULL].php_type	= IS_NULL;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NULL].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY].func		= ps_fetch_int8;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY].pack_len	= 1;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY].php_type	= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SHORT].func		= ps_fetch_int16;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SHORT].pack_len	= 2;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SHORT].php_type	= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SHORT].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_YEAR].func		= ps_fetch_int16;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_YEAR].pack_len	= 2;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_YEAR].php_type	= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_YEAR].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_INT24].func		= ps_fetch_int32;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_INT24].pack_len	= 4;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_INT24].php_type	= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_INT24].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG].func		= ps_fetch_int32;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG].pack_len	= 4;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG].php_type	= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONGLONG].func	= ps_fetch_int64;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONGLONG].pack_len= 8;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONGLONG].php_type= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONGLONG].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_FLOAT].func		= ps_fetch_float;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_FLOAT].pack_len	= 4;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_FLOAT].php_type	= IS_DOUBLE;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_FLOAT].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DOUBLE].func		= ps_fetch_double;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DOUBLE].pack_len	= 8;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DOUBLE].php_type	= IS_DOUBLE;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DOUBLE].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIME].func		= ps_fetch_time;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIME].pack_len	= MYSQLND_PS_SKIP_RESULT_W_LEN;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIME].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIME].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATE].func		= ps_fetch_date;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATE].pack_len	= MYSQLND_PS_SKIP_RESULT_W_LEN;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATE].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATE].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDATE].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDATE].pack_len	= MYSQLND_PS_SKIP_RESULT_W_LEN;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDATE].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDATE].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATETIME].func	= ps_fetch_datetime;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATETIME].pack_len= MYSQLND_PS_SKIP_RESULT_W_LEN;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATETIME].php_type= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DATETIME].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIMESTAMP].func	= ps_fetch_datetime;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIMESTAMP].pack_len= MYSQLND_PS_SKIP_RESULT_W_LEN;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIMESTAMP].php_type= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TIMESTAMP].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY_BLOB].func	= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY_BLOB].pack_len= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY_BLOB].php_type = IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY_BLOB].is_possibly_blob = TRUE;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_TINY_BLOB].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BLOB].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BLOB].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BLOB].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BLOB].is_possibly_blob = TRUE;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BLOB].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_MEDIUM_BLOB].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_MEDIUM_BLOB].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_MEDIUM_BLOB].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_MEDIUM_BLOB].is_possibly_blob = TRUE;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_MEDIUM_BLOB].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG_BLOB].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG_BLOB].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG_BLOB].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG_BLOB].is_possibly_blob = TRUE;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_LONG_BLOB].can_ret_as_str_in_uni 	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BIT].func		= ps_fetch_bit;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BIT].pack_len	= 8;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BIT].php_type	= IS_LONG;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_BIT].can_ret_as_str_in_uni = TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VAR_STRING].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VAR_STRING].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VAR_STRING].php_type = IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VAR_STRING].is_possibly_blob = TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VARCHAR].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VARCHAR].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VARCHAR].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_VARCHAR].is_possibly_blob = TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_STRING].func			= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_STRING].pack_len		= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_STRING].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_STRING].is_possibly_blob = TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DECIMAL].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DECIMAL].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DECIMAL].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_DECIMAL].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDECIMAL].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDECIMAL].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDECIMAL].php_type	= IS_STRING;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_NEWDECIMAL].can_ret_as_str_in_uni	= TRUE;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_ENUM].func		= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_ENUM].pack_len	= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_ENUM].php_type	= IS_STRING;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SET].func			= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SET].pack_len		= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_SET].php_type		= IS_STRING;
+
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_GEOMETRY].func	= ps_fetch_string;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_GEOMETRY].pack_len= MYSQLND_PS_SKIP_RESULT_STR;
+	mysqlnd_ps_fetch_functions[MYSQL_TYPE_GEOMETRY].php_type= IS_STRING;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_copy_it */
+static enum_func_status
+mysqlnd_stmt_copy_it(zval *** copies, zval *original, unsigned int param_count, unsigned int current TSRMLS_DC)
+{
+	if (!*copies) {
+		*copies = mnd_ecalloc(param_count, sizeof(zval *));
+	}
+	if (*copies) {
+		MAKE_STD_ZVAL((*copies)[current]);
+		*(*copies)[current] = *original;
+		Z_SET_REFCOUNT_P((*copies)[current], 1);
+		zval_copy_ctor((*copies)[current]);
+		return PASS;
+	}
+	return FAIL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_execute_store_params */
+static enum_func_status
+mysqlnd_stmt_execute_store_params(MYSQLND_STMT * s, zend_uchar **buf, zend_uchar **p, size_t *buf_len  TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s->data;
+	unsigned int i = 0;
+	zend_uchar * provided_buffer = *buf;
+	size_t left = (*buf_len - (*p - *buf));
+	size_t data_size = 0;
+	zval **copies = NULL;/* if there are different types */
+	enum_func_status ret = FAIL;
+	int resend_types_next_time = 0;
+	size_t null_byte_offset;
+
+	DBG_ENTER("mysqlnd_stmt_execute_store_params");
+
+	{
+		unsigned int null_count = (stmt->param_count + 7) / 8;
+		/* give it some reserved space - 20 bytes */
+		if (left < (null_count + 20)) {
+			unsigned int offset = *p - *buf;
+			zend_uchar *tmp_buf;
+			*buf_len = offset + null_count + 20;
+			tmp_buf = mnd_emalloc(*buf_len);
+			if (!tmp_buf) {
+				SET_OOM_ERROR(stmt->error_info);
+				goto end;
+			}
+			memcpy(tmp_buf, *buf, offset);
+			if (*buf != provided_buffer) {
+				mnd_efree(*buf);
+			}
+			*buf = tmp_buf;
+
+			/* Update our pos pointer */
+			*p = *buf + offset;
+		}
+		/* put `null` bytes */
+		null_byte_offset = *p - *buf;
+		memset(*p, 0, null_count);
+		*p += null_count;
+	}
+
+/* 1. Store type information */
+	/*
+	  check if need to send the types even if stmt->send_types_to_server is 0. This is because
+	  if we send "i" (42) then the type will be int and the server will expect int. However, if next
+	  time we try to send > LONG_MAX, the conversion to string will send a string and the server
+	  won't expect it and interpret the value as 0. Thus we need to resend the types, if any such values
+	  occur, and force resend for the next execution.
+	*/
+	for (i = 0; i < stmt->param_count; i++) {
+		if (Z_TYPE_P(stmt->param_bind[i].zv) != IS_NULL &&
+			(stmt->param_bind[i].type == MYSQL_TYPE_LONG || stmt->param_bind[i].type == MYSQL_TYPE_LONGLONG))
+		{
+			/* always copy the var, because we do many conversions */
+			if (Z_TYPE_P(stmt->param_bind[i].zv) != IS_LONG &&
+				PASS != mysqlnd_stmt_copy_it(&copies, stmt->param_bind[i].zv, stmt->param_count, i TSRMLS_CC))
+			{
+				SET_OOM_ERROR(stmt->error_info);
+				goto end;
+			}
+			/*
+			  if it doesn't fit in a long send it as a string.
+			  Check bug #52891 : Wrong data inserted with mysqli/mysqlnd when using bind_param, value > LONG_MAX
+			*/
+			if (Z_TYPE_P(stmt->param_bind[i].zv) != IS_LONG) {
+				zval *tmp_data = (copies && copies[i])? copies[i]: stmt->param_bind[i].zv;
+				convert_to_double_ex(&tmp_data);
+				if (Z_DVAL_P(tmp_data) > LONG_MAX || Z_DVAL_P(tmp_data) < LONG_MIN) {
+					stmt->send_types_to_server = resend_types_next_time = 1;
+				}
+			}
+		}
+	}
+
+	int1store(*p, stmt->send_types_to_server); 
+	(*p)++;
+
+	if (stmt->send_types_to_server) {
+		/* 2 bytes per type, and leave 20 bytes for future use */
+		if (left < ((stmt->param_count * 2) + 20)) {
+			unsigned int offset = *p - *buf;
+			zend_uchar *tmp_buf;
+			*buf_len = offset + stmt->param_count * 2 + 20;
+			tmp_buf = mnd_emalloc(*buf_len);
+			if (!tmp_buf) {
+				SET_OOM_ERROR(stmt->error_info);
+				goto end;
+			}
+			memcpy(tmp_buf, *buf, offset);
+			if (*buf != provided_buffer) {
+				mnd_efree(*buf);
+			}
+			*buf = tmp_buf;
+
+			/* Update our pos pointer */
+			*p = *buf + offset;
+		}
+		for (i = 0; i < stmt->param_count; i++) {
+			short current_type = stmt->param_bind[i].type;
+			/* our types are not unsigned */
+#if SIZEOF_LONG==8  
+			if (current_type == MYSQL_TYPE_LONG) {
+				current_type = MYSQL_TYPE_LONGLONG;
+			}
+#endif
+			if (Z_TYPE_P(stmt->param_bind[i].zv) != IS_NULL && (current_type == MYSQL_TYPE_LONG || current_type == MYSQL_TYPE_LONGLONG)) {
+				/*
+				  if it doesn't fit in a long send it as a string.
+				  Check bug #52891 : Wrong data inserted with mysqli/mysqlnd when using bind_param, value > LONG_MAX
+				*/
+				if (Z_TYPE_P(stmt->param_bind[i].zv) != IS_LONG) {
+					zval *tmp_data = (copies && copies[i])? copies[i]: stmt->param_bind[i].zv;
+
+					convert_to_double_ex(&tmp_data);
+					if (Z_DVAL_P(tmp_data) > LONG_MAX || Z_DVAL_P(tmp_data) < LONG_MIN) {
+						convert_to_string_ex(&tmp_data);
+						current_type = MYSQL_TYPE_VAR_STRING;
+						/*
+						  don't change stmt->param_bind[i].type to MYSQL_TYPE_VAR_STRING
+						  we force convert_to_long_ex in all cases, thus the type will be right in the next switch.
+						  if the type is however not long, then we will do a goto in the next switch.
+						  We want to preserve the original bind type given by the user. Thus, we do these hacks.
+						*/
+					} else {
+						convert_to_long_ex(&tmp_data);
+					}
+				}
+			}
+			int2store(*p, current_type);
+			*p+= 2;
+		}
+	}
+	stmt->send_types_to_server = resend_types_next_time;
+
+/* 2. Store data */
+	/* 2.1 Calculate how much space we need */
+	for (i = 0; i < stmt->param_count; i++) {
+		unsigned int j;
+		zval *the_var = stmt->param_bind[i].zv;
+
+		if (!the_var || (stmt->param_bind[i].type != MYSQL_TYPE_LONG_BLOB && Z_TYPE_P(the_var) == IS_NULL)) {
+			continue;
+		}
+		for (j = i + 1; j < stmt->param_count; j++) {
+			if (stmt->param_bind[j].zv == the_var) {
+				/* Double binding of the same zval, make a copy */
+				if (!copies || !copies[i]) {
+					if (PASS != mysqlnd_stmt_copy_it(&copies, the_var, stmt->param_count, i TSRMLS_CC)) {
+						SET_OOM_ERROR(stmt->error_info);
+						goto end;
+					}
+				}
+				break; 
+			}
+		}
+
+		switch (stmt->param_bind[i].type) {
+			case MYSQL_TYPE_DOUBLE:
+				data_size += 8;
+				if (Z_TYPE_P(the_var) != IS_DOUBLE) {
+					if (!copies || !copies[i]) {
+						if (PASS != mysqlnd_stmt_copy_it(&copies, the_var, stmt->param_count, i TSRMLS_CC)) {
+							SET_OOM_ERROR(stmt->error_info);
+							goto end;
+						}
+					}
+				}
+				break;
+			case MYSQL_TYPE_LONGLONG:
+				{
+					zval *tmp_data = (copies && copies[i])? copies[i]: stmt->param_bind[i].zv;
+					if (Z_TYPE_P(tmp_data) == IS_STRING) {
+						goto use_string;
+					}
+					convert_to_long_ex(&tmp_data);
+				}
+				data_size += 8;
+				break;
+			case MYSQL_TYPE_LONG:
+				{
+					zval *tmp_data = (copies && copies[i])? copies[i]: stmt->param_bind[i].zv;
+					if (Z_TYPE_P(tmp_data) == IS_STRING) {
+						goto use_string;
+					}
+					convert_to_long_ex(&tmp_data);
+				}
+				data_size += 4;
+				break;
+			case MYSQL_TYPE_LONG_BLOB:
+				if (!(stmt->param_bind[i].flags & MYSQLND_PARAM_BIND_BLOB_USED)) {
+					/*
+					  User hasn't sent anything, we will send empty string.
+					  Empty string has length of 0, encoded in 1 byte. No real
+					  data will follows after it.
+					*/
+					data_size++;
+				}
+				break;
+			case MYSQL_TYPE_VAR_STRING:
+use_string:
+				data_size += 8; /* max 8 bytes for size */
+#if MYSQLND_UNICODE
+				if (Z_TYPE_P(the_var) != IS_STRING || Z_TYPE_P(the_var) == IS_UNICODE)
+#else
+				if (Z_TYPE_P(the_var) != IS_STRING)
+#endif
+				{
+					if (!copies || !copies[i]) {
+						if (PASS != mysqlnd_stmt_copy_it(&copies, the_var, stmt->param_count, i TSRMLS_CC)) {
+							SET_OOM_ERROR(stmt->error_info);
+							goto end;
+						}
+					}
+					the_var = copies[i];
+#if MYSQLND_UNICODE
+					if (Z_TYPE_P(the_var) == IS_UNICODE) {
+						zval_unicode_to_string_ex(the_var, UG(utf8_conv) TSRMLS_CC);
+					}
+#endif
+				}
+				convert_to_string_ex(&the_var);
+				data_size += Z_STRLEN_P(the_var);
+				break;
+		}
+	}
+
+	/* 2.2 Enlarge the buffer, if needed */
+	left = (*buf_len - (*p - *buf));
+	if (left < data_size) {
+		unsigned int offset = *p - *buf;
+		zend_uchar *tmp_buf;
+		*buf_len = offset + data_size + 10; /* Allocate + 10 for safety */
+		tmp_buf = mnd_emalloc(*buf_len);
+		if (!tmp_buf) {
+			SET_OOM_ERROR(stmt->error_info);
+			goto end;
+		}
+		memcpy(tmp_buf, *buf, offset);
+		/*
+		  When too many columns the buffer provided to the function might not be sufficient.
+		  In this case new buffer has been allocated above. When we allocate a buffer and then
+		  allocate a bigger one here, we should free the first one.
+		*/
+		if (*buf != provided_buffer) {
+			mnd_efree(*buf);
+		}
+		*buf = tmp_buf;
+		/* Update our pos pointer */
+		*p = *buf + offset;
+	}
+
+	/* 2.3 Store the actual data */
+	for (i = 0; i < stmt->param_count; i++) {
+		zval *data = (copies && copies[i])? copies[i]: stmt->param_bind[i].zv;
+		/* Handle long data */
+		if (stmt->param_bind[i].zv && Z_TYPE_P(data) == IS_NULL) {
+			(*buf + null_byte_offset)[i/8] |= (zend_uchar) (1 << (i & 7));
+		} else {
+			switch (stmt->param_bind[i].type) {
+				case MYSQL_TYPE_DOUBLE:
+					convert_to_double_ex(&data);
+					float8store(*p, Z_DVAL_P(data));
+					(*p) += 8;
+					break;
+				case MYSQL_TYPE_LONGLONG:
+					if (Z_TYPE_P(data) == IS_STRING) {
+						goto send_string;
+					}
+					/* data has alreade been converted to long */
+					int8store(*p, Z_LVAL_P(data));
+					(*p) += 8;
+					break;
+				case MYSQL_TYPE_LONG:
+					if (Z_TYPE_P(data) == IS_STRING) {
+						goto send_string;
+					}
+					/* data has alreade been converted to long */
+					int4store(*p, Z_LVAL_P(data));
+					(*p) += 4;
+					break;
+				case MYSQL_TYPE_LONG_BLOB:
+					if (stmt->param_bind[i].flags & MYSQLND_PARAM_BIND_BLOB_USED) {
+						stmt->param_bind[i].flags &= ~MYSQLND_PARAM_BIND_BLOB_USED;
+					} else {
+						/* send_long_data() not called, send empty string */
+						*p = php_mysqlnd_net_store_length(*p, 0);
+					}
+					break;
+				case MYSQL_TYPE_VAR_STRING:
+send_string:
+					{
+						unsigned int len = Z_STRLEN_P(data);
+						/* to is after p. The latter hasn't been moved */
+						*p = php_mysqlnd_net_store_length(*p, len);
+						memcpy(*p, Z_STRVAL_P(data), len);
+						(*p) += len;
+					}
+					break;
+				default:
+					/* Won't happen, but set to NULL */
+					(*buf + null_byte_offset)[i/8] |= (zend_uchar) (1 << (i & 7));
+					break;
+			}
+		}
+	}
+	ret = PASS;
+end:
+	if (copies) {
+		for (i = 0; i < stmt->param_count; i++) {
+			if (copies[i]) {
+				zval_ptr_dtor(&copies[i]);
+			}
+		}
+		mnd_efree(copies);
+	}
+
+	DBG_INF_FMT("ret=%s", ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stmt_execute_generate_request */
+enum_func_status
+mysqlnd_stmt_execute_generate_request(MYSQLND_STMT * const s, zend_uchar ** request, size_t *request_len, zend_bool * free_buffer TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s->data;
+	zend_uchar	*p = stmt->execute_cmd_buffer.buffer,
+				*cmd_buffer = stmt->execute_cmd_buffer.buffer;
+	size_t cmd_buffer_length = stmt->execute_cmd_buffer.length;
+	enum_func_status ret;
+
+	DBG_ENTER("mysqlnd_stmt_execute_generate_request");
+
+	int4store(p, stmt->stmt_id);
+	p += 4;
+
+	/* flags is 4 bytes, we store just 1 */
+	int1store(p, (zend_uchar) stmt->flags);
+	p++;
+
+	/* Make it all zero */
+	int4store(p, 0); 
+
+	int1store(p, 1); /* and send 1 for iteration count */
+	p+= 4;
+
+	ret = mysqlnd_stmt_execute_store_params(s, &cmd_buffer, &p, &cmd_buffer_length TSRMLS_CC);
+
+	*free_buffer = (cmd_buffer != stmt->execute_cmd_buffer.buffer);
+	*request_len = (p - cmd_buffer);
+	*request = cmd_buffer;
+	DBG_INF_FMT("ret=%s", ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_result.c
@@ -0,0 +1,1764 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_block_alloc.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_result.h"
+#include "mysqlnd_result_meta.h"
+#include "mysqlnd_statistics.h"
+#include "mysqlnd_debug.h"
+
+#define MYSQLND_SILENT
+
+
+/* {{{ mysqlnd_res::initialize_result_set_rest */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_res, initialize_result_set_rest)(MYSQLND_RES * const result TSRMLS_DC)
+{
+	unsigned int i;
+	zval **data_cursor = result->stored_data? result->stored_data->data:NULL;
+	zval **data_begin = result->stored_data? result->stored_data->data:NULL;
+	unsigned int field_count = result->meta? result->meta->field_count : 0;
+	uint64_t row_count = result->stored_data? result->stored_data->row_count:0;
+	enum_func_status ret = PASS;
+	DBG_ENTER("mysqlnd_res::initialize_result_set_rest");
+
+	if (!data_cursor || row_count == result->stored_data->initialized_rows) {
+		DBG_RETURN(ret);
+	}
+	while ((data_cursor - data_begin) < (int)(row_count * field_count)) {
+		if (NULL == data_cursor[0]) {
+			enum_func_status rc = result->m.row_decoder(
+									result->stored_data->row_buffers[(data_cursor - data_begin) / field_count],
+									data_cursor,
+									result->meta->field_count,
+									result->meta->fields,
+									result->stored_data->persistent,
+									result->conn->options.numeric_and_datetime_as_unicode,
+									result->conn->options.int_and_float_native,
+									result->conn->stats TSRMLS_CC);
+			if (rc != PASS) {
+				ret = FAIL;
+				break;
+			}
+			result->stored_data->initialized_rows++;
+			for (i = 0; i < result->field_count; i++) {
+				/*
+				  NULL fields are 0 length, 0 is not more than 0
+				  String of zero size, definitely can't be the next max_length.
+				  Thus for NULL and zero-length we are quite efficient.
+				*/
+				if (Z_TYPE_P(data_cursor[i]) >= IS_STRING) {
+					unsigned long len = Z_STRLEN_P(data_cursor[i]);
+					if (result->meta->fields[i].max_length < len) {
+						result->meta->fields[i].max_length = len;
+					}
+				}
+			}
+		}
+		data_cursor += field_count;
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_rset_zval_ptr_dtor */
+static void
+mysqlnd_rset_zval_ptr_dtor(zval **zv, enum_mysqlnd_res_type type, zend_bool * copy_ctor_called TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_rset_zval_ptr_dtor");
+	if (!zv || !*zv) {
+		*copy_ctor_called = FALSE;
+		DBG_ERR_FMT("zv was NULL");
+		DBG_VOID_RETURN;
+	}
+	/*
+	  This zval is not from the cache block.
+	  Thus the refcount is -1 than of a zval from the cache,
+	  because the zvals from the cache are owned by it.
+	*/
+	if (type == MYSQLND_RES_PS_BUF || type == MYSQLND_RES_PS_UNBUF) {
+		*copy_ctor_called = FALSE;
+		; /* do nothing, zval_ptr_dtor will do the job*/
+	} else if (Z_REFCOUNT_PP(zv) > 1) {
+		/*
+		  Not a prepared statement, then we have to
+		  call copy_ctor and then zval_ptr_dtor()
+
+		  In Unicode mode the destruction  of the zvals should not call
+		  zval_copy_ctor() because then we will leak.
+		  I suppose we can use UG(unicode) in mysqlnd.c when freeing a result set
+		  to check if we need to call copy_ctor().
+
+		  If the type is IS_UNICODE, which can happen with PHP6, then we don't
+		  need to copy_ctor, as the data doesn't point to our internal buffers.
+		  If it's string (in PHP5 always) and in PHP6 if data is binary, then
+		  it still points to internal buffers and has to be copied.
+		*/
+		if (Z_TYPE_PP(zv) == IS_STRING) {
+			zval_copy_ctor(*zv);
+		}
+		*copy_ctor_called = TRUE;
+	} else {
+		/*
+		  noone but us point to this, so we can safely ZVAL_NULL the zval,
+		  so Zend does not try to free what the zval points to - which is
+		  in result set buffers
+		*/
+		*copy_ctor_called = FALSE;
+		if (Z_TYPE_PP(zv) == IS_STRING) {
+			ZVAL_NULL(*zv);
+		}
+	}
+	zval_ptr_dtor(zv);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::unbuffered_free_last_data */
+static void
+MYSQLND_METHOD(mysqlnd_res, unbuffered_free_last_data)(MYSQLND_RES * result TSRMLS_DC)
+{
+	MYSQLND_RES_UNBUFFERED *unbuf = result->unbuf;
+
+	DBG_ENTER("mysqlnd_res::unbuffered_free_last_data");
+
+	if (!unbuf) {
+		DBG_VOID_RETURN;
+	}
+
+	DBG_INF_FMT("last_row_data=%p", unbuf->last_row_data);
+	if (unbuf->last_row_data) {
+		unsigned int i, ctor_called_count = 0;
+		zend_bool copy_ctor_called;
+		MYSQLND_STATS *global_stats = result->conn? result->conn->stats:NULL;
+
+		DBG_INF_FMT("%u columns to free", result->field_count);
+		for (i = 0; i < result->field_count; i++) {
+			mysqlnd_rset_zval_ptr_dtor(&(unbuf->last_row_data[i]), result->type, &copy_ctor_called TSRMLS_CC);
+			if (copy_ctor_called) {
+				++ctor_called_count;
+			}
+		}
+		DBG_INF_FMT("copy_ctor_called_count=%u", ctor_called_count);
+		/* By using value3 macros we hold a mutex only once, there is no value2 */
+		MYSQLND_INC_CONN_STATISTIC_W_VALUE2(global_stats,
+											STAT_COPY_ON_WRITE_PERFORMED,
+											ctor_called_count,
+											STAT_COPY_ON_WRITE_SAVED,
+											result->field_count - ctor_called_count);
+		/* Free last row's zvals */
+		mnd_efree(unbuf->last_row_data);
+		unbuf->last_row_data = NULL;
+	}
+	if (unbuf->last_row_buffer) {
+		DBG_INF("Freeing last row buffer");
+		/* Nothing points to this buffer now, free it */
+		unbuf->last_row_buffer->free_chunk(unbuf->last_row_buffer TSRMLS_CC);
+		unbuf->last_row_buffer = NULL;
+	}
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::free_buffered_data */
+static void
+MYSQLND_METHOD(mysqlnd_res, free_buffered_data)(MYSQLND_RES * result TSRMLS_DC)
+{
+	MYSQLND_RES_BUFFERED *set = result->stored_data;
+	unsigned int field_count = result->field_count;
+	int64_t row;
+
+	DBG_ENTER("mysqlnd_res::free_buffered_data");
+	DBG_INF_FMT("Freeing "MYSQLND_LLU_SPEC" row(s)", set->row_count);
+
+	DBG_INF("Freeing data & row_buffer");
+	if (set->data) {
+		unsigned int copy_on_write_performed = 0;
+		unsigned int copy_on_write_saved = 0;
+
+		DBG_INF_FMT("before: real_usage=%lu  usage=%lu", zend_memory_usage(TRUE TSRMLS_CC), zend_memory_usage(FALSE TSRMLS_CC));
+		for (row = set->row_count - 1; row >= 0; row--) {
+			zval **current_row = set->data + row * field_count;
+			MYSQLND_MEMORY_POOL_CHUNK *current_buffer = set->row_buffers[row];
+			int64_t col;
+
+			if (current_row != NULL) {
+				for (col = field_count - 1; col >= 0; --col) {
+					if (current_row[col]) {
+						zend_bool copy_ctor_called;
+						mysqlnd_rset_zval_ptr_dtor(&(current_row[col]), result->type, &copy_ctor_called TSRMLS_CC);
+#if MYSQLND_DEBUG_MEMORY
+						DBG_INF_FMT("Copy_ctor_called=%u", copy_ctor_called);
+#endif
+						if (copy_ctor_called) {
+							++copy_on_write_performed;
+						} else {
+							++copy_on_write_saved;
+						}
+					}
+				}
+			}
+#if MYSQLND_DEBUG_MEMORY
+			DBG_INF("Freeing current_row & current_buffer");
+#endif
+			current_buffer->free_chunk(current_buffer TSRMLS_CC);
+		}
+
+		MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(STAT_COPY_ON_WRITE_PERFORMED, copy_on_write_performed,
+											  STAT_COPY_ON_WRITE_SAVED, copy_on_write_saved);
+		mnd_pefree(set->data, set->persistent);
+		set->data = NULL;
+	}
+
+	if (set->row_buffers) {
+		mnd_pefree(set->row_buffers, set->persistent);
+		set->row_buffers	= NULL;
+	}
+	set->data_cursor = NULL;
+	set->row_count	= 0;
+
+	DBG_INF("Freeing set");
+	mnd_pefree(set, set->persistent);
+
+	DBG_INF_FMT("after: real_usage=%lu  usage=%lu", zend_memory_usage(TRUE TSRMLS_CC), zend_memory_usage(FALSE TSRMLS_CC));
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::free_result_buffers */
+static void
+MYSQLND_METHOD(mysqlnd_res, free_result_buffers)(MYSQLND_RES * result TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::free_result_buffers");
+	DBG_INF_FMT("%s", result->unbuf? "unbuffered":(result->stored_data? "buffered":"unknown"));
+
+	if (result->unbuf) {
+		result->m.unbuffered_free_last_data(result TSRMLS_CC);
+		mnd_efree(result->unbuf);
+		result->unbuf = NULL;
+	} else if (result->stored_data) {
+		result->m.free_buffered_data(result TSRMLS_CC);
+		result->stored_data = NULL;
+	}
+
+	if (result->lengths) {
+		mnd_efree(result->lengths);
+		result->lengths = NULL;
+	}
+
+	if (result->row_packet) {
+		DBG_INF("Freeing packet");
+		PACKET_FREE(result->row_packet);
+		result->row_packet = NULL;
+	}
+
+	if (result->result_set_memory_pool) {
+		DBG_INF("Freeing memory pool");
+		mysqlnd_mempool_destroy(result->result_set_memory_pool TSRMLS_CC);
+		result->result_set_memory_pool = NULL;
+	}
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_internal_free_result_contents */
+static
+void mysqlnd_internal_free_result_contents(MYSQLND_RES * result TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_internal_free_result_contents");
+
+	result->m.free_result_buffers(result TSRMLS_CC);
+
+	if (result->meta) {
+		result->meta->m->free_metadata(result->meta TSRMLS_CC);
+		result->meta = NULL;
+	}
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_internal_free_result */
+static
+void mysqlnd_internal_free_result(MYSQLND_RES * result TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_internal_free_result");
+	result->m.free_result_contents(result TSRMLS_CC);
+
+	if (result->conn) {
+		result->conn->m->free_reference(result->conn TSRMLS_CC);
+		result->conn = NULL;
+	}
+
+	mnd_pefree(result, result->persistent);
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::read_result_metadata */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_res, read_result_metadata)(MYSQLND_RES * result, MYSQLND *conn TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::read_result_metadata");
+
+	/*
+	  Make it safe to call it repeatedly for PS -
+	  better free and allocate a new because the number of field might change 
+	  (select *) with altered table. Also for statements which skip the PS
+	  infrastructure!
+	*/
+	if (result->meta) {
+		result->meta->m->free_metadata(result->meta TSRMLS_CC);
+		result->meta = NULL;
+	}
+
+	result->meta = result->m.result_meta_init(result->field_count, result->persistent TSRMLS_CC);
+	if (!result->meta) {
+		SET_OOM_ERROR(conn->error_info);
+		DBG_RETURN(FAIL);
+	}
+
+	/* 1. Read all fields metadata */
+
+	/* It's safe to reread without freeing */
+	if (FAIL == result->meta->m->read_metadata(result->meta, conn TSRMLS_CC)) {
+		result->m.free_result_contents(result TSRMLS_CC);
+		DBG_RETURN(FAIL);
+	}
+	/* COM_FIELD_LIST is broken and has premature EOF, thus we need to hack here and in mysqlnd_res_meta.c */
+	result->field_count = result->meta->field_count;
+
+	/*
+	  2. Follows an EOF packet, which the client of mysqlnd_read_result_metadata()
+	     should consume.
+	  3. If there is a result set, it follows. The last packet will have 'eof' set
+	     If PS, then no result set follows.
+	*/
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_query_read_result_set_header */
+enum_func_status
+mysqlnd_query_read_result_set_header(MYSQLND *conn, MYSQLND_STMT * s TSRMLS_DC)
+{
+	MYSQLND_STMT_DATA * stmt = s ? s->data:NULL;
+	enum_func_status ret;
+	MYSQLND_PACKET_RSET_HEADER * rset_header = NULL;
+	MYSQLND_PACKET_EOF * fields_eof = NULL;
+
+	DBG_ENTER("mysqlnd_query_read_result_set_header");
+	DBG_INF_FMT("stmt=%lu", stmt? stmt->stmt_id:0);
+
+	ret = FAIL;
+	do {
+		rset_header = conn->protocol->m.get_rset_header_packet(conn->protocol, FALSE TSRMLS_CC);
+		if (!rset_header) {
+			SET_OOM_ERROR(conn->error_info);
+			ret = FAIL;
+			break;
+		}
+
+		SET_ERROR_AFF_ROWS(conn);
+
+		if (FAIL == (ret = PACKET_READ(rset_header, conn))) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading result set's header");
+			break;
+		}
+
+		if (rset_header->error_info.error_no) {
+			/*
+			  Cover a protocol design error: error packet does not
+			  contain the server status. Therefore, the client has no way
+			  to find out whether there are more result sets of
+			  a multiple-result-set statement pending. Luckily, in 5.0 an
+			  error always aborts execution of a statement, wherever it is
+			  a multi-statement or a stored procedure, so it should be
+			  safe to unconditionally turn off the flag here.
+			*/
+			conn->upsert_status.server_status &= ~SERVER_MORE_RESULTS_EXISTS;
+			/*
+			  This will copy the error code and the messages, as they
+			  are buffers in the struct
+			*/
+			conn->error_info = rset_header->error_info;
+			ret = FAIL;
+			DBG_ERR_FMT("error=%s", rset_header->error_info.error);
+			/* Return back from CONN_QUERY_SENT */
+			CONN_SET_STATE(conn, CONN_READY);
+			break;
+		}
+		conn->error_info.error_no = 0;
+
+		switch (rset_header->field_count) {
+			case MYSQLND_NULL_LENGTH: {	/* LOAD DATA LOCAL INFILE */
+				zend_bool is_warning;
+				DBG_INF("LOAD DATA");
+				conn->last_query_type = QUERY_LOAD_LOCAL;
+				conn->field_count = 0; /* overwrite previous value, or the last value could be used and lead to bug#53503 */
+				CONN_SET_STATE(conn, CONN_SENDING_LOAD_DATA);
+				ret = mysqlnd_handle_local_infile(conn, rset_header->info_or_local_file, &is_warning TSRMLS_CC);
+				CONN_SET_STATE(conn,  (ret == PASS || is_warning == TRUE)? CONN_READY:CONN_QUIT_SENT);
+				MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_NON_RSET_QUERY);
+				break;
+			}
+			case 0:				/* UPSERT */
+				DBG_INF("UPSERT");
+				conn->last_query_type = QUERY_UPSERT;
+				conn->field_count = rset_header->field_count;
+				conn->upsert_status.warning_count = rset_header->warning_count;
+				conn->upsert_status.server_status = rset_header->server_status;
+				conn->upsert_status.affected_rows = rset_header->affected_rows;
+				conn->upsert_status.last_insert_id = rset_header->last_insert_id;
+				SET_NEW_MESSAGE(conn->last_message, conn->last_message_len,
+								rset_header->info_or_local_file, rset_header->info_or_local_file_len,
+								conn->persistent);
+				/* Result set can follow UPSERT statement, check server_status */
+				if (conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS) {
+					CONN_SET_STATE(conn, CONN_NEXT_RESULT_PENDING);
+				} else {
+					CONN_SET_STATE(conn, CONN_READY);
+				}
+				ret = PASS;
+				MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_NON_RSET_QUERY);
+				break;
+			default: do {			/* Result set */
+				MYSQLND_RES * result;
+				enum_mysqlnd_collected_stats statistic = STAT_LAST;
+
+				DBG_INF("Result set pending");
+				SET_EMPTY_MESSAGE(conn->last_message, conn->last_message_len, conn->persistent);
+
+				MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_RSET_QUERY);
+				memset(&conn->upsert_status, 0, sizeof(conn->upsert_status));
+				/* restore after zeroing */
+				SET_ERROR_AFF_ROWS(conn);
+
+				conn->last_query_type = QUERY_SELECT;
+				CONN_SET_STATE(conn, CONN_FETCHING_DATA);
+				/* PS has already allocated it */
+				conn->field_count = rset_header->field_count;
+				if (!stmt) {
+					result = conn->current_result = conn->m->result_init(rset_header->field_count, conn->persistent TSRMLS_CC);
+				} else {
+					if (!stmt->result) {
+						DBG_INF("This is 'SHOW'/'EXPLAIN'-like query.");
+						/*
+						  This is 'SHOW'/'EXPLAIN'-like query. Current implementation of
+						  prepared statements can't send result set metadata for these queries
+						  on prepare stage. Read it now.
+						*/
+						result = stmt->result = conn->m->result_init(rset_header->field_count, stmt->persistent TSRMLS_CC);
+					} else {
+						/*
+						  Update result set metadata if it for some reason changed between
+						  prepare and execute, i.e.:
+						  - in case of 'SELECT ?' we don't know column type unless data was
+							supplied to mysql_stmt_execute, so updated column type is sent
+							now.
+						  - if data dictionary changed between prepare and execute, for
+							example a table used in the query was altered.
+						  Note, that now (4.1.3) we always send metadata in reply to
+						  COM_STMT_EXECUTE (even if it is not necessary), so either this or
+						  previous branch always works.
+						*/
+					}
+					result = stmt->result;
+				}
+				if (!result) {
+					SET_OOM_ERROR(conn->error_info);
+					ret = FAIL;
+					break;
+				}
+
+				if (FAIL == (ret = result->m.read_result_metadata(result, conn TSRMLS_CC))) {
+					/* For PS, we leave them in Prepared state */
+					if (!stmt && conn->current_result) {
+						mnd_efree(conn->current_result);
+						conn->current_result = NULL;
+					}
+					DBG_ERR("Error ocurred while reading metadata");
+					break;
+				}
+
+				/* Check for SERVER_STATUS_MORE_RESULTS if needed */
+				fields_eof = conn->protocol->m.get_eof_packet(conn->protocol, FALSE TSRMLS_CC);
+				if (!fields_eof) {
+					SET_OOM_ERROR(conn->error_info);
+					ret = FAIL;
+					break;
+				}
+				if (FAIL == (ret = PACKET_READ(fields_eof, conn))) {
+					DBG_ERR("Error ocurred while reading the EOF packet");
+					result->m.free_result_contents(result TSRMLS_CC);
+					mnd_efree(result);
+					if (!stmt) {
+						conn->current_result = NULL;
+					} else {
+						stmt->result = NULL;
+						memset(stmt, 0, sizeof(MYSQLND_STMT));
+						stmt->state = MYSQLND_STMT_INITTED;
+					}
+				} else {
+					unsigned int to_log = MYSQLND_G(log_mask);
+					to_log &= fields_eof->server_status;
+					DBG_INF_FMT("warnings=%u server_status=%u", fields_eof->warning_count, fields_eof->server_status);
+					conn->upsert_status.warning_count = fields_eof->warning_count;
+					/*
+					  If SERVER_MORE_RESULTS_EXISTS is set then this is either MULTI_QUERY or a CALL()
+					  The first packet after sending the query/com_execute has the bit set only
+					  in this cases. Not sure why it's a needed but it marks that the whole stream
+					  will include many result sets. What actually matters are the bits set at the end
+					  of every result set (the EOF packet).
+					*/
+					conn->upsert_status.server_status = fields_eof->server_status;
+					if (fields_eof->server_status & SERVER_QUERY_NO_GOOD_INDEX_USED) {
+						statistic = STAT_BAD_INDEX_USED;
+					} else if (fields_eof->server_status & SERVER_QUERY_NO_INDEX_USED) {
+						statistic = STAT_NO_INDEX_USED;
+					} else if (fields_eof->server_status & SERVER_QUERY_WAS_SLOW) {
+						statistic = STAT_QUERY_WAS_SLOW;
+					}
+					if (to_log) {
+#if A0
+						char *backtrace = mysqlnd_get_backtrace(TSRMLS_C);
+						php_log_err(backtrace TSRMLS_CC);
+						efree(backtrace);
+#endif
+					}
+					MYSQLND_INC_CONN_STATISTIC(conn->stats, statistic);
+				}
+			} while (0);
+			PACKET_FREE(fields_eof);
+			break; /* switch break */
+		}
+	} while (0);
+	PACKET_FREE(rset_header);
+
+	DBG_INF(ret == PASS? "PASS":"FAIL");
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_fetch_lengths_buffered */
+/*
+  Do lazy initialization for buffered results. As PHP strings have
+  length inside, this function makes not much sense in the context
+  of PHP, to be called as separate function. But let's have it for
+  completeness.
+*/
+static unsigned long *
+mysqlnd_fetch_lengths_buffered(MYSQLND_RES * const result TSRMLS_DC)
+{
+	unsigned int i;
+	zval **previous_row;
+	MYSQLND_RES_BUFFERED *set = result->stored_data;
+
+	/*
+	  If:
+	  - unbuffered result
+	  - first row has not been read
+	  - last_row has been read
+	*/
+	if (set->data_cursor == NULL ||
+		set->data_cursor == set->data ||
+		((set->data_cursor - set->data) > (set->row_count * result->meta->field_count) ))
+	{
+		return NULL;/* No rows or no more rows */
+	}
+
+	previous_row = set->data_cursor - result->meta->field_count;
+	for (i = 0; i < result->meta->field_count; i++) {
+		result->lengths[i] = (Z_TYPE_P(previous_row[i]) == IS_NULL)? 0:Z_STRLEN_P(previous_row[i]);
+	}
+
+	return result->lengths;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_fetch_lengths_unbuffered */
+static unsigned long *
+mysqlnd_fetch_lengths_unbuffered(MYSQLND_RES * const result TSRMLS_DC)
+{
+	/* simulate output of libmysql */
+	return (!result->unbuf || result->unbuf->last_row_data || result->unbuf->eof_reached)? result->lengths:NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_lengths */
+PHPAPI unsigned long * _mysqlnd_fetch_lengths(MYSQLND_RES * const result TSRMLS_DC)
+{
+	return result->m.fetch_lengths? result->m.fetch_lengths(result TSRMLS_CC) : NULL;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_fetch_row_unbuffered_c */
+static MYSQLND_ROW_C
+mysqlnd_fetch_row_unbuffered_c(MYSQLND_RES * result TSRMLS_DC)
+{
+	enum_func_status	ret;
+	MYSQLND_ROW_C		retrow = NULL;
+	unsigned int		i,
+						field_count = result->field_count;
+	MYSQLND_PACKET_ROW	*row_packet = result->row_packet;
+	unsigned long		*lengths = result->lengths;
+
+	DBG_ENTER("mysqlnd_fetch_row_unbuffered_c");
+
+	if (result->unbuf->eof_reached) {
+		/* No more rows obviously */
+		DBG_RETURN(retrow);
+	}
+	if (CONN_GET_STATE(result->conn) != CONN_FETCHING_DATA) {
+		SET_CLIENT_ERROR(result->conn->error_info, CR_COMMANDS_OUT_OF_SYNC,
+						 UNKNOWN_SQLSTATE, mysqlnd_out_of_sync); 
+		DBG_RETURN(retrow);
+	}
+	if (!row_packet) {
+		/* Not fully initialized object that is being cleaned up */
+		DBG_RETURN(retrow);
+	}
+	/* Let the row packet fill our buffer and skip additional mnd_malloc + memcpy */
+	row_packet->skip_extraction = FALSE;
+
+	/*
+	  If we skip rows (row == NULL) we have to
+	  result->m.unbuffered_free_last_data() before it. The function returns always true.
+	*/
+	if (PASS == (ret = PACKET_READ(row_packet, result->conn)) && !row_packet->eof) {
+		result->unbuf->row_count++;
+
+		result->m.unbuffered_free_last_data(result TSRMLS_CC);
+
+		result->unbuf->last_row_data = row_packet->fields;
+		result->unbuf->last_row_buffer = row_packet->row_buffer;
+		row_packet->fields = NULL;
+		row_packet->row_buffer = NULL;
+
+		MYSQLND_INC_CONN_STATISTIC(result->conn->stats, STAT_ROWS_FETCHED_FROM_CLIENT_NORMAL_UNBUF);
+
+		if (!row_packet->skip_extraction) {
+			MYSQLND_FIELD *field = result->meta->fields;
+			struct mysqlnd_field_hash_key * hash_key = result->meta->zend_hash_keys;
+
+			enum_func_status rc = result->m.row_decoder(result->unbuf->last_row_buffer,
+										  result->unbuf->last_row_data,
+										  row_packet->field_count,
+										  row_packet->fields_metadata,
+										  FALSE,
+										  result->conn->options.numeric_and_datetime_as_unicode,
+										  result->conn->options.int_and_float_native,
+										  result->conn->stats TSRMLS_CC);
+			if (PASS != rc) {
+				DBG_RETURN(retrow);
+			}
+
+			retrow = mnd_malloc(result->field_count * sizeof(char *));
+			if (retrow) {
+				for (i = 0; i < field_count; i++, field++, hash_key++) {
+					zval *data = result->unbuf->last_row_data[i];
+					unsigned int len;
+
+					if (Z_TYPE_P(data) != IS_NULL) {
+						convert_to_string(data);
+						retrow[i] = Z_STRVAL_P(data);
+						len = Z_STRLEN_P(data);
+					} else {
+						retrow[i] = NULL;
+						len = 0;
+					}
+
+					if (lengths) {
+						lengths[i] = len;
+					}
+
+					if (field->max_length < len) {
+						field->max_length = len;
+					}
+				}
+			} else {
+				SET_OOM_ERROR(result->conn->error_info);
+			}
+		}
+	} else if (ret == FAIL) {
+		if (row_packet->error_info.error_no) {
+			result->conn->error_info = row_packet->error_info;
+			DBG_ERR_FMT("errorno=%u error=%s", row_packet->error_info.error_no, row_packet->error_info.error);
+		}
+		CONN_SET_STATE(result->conn, CONN_READY);
+		result->unbuf->eof_reached = TRUE; /* so next time we won't get an error */
+	} else if (row_packet->eof) {
+		/* Mark the connection as usable again */
+		DBG_INF_FMT("warningss=%u server_status=%u", row_packet->warning_count, row_packet->server_status);
+		result->unbuf->eof_reached = TRUE;
+		result->conn->upsert_status.warning_count = row_packet->warning_count;
+		result->conn->upsert_status.server_status = row_packet->server_status;
+		/*
+		  result->row_packet will be cleaned when
+		  destroying the result object
+		*/
+		if (result->conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS) {
+			CONN_SET_STATE(result->conn, CONN_NEXT_RESULT_PENDING);
+		} else {
+			CONN_SET_STATE(result->conn, CONN_READY);
+		}
+		result->m.unbuffered_free_last_data(result TSRMLS_CC);
+	}
+
+	DBG_RETURN(retrow);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_fetch_row_unbuffered */
+static enum_func_status
+mysqlnd_fetch_row_unbuffered(MYSQLND_RES * result, void *param, unsigned int flags, zend_bool *fetched_anything TSRMLS_DC)
+{
+	enum_func_status	ret;
+	zval				*row = (zval *) param;
+	MYSQLND_PACKET_ROW	*row_packet = result->row_packet;
+
+	DBG_ENTER("mysqlnd_fetch_row_unbuffered");
+	DBG_INF_FMT("flags=%u", flags);
+
+	*fetched_anything = FALSE;
+	if (result->unbuf->eof_reached) {
+		/* No more rows obviously */
+		DBG_RETURN(PASS);
+	}
+	if (CONN_GET_STATE(result->conn) != CONN_FETCHING_DATA) {
+		SET_CLIENT_ERROR(result->conn->error_info, CR_COMMANDS_OUT_OF_SYNC, UNKNOWN_SQLSTATE, mysqlnd_out_of_sync);
+		DBG_RETURN(FAIL);
+	}
+	if (!row_packet) {
+		/* Not fully initialized object that is being cleaned up */
+		DBG_RETURN(FAIL);
+	}
+	/* Let the row packet fill our buffer and skip additional mnd_malloc + memcpy */
+	row_packet->skip_extraction = row? FALSE:TRUE;
+
+	/*
+	  If we skip rows (row == NULL) we have to
+	  result->m.unbuffered_free_last_data() before it. The function returns always true.
+	*/
+	if (PASS == (ret = PACKET_READ(row_packet, result->conn)) && !row_packet->eof) {
+		result->m.unbuffered_free_last_data(result TSRMLS_CC);
+
+		result->unbuf->last_row_data = row_packet->fields;
+		result->unbuf->last_row_buffer = row_packet->row_buffer;
+		row_packet->fields = NULL;
+		row_packet->row_buffer = NULL;
+
+		MYSQLND_INC_CONN_STATISTIC(result->conn->stats, STAT_ROWS_FETCHED_FROM_CLIENT_NORMAL_UNBUF);
+
+		if (!row_packet->skip_extraction) {
+			HashTable *row_ht = Z_ARRVAL_P(row);
+			MYSQLND_FIELD *field = result->meta->fields;
+			struct mysqlnd_field_hash_key * hash_key = result->meta->zend_hash_keys;
+			unsigned int i, field_count = result->field_count;
+			unsigned long *lengths = result->lengths;
+
+			enum_func_status rc = result->m.row_decoder(result->unbuf->last_row_buffer,
+											result->unbuf->last_row_data,
+											field_count,
+											row_packet->fields_metadata,
+											FALSE,
+											result->conn->options.numeric_and_datetime_as_unicode,
+											result->conn->options.int_and_float_native,
+											result->conn->stats TSRMLS_CC);
+			if (PASS != rc) {
+				DBG_RETURN(FAIL);
+			}
+			for (i = 0; i < field_count; i++, field++, hash_key++) {
+				zval *data = result->unbuf->last_row_data[i];
+				unsigned int len = (Z_TYPE_P(data) == IS_NULL)? 0:Z_STRLEN_P(data);
+
+				if (lengths) {
+					lengths[i] = len;
+				}
+
+				if (flags & MYSQLND_FETCH_NUM) {
+					Z_ADDREF_P(data);
+					zend_hash_next_index_insert(row_ht, &data, sizeof(zval *), NULL);
+				}
+				if (flags & MYSQLND_FETCH_ASSOC) {
+					/* zend_hash_quick_update needs length + trailing zero */
+					/* QQ: Error handling ? */
+					/*
+					  zend_hash_quick_update does not check, as add_assoc_zval_ex do, whether
+					  the index is a numeric and convert it to it. This however means constant
+					  hashing of the column name, which is not needed as it can be precomputed.
+					*/
+					Z_ADDREF_P(data);
+					if (hash_key->is_numeric == FALSE) {
+#if MYSQLND_UNICODE
+						zend_u_hash_quick_update(Z_ARRVAL_P(row), IS_UNICODE,
+												 hash_key->ustr,
+												 hash_key->ulen + 1,
+												 hash_key->key,
+												 (void *) &data, sizeof(zval *), NULL);
+#else
+						zend_hash_quick_update(Z_ARRVAL_P(row),
+											   field->name,
+											   field->name_length + 1,
+											   hash_key->key,
+											   (void *) &data, sizeof(zval *), NULL);
+#endif
+					} else {
+						zend_hash_index_update(Z_ARRVAL_P(row),
+											   hash_key->key,
+											   (void *) &data, sizeof(zval *), NULL);
+					}
+				}
+				if (field->max_length < len) {
+					field->max_length = len;
+				}
+			}
+		}
+		*fetched_anything = TRUE;
+		result->unbuf->row_count++;
+	} else if (ret == FAIL) {
+		if (row_packet->error_info.error_no) {
+			result->conn->error_info = row_packet->error_info;
+			DBG_ERR_FMT("errorno=%u error=%s", row_packet->error_info.error_no, row_packet->error_info.error);
+		}
+		CONN_SET_STATE(result->conn, CONN_READY);
+		result->unbuf->eof_reached = TRUE; /* so next time we won't get an error */
+	} else if (row_packet->eof) {
+		/* Mark the connection as usable again */
+		DBG_INF_FMT("warnings=%u server_status=%u", row_packet->warning_count, row_packet->server_status);
+		result->unbuf->eof_reached = TRUE;
+		result->conn->upsert_status.warning_count = row_packet->warning_count;
+		result->conn->upsert_status.server_status = row_packet->server_status;
+		/*
+		  result->row_packet will be cleaned when
+		  destroying the result object
+		*/
+		if (result->conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS) {
+			CONN_SET_STATE(result->conn, CONN_NEXT_RESULT_PENDING);
+		} else {
+			CONN_SET_STATE(result->conn, CONN_READY);
+		}
+		result->m.unbuffered_free_last_data(result TSRMLS_CC);
+	}
+
+	DBG_INF_FMT("ret=%s fetched=%u", ret == PASS? "PASS":"FAIL", *fetched_anything);
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::use_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_res, use_result)(MYSQLND_RES * const result, zend_bool ps TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::use_result");
+	DBG_INF_FMT("ps=%u", ps);
+
+	SET_EMPTY_ERROR(result->conn->error_info);
+
+
+	if (ps == FALSE) {
+		result->type			= MYSQLND_RES_NORMAL;
+		result->m.fetch_row		= result->m.fetch_row_normal_unbuffered;
+		result->m.fetch_lengths	= mysqlnd_fetch_lengths_unbuffered;
+		result->m.row_decoder	= php_mysqlnd_rowp_read_text_protocol;
+		result->lengths			= mnd_ecalloc(result->field_count, sizeof(unsigned long));
+		if (!result->lengths) {
+			goto oom;
+		}
+	} else {
+		result->type			= MYSQLND_RES_PS_UNBUF;
+		result->m.fetch_row		= NULL;
+		/* result->m.fetch_row() will be set in mysqlnd_ps.c */
+		result->m.fetch_lengths	= NULL; /* makes no sense */
+		result->m.row_decoder	= php_mysqlnd_rowp_read_binary_protocol;
+		result->lengths 		= NULL;
+	}
+
+	result->result_set_memory_pool = mysqlnd_mempool_create(MYSQLND_G(mempool_default_size) TSRMLS_CC);
+	result->unbuf = mnd_ecalloc(1, sizeof(MYSQLND_RES_UNBUFFERED));
+	if (!result->result_set_memory_pool || !result->unbuf) {
+		goto oom;
+	}
+
+	/*
+	  Will be freed in the mysqlnd_internal_free_result_contents() called
+	  by the resource destructor. mysqlnd_fetch_row_unbuffered() expects
+	  this to be not NULL.
+	*/
+	/* FALSE = non-persistent */
+	result->row_packet = result->conn->protocol->m.get_row_packet(result->conn->protocol, FALSE TSRMLS_CC);
+	if (!result->row_packet) {
+		goto oom;
+	}
+	result->row_packet->result_set_memory_pool = result->result_set_memory_pool;
+	result->row_packet->field_count = result->field_count;
+	result->row_packet->binary_protocol = ps;
+	result->row_packet->fields_metadata = result->meta->fields;
+	result->row_packet->bit_fields_count = result->meta->bit_fields_count;
+	result->row_packet->bit_fields_total_len = result->meta->bit_fields_total_len;
+
+	DBG_RETURN(result);
+oom:
+	SET_OOM_ERROR(result->conn->error_info);
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_fetch_row_buffered_c */
+static MYSQLND_ROW_C
+mysqlnd_fetch_row_buffered_c(MYSQLND_RES * result TSRMLS_DC)
+{
+	MYSQLND_ROW_C ret = NULL;
+	MYSQLND_RES_BUFFERED *set = result->stored_data;
+
+	DBG_ENTER("mysqlnd_fetch_row_buffered_c");
+
+	/* If we haven't read everything */
+	if (set->data_cursor &&
+		(set->data_cursor - set->data) < (set->row_count * result->meta->field_count))
+	{
+		zval **current_row = set->data_cursor;
+		MYSQLND_FIELD *field = result->meta->fields;
+		struct mysqlnd_field_hash_key * hash_key = result->meta->zend_hash_keys;
+		unsigned int i;
+
+		if (NULL == current_row[0]) {
+			uint64_t row_num = (set->data_cursor - set->data) / result->meta->field_count;
+			enum_func_status rc = result->m.row_decoder(set->row_buffers[row_num],
+											current_row,
+											result->meta->field_count,
+											result->meta->fields,
+											FALSE,
+											result->conn->options.numeric_and_datetime_as_unicode,
+											result->conn->options.int_and_float_native,
+											result->conn->stats TSRMLS_CC);
+			if (rc != PASS) {
+				DBG_RETURN(ret);
+			}
+			set->initialized_rows++;
+			for (i = 0; i < result->field_count; i++) {
+				/*
+				  NULL fields are 0 length, 0 is not more than 0
+				  String of zero size, definitely can't be the next max_length.
+				  Thus for NULL and zero-length we are quite efficient.
+				*/
+				if (Z_TYPE_P(current_row[i]) >= IS_STRING) {
+					unsigned long len = Z_STRLEN_P(current_row[i]);
+					if (field->max_length < len) {
+						field->max_length = len;
+					}
+				}
+			}
+		}
+
+		set->data_cursor += result->meta->field_count;
+		MYSQLND_INC_GLOBAL_STATISTIC(STAT_ROWS_FETCHED_FROM_CLIENT_NORMAL_BUF);
+
+		ret = mnd_malloc(result->field_count * sizeof(char *));
+		if (ret) {
+			for (i = 0; i < result->field_count; i++, field++, hash_key++) {
+				zval *data = current_row[i];
+
+				if (Z_TYPE_P(data) != IS_NULL) {
+					convert_to_string(data);
+					ret[i] = Z_STRVAL_P(data);
+				} else {
+					ret[i] = NULL;
+				}
+			}
+		}
+		/* there is no conn handle in this function thus we can't set OOM in error_info */
+	} else {
+		set->data_cursor = NULL;
+		DBG_INF("EOF reached");
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_fetch_row_buffered */
+static enum_func_status
+mysqlnd_fetch_row_buffered(MYSQLND_RES * result, void *param, unsigned int flags, zend_bool *fetched_anything TSRMLS_DC)
+{
+	unsigned int i;
+	zval *row = (zval *) param;
+	MYSQLND_RES_BUFFERED *set = result->stored_data;
+	enum_func_status ret = FAIL;
+
+	DBG_ENTER("mysqlnd_fetch_row_buffered");
+	DBG_INF_FMT("flags=%u row=%p", flags, row);
+
+	/* If we haven't read everything */
+	if (set->data_cursor &&
+		(set->data_cursor - set->data) < (set->row_count * result->meta->field_count))
+	{
+		zval **current_row = set->data_cursor;
+		MYSQLND_FIELD *field = result->meta->fields;
+		struct mysqlnd_field_hash_key * hash_key = result->meta->zend_hash_keys;
+
+		if (NULL == current_row[0]) {
+			uint64_t row_num = (set->data_cursor - set->data) / result->meta->field_count;
+			enum_func_status rc = result->m.row_decoder(set->row_buffers[row_num],
+											current_row,
+											result->meta->field_count,
+											result->meta->fields,
+											result->stored_data->persistent,
+											result->conn->options.numeric_and_datetime_as_unicode,
+											result->conn->options.int_and_float_native,
+											result->conn->stats TSRMLS_CC);
+			if (rc != PASS) {
+				DBG_RETURN(FAIL);
+			}
+			set->initialized_rows++;
+			for (i = 0; i < result->field_count; i++) {
+				/*
+				  NULL fields are 0 length, 0 is not more than 0
+				  String of zero size, definitely can't be the next max_length.
+				  Thus for NULL and zero-length we are quite efficient.
+				*/
+				if (Z_TYPE_P(current_row[i]) >= IS_STRING) {
+					unsigned long len = Z_STRLEN_P(current_row[i]);
+					if (field->max_length < len) {
+						field->max_length = len;
+					}
+				}
+			}
+		}
+
+		for (i = 0; i < result->field_count; i++, field++, hash_key++) {
+			zval *data = current_row[i];
+
+			if (flags & MYSQLND_FETCH_NUM) {
+				Z_ADDREF_P(data);
+				zend_hash_next_index_insert(Z_ARRVAL_P(row), &data, sizeof(zval *), NULL);
+			}
+			if (flags & MYSQLND_FETCH_ASSOC) {
+				/* zend_hash_quick_update needs length + trailing zero */
+				/* QQ: Error handling ? */
+				/*
+				  zend_hash_quick_update does not check, as add_assoc_zval_ex do, whether
+				  the index is a numeric and convert it to it. This however means constant
+				  hashing of the column name, which is not needed as it can be precomputed.
+				*/
+				Z_ADDREF_P(data);
+				if (hash_key->is_numeric == FALSE) {
+#if MYSQLND_UNICODE
+					zend_u_hash_quick_update(Z_ARRVAL_P(row), IS_UNICODE,
+											 hash_key->ustr,
+											 hash_key->ulen + 1,
+											 hash_key->key,
+											 (void *) &data, sizeof(zval *), NULL);
+#else
+					zend_hash_quick_update(Z_ARRVAL_P(row),
+										   field->name,
+										   field->name_length + 1,
+										   hash_key->key,
+										   (void *) &data, sizeof(zval *), NULL);
+#endif
+				} else {
+					zend_hash_index_update(Z_ARRVAL_P(row),
+										   hash_key->key,
+										   (void *) &data, sizeof(zval *), NULL);
+				}
+			}
+		}
+		set->data_cursor += result->meta->field_count;
+		*fetched_anything = TRUE;
+		MYSQLND_INC_GLOBAL_STATISTIC(STAT_ROWS_FETCHED_FROM_CLIENT_NORMAL_BUF);
+		ret = PASS;
+	} else {
+		set->data_cursor = NULL;
+		*fetched_anything = FALSE;
+		ret = PASS;
+		DBG_INF("EOF reached");
+	}
+	DBG_INF_FMT("ret=PASS fetched=%u", *fetched_anything);
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+#define STORE_RESULT_PREALLOCATED_SET_IF_NOT_EMPTY 2
+
+/* {{{ mysqlnd_res::store_result_fetch_data */
+enum_func_status
+MYSQLND_METHOD(mysqlnd_res, store_result_fetch_data)(MYSQLND * const conn, MYSQLND_RES * result,
+													MYSQLND_RES_METADATA *meta,
+													zend_bool binary_protocol,
+													zend_bool to_cache TSRMLS_DC)
+{
+	enum_func_status ret;
+	MYSQLND_PACKET_ROW *row_packet = NULL;
+	unsigned int next_extend = STORE_RESULT_PREALLOCATED_SET_IF_NOT_EMPTY, free_rows = 1;
+	MYSQLND_RES_BUFFERED *set;
+
+	DBG_ENTER("mysqlnd_res::store_result_fetch_data");
+	DBG_INF_FMT("conn=%llu binary_proto=%u to_cache=%u",
+				conn->thread_id, binary_protocol, to_cache);
+
+	result->stored_data	= set = mnd_pecalloc(1, sizeof(MYSQLND_RES_BUFFERED), to_cache);
+	if (!set) {
+		SET_OOM_ERROR(conn->error_info);
+		ret = FAIL;
+		goto end;
+	}
+	if (free_rows) {
+		set->row_buffers = mnd_pemalloc((size_t)(free_rows * sizeof(MYSQLND_MEMORY_POOL_CHUNK *)), to_cache);
+		if (!set->row_buffers) {
+			SET_OOM_ERROR(conn->error_info);
+			ret = FAIL;
+			goto end;
+		}
+	}
+	set->persistent	= to_cache;
+	set->references	= 1;
+
+	result->m.row_decoder = binary_protocol? php_mysqlnd_rowp_read_binary_protocol:
+											 php_mysqlnd_rowp_read_text_protocol;
+
+	/* non-persistent */
+	row_packet = conn->protocol->m.get_row_packet(conn->protocol, FALSE TSRMLS_CC);
+	if (!row_packet) {
+		SET_OOM_ERROR(conn->error_info);
+		ret = FAIL;
+		goto end;
+	}
+	row_packet->result_set_memory_pool = result->result_set_memory_pool;
+	row_packet->field_count = meta->field_count;
+	row_packet->binary_protocol = binary_protocol;
+	row_packet->fields_metadata = meta->fields;
+	row_packet->bit_fields_count	= meta->bit_fields_count;
+	row_packet->bit_fields_total_len = meta->bit_fields_total_len;
+
+	row_packet->skip_extraction = TRUE; /* let php_mysqlnd_rowp_read() not allocate row_packet->fields, we will do it */
+
+	while (FAIL != (ret = PACKET_READ(row_packet, conn)) && !row_packet->eof) {
+		if (!free_rows) {
+			uint64_t total_allocated_rows = free_rows = next_extend = next_extend * 11 / 10; /* extend with 10% */
+			MYSQLND_MEMORY_POOL_CHUNK ** new_row_buffers;
+			total_allocated_rows += set->row_count;
+
+			/* don't try to allocate more than possible - mnd_XXalloc expects size_t, and it can have narrower range than uint64_t */
+			if (total_allocated_rows * sizeof(MYSQLND_MEMORY_POOL_CHUNK *) > SIZE_MAX) {
+				SET_OOM_ERROR(conn->error_info);
+				ret = FAIL;
+				goto end;
+			}
+			new_row_buffers = mnd_perealloc(set->row_buffers,
+											(size_t)(total_allocated_rows * sizeof(MYSQLND_MEMORY_POOL_CHUNK *)),
+											set->persistent);
+			if (!new_row_buffers) {
+				SET_OOM_ERROR(conn->error_info);
+				ret = FAIL;
+				goto end;
+			}
+			set->row_buffers = new_row_buffers;
+		}
+		free_rows--;
+		set->row_buffers[set->row_count] = row_packet->row_buffer;
+
+		set->row_count++;
+
+		/* So row_packet's destructor function won't efree() it */
+		row_packet->fields = NULL;
+		row_packet->row_buffer = NULL;
+
+		/*
+		  No need to FREE_ALLOCA as we can reuse the
+		  'lengths' and 'fields' arrays. For lengths its absolutely safe.
+		  'fields' is reused because the ownership of the strings has been
+		  transfered above. 
+		*/
+	}
+	/* Overflow ? */
+	if (set->row_count) {
+		/* don't try to allocate more than possible - mnd_XXalloc expects size_t, and it can have narrower range than uint64_t */
+		if (set->row_count * meta->field_count * sizeof(zval *) > SIZE_MAX) {
+			SET_OOM_ERROR(conn->error_info);
+			ret = FAIL;
+			goto end;
+		}
+		/* if pecalloc is used valgrind barks gcc version 4.3.1 20080507 (prerelease) [gcc-4_3-branch revision 135036] (SUSE Linux) */
+		set->data = mnd_pemalloc((size_t)(set->row_count * meta->field_count * sizeof(zval *)), to_cache);
+		if (!set->data) {
+			SET_OOM_ERROR(conn->error_info);
+			ret = FAIL;
+			goto end;
+		}
+		memset(set->data, 0, (size_t)(set->row_count * meta->field_count * sizeof(zval *)));
+	}
+
+	MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn->stats,
+									   binary_protocol? STAT_ROWS_BUFFERED_FROM_CLIENT_PS:
+														STAT_ROWS_BUFFERED_FROM_CLIENT_NORMAL,
+									   set->row_count);
+
+	/* Finally clean */
+	if (row_packet->eof) { 
+		conn->upsert_status.warning_count = row_packet->warning_count;
+		conn->upsert_status.server_status = row_packet->server_status;
+	}
+	/* save some memory */
+	if (free_rows) {
+		/* don't try to allocate more than possible - mnd_XXalloc expects size_t, and it can have narrower range than uint64_t */
+		if (set->row_count * sizeof(MYSQLND_MEMORY_POOL_CHUNK *) > SIZE_MAX) {
+			SET_OOM_ERROR(conn->error_info);
+			ret = FAIL;
+			goto end;
+		}
+		set->row_buffers = mnd_perealloc(set->row_buffers,
+										 (size_t) (set->row_count * sizeof(MYSQLND_MEMORY_POOL_CHUNK *)),
+										 set->persistent);
+	}
+
+	if (conn->upsert_status.server_status & SERVER_MORE_RESULTS_EXISTS) {
+		CONN_SET_STATE(conn, CONN_NEXT_RESULT_PENDING);
+	} else {
+		CONN_SET_STATE(conn, CONN_READY);
+	}
+
+	if (ret == FAIL) {
+		set->error_info = row_packet->error_info;
+	} else {
+		/* Position at the first row */
+		set->data_cursor = set->data;
+
+		/* libmysql's documentation says it should be so for SELECT statements */
+		conn->upsert_status.affected_rows = set->row_count;
+	}
+	DBG_INF_FMT("ret=%s row_count=%u warnings=%u server_status=%u",
+				ret == PASS? "PASS":"FAIL", (uint) set->row_count, conn->upsert_status.warning_count, conn->upsert_status.server_status);
+end:
+	PACKET_FREE(row_packet);
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::store_result */
+static MYSQLND_RES *
+MYSQLND_METHOD(mysqlnd_res, store_result)(MYSQLND_RES * result,
+										  MYSQLND * const conn,
+										  zend_bool ps_protocol TSRMLS_DC)
+{
+	enum_func_status ret;
+	zend_bool to_cache = FALSE;
+
+	DBG_ENTER("mysqlnd_res::store_result");
+	DBG_INF_FMT("conn=%u ps_protocol=%u", conn->thread_id, ps_protocol);
+
+	/* We need the conn because we are doing lazy zval initialization in buffered_fetch_row */
+	result->conn 			= conn->m->get_reference(conn TSRMLS_CC);
+	result->type			= MYSQLND_RES_NORMAL;
+	result->m.fetch_row		= result->m.fetch_row_normal_buffered;
+	result->m.fetch_lengths	= mysqlnd_fetch_lengths_buffered;
+
+	result->result_set_memory_pool = mysqlnd_mempool_create(MYSQLND_G(mempool_default_size) TSRMLS_CC);
+	result->lengths = mnd_ecalloc(result->field_count, sizeof(unsigned long));
+	if (!result->result_set_memory_pool || !result->lengths) {
+		SET_OOM_ERROR(conn->error_info);
+		DBG_RETURN(NULL);
+	}
+
+	CONN_SET_STATE(conn, CONN_FETCHING_DATA);
+
+	ret = result->m.store_result_fetch_data(conn, result, result->meta, ps_protocol, to_cache TSRMLS_CC);
+	if (FAIL == ret) {
+		if (result->stored_data) {
+			conn->error_info = result->stored_data->error_info;
+		} else {
+			SET_OOM_ERROR(conn->error_info);
+		}
+		DBG_RETURN(NULL);
+	}
+	/* libmysql's documentation says it should be so for SELECT statements */
+	conn->upsert_status.affected_rows = result->stored_data->row_count;
+
+	DBG_RETURN(result);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::skip_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_res, skip_result)(MYSQLND_RES * const result TSRMLS_DC)
+{
+	zend_bool fetched_anything;
+
+	DBG_ENTER("mysqlnd_res::skip_result");
+	/*
+	  Unbuffered sets
+	  A PS could be prepared - there is metadata and thus a stmt->result but the
+	  fetch_row function isn't actually set (NULL), thus we have to skip these.
+	*/
+	if (!result->stored_data && result->unbuf &&
+		!result->unbuf->eof_reached && result->m.fetch_row)
+	{
+		DBG_INF("skipping result");
+		/* We have to fetch all data to clean the line */
+		MYSQLND_INC_CONN_STATISTIC(result->conn->stats,
+									result->type == MYSQLND_RES_NORMAL? STAT_FLUSHED_NORMAL_SETS:
+																		STAT_FLUSHED_PS_SETS);
+
+		while ((PASS == result->m.fetch_row(result, NULL, 0, &fetched_anything TSRMLS_CC)) && fetched_anything == TRUE) {
+			/* do nothing */;
+		}
+	}
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::free_result */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_res, free_result)(MYSQLND_RES * result, zend_bool implicit TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::free_result");
+	DBG_INF_FMT("implicit=%u", implicit);
+
+	result->m.skip_result(result TSRMLS_CC);
+	MYSQLND_INC_CONN_STATISTIC(result->conn? result->conn->stats : NULL,
+							   implicit == TRUE?	STAT_FREE_RESULT_IMPLICIT:
+							   						STAT_FREE_RESULT_EXPLICIT);
+
+	result->m.free_result_internal(result TSRMLS_CC);
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::data_seek */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_res, data_seek)(MYSQLND_RES * result, uint64_t row TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::data_seek");
+	DBG_INF_FMT("row=%lu", row);
+
+	if (!result->stored_data) {
+		return FAIL;
+	}
+
+	/* libmysql just moves to the end, it does traversing of a linked list */
+	if (row >= result->stored_data->row_count) {
+		result->stored_data->data_cursor = NULL;
+	} else {
+		result->stored_data->data_cursor = result->stored_data->data + row * result->meta->field_count;
+	}
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::num_rows */
+static uint64_t
+MYSQLND_METHOD(mysqlnd_res, num_rows)(const MYSQLND_RES * const result TSRMLS_DC)
+{
+	/* Be compatible with libmysql. We count row_count, but will return 0 */
+	return result->stored_data? result->stored_data->row_count:(result->unbuf && result->unbuf->eof_reached? result->unbuf->row_count:0);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::num_fields */
+static unsigned int
+MYSQLND_METHOD(mysqlnd_res, num_fields)(const MYSQLND_RES * const result TSRMLS_DC)
+{
+	return result->field_count;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_field */
+static const MYSQLND_FIELD *
+MYSQLND_METHOD(mysqlnd_res, fetch_field)(MYSQLND_RES * const result TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::fetch_field");
+	do {
+		if (result->meta) {
+			/*
+			  We optimize the result set, so we don't convert all the data from raw buffer format to
+			  zval arrays during store. In the case someone doesn't read all the lines this will
+			  save time. However, when a metadata call is done, we need to calculate max_length.
+			  We don't have control whether max_length will be used, unfortunately. Otherwise we
+			  could have been able to skip that step.
+			  Well, if the mysqli API switches from returning stdClass to class like mysqli_field_metadata,
+			  then we can have max_length as dynamic property, which will be calculated during runtime and
+			  not during mysqli_fetch_field() time.
+			*/
+			if (result->stored_data && (result->stored_data->initialized_rows < result->stored_data->row_count)) {
+				DBG_INF_FMT("We have decode the whole result set to be able to satisfy this meta request");
+				/* we have to initialize the rest to get the updated max length */
+				if (PASS != result->m.initialize_result_set_rest(result TSRMLS_CC)) {
+					break;
+				}
+			}
+			DBG_RETURN(result->meta->m->fetch_field(result->meta TSRMLS_CC));
+		}
+	} while (0);
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_field_direct */
+static const MYSQLND_FIELD *
+MYSQLND_METHOD(mysqlnd_res, fetch_field_direct)(MYSQLND_RES * const result, MYSQLND_FIELD_OFFSET fieldnr TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::fetch_field_direct");
+	do {
+		if (result->meta) {
+			/*
+			  We optimize the result set, so we don't convert all the data from raw buffer format to
+			  zval arrays during store. In the case someone doesn't read all the lines this will
+			  save time. However, when a metadata call is done, we need to calculate max_length.
+			  We don't have control whether max_length will be used, unfortunately. Otherwise we
+			  could have been able to skip that step.
+			  Well, if the mysqli API switches from returning stdClass to class like mysqli_field_metadata,
+			  then we can have max_length as dynamic property, which will be calculated during runtime and
+			  not during mysqli_fetch_field_direct() time.
+			*/
+			if (result->stored_data && (result->stored_data->initialized_rows < result->stored_data->row_count)) {
+				DBG_INF_FMT("We have decode the whole result set to be able to satisfy this meta request");
+				/* we have to initialized the rest to get the updated max length */
+				if (PASS != result->m.initialize_result_set_rest(result TSRMLS_CC)) {
+					break;
+				}
+			}
+			DBG_RETURN(result->meta->m->fetch_field_direct(result->meta, fieldnr TSRMLS_CC));
+		}
+	} while (0);
+
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_field */
+static const MYSQLND_FIELD *
+MYSQLND_METHOD(mysqlnd_res, fetch_fields)(MYSQLND_RES * const result TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res::fetch_fields");
+	do {
+		if (result->meta) {
+			if (result->stored_data && (result->stored_data->initialized_rows < result->stored_data->row_count)) {
+				/* we have to initialize the rest to get the updated max length */
+				if (PASS != result->m.initialize_result_set_rest(result TSRMLS_CC)) {
+					break;
+				}
+			}
+			DBG_RETURN(result->meta->m->fetch_fields(result->meta TSRMLS_CC));
+		}
+	} while (0);
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+
+/* {{{ mysqlnd_res::field_seek */
+static MYSQLND_FIELD_OFFSET
+MYSQLND_METHOD(mysqlnd_res, field_seek)(MYSQLND_RES * const result, MYSQLND_FIELD_OFFSET field_offset TSRMLS_DC)
+{
+	MYSQLND_FIELD_OFFSET return_value = 0;
+	if (result->meta) {
+		return_value = result->meta->current_field;
+		result->meta->current_field = field_offset;
+	}
+	return return_value;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::field_tell */
+static MYSQLND_FIELD_OFFSET
+MYSQLND_METHOD(mysqlnd_res, field_tell)(const MYSQLND_RES * const result TSRMLS_DC)
+{
+	return result->meta? result->meta->m->field_tell(result->meta TSRMLS_CC) : 0;
+}
+/* }}} */
+
+
+/* for php_addslashes */
+#include "ext/standard/php_string.h"
+
+/* {{{ mysqlnd_res::fetch_into */
+static void
+MYSQLND_METHOD(mysqlnd_res, fetch_into)(MYSQLND_RES * result, unsigned int flags,
+										zval *return_value,
+										enum_mysqlnd_extension extension TSRMLS_DC ZEND_FILE_LINE_DC)
+{
+	zend_bool fetched_anything;
+
+	DBG_ENTER("mysqlnd_res::fetch_into");
+	DBG_INF_FMT("flags=%u mysqlnd_extension=%u", flags, extension);
+
+	if (!result->m.fetch_row) {
+		RETVAL_NULL();
+		DBG_VOID_RETURN;
+	}
+	/*
+	  Hint Zend how many elements we will have in the hash. Thus it won't
+	  extend and rehash the hash constantly.
+	*/
+	mysqlnd_array_init(return_value, mysqlnd_num_fields(result) * 2);
+	if (FAIL == result->m.fetch_row(result, (void *)return_value, flags, &fetched_anything TSRMLS_CC)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading a row");
+		zval_dtor(return_value);
+		RETVAL_FALSE;
+	} else if (fetched_anything == FALSE) {
+		zval_dtor(return_value);
+		switch (extension) {
+			case MYSQLND_MYSQLI:
+				RETVAL_NULL();
+				break;
+			case MYSQLND_MYSQL:
+				RETVAL_FALSE;
+				break;
+			default:exit(0);
+		}
+	} 
+	/*
+	  return_value is IS_NULL for no more data and an array for data. Thus it's ok
+	  to return here.
+	*/
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_row_c */
+static MYSQLND_ROW_C
+MYSQLND_METHOD(mysqlnd_res, fetch_row_c)(MYSQLND_RES * result TSRMLS_DC)
+{
+	MYSQLND_ROW_C ret = NULL;
+	DBG_ENTER("mysqlnd_res::fetch_row_c");
+
+	if (result->m.fetch_row) {
+		if (result->m.fetch_row == result->m.fetch_row_normal_buffered) {
+			DBG_RETURN(mysqlnd_fetch_row_buffered_c(result TSRMLS_CC));
+		} else if (result->m.fetch_row == result->m.fetch_row_normal_unbuffered) {
+			DBG_RETURN(mysqlnd_fetch_row_unbuffered_c(result TSRMLS_CC));
+		} else {
+			php_error_docref(NULL TSRMLS_CC, E_ERROR, "result->m.fetch_row has invalid value. Report to the developers");
+		}
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_all */
+static void
+MYSQLND_METHOD(mysqlnd_res, fetch_all)(MYSQLND_RES * result, unsigned int flags, zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC)
+{
+	zval  *row;
+	ulong i = 0;
+	MYSQLND_RES_BUFFERED *set = result->stored_data;
+
+	DBG_ENTER("mysqlnd_res::fetch_all");
+	DBG_INF_FMT("flags=%u", flags);
+
+	if ((!result->unbuf && !set)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "fetch_all can be used only with buffered sets");
+		if (result->conn) {
+			SET_CLIENT_ERROR(result->conn->error_info, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE, "fetch_all can be used only with buffered sets");
+		}
+		RETVAL_NULL();
+		DBG_VOID_RETURN;
+	}
+
+	/* 4 is a magic value. The cast is safe, if larger then the array will be later extended - no big deal :) */
+	mysqlnd_array_init(return_value, set? (unsigned int) set->row_count : 4); 
+
+	do {
+		MAKE_STD_ZVAL(row);
+		mysqlnd_fetch_into(result, flags, row, MYSQLND_MYSQLI);
+		if (Z_TYPE_P(row) != IS_ARRAY) {
+			zval_ptr_dtor(&row);
+			break;
+		}
+		add_index_zval(return_value, i++, row);
+	} while (1);
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::fetch_field_data */
+static void
+MYSQLND_METHOD(mysqlnd_res, fetch_field_data)(MYSQLND_RES * result, unsigned int offset, zval *return_value TSRMLS_DC)
+{
+	zval row;
+	zval **entry;
+	unsigned int i = 0;
+
+	DBG_ENTER("mysqlnd_res::fetch_field_data");
+	DBG_INF_FMT("offset=%u", offset);
+
+	if (!result->m.fetch_row) {
+		RETVAL_NULL();
+		DBG_VOID_RETURN;
+	}
+	/*
+	  Hint Zend how many elements we will have in the hash. Thus it won't
+	  extend and rehash the hash constantly.
+	*/
+	INIT_PZVAL(&row);
+	mysqlnd_fetch_into(result, MYSQLND_FETCH_NUM, &row, MYSQLND_MYSQL);
+	if (Z_TYPE(row) != IS_ARRAY) {
+		zval_dtor(&row);
+		RETVAL_NULL();
+		DBG_VOID_RETURN;
+	}
+	zend_hash_internal_pointer_reset(Z_ARRVAL(row));
+	while (i++ < offset) {
+		zend_hash_move_forward(Z_ARRVAL(row));
+		zend_hash_get_current_data(Z_ARRVAL(row), (void **)&entry);
+	}
+
+	zend_hash_get_current_data(Z_ARRVAL(row), (void **)&entry);
+
+	*return_value = **entry;
+	zval_copy_ctor(return_value);
+	Z_SET_REFCOUNT_P(return_value, 1);
+	zval_dtor(&row);
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+static 
+MYSQLND_CLASS_METHODS_START(mysqlnd_res)
+	NULL, /* fetch_row */
+	mysqlnd_fetch_row_buffered,
+	mysqlnd_fetch_row_unbuffered,
+	MYSQLND_METHOD(mysqlnd_res, use_result),
+	MYSQLND_METHOD(mysqlnd_res, store_result),
+	MYSQLND_METHOD(mysqlnd_res, fetch_into),
+	MYSQLND_METHOD(mysqlnd_res, fetch_row_c),
+	MYSQLND_METHOD(mysqlnd_res, fetch_all),
+	MYSQLND_METHOD(mysqlnd_res, fetch_field_data),
+	MYSQLND_METHOD(mysqlnd_res, num_rows),
+	MYSQLND_METHOD(mysqlnd_res, num_fields),
+	MYSQLND_METHOD(mysqlnd_res, skip_result),
+	MYSQLND_METHOD(mysqlnd_res, data_seek),
+	MYSQLND_METHOD(mysqlnd_res, field_seek),
+	MYSQLND_METHOD(mysqlnd_res, field_tell),
+	MYSQLND_METHOD(mysqlnd_res, fetch_field),
+	MYSQLND_METHOD(mysqlnd_res, fetch_field_direct),
+	MYSQLND_METHOD(mysqlnd_res, fetch_fields),
+	MYSQLND_METHOD(mysqlnd_res, read_result_metadata),
+	NULL, /* fetch_lengths */
+	MYSQLND_METHOD(mysqlnd_res, store_result_fetch_data),
+	MYSQLND_METHOD(mysqlnd_res, initialize_result_set_rest),
+	MYSQLND_METHOD(mysqlnd_res, free_result_buffers),
+	MYSQLND_METHOD(mysqlnd_res, free_result),
+
+	mysqlnd_internal_free_result, /* free_result_internal */
+	mysqlnd_internal_free_result_contents, /* free_result_contents */
+	MYSQLND_METHOD(mysqlnd_res, free_buffered_data),
+	MYSQLND_METHOD(mysqlnd_res, unbuffered_free_last_data),
+
+	NULL /* row_decoder */,
+	mysqlnd_result_meta_init
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ mysqlnd_result_init */
+PHPAPI MYSQLND_RES *
+mysqlnd_result_init(unsigned int field_count, zend_bool persistent TSRMLS_DC)
+{
+	size_t alloc_size = sizeof(MYSQLND_RES) + mysqlnd_plugin_count() * sizeof(void *);
+	MYSQLND_RES *ret = mnd_pecalloc(1, alloc_size, persistent);
+
+	DBG_ENTER("mysqlnd_result_init");
+	DBG_INF_FMT("field_count=%u", field_count);
+
+	if (!ret) {
+		DBG_RETURN(NULL);
+	}
+
+	ret->persistent		= persistent;
+	ret->field_count	= field_count;
+	ret->m = mysqlnd_mysqlnd_res_methods;
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_plugin_get_plugin_result_data */
+PHPAPI void ** _mysqlnd_plugin_get_plugin_result_data(const MYSQLND_RES * result, unsigned int plugin_id TSRMLS_DC)
+{
+	DBG_ENTER("_mysqlnd_plugin_get_plugin_result_data");
+	DBG_INF_FMT("plugin_id=%u", plugin_id);
+	if (!result || plugin_id >= mysqlnd_plugin_count()) {
+		return NULL;
+	}
+	DBG_RETURN((void *)((char *)result + sizeof(MYSQLND_RES) + plugin_id * sizeof(void *)));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_result_get_methods */
+PHPAPI struct st_mysqlnd_res_methods *
+mysqlnd_result_get_methods()
+{
+	return &mysqlnd_mysqlnd_res_methods;
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_result.h
@@ -0,0 +1,40 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_RESULT_H
+#define MYSQLND_RESULT_H
+
+PHPAPI MYSQLND_RES * mysqlnd_result_init(unsigned int field_count, zend_bool persistent TSRMLS_DC);
+PHPAPI struct st_mysqlnd_res_methods * mysqlnd_result_get_methods();
+
+enum_func_status mysqlnd_query_read_result_set_header(MYSQLND * conn, MYSQLND_STMT * stmt TSRMLS_DC);
+
+#endif /* MYSQLND_RESULT_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_result_meta.c
@@ -0,0 +1,532 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_result.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_debug.h"
+#include "ext/standard/basic_functions.h"
+
+
+/* {{{ php_mysqlnd_free_field_metadata */
+static void
+php_mysqlnd_free_field_metadata(MYSQLND_FIELD *meta, zend_bool persistent TSRMLS_DC)
+{
+	if (meta) {
+		if (meta->root) {
+			mnd_pefree(meta->root, persistent);
+			meta->root = NULL;
+		}
+		if (meta->def) {
+			mnd_pefree(meta->def, persistent);
+			meta->def = NULL;
+		}
+	}
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_handle_numeric */
+/*
+  The following code is stolen from ZE - HANDLE_NUMERIC() macro from zend_hash.c
+  and modified for the needs of mysqlnd.
+*/
+static zend_bool
+mysqlnd_is_key_numeric(const char * key, size_t length, long *idx)
+{
+	register const char * tmp = key;
+
+	if (*tmp=='-') {
+		tmp++;
+	}
+	if ((*tmp>='0' && *tmp<='9')) {
+		do { /* possibly a numeric index */
+			const char *end=key+length-1;
+
+			if (*tmp++=='0' && length>2) { /* don't accept numbers with leading zeros */
+				break;
+			}
+			while (tmp<end) {
+				if (!(*tmp>='0' && *tmp<='9')) {
+					break;
+				}
+				tmp++;
+			}
+			if (tmp==end && *tmp=='\0') { /* a numeric index */
+				if (*key=='-') {
+					*idx = strtol(key, NULL, 10);
+					if (*idx!=LONG_MIN) {
+						return TRUE;
+					}
+				} else {
+					*idx = strtol(key, NULL, 10);
+					if (*idx!=LONG_MAX) {
+						return TRUE;
+					}
+				}
+			}
+		} while (0);
+	}
+	return FALSE;
+}
+/* }}} */
+
+
+#if MYSQLND_UNICODE
+/* {{{ mysqlnd_unicode_is_key_numeric */
+static zend_bool
+mysqlnd_unicode_is_key_numeric(UChar *key, size_t length, long *idx)
+{
+	register UChar * tmp=key;
+
+	if (*tmp==0x2D /*'-'*/) {
+		tmp++;
+	}
+	if ((*tmp>=0x30 /*'0'*/ && *tmp<=0x39 /*'9'*/)) { /* possibly a numeric index */
+		do {
+			UChar *end=key+length-1;
+
+			if (*tmp++==0x30 && length>2) { /* don't accept numbers with leading zeros */
+				break;
+			}
+			while (tmp<end) {
+				if (!(*tmp>=0x30 /*'0'*/ && *tmp<=0x39 /*'9'*/)) {
+					break;
+				}
+				tmp++;
+			}
+			if (tmp==end && *tmp==0) { /* a numeric index */
+				if (*key==0x2D /*'-'*/) {
+					*idx = zend_u_strtol(key, NULL, 10);
+					if (*idx!=LONG_MIN) {
+						return TRUE;
+					}
+				} else {
+					*idx = zend_u_strtol(key, NULL, 10);
+					if (*idx!=LONG_MAX) {
+						return TRUE;
+					}
+				}
+			}
+		} while (0);
+	}
+	return FALSE;
+}
+/* }}} */
+#endif
+
+
+/* {{{ mysqlnd_res_meta::read_metadata */
+static enum_func_status
+MYSQLND_METHOD(mysqlnd_res_meta, read_metadata)(MYSQLND_RES_METADATA * const meta, MYSQLND *conn TSRMLS_DC)
+{
+	unsigned int i = 0;
+	MYSQLND_PACKET_RES_FIELD * field_packet;
+#if MYSQLND_UNICODE
+	UChar *ustr;
+	int ulen;
+#endif
+
+	DBG_ENTER("mysqlnd_res_meta::read_metadata");
+
+	field_packet = conn->protocol->m.get_result_field_packet(conn->protocol, FALSE TSRMLS_CC);
+	if (!field_packet) {
+		SET_OOM_ERROR(conn->error_info);
+		DBG_RETURN(FAIL);
+	}
+	field_packet->persistent_alloc = meta->persistent;
+	for (;i < meta->field_count; i++) {
+		long idx;
+
+		if (meta->fields[i].root) {
+			/* We re-read metadata for PS */
+			mnd_pefree(meta->fields[i].root, meta->persistent);
+			meta->fields[i].root = NULL;
+		}
+
+		field_packet->metadata = &(meta->fields[i]);
+		if (FAIL == PACKET_READ(field_packet, conn)) {
+			PACKET_FREE(field_packet);
+			DBG_RETURN(FAIL);
+		}
+		if (field_packet->error_info.error_no) {
+			conn->error_info = field_packet->error_info;
+			/* Return back from CONN_QUERY_SENT */
+			PACKET_FREE(field_packet);
+			DBG_RETURN(FAIL);
+		}
+
+		if (field_packet->stupid_list_fields_eof == TRUE) {
+			meta->field_count = i;
+			break;
+		}
+
+		if (mysqlnd_ps_fetch_functions[meta->fields[i].type].func == NULL) {
+			DBG_ERR_FMT("Unknown type %u sent by the server.  Please send a report to the developers",
+						meta->fields[i].type);
+			php_error_docref(NULL TSRMLS_CC, E_WARNING,
+							 "Unknown type %u sent by the server. "
+							 "Please send a report to the developers",
+							 meta->fields[i].type);
+			PACKET_FREE(field_packet);
+			DBG_RETURN(FAIL);
+		}
+		if (meta->fields[i].type == MYSQL_TYPE_BIT) {
+			size_t field_len;
+			DBG_INF("BIT");
+			++meta->bit_fields_count;
+			/* .length is in bits */
+			field_len = meta->fields[i].length / 8;
+			/*
+			  If there is rest, add one byte :
+			  8 bits = 1 byte but 9 bits = 2 bytes
+			*/
+			if (meta->fields[i].length % 8) {
+				++field_len;
+			}
+			switch (field_len) {
+				case 8:
+				case 7:
+				case 6:
+				case 5:
+					meta->bit_fields_total_len += 20;/* 21 digis, no sign*/
+					break;
+				case 4:
+					meta->bit_fields_total_len += 10;/* 2 000 000 000*/
+					break;
+				case 3:
+					meta->bit_fields_total_len += 8;/*  12 000 000*/
+					break;
+				case 2:
+					meta->bit_fields_total_len += 5;/* 32 500 */
+					break;
+				case 1:
+					meta->bit_fields_total_len += 3;/* 120 */
+					break;
+			}
+		}
+
+#if MYSQLND_UNICODE
+		zend_string_to_unicode(UG(utf8_conv), &ustr, &ulen,
+							   meta->fields[i].name,
+							   meta->fields[i].name_length TSRMLS_CC);
+		if ((meta->zend_hash_keys[i].is_numeric =
+						mysqlnd_unicode_is_key_numeric(ustr, ulen + 1, &idx)))
+		{
+			meta->zend_hash_keys[i].key = idx;
+			mnd_efree(ustr);
+		} else {
+			meta->zend_hash_keys[i].ustr.u = ustr;
+			meta->zend_hash_keys[i].ulen = ulen;
+			meta->zend_hash_keys[i].key = zend_u_get_hash_value(IS_UNICODE, ZSTR(ustr), ulen + 1);
+		}
+#else
+		/* For BC we have to check whether the key is numeric and use it like this */
+		if ((meta->zend_hash_keys[i].is_numeric =
+					mysqlnd_is_key_numeric(field_packet->metadata->name,
+										   field_packet->metadata->name_length + 1,
+										   &idx)))
+		{
+			meta->zend_hash_keys[i].key = idx;
+		} else {
+			meta->zend_hash_keys[i].key =
+					zend_get_hash_value(field_packet->metadata->name,
+										field_packet->metadata->name_length + 1);
+		}
+#endif
+	}
+	PACKET_FREE(field_packet);
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res_meta::free */
+static void
+MYSQLND_METHOD(mysqlnd_res_meta, free)(MYSQLND_RES_METADATA * meta TSRMLS_DC)
+{
+	int i;
+	MYSQLND_FIELD *fields;
+	DBG_ENTER("mysqlnd_res_meta::free");
+	DBG_INF_FMT("persistent=%u", meta->persistent);
+
+	if ((fields = meta->fields)) {
+		DBG_INF("Freeing fields metadata");
+		i = meta->field_count;
+		while (i--) {
+			php_mysqlnd_free_field_metadata(fields++, meta->persistent TSRMLS_CC);
+		}
+		mnd_pefree(meta->fields, meta->persistent);
+		meta->fields = NULL;
+	}
+
+	if (meta->zend_hash_keys) {
+		DBG_INF("Freeing zend_hash_keys");
+#if MYSQLND_UNICODE
+		if (UG(unicode)) {
+			for (i = 0; i < meta->field_count; i++) {
+				if (meta->zend_hash_keys[i].ustr.v) {
+					mnd_pefree(meta->zend_hash_keys[i].ustr.v, meta->persistent);
+				}
+			}
+		}
+#endif
+		mnd_pefree(meta->zend_hash_keys, meta->persistent);
+		meta->zend_hash_keys = NULL;
+	}
+	DBG_INF("Freeing metadata structure");
+	mnd_pefree(meta, meta->persistent);
+
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res::clone_metadata */
+static MYSQLND_RES_METADATA *
+MYSQLND_METHOD(mysqlnd_res_meta, clone_metadata)(const MYSQLND_RES_METADATA * const meta, zend_bool persistent TSRMLS_DC)
+{
+	unsigned int i;
+	/* +1 is to have empty marker at the end */
+	MYSQLND_RES_METADATA * new_meta = NULL;
+	MYSQLND_FIELD * new_fields;
+	MYSQLND_FIELD * orig_fields = meta->fields;
+	size_t len = meta->field_count * sizeof(struct mysqlnd_field_hash_key);
+
+	DBG_ENTER("mysqlnd_res_meta::clone_metadata");
+	DBG_INF_FMT("persistent=%u", persistent);
+
+	new_meta = mnd_pecalloc(1, sizeof(MYSQLND_RES_METADATA), persistent);
+	if (!new_meta) {
+		goto oom;
+	}
+	new_meta->persistent = persistent;
+	new_meta->m = meta->m;
+
+	new_fields = mnd_pecalloc(meta->field_count + 1, sizeof(MYSQLND_FIELD), persistent);
+	if (!new_fields) {
+		goto oom;
+	}
+
+	new_meta->zend_hash_keys = mnd_pemalloc(len, persistent);
+	if (!new_meta->zend_hash_keys) {
+		goto oom;
+	}
+	memcpy(new_meta->zend_hash_keys, meta->zend_hash_keys, len);
+
+	/*
+	  This will copy also the strings and the root, which we will have
+	  to adjust in the loop
+	*/
+	memcpy(new_fields, orig_fields, (meta->field_count) * sizeof(MYSQLND_FIELD));
+	for (i = 0; i < meta->field_count; i++) {
+		/* First copy the root, then field by field adjust the pointers */
+		new_fields[i].root = mnd_pemalloc(orig_fields[i].root_len, persistent);
+		if (!new_fields[i].root) {
+			goto oom;
+		}
+		memcpy(new_fields[i].root, orig_fields[i].root, new_fields[i].root_len);
+
+		if (orig_fields[i].name && orig_fields[i].name != mysqlnd_empty_string) {
+			new_fields[i].name = new_fields[i].root +
+								 (orig_fields[i].name - orig_fields[i].root);
+		}
+		if (orig_fields[i].org_name && orig_fields[i].org_name != mysqlnd_empty_string) {
+			new_fields[i].org_name = new_fields[i].root +
+									 (orig_fields[i].org_name - orig_fields[i].root);
+		}
+		if (orig_fields[i].table && orig_fields[i].table != mysqlnd_empty_string) {
+			new_fields[i].table	= new_fields[i].root +
+								  (orig_fields[i].table - orig_fields[i].root);
+		}
+		if (orig_fields[i].org_table && orig_fields[i].org_table != mysqlnd_empty_string) {
+			new_fields[i].org_table	= new_fields[i].root +
+									  (orig_fields[i].org_table - orig_fields[i].root);
+		}
+		if (orig_fields[i].db && orig_fields[i].db != mysqlnd_empty_string) {
+			new_fields[i].db = new_fields[i].root + (orig_fields[i].db - orig_fields[i].root);
+		}
+		if (orig_fields[i].catalog && orig_fields[i].catalog != mysqlnd_empty_string) {
+			new_fields[i].catalog = new_fields[i].root + (orig_fields[i].catalog - orig_fields[i].root);
+		}
+		/* def is not on the root, if allocated at all */
+		if (orig_fields[i].def) {
+			new_fields[i].def = mnd_pemalloc(orig_fields[i].def_length + 1, persistent);
+			if (!new_fields[i].def) {
+				goto oom;
+			}
+			/* copy the trailing \0 too */
+			memcpy(new_fields[i].def, orig_fields[i].def, orig_fields[i].def_length + 1);
+		}
+#if MYSQLND_UNICODE
+		if (new_meta->zend_hash_keys[i].ustr.u) {
+			new_meta->zend_hash_keys[i].ustr.u =
+					eustrndup(new_meta->zend_hash_keys[i].ustr.u, new_meta->zend_hash_keys[i].ulen);
+			if (!new_meta->zend_hash_keys[i].ustr.u) {
+				goto oom;
+			}
+		}
+#endif
+	}
+	new_meta->current_field = 0;
+	new_meta->field_count = meta->field_count;
+
+	new_meta->fields = new_fields;
+
+	DBG_RETURN(new_meta);
+oom:
+	if (new_meta) {
+		new_meta->m->free_metadata(new_meta TSRMLS_CC);
+		new_meta = NULL;
+	}
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+/* {{{ mysqlnd_res_meta::fetch_field */
+static const MYSQLND_FIELD *
+MYSQLND_METHOD(mysqlnd_res_meta, fetch_field)(MYSQLND_RES_METADATA * const meta TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res_meta::fetch_field");
+	if (meta->current_field >= meta->field_count) {
+		DBG_INF("no more fields");
+		DBG_RETURN(NULL);
+	}
+	DBG_INF_FMT("name=%s max_length=%u",
+		meta->fields[meta->current_field].name? meta->fields[meta->current_field].name:"",
+		meta->fields[meta->current_field].max_length);
+	DBG_RETURN(&meta->fields[meta->current_field++]);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res_meta::fetch_field_direct */
+static const MYSQLND_FIELD *
+MYSQLND_METHOD(mysqlnd_res_meta, fetch_field_direct)(const MYSQLND_RES_METADATA * const meta, MYSQLND_FIELD_OFFSET fieldnr TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res_meta::fetch_field_direct");
+	DBG_INF_FMT("fieldnr=%u", fieldnr);
+	DBG_INF_FMT("name=%s max_length=%u",
+		meta->fields[meta->current_field].name? meta->fields[meta->current_field].name:"",
+		meta->fields[meta->current_field].max_length);
+	DBG_RETURN(&meta->fields[fieldnr]);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res_meta::fetch_fields */
+static const MYSQLND_FIELD *
+MYSQLND_METHOD(mysqlnd_res_meta, fetch_fields)(MYSQLND_RES_METADATA * const meta TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_res_meta::fetch_fields");
+	DBG_RETURN(meta->fields);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res_meta::field_tell */
+static MYSQLND_FIELD_OFFSET
+MYSQLND_METHOD(mysqlnd_res_meta, field_tell)(const MYSQLND_RES_METADATA * const meta TSRMLS_DC)
+{
+	return meta->current_field;
+}
+/* }}} */
+
+
+static
+MYSQLND_CLASS_METHODS_START(mysqlnd_res_meta)
+	MYSQLND_METHOD(mysqlnd_res_meta, fetch_field),
+	MYSQLND_METHOD(mysqlnd_res_meta, fetch_field_direct),
+	MYSQLND_METHOD(mysqlnd_res_meta, fetch_fields),
+	MYSQLND_METHOD(mysqlnd_res_meta, field_tell),
+	MYSQLND_METHOD(mysqlnd_res_meta, read_metadata),
+	MYSQLND_METHOD(mysqlnd_res_meta, clone_metadata),
+	MYSQLND_METHOD(mysqlnd_res_meta, free),
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ mysqlnd_result_meta_init */
+PHPAPI MYSQLND_RES_METADATA *
+mysqlnd_result_meta_init(unsigned int field_count, zend_bool persistent TSRMLS_DC)
+{
+	size_t alloc_size = sizeof(MYSQLND_RES_METADATA) + mysqlnd_plugin_count() * sizeof(void *);
+	MYSQLND_RES_METADATA *ret = mnd_pecalloc(1, alloc_size, persistent);
+	DBG_ENTER("mysqlnd_result_meta_init");
+	DBG_INF_FMT("persistent=%u", persistent);
+
+	do {
+		if (!ret) {
+			break;
+		}
+		ret->m = & mysqlnd_mysqlnd_res_meta_methods;
+
+		ret->persistent = persistent;
+		ret->field_count = field_count;
+		/* +1 is to have empty marker at the end */
+		ret->fields = mnd_pecalloc(field_count + 1, sizeof(MYSQLND_FIELD), ret->persistent);
+		ret->zend_hash_keys = mnd_pecalloc(field_count, sizeof(struct mysqlnd_field_hash_key), ret->persistent);
+		if (!ret->fields || !ret->zend_hash_keys) {
+			break;
+		}
+		DBG_INF_FMT("meta=%p", ret);
+		DBG_RETURN(ret);
+	} while (0);
+	if (ret) {
+		ret->m->free_metadata(ret TSRMLS_CC);
+	}
+	DBG_RETURN(NULL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_res_meta_get_methods */
+PHPAPI struct st_mysqlnd_res_meta_methods *
+mysqlnd_result_metadata_get_methods()
+{
+	return &mysqlnd_mysqlnd_res_meta_methods;
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_plugin_get_plugin_result_metadata_data */
+PHPAPI void **
+_mysqlnd_plugin_get_plugin_result_metadata_data(const MYSQLND_RES_METADATA * meta, unsigned int plugin_id TSRMLS_DC)
+{
+	DBG_ENTER("_mysqlnd_plugin_get_plugin_result_metadata_data");
+	DBG_INF_FMT("plugin_id=%u", plugin_id);
+	if (!meta || plugin_id >= mysqlnd_plugin_count()) {
+		return NULL;
+	}
+	DBG_RETURN((void *)((char *)meta + sizeof(MYSQLND_RES_METADATA) + plugin_id * sizeof(void *)));
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_result_meta.h
@@ -0,0 +1,39 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_RESULT_META_H
+#define MYSQLND_RESULT_META_H
+
+PHPAPI MYSQLND_RES_METADATA * mysqlnd_result_meta_init(unsigned int field_count, zend_bool persistent TSRMLS_DC);
+PHPAPI struct st_mysqlnd_res_meta_methods * mysqlnd_result_metadata_get_methods();
+PHPAPI void ** _mysqlnd_plugin_get_plugin_result_metadata_data(const MYSQLND_RES_METADATA * meta, unsigned int plugin_id TSRMLS_DC);
+
+#endif /* MYSQLND_RESULT_META_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_statistics.c
@@ -0,0 +1,320 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_statistics.h"
+#include "mysqlnd_debug.h"
+
+
+#define STR_W_LEN(str)  str, (sizeof(str) - 1)
+
+/* {{{ mysqlnd_stats_values_names 
+ */
+
+const MYSQLND_STRING mysqlnd_stats_values_names[STAT_LAST] =
+{
+	{ STR_W_LEN("bytes_sent") },
+	{ STR_W_LEN("bytes_received") }, 
+	{ STR_W_LEN("packets_sent") },
+	{ STR_W_LEN("packets_received") },
+	{ STR_W_LEN("protocol_overhead_in") },
+	{ STR_W_LEN("protocol_overhead_out") },
+	{ STR_W_LEN("bytes_received_ok_packet") }, 
+	{ STR_W_LEN("bytes_received_eof_packet") }, 
+	{ STR_W_LEN("bytes_received_rset_header_packet") }, 
+	{ STR_W_LEN("bytes_received_rset_field_meta_packet") }, 
+	{ STR_W_LEN("bytes_received_rset_row_packet") }, 
+	{ STR_W_LEN("bytes_received_prepare_response_packet") }, 
+	{ STR_W_LEN("bytes_received_change_user_packet") }, 
+	{ STR_W_LEN("packets_sent_command") }, 
+	{ STR_W_LEN("packets_received_ok") }, 
+	{ STR_W_LEN("packets_received_eof") }, 
+	{ STR_W_LEN("packets_received_rset_header") }, 
+	{ STR_W_LEN("packets_received_rset_field_meta") }, 
+	{ STR_W_LEN("packets_received_rset_row") }, 
+	{ STR_W_LEN("packets_received_prepare_response") }, 
+	{ STR_W_LEN("packets_received_change_user") }, 
+	{ STR_W_LEN("result_set_queries") },
+	{ STR_W_LEN("non_result_set_queries") },
+	{ STR_W_LEN("no_index_used") },
+	{ STR_W_LEN("bad_index_used") },
+	{ STR_W_LEN("slow_queries") },
+	{ STR_W_LEN("buffered_sets") },
+	{ STR_W_LEN("unbuffered_sets") },
+	{ STR_W_LEN("ps_buffered_sets") },
+	{ STR_W_LEN("ps_unbuffered_sets") },
+	{ STR_W_LEN("flushed_normal_sets") },
+	{ STR_W_LEN("flushed_ps_sets") },
+	{ STR_W_LEN("ps_prepared_never_executed") },
+	{ STR_W_LEN("ps_prepared_once_executed") },
+	{ STR_W_LEN("rows_fetched_from_server_normal") },
+	{ STR_W_LEN("rows_fetched_from_server_ps") },
+	{ STR_W_LEN("rows_buffered_from_client_normal") },
+	{ STR_W_LEN("rows_buffered_from_client_ps") },
+	{ STR_W_LEN("rows_fetched_from_client_normal_buffered") },
+	{ STR_W_LEN("rows_fetched_from_client_normal_unbuffered") },
+	{ STR_W_LEN("rows_fetched_from_client_ps_buffered") },
+	{ STR_W_LEN("rows_fetched_from_client_ps_unbuffered") },
+	{ STR_W_LEN("rows_fetched_from_client_ps_cursor") },
+	{ STR_W_LEN("rows_affected_normal") },
+	{ STR_W_LEN("rows_affected_ps") },
+	{ STR_W_LEN("rows_skipped_normal") },
+	{ STR_W_LEN("rows_skipped_ps") },
+	{ STR_W_LEN("copy_on_write_saved") },
+	{ STR_W_LEN("copy_on_write_performed") },
+	{ STR_W_LEN("command_buffer_too_small") },
+	{ STR_W_LEN("connect_success") },
+	{ STR_W_LEN("connect_failure") },
+	{ STR_W_LEN("connection_reused") },
+	{ STR_W_LEN("reconnect") },
+	{ STR_W_LEN("pconnect_success") },
+	{ STR_W_LEN("active_connections") },
+	{ STR_W_LEN("active_persistent_connections") },
+	{ STR_W_LEN("explicit_close") },
+	{ STR_W_LEN("implicit_close") },
+	{ STR_W_LEN("disconnect_close") },
+	{ STR_W_LEN("in_middle_of_command_close") },
+	{ STR_W_LEN("explicit_free_result") },
+	{ STR_W_LEN("implicit_free_result") },
+	{ STR_W_LEN("explicit_stmt_close") },
+	{ STR_W_LEN("implicit_stmt_close") },
+	{ STR_W_LEN("mem_emalloc_count") },
+	{ STR_W_LEN("mem_emalloc_amount") },
+	{ STR_W_LEN("mem_ecalloc_count") },
+	{ STR_W_LEN("mem_ecalloc_amount") },
+	{ STR_W_LEN("mem_erealloc_count") },
+	{ STR_W_LEN("mem_erealloc_amount") },
+	{ STR_W_LEN("mem_efree_count") },
+	{ STR_W_LEN("mem_efree_amount") },
+	{ STR_W_LEN("mem_malloc_count") },
+	{ STR_W_LEN("mem_malloc_amount") },
+	{ STR_W_LEN("mem_calloc_count") },
+	{ STR_W_LEN("mem_calloc_amount") },
+	{ STR_W_LEN("mem_realloc_count") },
+	{ STR_W_LEN("mem_realloc_amount") },
+	{ STR_W_LEN("mem_free_count") },
+	{ STR_W_LEN("mem_free_amount") },
+	{ STR_W_LEN("mem_estrndup_count") },
+	{ STR_W_LEN("mem_strndup_count") },
+	{ STR_W_LEN("mem_estndup_count") },
+	{ STR_W_LEN("mem_strdup_count") },
+	{ STR_W_LEN("proto_text_fetched_null") },
+	{ STR_W_LEN("proto_text_fetched_bit") },
+	{ STR_W_LEN("proto_text_fetched_tinyint") },
+	{ STR_W_LEN("proto_text_fetched_short") },
+	{ STR_W_LEN("proto_text_fetched_int24") },
+	{ STR_W_LEN("proto_text_fetched_int") },
+	{ STR_W_LEN("proto_text_fetched_bigint") },
+	{ STR_W_LEN("proto_text_fetched_decimal") },
+	{ STR_W_LEN("proto_text_fetched_float") },
+	{ STR_W_LEN("proto_text_fetched_double") },
+	{ STR_W_LEN("proto_text_fetched_date") },
+	{ STR_W_LEN("proto_text_fetched_year") },
+	{ STR_W_LEN("proto_text_fetched_time") },
+	{ STR_W_LEN("proto_text_fetched_datetime") },
+	{ STR_W_LEN("proto_text_fetched_timestamp") },
+	{ STR_W_LEN("proto_text_fetched_string") },
+	{ STR_W_LEN("proto_text_fetched_blob") },
+	{ STR_W_LEN("proto_text_fetched_enum") },
+	{ STR_W_LEN("proto_text_fetched_set") },
+	{ STR_W_LEN("proto_text_fetched_geometry") },
+	{ STR_W_LEN("proto_text_fetched_other") },
+	{ STR_W_LEN("proto_binary_fetched_null") },
+	{ STR_W_LEN("proto_binary_fetched_bit") },
+	{ STR_W_LEN("proto_binary_fetched_tinyint") },
+	{ STR_W_LEN("proto_binary_fetched_short") },
+	{ STR_W_LEN("proto_binary_fetched_int24") },
+	{ STR_W_LEN("proto_binary_fetched_int") },
+	{ STR_W_LEN("proto_binary_fetched_bigint") },
+	{ STR_W_LEN("proto_binary_fetched_decimal") },
+	{ STR_W_LEN("proto_binary_fetched_float") },
+	{ STR_W_LEN("proto_binary_fetched_double") },
+	{ STR_W_LEN("proto_binary_fetched_date") },
+	{ STR_W_LEN("proto_binary_fetched_year") },
+	{ STR_W_LEN("proto_binary_fetched_time") },
+	{ STR_W_LEN("proto_binary_fetched_datetime") },
+	{ STR_W_LEN("proto_binary_fetched_timestamp") },
+	{ STR_W_LEN("proto_binary_fetched_string") },
+	{ STR_W_LEN("proto_binary_fetched_blob") },
+	{ STR_W_LEN("proto_binary_fetched_enum") },
+	{ STR_W_LEN("proto_binary_fetched_set") },
+	{ STR_W_LEN("proto_binary_fetched_geometry") },
+	{ STR_W_LEN("proto_binary_fetched_other") },
+	{ STR_W_LEN("init_command_executed_count") },
+	{ STR_W_LEN("init_command_failed_count") },
+	{ STR_W_LEN("com_quit") },
+	{ STR_W_LEN("com_init_db") },
+	{ STR_W_LEN("com_query") },
+	{ STR_W_LEN("com_field_list") },
+	{ STR_W_LEN("com_create_db") },
+	{ STR_W_LEN("com_drop_db") },
+	{ STR_W_LEN("com_refresh") },
+	{ STR_W_LEN("com_shutdown") },
+	{ STR_W_LEN("com_statistics") },
+	{ STR_W_LEN("com_process_info") },
+	{ STR_W_LEN("com_connect") },
+	{ STR_W_LEN("com_process_kill") },
+	{ STR_W_LEN("com_debug") },
+	{ STR_W_LEN("com_ping") },
+	{ STR_W_LEN("com_time") },
+	{ STR_W_LEN("com_delayed_insert") },
+	{ STR_W_LEN("com_change_user") },
+	{ STR_W_LEN("com_binlog_dump") },
+	{ STR_W_LEN("com_table_dump") },
+	{ STR_W_LEN("com_connect_out") },
+	{ STR_W_LEN("com_register_slave") },
+	{ STR_W_LEN("com_stmt_prepare") },
+	{ STR_W_LEN("com_stmt_execute") },
+	{ STR_W_LEN("com_stmt_send_long_data") },
+	{ STR_W_LEN("com_stmt_close") },
+	{ STR_W_LEN("com_stmt_reset") },
+	{ STR_W_LEN("com_stmt_set_option") },
+	{ STR_W_LEN("com_stmt_fetch") },
+	{ STR_W_LEN("com_deamon") },
+	{ STR_W_LEN("bytes_received_real_data_normal") },
+	{ STR_W_LEN("bytes_received_real_data_ps") }
+};
+/* }}} */
+
+
+/* {{{ mysqlnd_fill_stats_hash */
+PHPAPI void
+mysqlnd_fill_stats_hash(const MYSQLND_STATS * const stats, const MYSQLND_STRING * names, zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC)
+{
+	unsigned int i;
+
+	mysqlnd_array_init(return_value, stats->count);
+	for (i = 0; i < stats->count; i++) {
+#if MYSQLND_UNICODE
+		UChar *ustr, *tstr;
+		int ulen, tlen;
+#endif
+		char tmp[25];
+
+		sprintf((char *)&tmp, MYSQLND_LLU_SPEC, stats->values[i]);
+#if MYSQLND_UNICODE
+		zend_string_to_unicode(UG(utf8_conv), &ustr, &ulen, names[i].s, names[i].l + 1 TSRMLS_CC);
+		zend_string_to_unicode(UG(utf8_conv), &tstr, &tlen, tmp, strlen(tmp) + 1 TSRMLS_CC);
+		add_u_assoc_unicode_ex(return_value, IS_UNICODE, ZSTR(ustr), ulen, tstr, 1);
+		efree(ustr);
+		efree(tstr);
+#else
+		add_assoc_string_ex(return_value, names[i].s, names[i].l + 1, tmp, 1);
+#endif
+	}
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_get_client_stats */
+PHPAPI void
+_mysqlnd_get_client_stats(zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC)
+{
+	MYSQLND_STATS stats, *stats_ptr = mysqlnd_global_stats;
+	DBG_ENTER("_mysqlnd_get_client_stats");
+	if (!stats_ptr) {
+		memset(&stats, 0, sizeof(stats));
+		stats_ptr = &stats;
+	}
+	mysqlnd_fill_stats_hash(stats_ptr, mysqlnd_stats_values_names, return_value TSRMLS_CC ZEND_FILE_LINE_CC);
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stats_init */
+PHPAPI void
+mysqlnd_stats_init(MYSQLND_STATS ** stats, size_t statistic_count)
+{
+	*stats = calloc(1, sizeof(MYSQLND_STATS));
+	if (*stats == NULL) {
+		return;
+	}
+	(*stats)->values = calloc(statistic_count, sizeof(uint64_t));
+	(*stats)->triggers = calloc(statistic_count, sizeof(mysqlnd_stat_trigger));
+	(*stats)->in_trigger = FALSE;
+	(*stats)->count = statistic_count;
+#ifdef ZTS
+	(*stats)->LOCK_access = tsrm_mutex_alloc();
+#endif
+
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stats_end */
+PHPAPI void
+mysqlnd_stats_end(MYSQLND_STATS * stats)
+{
+#ifdef ZTS
+	tsrm_mutex_free(stats->LOCK_access);
+#endif
+	free(stats->triggers);
+	free(stats->values);
+	/* mnd_free will reference LOCK_access and crash...*/
+	free(stats);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stats_set_trigger */
+PHPAPI mysqlnd_stat_trigger
+mysqlnd_stats_set_trigger(MYSQLND_STATS * const stats, enum_mysqlnd_collected_stats statistic, mysqlnd_stat_trigger trigger TSRMLS_DC)
+{
+	mysqlnd_stat_trigger ret = NULL;
+	DBG_ENTER("mysqlnd_stats_set_trigger");
+	if (stats) {
+		MYSQLND_STATS_LOCK(stats);
+		ret = stats->triggers[statistic];
+		stats->triggers[statistic] = trigger;
+		MYSQLND_STATS_UNLOCK(stats);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_stats_set_handler */
+PHPAPI mysqlnd_stat_trigger
+mysqlnd_stats_reset_triggers(MYSQLND_STATS * const stats TSRMLS_DC)
+{
+	mysqlnd_stat_trigger ret = NULL;
+	DBG_ENTER("mysqlnd_stats_reset_trigger");
+	if (stats) {
+		MYSQLND_STATS_LOCK(stats);
+		memset(stats->triggers, 0, stats->count * sizeof(mysqlnd_stat_trigger));
+		MYSQLND_STATS_UNLOCK(stats);
+	}
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_statistics.h
@@ -0,0 +1,183 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_STATISTICS_H
+#define MYSQLND_STATISTICS_H
+
+
+PHPAPI extern MYSQLND_STATS * mysqlnd_global_stats;
+
+typedef struct st_mysqlnd_string
+{
+	char	*s;
+	size_t	l;
+} MYSQLND_STRING;
+
+extern const MYSQLND_STRING mysqlnd_stats_values_names[];
+
+#ifdef ZTS
+#define MYSQLND_STATS_LOCK(stats) tsrm_mutex_lock((stats)->LOCK_access)
+#define MYSQLND_STATS_UNLOCK(stats) tsrm_mutex_unlock((stats)->LOCK_access)
+#else
+#define MYSQLND_STATS_LOCK(stats)
+#define MYSQLND_STATS_UNLOCK(stats)
+#endif
+
+#ifndef MYSQLND_CORE_STATISTICS_TRIGGERS_DISABLED
+#define MYSQLND_STAT_CALL_TRIGGER(s_array, statistic, val) \
+			if ((s_array)->triggers[(statistic)] && (s_array)->in_trigger == FALSE) { \
+				(s_array)->in_trigger = TRUE; \
+				MYSQLND_STATS_UNLOCK((s_array)); \
+																						\
+				(s_array)->triggers[(statistic)]((s_array), (statistic), (val) TSRMLS_CC); \
+																						\
+				MYSQLND_STATS_LOCK((s_array)); \
+				(s_array)->in_trigger = FALSE; \
+			} 
+#else
+#define MYSQLND_STAT_CALL_TRIGGER(s_array, statistic, val)
+#endif /* MYSQLND_CORE_STATISTICS_TRIGGERS_DISABLED */
+
+#define MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(stats, statistic, value) \
+	{ \
+			MYSQLND_STATS_LOCK(stats); \
+			(stats)->values[(statistic)] += (value); \
+			MYSQLND_STAT_CALL_TRIGGER((stats), (statistic), (value)); \
+			MYSQLND_STATS_UNLOCK(_p_s); \
+	}
+
+#define MYSQLND_DEC_STATISTIC(enabler, stats, statistic) \
+ { \
+	enum_mysqlnd_collected_stats _s = (statistic);\
+	MYSQLND_STATS * _p_s = (MYSQLND_STATS *) (stats); \
+	if ((enabler) && _p_s && _s != _p_s->count) { \
+		MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s, -1); \
+	}\
+ }
+
+#define MYSQLND_INC_STATISTIC(enabler, stats, statistic) \
+ { \
+	enum_mysqlnd_collected_stats _s = (statistic);\
+	MYSQLND_STATS * _p_s = (MYSQLND_STATS *) (stats); \
+	if ((enabler) && _p_s && _s != _p_s->count) { \
+		MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s, 1); \
+	}\
+ }
+
+#define MYSQLND_INC_STATISTIC_W_VALUE(enabler, stats, statistic, value) \
+ { \
+	enum_mysqlnd_collected_stats _s = (statistic);\
+	MYSQLND_STATS * _p_s = (MYSQLND_STATS *) (stats); \
+	if ((enabler) && _p_s && _s != _p_s->count) { \
+		uint64_t v = (uint64_t) (value); \
+		MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s, v); \
+	}\
+ }
+
+#define MYSQLND_INC_STATISTIC_W_VALUE2(enabler, stats, statistic1, value1, statistic2, value2) \
+ { \
+	MYSQLND_STATS * _p_s = (MYSQLND_STATS *) (stats); \
+	if ((enabler) && _p_s) { \
+		uint64_t v1 = (uint64_t) (value1); \
+		uint64_t v2 = (uint64_t) (value2); \
+		enum_mysqlnd_collected_stats _s1 = (statistic1);\
+		enum_mysqlnd_collected_stats _s2 = (statistic2);\
+		if (_s1 != _p_s->count) MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s1, v1); \
+		if (_s2 != _p_s->count) MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s2, v2); \
+	}\
+ }
+
+#define MYSQLND_INC_STATISTIC_W_VALUE3(enabler, stats, statistic1, value1, statistic2, value2, statistic3, value3) \
+ { \
+	MYSQLND_STATS * _p_s = (MYSQLND_STATS *) (stats); \
+	if ((enabler) && _p_s) { \
+		uint64_t v1 = (uint64_t) (value1); \
+		uint64_t v2 = (uint64_t) (value2); \
+		uint64_t v3 = (uint64_t) (value3); \
+		enum_mysqlnd_collected_stats _s1 = (statistic1);\
+		enum_mysqlnd_collected_stats _s2 = (statistic2);\
+		enum_mysqlnd_collected_stats _s3 = (statistic3);\
+		if (_s1 != _p_s->count) MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s1, v1); \
+		if (_s2 != _p_s->count) MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s2, v2); \
+		if (_s3 != _p_s->count) MYSQLND_UPDATE_VALUE_AND_CALL_TRIGGER(_p_s, _s3, v3); \
+	}\
+ }
+
+
+
+#ifndef MYSQLND_CORE_STATISTICS_DISABLED
+
+#define MYSQLND_INC_GLOBAL_STATISTIC(statistic) \
+	MYSQLND_INC_STATISTIC(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic))
+
+#define MYSQLND_DEC_CONN_STATISTIC(conn_stats, statistic) \
+	MYSQLND_DEC_STATISTIC(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic))
+
+#define MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(statistic1, value1, statistic2, value2) \
+	MYSQLND_INC_STATISTIC_W_VALUE2(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic1), (value1), (statistic2), (value2))
+
+#define MYSQLND_INC_CONN_STATISTIC(conn_stats, statistic) \
+	MYSQLND_INC_STATISTIC(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic)); \
+	MYSQLND_INC_STATISTIC(MYSQLND_G(collect_statistics), (conn_stats), (statistic));
+
+#define MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn_stats, statistic, value) \
+	MYSQLND_INC_STATISTIC_W_VALUE(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic), (value)); \
+	MYSQLND_INC_STATISTIC_W_VALUE(MYSQLND_G(collect_statistics), (conn_stats), (statistic), (value));
+
+#define MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn_stats, statistic1, value1, statistic2, value2) \
+	MYSQLND_INC_STATISTIC_W_VALUE2(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic1), (value1), (statistic2), (value2)); \
+	MYSQLND_INC_STATISTIC_W_VALUE2(MYSQLND_G(collect_statistics), (conn_stats), (statistic1), (value1), (statistic2), (value2));
+
+#define MYSQLND_INC_CONN_STATISTIC_W_VALUE3(conn_stats, statistic1, value1, statistic2, value2, statistic3, value3) \
+	MYSQLND_INC_STATISTIC_W_VALUE3(MYSQLND_G(collect_statistics), mysqlnd_global_stats, (statistic1), (value1), (statistic2), (value2), (statistic3), (value3)); \
+	MYSQLND_INC_STATISTIC_W_VALUE3(MYSQLND_G(collect_statistics), (conn_stats), (statistic1), (value1), (statistic2), (value2), (statistic3), (value3));
+
+#else
+
+#define MYSQLND_INC_GLOBAL_STATISTIC(statistic) 
+#define MYSQLND_DEC_CONN_STATISTIC(conn_stats, statistic)
+#define MYSQLND_INC_GLOBAL_STATISTIC_W_VALUE2(statistic1, value1, statistic2, value2)
+#define MYSQLND_INC_CONN_STATISTIC(conn_stats, statistic)
+#define MYSQLND_INC_CONN_STATISTIC_W_VALUE(conn_stats, statistic, value)
+#define MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn_stats, statistic1, value1, statistic2, value2)
+#define MYSQLND_INC_CONN_STATISTIC_W_VALUE3(conn_stats, statistic1, value1, statistic2, value2, statistic3, value3)
+
+#endif /* MYSQLND_CORE_STATISTICS_DISABLED */
+
+PHPAPI void mysqlnd_fill_stats_hash(const MYSQLND_STATS * const stats, const MYSQLND_STRING * names, zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC);
+
+PHPAPI void mysqlnd_stats_init(MYSQLND_STATS ** stats, size_t statistic_count);
+PHPAPI void mysqlnd_stats_end(MYSQLND_STATS * stats);
+
+PHPAPI mysqlnd_stat_trigger mysqlnd_stats_set_trigger(MYSQLND_STATS * const stats, enum_mysqlnd_collected_stats stat, mysqlnd_stat_trigger trigger TSRMLS_DC);
+PHPAPI mysqlnd_stat_trigger mysqlnd_stats_reset_triggers(MYSQLND_STATS * const stats TSRMLS_DC);
+
+#endif	/* MYSQLND_STATISTICS_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_structs.h
@@ -0,0 +1,934 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_STRUCTS_H
+#define MYSQLND_STRUCTS_H
+
+#define MYSQLND_TYPEDEFED_METHODS
+
+typedef struct st_mysqlnd_memory_pool MYSQLND_MEMORY_POOL;
+typedef struct st_mysqlnd_memory_pool_chunk MYSQLND_MEMORY_POOL_CHUNK;
+typedef struct st_mysqlnd_memory_pool_chunk_llist MYSQLND_MEMORY_POOL_CHUNK_LLIST;
+
+
+#define MYSQLND_MEMORY_POOL_CHUNK_LIST_SIZE 100
+
+struct st_mysqlnd_memory_pool
+{
+	zend_uchar *arena;
+	unsigned int refcount;
+	unsigned int arena_size;
+	unsigned int free_size;
+
+	MYSQLND_MEMORY_POOL_CHUNK*	(*get_chunk)(MYSQLND_MEMORY_POOL * pool, unsigned int size TSRMLS_DC);
+};
+
+struct st_mysqlnd_memory_pool_chunk
+{
+	size_t				app;
+	MYSQLND_MEMORY_POOL	*pool;
+	zend_uchar			*ptr;
+	unsigned int		size;
+	enum_func_status	(*resize_chunk)(MYSQLND_MEMORY_POOL_CHUNK * chunk, unsigned int size TSRMLS_DC);
+	void				(*free_chunk)(MYSQLND_MEMORY_POOL_CHUNK * chunk TSRMLS_DC);
+	zend_bool			from_pool;
+};
+
+
+typedef struct st_mysqlnd_cmd_buffer
+{
+	zend_uchar		*buffer;
+	size_t			length;
+} MYSQLND_CMD_BUFFER;
+
+
+typedef struct st_mysqlnd_field
+{
+	const char *name;			/* Name of column */
+	const char *org_name;		/* Original column name, if an alias */
+	const char *table;			/* Table of column if column was a field */
+	const char *org_table;		/* Org table name, if table was an alias */
+	const char *db;				/* Database for table */
+	const char *catalog;		/* Catalog for table */
+	char *def;					/* Default value (set by mysql_list_fields) */
+	unsigned long length;		/* Width of column (create length) */
+	unsigned long max_length;	/* Max width for selected set */
+	unsigned int name_length;
+	unsigned int org_name_length;
+	unsigned int table_length;
+	unsigned int org_table_length;
+	unsigned int db_length;
+	unsigned int catalog_length;
+	unsigned int def_length;
+	unsigned int flags;			/* Diverse flags */
+	unsigned int decimals;		/* Number of decimals in field */
+	unsigned int charsetnr;		/* Character set */
+	enum mysqlnd_field_types type;	/* Type of field. See mysql_com.h for types */
+	char *root;
+	size_t root_len;
+} MYSQLND_FIELD;
+
+
+typedef struct st_mysqlnd_upsert_result
+{
+	unsigned int	warning_count;
+	unsigned int	server_status;
+	uint64_t		affected_rows;
+	uint64_t		last_insert_id;
+} MYSQLND_UPSERT_STATUS;
+
+
+typedef struct st_mysqlnd_error_info
+{
+	char error[MYSQLND_ERRMSG_SIZE+1];
+	char sqlstate[MYSQLND_SQLSTATE_LENGTH + 1];
+	unsigned int error_no;
+} MYSQLND_ERROR_INFO;
+
+
+typedef struct st_mysqlnd_infile_info
+{
+	php_stream	*fd;
+	int			error_no;
+	char		error_msg[MYSQLND_ERRMSG_SIZE + 1];
+	const char	*filename;
+} MYSQLND_INFILE_INFO;
+
+
+/* character set information */
+typedef struct st_mysqlnd_charset
+{
+	unsigned int	nr;
+	const char		*name;
+	const char		*collation;
+	unsigned int	char_minlen;
+	unsigned int	char_maxlen;
+	const char		*comment;
+	unsigned int 	(*mb_charlen)(unsigned int c);
+	unsigned int 	(*mb_valid)(const char *start, const char *end);
+} MYSQLND_CHARSET;
+
+
+/* local infile handler */
+typedef struct st_mysqlnd_infile
+{
+	int		(*local_infile_init)(void **ptr, char *filename, void **userdata TSRMLS_DC);
+	int		(*local_infile_read)(void *ptr, char *buf, unsigned int buf_len TSRMLS_DC);
+	int		(*local_infile_error)(void *ptr, char *error_msg, unsigned int error_msg_len TSRMLS_DC);
+	void	(*local_infile_end)(void *ptr TSRMLS_DC);
+	zval	*callback;
+	void	*userdata;
+} MYSQLND_INFILE;
+
+typedef struct st_mysqlnd_options
+{
+	ulong		flags;
+
+	/* init commands - we need to send them to server directly after connect */
+	unsigned int	num_commands;
+	char			**init_commands;
+
+	/* configuration file information */
+	char 		*cfg_file;
+	char		*cfg_section;
+
+	/*
+	  We need to keep these because otherwise st_mysqlnd_conn will be changed.
+	  The ABI will be broken and the methods structure will be somewhere else
+	  in the memory which can crash external code. Feel free to reuse these.
+	*/
+	char		* unused1;
+	char		* unused2;
+	char		* unused3;
+	char		* unused4;
+	char		* unused5;
+
+	enum_mysqlnd_protocol_type protocol;
+
+	char 		*charset_name;
+	/* maximum allowed packet size for communication */
+	ulong		max_allowed_packet;
+
+	zend_bool	numeric_and_datetime_as_unicode;
+#ifdef MYSQLND_STRING_TO_INT_CONVERSION
+	zend_bool	int_and_float_native;
+#endif
+} MYSQLND_OPTIONS;
+
+typedef struct st_mysqlnd_net_options
+{
+	/* timeouts */
+	unsigned int timeout_connect;
+	unsigned int timeout_read;
+	unsigned int timeout_write;
+
+	unsigned int net_read_buffer_size;
+
+	/* SSL information */
+	char		*ssl_key;
+	char		*ssl_cert;
+	char		*ssl_ca;
+	char		*ssl_capath;
+	char		*ssl_cipher;
+	char		*ssl_passphrase;
+	zend_bool	ssl_verify_peer;
+	uint64_t	flags;
+} MYSQLND_NET_OPTIONS;
+
+
+typedef struct st_mysqlnd_connection MYSQLND;
+typedef struct st_mysqlnd_net	MYSQLND_NET;
+typedef struct st_mysqlnd_protocol	MYSQLND_PROTOCOL;
+typedef struct st_mysqlnd_res	MYSQLND_RES;
+typedef char** 					MYSQLND_ROW_C;		/* return data as array of strings */
+typedef struct st_mysqlnd_stmt_data	MYSQLND_STMT_DATA;
+typedef struct st_mysqlnd_stmt	MYSQLND_STMT;
+typedef unsigned int			MYSQLND_FIELD_OFFSET;
+
+typedef struct st_mysqlnd_param_bind MYSQLND_PARAM_BIND;
+
+typedef struct st_mysqlnd_result_bind MYSQLND_RESULT_BIND;
+
+typedef struct st_mysqlnd_result_metadata MYSQLND_RES_METADATA;
+typedef struct st_mysqlnd_buffered_result MYSQLND_RES_BUFFERED;
+typedef struct st_mysqlnd_unbuffered_result MYSQLND_RES_UNBUFFERED;
+
+typedef struct st_mysqlnd_debug MYSQLND_DEBUG;
+
+
+typedef MYSQLND_RES* (*mysqlnd_stmt_use_or_store_func)(MYSQLND_STMT * const TSRMLS_DC);
+typedef enum_func_status  (*mysqlnd_fetch_row_func)(MYSQLND_RES *result,
+													void *param,
+													unsigned int flags,
+													zend_bool *fetched_anything
+													TSRMLS_DC);
+
+typedef struct st_mysqlnd_stats MYSQLND_STATS;
+
+typedef void (*mysqlnd_stat_trigger)(MYSQLND_STATS * stats, enum_mysqlnd_collected_stats stat, int64_t change TSRMLS_DC);
+
+struct st_mysqlnd_stats
+{
+	uint64_t				*values;
+	mysqlnd_stat_trigger	*triggers;
+	size_t					count;
+	zend_bool				in_trigger;
+#ifdef ZTS
+	MUTEX_T	LOCK_access;
+#endif
+};
+
+
+typedef struct st_mysqlnd_read_buffer {
+	zend_uchar 	* data;
+	size_t 		offset;
+	size_t 		size;
+	size_t		len;
+	zend_bool	(*is_empty)(struct st_mysqlnd_read_buffer *);
+	void		(*read)(struct st_mysqlnd_read_buffer *, size_t count, zend_uchar * dest);
+	size_t		(*bytes_left)(struct st_mysqlnd_read_buffer *);
+	void		(*free_buffer)(struct st_mysqlnd_read_buffer ** TSRMLS_DC);
+} MYSQLND_READ_BUFFER;
+
+
+
+typedef enum_func_status	(*func_mysqlnd_net__connect)(MYSQLND_NET * net, const char * const scheme, size_t scheme_len, zend_bool persistent, char **errstr, int * errcode TSRMLS_DC);
+typedef size_t				(*func_mysqlnd_net__send)(MYSQLND * const conn, char * const buf, size_t count TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__receive)(MYSQLND * conn, zend_uchar * buffer, size_t count TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__set_client_option)(MYSQLND_NET * const net, enum_mysqlnd_option option, const char * const value TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__network_read)(MYSQLND * conn, zend_uchar * buffer, size_t count TSRMLS_DC);
+typedef size_t				(*func_mysqlnd_net__network_write)(MYSQLND * const conn, const zend_uchar * const buf, size_t count TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__decode)(zend_uchar * uncompressed_data, size_t uncompressed_data_len, const zend_uchar * const compressed_data, size_t compressed_data_len TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__encode)(zend_uchar * compress_buffer, size_t * compress_buffer_len, const zend_uchar * const uncompressed_data, size_t uncompressed_data_len TSRMLS_DC);
+typedef size_t				(*func_mysqlnd_net__consume_uneaten_data)(MYSQLND_NET * const net, enum php_mysqlnd_server_command cmd TSRMLS_DC);
+typedef void				(*func_mysqlnd_net__free_contents)(MYSQLND_NET * net TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__enable_ssl)(MYSQLND_NET * const net TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_net__disable_ssl)(MYSQLND_NET * const net TSRMLS_DC);
+
+
+struct st_mysqlnd_net_methods
+{
+	func_mysqlnd_net__connect connect;
+	func_mysqlnd_net__send send;
+	func_mysqlnd_net__receive receive;
+	func_mysqlnd_net__set_client_option set_client_option;
+	func_mysqlnd_net__network_read network_read;
+	func_mysqlnd_net__network_write network_write;
+	func_mysqlnd_net__decode decode;
+	func_mysqlnd_net__encode encode;
+	func_mysqlnd_net__consume_uneaten_data consume_uneaten_data;
+	func_mysqlnd_net__free_contents free_contents;
+	func_mysqlnd_net__enable_ssl enable_ssl;
+	func_mysqlnd_net__disable_ssl disable_ssl;
+
+	void * unused1;
+	void * unused2;
+	void * unused3;
+	void * unused4;
+	void * unused5;
+};
+
+
+struct st_mysqlnd_packet_greet;
+struct st_mysqlnd_packet_greet;
+struct st_mysqlnd_packet_auth;
+struct st_mysqlnd_packet_ok;
+struct st_mysqlnd_packet_command;
+struct st_mysqlnd_packet_eof;
+struct st_mysqlnd_packet_rset_header;
+struct st_mysqlnd_packet_res_field;
+struct st_mysqlnd_packet_row;
+struct st_mysqlnd_packet_stats;
+struct st_mysqlnd_packet_prepare_response;
+struct st_mysqlnd_packet_chg_user_resp;
+
+typedef struct st_mysqlnd_packet_greet *		(*func_mysqlnd_protocol__get_greet_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_auth *			(*func_mysqlnd_protocol__get_auth_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_ok *			(*func_mysqlnd_protocol__get_ok_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_command *		(*func_mysqlnd_protocol__get_command_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_eof *			(*func_mysqlnd_protocol__get_eof_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_rset_header *	(*func_mysqlnd_protocol__get_rset_header_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_res_field *	(*func_mysqlnd_protocol__get_result_field_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_row *			(*func_mysqlnd_protocol__get_row_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_stats *		(*func_mysqlnd_protocol__get_stats_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_prepare_response *(*func_mysqlnd_protocol__get_prepare_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+typedef struct st_mysqlnd_packet_chg_user_resp*(*func_mysqlnd_protocol__get_change_user_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC);
+
+struct st_mysqlnd_protocol_methods
+{
+	func_mysqlnd_protocol__get_greet_packet get_greet_packet;
+	func_mysqlnd_protocol__get_auth_packet get_auth_packet;
+	func_mysqlnd_protocol__get_ok_packet get_ok_packet;
+	func_mysqlnd_protocol__get_command_packet get_command_packet;
+	func_mysqlnd_protocol__get_eof_packet get_eof_packet;
+	func_mysqlnd_protocol__get_rset_header_packet get_rset_header_packet;
+	func_mysqlnd_protocol__get_result_field_packet get_result_field_packet;
+	func_mysqlnd_protocol__get_row_packet get_row_packet;
+	func_mysqlnd_protocol__get_stats_packet get_stats_packet;
+	func_mysqlnd_protocol__get_prepare_response_packet get_prepare_response_packet;
+	func_mysqlnd_protocol__get_change_user_response_packet get_change_user_response_packet;
+
+	void * unused1;
+	void * unused2;
+	void * unused3;
+	void * unused4;
+	void * unused5;
+};
+
+
+
+typedef enum_func_status	(*func_mysqlnd_conn__init)(MYSQLND * conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__connect)(MYSQLND *conn, const char *host, const char * user, const char * passwd, unsigned int passwd_len, const char * db, unsigned int db_len, unsigned int port, const char * socket_or_pipe, unsigned int mysql_flags TSRMLS_DC);
+typedef ulong				(*func_mysqlnd_conn__escape_string)(MYSQLND * const conn, char *newstr, const char *escapestr, size_t escapestr_len TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__set_charset)(MYSQLND * const conn, const char * const charset TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__query)(MYSQLND *conn, const char *query, unsigned int query_len TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__send_query)(MYSQLND *conn, const char *query, unsigned int query_len TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__reap_query)(MYSQLND *conn TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_conn__use_result)(MYSQLND * const conn TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_conn__store_result)(MYSQLND * const conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__next_result)(MYSQLND * const conn TSRMLS_DC);
+typedef zend_bool			(*func_mysqlnd_conn__more_results)(const MYSQLND * const conn TSRMLS_DC);
+
+typedef MYSQLND_STMT *		(*func_mysqlnd_conn__stmt_init)(MYSQLND * const conn TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_conn__shutdown_server)(MYSQLND * const conn, uint8_t level TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__refresh_server)(MYSQLND * const conn, uint8_t options TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_conn__ping)(MYSQLND * const conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__kill_connection)(MYSQLND *conn, unsigned int pid TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__select_db)(MYSQLND * const conn, const char * const db, unsigned int db_len TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__server_dump_debug_information)(MYSQLND * const conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__change_user)(MYSQLND * const conn, const char * user, const char * passwd, const char * db, zend_bool silent TSRMLS_DC);
+
+typedef unsigned int		(*func_mysqlnd_conn__get_error_no)(const MYSQLND * const conn TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_conn__get_error_str)(const MYSQLND * const conn TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_conn__get_sqlstate)(const MYSQLND * const conn TSRMLS_DC);
+typedef uint64_t			(*func_mysqlnd_conn__get_thread_id)(const MYSQLND * const conn TSRMLS_DC);
+typedef void				(*func_mysqlnd_conn__get_statistics)(const MYSQLND * const conn, zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC);
+
+typedef unsigned long		(*func_mysqlnd_conn__get_server_version)(const MYSQLND * const conn TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_conn__get_server_information)(const MYSQLND * const conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__get_server_statistics)(MYSQLND *conn, char **message, unsigned int * message_len TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_conn__get_host_information)(const MYSQLND * const conn TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_conn__get_protocol_information)(const MYSQLND * const conn TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_conn__get_last_message)(const MYSQLND * const conn TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_conn__charset_name)(const MYSQLND * const conn TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_conn__list_fields)(MYSQLND *conn, const char *table, const char *achtung_wild TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_conn__list_method)(MYSQLND *conn, const char *query, const char *achtung_wild, char *par1 TSRMLS_DC);
+
+typedef uint64_t			(*func_mysqlnd_conn__get_last_insert_id)(const MYSQLND * const conn TSRMLS_DC);
+typedef uint64_t			(*func_mysqlnd_conn__get_affected_rows)(const MYSQLND * const conn TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_conn__get_warning_count)(const MYSQLND * const conn TSRMLS_DC);
+
+typedef unsigned int		(*func_mysqlnd_conn__get_field_count)(const MYSQLND * const conn TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_conn__set_server_option)(MYSQLND * const conn, enum_mysqlnd_server_option option TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__set_client_option)(MYSQLND * const conn, enum_mysqlnd_option option, const char * const value TSRMLS_DC);
+typedef void				(*func_mysqlnd_conn__free_contents)(MYSQLND *conn TSRMLS_DC);	/* private */
+typedef void				(*func_mysqlnd_conn__free_options)(MYSQLND * conn TSRMLS_DC);	/* private */
+typedef enum_func_status	(*func_mysqlnd_conn__close)(MYSQLND *conn, enum_connection_close_type close_type TSRMLS_DC);
+typedef void				(*func_mysqlnd_conn__dtor)(MYSQLND *conn TSRMLS_DC);	/* private */
+
+typedef enum_func_status	(*func_mysqlnd_conn__query_read_result_set_header)(MYSQLND *conn, MYSQLND_STMT *stmt TSRMLS_DC);
+
+typedef MYSQLND *			(*func_mysqlnd_conn__get_reference)(MYSQLND * const conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__free_reference)(MYSQLND * const conn TSRMLS_DC);
+typedef enum mysqlnd_connection_state (*func_mysqlnd_conn__get_state)(MYSQLND * const conn TSRMLS_DC);
+typedef void				(*func_mysqlnd_conn__set_state)(MYSQLND * const conn, enum mysqlnd_connection_state new_state TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_conn__simple_command)(MYSQLND *conn, enum php_mysqlnd_server_command command, const char * const arg, size_t arg_len, enum mysqlnd_packet_type ok_packet, zend_bool silent, zend_bool ignore_upsert_status TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__simple_command_handle_response)(MYSQLND *conn, enum mysqlnd_packet_type ok_packet, zend_bool silent, enum php_mysqlnd_server_command command, zend_bool ignore_upsert_status TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_conn__restart_psession)(MYSQLND *conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__end_psession)(MYSQLND *conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__send_close)(MYSQLND * conn TSRMLS_DC);
+
+typedef enum_func_status    (*func_mysqlnd_conn__ssl_set)(MYSQLND * const conn, const char * key, const char * const cert, const char * const ca, const char * const capath, const char * const cipher TSRMLS_DC);
+
+typedef MYSQLND_RES * 		(*func_mysqlnd_conn__result_init)(unsigned int field_count, zend_bool persistent TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_conn__set_autocommit)(MYSQLND * conn, unsigned int mode TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__tx_commit)(MYSQLND * conn TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_conn__tx_rollback)(MYSQLND * conn TSRMLS_DC);
+
+
+struct st_mysqlnd_conn_methods
+{
+	func_mysqlnd_conn__init init;
+	func_mysqlnd_conn__connect connect;
+	func_mysqlnd_conn__escape_string escape_string;
+	func_mysqlnd_conn__set_charset set_charset;
+	func_mysqlnd_conn__query query;
+	func_mysqlnd_conn__send_query send_query;
+	func_mysqlnd_conn__reap_query reap_query;
+	func_mysqlnd_conn__use_result use_result;
+	func_mysqlnd_conn__store_result store_result;
+	func_mysqlnd_conn__next_result next_result;
+	func_mysqlnd_conn__more_results more_results;
+
+	func_mysqlnd_conn__stmt_init stmt_init;
+
+	func_mysqlnd_conn__shutdown_server shutdown_server;
+	func_mysqlnd_conn__refresh_server refresh_server;
+
+	func_mysqlnd_conn__ping ping;
+	func_mysqlnd_conn__kill_connection kill_connection;
+	func_mysqlnd_conn__select_db select_db;
+	func_mysqlnd_conn__server_dump_debug_information server_dump_debug_information;
+	func_mysqlnd_conn__change_user change_user;
+
+	func_mysqlnd_conn__get_error_no get_error_no;
+	func_mysqlnd_conn__get_error_str get_error_str;
+	func_mysqlnd_conn__get_sqlstate get_sqlstate;
+	func_mysqlnd_conn__get_thread_id get_thread_id;
+	func_mysqlnd_conn__get_statistics get_statistics;
+
+	func_mysqlnd_conn__get_server_version get_server_version;
+	func_mysqlnd_conn__get_server_information get_server_information;
+	func_mysqlnd_conn__get_server_statistics get_server_statistics;
+	func_mysqlnd_conn__get_host_information get_host_information;
+	func_mysqlnd_conn__get_protocol_information get_protocol_information;
+	func_mysqlnd_conn__get_last_message get_last_message;
+	func_mysqlnd_conn__charset_name charset_name;
+	func_mysqlnd_conn__list_fields list_fields;
+	func_mysqlnd_conn__list_method list_method;
+
+	func_mysqlnd_conn__get_last_insert_id get_last_insert_id;
+	func_mysqlnd_conn__get_affected_rows get_affected_rows;
+	func_mysqlnd_conn__get_warning_count get_warning_count;
+
+	func_mysqlnd_conn__get_field_count get_field_count;
+
+	func_mysqlnd_conn__set_server_option set_server_option;
+	func_mysqlnd_conn__set_client_option set_client_option;
+	func_mysqlnd_conn__free_contents free_contents;
+	func_mysqlnd_conn__free_options free_options;
+	func_mysqlnd_conn__close close;
+	func_mysqlnd_conn__dtor dtor;
+
+	func_mysqlnd_conn__query_read_result_set_header query_read_result_set_header;
+
+	func_mysqlnd_conn__get_reference get_reference;
+	func_mysqlnd_conn__free_reference free_reference;
+	func_mysqlnd_conn__get_state get_state;
+	func_mysqlnd_conn__set_state set_state;
+
+	func_mysqlnd_conn__simple_command simple_command;
+	func_mysqlnd_conn__simple_command_handle_response simple_command_handle_response;
+
+	func_mysqlnd_conn__restart_psession restart_psession;
+	func_mysqlnd_conn__end_psession end_psession;
+	func_mysqlnd_conn__send_close send_close;
+
+	func_mysqlnd_conn__ssl_set ssl_set;
+
+	func_mysqlnd_conn__result_init result_init;
+#ifdef AUTOCOMMIT_TX_COMMIT_ROLLBACK
+	func_mysqlnd_conn__set_autocommit set_autocommit;
+	func_mysqlnd_conn__tx_commit tx_commit;
+	func_mysqlnd_conn__tx_rollback tx_rollback;
+#endif
+};
+
+
+
+
+typedef mysqlnd_fetch_row_func	fetch_row;
+typedef mysqlnd_fetch_row_func	fetch_row_normal_buffered; /* private */
+typedef mysqlnd_fetch_row_func	fetch_row_normal_unbuffered; /* private */
+
+typedef MYSQLND_RES *		(*func_mysqlnd_res__use_result)(MYSQLND_RES * const result, zend_bool ps_protocol TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_res__store_result)(MYSQLND_RES * result, MYSQLND * const conn, zend_bool ps TSRMLS_DC);
+typedef void 				(*func_mysqlnd_res__fetch_into)(MYSQLND_RES *result, unsigned int flags, zval *return_value, enum_mysqlnd_extension ext TSRMLS_DC ZEND_FILE_LINE_DC);
+typedef MYSQLND_ROW_C 		(*func_mysqlnd_res__fetch_row_c)(MYSQLND_RES *result TSRMLS_DC);
+typedef void 				(*func_mysqlnd_res__fetch_all)(MYSQLND_RES *result, unsigned int flags, zval *return_value TSRMLS_DC ZEND_FILE_LINE_DC);
+typedef void 				(*func_mysqlnd_res__fetch_field_data)(MYSQLND_RES *result, unsigned int offset, zval *return_value TSRMLS_DC);
+typedef uint64_t			(*func_mysqlnd_res__num_rows)(const MYSQLND_RES * const result TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_res__num_fields)(const MYSQLND_RES * const result TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_res__skip_result)(MYSQLND_RES * const result TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_res__seek_data)(MYSQLND_RES * result, uint64_t row TSRMLS_DC);
+typedef MYSQLND_FIELD_OFFSET (*func_mysqlnd_res__seek_field)(MYSQLND_RES * const result, MYSQLND_FIELD_OFFSET field_offset TSRMLS_DC);
+typedef MYSQLND_FIELD_OFFSET (*func_mysqlnd_res__field_tell)(const MYSQLND_RES * const result TSRMLS_DC);
+typedef const MYSQLND_FIELD *(*func_mysqlnd_res__fetch_field)(MYSQLND_RES * const result TSRMLS_DC);
+typedef const MYSQLND_FIELD *(*func_mysqlnd_res__fetch_field_direct)(MYSQLND_RES * const result, MYSQLND_FIELD_OFFSET fieldnr TSRMLS_DC);
+typedef const MYSQLND_FIELD *(*func_mysqlnd_res__fetch_fields)(MYSQLND_RES * const result TSRMLS_DC);
+
+typedef enum_func_status	(*func_mysqlnd_res__read_result_metadata)(MYSQLND_RES *result, MYSQLND * conn TSRMLS_DC);
+typedef unsigned long *		(*func_mysqlnd_res__fetch_lengths)(MYSQLND_RES * const result TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_res__store_result_fetch_data)(MYSQLND * const conn, MYSQLND_RES *result, MYSQLND_RES_METADATA *meta, zend_bool binary_protocol, zend_bool to_cache TSRMLS_DC);
+typedef enum_func_status 	(*func_mysqlnd_res__initialize_result_set_rest)(MYSQLND_RES * const result TSRMLS_DC);
+
+typedef void				(*func_mysqlnd_res__free_result_buffers)(MYSQLND_RES * result TSRMLS_DC);	/* private */
+typedef enum_func_status	(*func_mysqlnd_res__free_result)(MYSQLND_RES * result, zend_bool implicit TSRMLS_DC);
+typedef void				(*func_mysqlnd_res__free_result_internal)(MYSQLND_RES *result TSRMLS_DC);
+typedef void				(*func_mysqlnd_res__free_result_contents)(MYSQLND_RES *result TSRMLS_DC);
+typedef void				(*func_mysqlnd_res__free_buffered_data)(MYSQLND_RES *result TSRMLS_DC);
+typedef void				(*func_mysqlnd_res__unbuffered_free_last_data)(MYSQLND_RES *result TSRMLS_DC);
+
+	/* for decoding - binary or text protocol */
+typedef enum_func_status	(*func_mysqlnd_res__row_decoder)(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,
+									unsigned int field_count, MYSQLND_FIELD *fields_metadata,
+									zend_bool persistent,
+									zend_bool as_unicode, zend_bool as_int_or_float,
+									MYSQLND_STATS * stats TSRMLS_DC);
+
+typedef MYSQLND_RES_METADATA * (*func_mysqlnd_res__result_meta_init)(unsigned int field_count, zend_bool persistent TSRMLS_DC);
+
+struct st_mysqlnd_res_methods
+{
+	mysqlnd_fetch_row_func	fetch_row;
+	mysqlnd_fetch_row_func	fetch_row_normal_buffered; /* private */
+	mysqlnd_fetch_row_func	fetch_row_normal_unbuffered; /* private */
+
+	func_mysqlnd_res__use_result use_result;
+	func_mysqlnd_res__store_result store_result;
+	func_mysqlnd_res__fetch_into fetch_into;
+	func_mysqlnd_res__fetch_row_c fetch_row_c;
+	func_mysqlnd_res__fetch_all fetch_all;
+	func_mysqlnd_res__fetch_field_data fetch_field_data;
+	func_mysqlnd_res__num_rows num_rows;
+	func_mysqlnd_res__num_fields num_fields;
+	func_mysqlnd_res__skip_result skip_result;
+	func_mysqlnd_res__seek_data seek_data;
+	func_mysqlnd_res__seek_field seek_field;
+	func_mysqlnd_res__field_tell field_tell;
+	func_mysqlnd_res__fetch_field fetch_field;
+	func_mysqlnd_res__fetch_field_direct fetch_field_direct;
+	func_mysqlnd_res__fetch_fields fetch_fields;
+	func_mysqlnd_res__read_result_metadata read_result_metadata;
+	func_mysqlnd_res__fetch_lengths fetch_lengths;
+	func_mysqlnd_res__store_result_fetch_data store_result_fetch_data;
+	func_mysqlnd_res__initialize_result_set_rest initialize_result_set_rest;
+	func_mysqlnd_res__free_result_buffers free_result_buffers;
+	func_mysqlnd_res__free_result free_result;
+	func_mysqlnd_res__free_result_internal free_result_internal;
+	func_mysqlnd_res__free_result_contents free_result_contents;
+	func_mysqlnd_res__free_buffered_data free_buffered_data;
+	func_mysqlnd_res__unbuffered_free_last_data unbuffered_free_last_data;
+
+	/* for decoding - binary or text protocol */
+	func_mysqlnd_res__row_decoder row_decoder;
+
+	func_mysqlnd_res__result_meta_init result_meta_init;
+
+	void * unused1;
+	void * unused2;
+	void * unused3;
+	void * unused4;
+	void * unused5;
+};
+
+
+typedef const MYSQLND_FIELD *	(*func_mysqlnd_res_meta__fetch_field)(MYSQLND_RES_METADATA * const meta TSRMLS_DC);
+typedef const MYSQLND_FIELD *	(*func_mysqlnd_res_meta__fetch_field_direct)(const MYSQLND_RES_METADATA * const meta, MYSQLND_FIELD_OFFSET fieldnr TSRMLS_DC);
+typedef const MYSQLND_FIELD *	(*func_mysqlnd_res_meta__fetch_fields)(MYSQLND_RES_METADATA * const meta TSRMLS_DC);
+typedef MYSQLND_FIELD_OFFSET	(*func_mysqlnd_res_meta__field_tell)(const MYSQLND_RES_METADATA * const meta TSRMLS_DC);
+typedef enum_func_status		(*func_mysqlnd_res_meta__read_metadata)(MYSQLND_RES_METADATA * const meta, MYSQLND * conn TSRMLS_DC);
+typedef MYSQLND_RES_METADATA *	(*func_mysqlnd_res_meta__clone_metadata)(const MYSQLND_RES_METADATA * const meta, zend_bool persistent TSRMLS_DC);
+typedef void					(*func_mysqlnd_res_meta__free_metadata)(MYSQLND_RES_METADATA * meta TSRMLS_DC);
+
+struct st_mysqlnd_res_meta_methods
+{
+	func_mysqlnd_res_meta__fetch_field fetch_field;
+	func_mysqlnd_res_meta__fetch_field_direct fetch_field_direct;
+	func_mysqlnd_res_meta__fetch_fields fetch_fields;
+	func_mysqlnd_res_meta__field_tell field_tell;
+	func_mysqlnd_res_meta__read_metadata read_metadata;
+	func_mysqlnd_res_meta__clone_metadata clone_metadata;
+	func_mysqlnd_res_meta__free_metadata free_metadata;
+};
+
+
+typedef enum_func_status	(*func_mysqlnd_stmt__prepare)(MYSQLND_STMT * const stmt, const char * const query, unsigned int query_len TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__execute)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_stmt__use_result)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_stmt__store_result)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_stmt__get_result)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef zend_bool			(*func_mysqlnd_stmt__more_results)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__next_result)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__free_result)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__seek_data)(const MYSQLND_STMT * const stmt, uint64_t row TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__reset)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__net_close)(MYSQLND_STMT * const stmt, zend_bool implicit TSRMLS_DC); /* private */
+typedef enum_func_status	(*func_mysqlnd_stmt__dtor)(MYSQLND_STMT * const stmt, zend_bool implicit TSRMLS_DC); /* use this for mysqlnd_stmt_close */
+typedef enum_func_status	(*func_mysqlnd_stmt__fetch)(MYSQLND_STMT * const stmt, zend_bool * const fetched_anything TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__bind_parameters)(MYSQLND_STMT * const stmt, MYSQLND_PARAM_BIND * const param_bind TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__bind_one_parameter)(MYSQLND_STMT * const stmt, unsigned int param_no, zval * const zv, zend_uchar	type TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__refresh_bind_param)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__bind_result)(MYSQLND_STMT * const stmt, MYSQLND_RESULT_BIND * const result_bind TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__bind_one_result)(MYSQLND_STMT * const stmt, unsigned int param_no TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__send_long_data)(MYSQLND_STMT * const stmt, unsigned int param_num, const char * const data, unsigned long length TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_stmt__get_parameter_metadata)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef MYSQLND_RES *		(*func_mysqlnd_stmt__get_result_metadata)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef uint64_t			(*func_mysqlnd_stmt__get_last_insert_id)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef uint64_t			(*func_mysqlnd_stmt__get_affected_rows)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef uint64_t			(*func_mysqlnd_stmt__get_num_rows)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_stmt__get_param_count)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_stmt__get_field_count)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_stmt__get_warning_count)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_stmt__get_error_no)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_stmt__get_error_str)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef const char *		(*func_mysqlnd_stmt__get_sqlstate)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__get_attribute)(const MYSQLND_STMT * const stmt, enum mysqlnd_stmt_attr attr_type, void * const value TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__set_attribute)(MYSQLND_STMT * const stmt, enum mysqlnd_stmt_attr attr_type, const void * const value TSRMLS_DC);
+typedef MYSQLND_PARAM_BIND *(*func_mysqlnd_stmt__alloc_param_bind)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef MYSQLND_RESULT_BIND*(*func_mysqlnd_stmt__alloc_result_bind)(MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef	void 				(*func_mysqlnd_stmt__free_parameter_bind)(MYSQLND_STMT * const stmt, MYSQLND_PARAM_BIND * TSRMLS_DC);
+typedef	void 				(*func_mysqlnd_stmt__free_result_bind)(MYSQLND_STMT * const stmt, MYSQLND_RESULT_BIND * TSRMLS_DC);
+typedef unsigned int		(*func_mysqlnd_stmt__server_status)(const MYSQLND_STMT * const stmt TSRMLS_DC);
+typedef enum_func_status 	(*func_mysqlnd_stmt__generate_execute_request)(MYSQLND_STMT * const s, zend_uchar ** request, size_t *request_len, zend_bool * free_buffer TSRMLS_DC);
+typedef enum_func_status	(*func_mysqlnd_stmt__parse_execute_response)(MYSQLND_STMT * const s TSRMLS_DC);
+typedef void 				(*func_mysqlnd_stmt__free_stmt_content)(MYSQLND_STMT * const s TSRMLS_DC);
+
+struct st_mysqlnd_stmt_methods
+{
+	func_mysqlnd_stmt__prepare prepare;
+	func_mysqlnd_stmt__execute execute;
+	func_mysqlnd_stmt__use_result use_result;
+	func_mysqlnd_stmt__store_result store_result;
+	func_mysqlnd_stmt__get_result get_result;
+	func_mysqlnd_stmt__more_results more_results;
+	func_mysqlnd_stmt__next_result next_result;
+	func_mysqlnd_stmt__free_result free_result;
+	func_mysqlnd_stmt__seek_data seek_data;
+	func_mysqlnd_stmt__reset reset;
+	func_mysqlnd_stmt__net_close net_close;
+	func_mysqlnd_stmt__dtor dtor;
+	func_mysqlnd_stmt__fetch fetch;
+
+	func_mysqlnd_stmt__bind_parameters bind_parameters;
+	func_mysqlnd_stmt__bind_one_parameter bind_one_parameter;
+	func_mysqlnd_stmt__refresh_bind_param refresh_bind_param;
+	func_mysqlnd_stmt__bind_result bind_result;
+	func_mysqlnd_stmt__bind_one_result bind_one_result;
+	func_mysqlnd_stmt__send_long_data send_long_data;
+	func_mysqlnd_stmt__get_parameter_metadata get_parameter_metadata;
+	func_mysqlnd_stmt__get_result_metadata get_result_metadata;
+
+	func_mysqlnd_stmt__get_last_insert_id get_last_insert_id;
+	func_mysqlnd_stmt__get_affected_rows get_affected_rows;
+	func_mysqlnd_stmt__get_num_rows get_num_rows;
+
+	func_mysqlnd_stmt__get_param_count get_param_count;
+	func_mysqlnd_stmt__get_field_count get_field_count;
+	func_mysqlnd_stmt__get_warning_count get_warning_count;
+
+	func_mysqlnd_stmt__get_error_no get_error_no;
+	func_mysqlnd_stmt__get_error_str get_error_str;
+	func_mysqlnd_stmt__get_sqlstate get_sqlstate;
+
+	func_mysqlnd_stmt__get_attribute get_attribute;
+	func_mysqlnd_stmt__set_attribute set_attribute;
+
+	func_mysqlnd_stmt__alloc_param_bind alloc_parameter_bind;
+	func_mysqlnd_stmt__alloc_result_bind alloc_result_bind;
+
+	func_mysqlnd_stmt__free_parameter_bind free_parameter_bind;
+	func_mysqlnd_stmt__free_result_bind free_result_bind;
+
+	func_mysqlnd_stmt__server_status get_server_status;
+
+	func_mysqlnd_stmt__generate_execute_request generate_execute_request;
+	func_mysqlnd_stmt__parse_execute_response parse_execute_response;
+
+	func_mysqlnd_stmt__free_stmt_content free_stmt_content;
+};
+
+
+struct st_mysqlnd_net
+{
+	php_stream			*stream;
+	struct st_mysqlnd_net_methods m;
+
+	/* sequence for simple checking of correct packets */
+	zend_uchar			packet_no;
+	zend_bool			compressed;
+	zend_uchar			compressed_envelope_packet_no;
+#ifdef MYSQLND_COMPRESSION_ENABLED
+	MYSQLND_READ_BUFFER	* uncompressed_data;
+#endif
+#ifdef MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND
+	zend_uchar			last_command;
+#endif
+	/* cmd buffer */
+	MYSQLND_CMD_BUFFER	cmd_buffer;
+
+	MYSQLND_NET_OPTIONS	options;
+
+	zend_bool			persistent;
+};
+
+
+struct st_mysqlnd_protocol
+{
+	struct st_mysqlnd_protocol_methods m;
+	zend_bool persistent;
+};
+
+
+struct st_mysqlnd_connection
+{
+/* Operation related */
+	MYSQLND_NET		* net;
+	MYSQLND_PROTOCOL * protocol;
+
+/* Information related */
+	char			*host;
+	unsigned int	host_len;
+	char			*unix_socket;
+	unsigned int	unix_socket_len;
+	char			*user;
+	unsigned int	user_len;
+	char			*passwd;
+	unsigned int	passwd_len;
+	char			*scheme;
+	unsigned int	scheme_len;
+	uint64_t		thread_id;
+	char			*server_version;
+	char			*host_info;
+	unsigned char	*scramble;
+	const MYSQLND_CHARSET *charset;
+	const MYSQLND_CHARSET *greet_charset;
+	char			*connect_or_select_db;
+	unsigned int	connect_or_select_db_len;
+	MYSQLND_INFILE	infile;
+	unsigned int	protocol_version;
+	unsigned long	max_packet_size;
+	unsigned int	port;
+	unsigned long	client_flag;
+	unsigned long	server_capabilities;
+
+	/* For UPSERT queries */
+	MYSQLND_UPSERT_STATUS upsert_status;
+	char			*last_message;
+	unsigned int	last_message_len;
+
+	/* If error packet, we use these */
+	MYSQLND_ERROR_INFO	error_info;
+
+	/*
+	  To prevent queries during unbuffered fetches. Also to
+	  mark the connection as destroyed for garbage collection.
+	*/
+	enum mysqlnd_connection_state	state;
+	enum_mysqlnd_query_type			last_query_type;
+	/* Temporary storage between query and (use|store)_result() call */
+	MYSQLND_RES						*current_result;
+
+	/*
+	  How many result sets reference this connection.
+	  It won't be freed until this number reaches 0.
+	  The last one, please close the door! :-)
+	  The result set objects can determine by inspecting
+	  'quit_sent' whether the connection is still valid.
+	*/
+	unsigned int	refcount;
+
+	/* Temporal storage for mysql_query */
+	unsigned int	field_count;
+
+	/* persistent connection */
+	zend_bool		persistent;
+
+	/* options */
+	MYSQLND_OPTIONS	options;
+
+	/* stats */
+	MYSQLND_STATS	* stats;
+
+	struct st_mysqlnd_conn_methods *m;
+};
+
+
+struct mysqlnd_field_hash_key
+{
+	zend_bool		is_numeric;
+	unsigned long	key;
+#if MYSQLND_UNICODE
+	zstr			ustr;
+	unsigned int	ulen;
+#endif
+};
+
+
+struct st_mysqlnd_result_metadata
+{
+	MYSQLND_FIELD					*fields;
+	struct mysqlnd_field_hash_key	*zend_hash_keys;
+	unsigned int					current_field;
+	unsigned int					field_count;
+	/* We need this to make fast allocs in rowp_read */
+	unsigned int					bit_fields_count;
+	size_t							bit_fields_total_len; /* trailing \0 not counted */
+	zend_bool						persistent;
+
+	struct st_mysqlnd_res_meta_methods *m;
+};
+
+
+struct st_mysqlnd_buffered_result
+{
+	zval				**data;
+	zval				**data_cursor;
+	MYSQLND_MEMORY_POOL_CHUNK **row_buffers;
+	uint64_t			row_count;
+	uint64_t			initialized_rows;
+	zend_bool			persistent;
+
+	unsigned int		references;
+
+	MYSQLND_ERROR_INFO	error_info;
+};
+
+
+struct st_mysqlnd_unbuffered_result
+{
+	/* For unbuffered (both normal and PS) */
+	zval				**last_row_data;
+	MYSQLND_MEMORY_POOL_CHUNK *last_row_buffer;
+
+	uint64_t			row_count;
+	zend_bool			eof_reached;
+};
+
+
+struct st_mysqlnd_res
+{
+	struct st_mysqlnd_res_methods m;
+
+	MYSQLND					*conn;
+	enum_mysqlnd_res_type	type;
+	unsigned int			field_count;
+
+	/* For metadata functions */
+	MYSQLND_RES_METADATA	*meta;
+
+	/* To be used with store_result() - both normal and PS */
+	MYSQLND_RES_BUFFERED		*stored_data;
+	MYSQLND_RES_UNBUFFERED		*unbuf;
+
+	/*
+	  Column lengths of current row - both buffered and unbuffered.
+	  For buffered results it duplicates the data found in **data
+	*/
+	unsigned long			*lengths;
+
+	struct st_mysqlnd_packet_row * row_packet;
+
+	MYSQLND_MEMORY_POOL		* result_set_memory_pool;
+	zend_bool				persistent;
+};
+
+
+struct st_mysqlnd_param_bind
+{
+	zval		*zv;
+	zend_uchar	type;
+	enum_param_bind_flags	flags;
+};
+
+struct st_mysqlnd_result_bind
+{
+	zval		*zv;
+	zend_bool	bound;
+};
+
+
+struct st_mysqlnd_stmt_data
+{
+	MYSQLND						*conn;
+	unsigned long				stmt_id;
+	unsigned long				flags;/* cursor is set here */
+	enum_mysqlnd_stmt_state		state;
+	unsigned int				warning_count;
+	MYSQLND_RES					*result;
+	unsigned int				field_count;
+	unsigned int				param_count;
+	unsigned char				send_types_to_server;
+	MYSQLND_PARAM_BIND			*param_bind;
+	MYSQLND_RESULT_BIND			*result_bind;
+	zend_bool					result_zvals_separated_once;
+	zend_bool					persistent;
+
+	MYSQLND_UPSERT_STATUS		upsert_status;
+
+	MYSQLND_ERROR_INFO			error_info;
+
+	zend_bool					update_max_length;
+	unsigned long				prefetch_rows;
+
+	zend_bool					cursor_exists;
+	mysqlnd_stmt_use_or_store_func default_rset_handler;
+
+	MYSQLND_CMD_BUFFER			execute_cmd_buffer;
+	unsigned int				execute_count;/* count how many times the stmt was executed */
+};
+
+
+struct st_mysqlnd_stmt
+{
+	MYSQLND_STMT_DATA * data;
+	struct st_mysqlnd_stmt_methods	*m;
+	zend_bool persistent;
+};
+
+#endif /* MYSQLND_STRUCTS_H */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_wireprotocol.c
@@ -0,0 +1,2160 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+#include "php.h"
+#include "php_globals.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_wireprotocol.h"
+#include "mysqlnd_statistics.h"
+#include "mysqlnd_debug.h"
+#include "ext/standard/sha1.h"
+#include "zend_ini.h"
+
+#define MYSQLND_SILENT 1
+
+#define MYSQLND_DUMP_HEADER_N_BODY
+
+#define	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_size, packet_type_as_text, packet_type) \
+	{ \
+		DBG_INF_FMT("buf=%p size=%u", (buf), (buf_size)); \
+		if (FAIL == mysqlnd_read_header((conn), &((packet)->header) TSRMLS_CC)) {\
+			CONN_SET_STATE(conn, CONN_QUIT_SENT); \
+			SET_CLIENT_ERROR(conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", mysqlnd_server_gone); \
+			DBG_ERR_FMT("Can't read %s's header", (packet_type_as_text)); \
+			DBG_RETURN(FAIL);\
+		}\
+		if ((buf_size) < (packet)->header.size) { \
+			DBG_ERR_FMT("Packet buffer %u wasn't big enough %u, %u bytes will be unread", \
+						(buf_size), (packet)->header.size, (packet)->header.size - (buf_size)); \
+						DBG_RETURN(FAIL); \
+		}\
+		if (FAIL == conn->net->m.receive((conn), (buf), (packet)->header.size TSRMLS_CC)) { \
+			CONN_SET_STATE(conn, CONN_QUIT_SENT); \
+			SET_CLIENT_ERROR(conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", mysqlnd_server_gone); \
+			DBG_ERR_FMT("Empty '%s' packet body", (packet_type_as_text)); \
+			DBG_RETURN(FAIL);\
+		} \
+		MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, packet_type_to_statistic_byte_count[packet_type], \
+											MYSQLND_HEADER_SIZE + (packet)->header.size, \
+											packet_type_to_statistic_packet_count[packet_type], \
+											1); \
+	}
+
+
+#define BAIL_IF_NO_MORE_DATA \
+	if ((size_t)(p - begin) > packet->header.size) { \
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Premature end of data (mysqlnd_wireprotocol.c:%u)", __LINE__); \
+		goto premature_end; \
+	} \
+
+
+static const char *unknown_sqlstate= "HY000";
+
+const char * const mysqlnd_empty_string = "";
+
+/* Used in mysqlnd_debug.c */
+const char mysqlnd_read_header_name[]	= "mysqlnd_read_header";
+const char mysqlnd_read_body_name[]		= "mysqlnd_read_body";
+
+
+#define ERROR_MARKER 0xFF
+#define EODATA_MARKER 0xFE
+
+/* {{{ mysqlnd_command_to_text
+ */
+const char * const mysqlnd_command_to_text[COM_END] =
+{
+  "SLEEP", "QUIT", "INIT_DB", "QUERY", "FIELD_LIST",
+  "CREATE_DB", "DROP_DB", "REFRESH", "SHUTDOWN", "STATISTICS",
+  "PROCESS_INFO", "CONNECT", "PROCESS_KILL", "DEBUG", "PING",
+  "TIME", "DELAYED_INSERT", "CHANGE_USER", "BINLOG_DUMP",
+  "TABLE_DUMP", "CONNECT_OUT", "REGISTER_SLAVE",
+  "STMT_PREPARE", "STMT_EXECUTE", "STMT_SEND_LONG_DATA", "STMT_CLOSE",
+  "STMT_RESET", "SET_OPTION", "STMT_FETCH", "DAEMON"
+};
+/* }}} */
+
+
+
+static enum_mysqlnd_collected_stats packet_type_to_statistic_byte_count[PROT_LAST] =
+{
+	STAT_LAST,
+	STAT_LAST,
+	STAT_BYTES_RECEIVED_OK,
+	STAT_BYTES_RECEIVED_EOF,
+	STAT_LAST,
+	STAT_BYTES_RECEIVED_RSET_HEADER,
+	STAT_BYTES_RECEIVED_RSET_FIELD_META,
+	STAT_BYTES_RECEIVED_RSET_ROW,
+	STAT_BYTES_RECEIVED_PREPARE_RESPONSE,
+	STAT_BYTES_RECEIVED_CHANGE_USER,
+};
+
+static enum_mysqlnd_collected_stats packet_type_to_statistic_packet_count[PROT_LAST] =
+{
+	STAT_LAST,
+	STAT_LAST,
+	STAT_PACKETS_RECEIVED_OK,
+	STAT_PACKETS_RECEIVED_EOF,
+	STAT_LAST,
+	STAT_PACKETS_RECEIVED_RSET_HEADER,
+	STAT_PACKETS_RECEIVED_RSET_FIELD_META,
+	STAT_PACKETS_RECEIVED_RSET_ROW,
+	STAT_PACKETS_RECEIVED_PREPARE_RESPONSE,
+	STAT_PACKETS_RECEIVED_CHANGE_USER,
+};
+
+
+/* {{{ php_mysqlnd_net_field_length
+   Get next field's length */
+unsigned long
+php_mysqlnd_net_field_length(zend_uchar **packet)
+{
+	register zend_uchar *p= (zend_uchar *)*packet;
+
+	if (*p < 251) {
+		(*packet)++;
+		return (unsigned long) *p;
+	}
+
+	switch (*p) {
+		case 251:
+			(*packet)++;
+			return MYSQLND_NULL_LENGTH;
+		case 252:
+			(*packet) += 3;
+			return (unsigned long) uint2korr(p+1);
+		case 253:
+			(*packet) += 4;
+			return (unsigned long) uint3korr(p+1);
+		default:
+			(*packet) += 9;
+			return (unsigned long) uint4korr(p+1);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_net_field_length_ll
+   Get next field's length */
+uint64_t
+php_mysqlnd_net_field_length_ll(zend_uchar **packet)
+{
+	register zend_uchar *p= (zend_uchar *)*packet;
+
+	if (*p < 251) {
+		(*packet)++;
+		return (uint64_t) *p;
+	}
+
+	switch (*p) {
+		case 251:
+			(*packet)++;
+			return (uint64_t) MYSQLND_NULL_LENGTH;
+		case 252:
+			(*packet) += 3;
+			return (uint64_t) uint2korr(p + 1);
+		case 253:
+			(*packet) += 4;
+			return (uint64_t) uint3korr(p + 1);
+		default:
+			(*packet) += 9;
+			return (uint64_t) uint8korr(p + 1);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_net_store_length */
+zend_uchar *
+php_mysqlnd_net_store_length(zend_uchar *packet, uint64_t length)
+{
+	if (length < (uint64_t) L64(251)) {
+		*packet = (zend_uchar) length;
+		return packet + 1;
+	}
+
+	if (length < (uint64_t) L64(65536)) {
+		*packet++ = 252;
+		int2store(packet,(unsigned int) length);
+		return packet + 2;
+	}
+
+	if (length < (uint64_t) L64(16777216)) {
+		*packet++ = 253;
+		int3store(packet,(ulong) length);
+		return packet + 3;
+	}
+	*packet++ = 254;
+	int8store(packet, length);
+	return packet + 8;
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_read_error_from_line */
+static enum_func_status
+php_mysqlnd_read_error_from_line(zend_uchar *buf, size_t buf_len,
+								char *error, int error_buf_len,
+								unsigned int *error_no, char *sqlstate TSRMLS_DC)
+{
+	zend_uchar *p = buf;
+	int error_msg_len= 0;
+
+	DBG_ENTER("php_mysqlnd_read_error_from_line");
+
+	*error_no = CR_UNKNOWN_ERROR;
+	memcpy(sqlstate, unknown_sqlstate, MYSQLND_SQLSTATE_LENGTH);
+
+	if (buf_len > 2) {
+		*error_no = uint2korr(p);
+		p+= 2;
+		/*
+		  sqlstate is following. No need to check for buf_left_len as we checked > 2 above,
+		  if it was >=2 then we would need a check
+		*/
+		if (*p == '#') {
+			++p;
+			if ((buf_len - (p - buf)) >= MYSQLND_SQLSTATE_LENGTH) {
+				memcpy(sqlstate, p, MYSQLND_SQLSTATE_LENGTH);
+				p+= MYSQLND_SQLSTATE_LENGTH;
+			} else {
+				goto end;
+			}
+		}
+		if ((buf_len - (p - buf)) > 0) {
+			error_msg_len = MIN((int)((buf_len - (p - buf))), (int) (error_buf_len - 1));
+			memcpy(error, p, error_msg_len);
+		}
+	}
+end:
+	sqlstate[MYSQLND_SQLSTATE_LENGTH] = '\0';
+	error[error_msg_len]= '\0';
+
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_read_header */
+static enum_func_status
+mysqlnd_read_header(MYSQLND * conn, MYSQLND_PACKET_HEADER * header TSRMLS_DC)
+{
+	MYSQLND_NET * net = conn->net;
+	zend_uchar buffer[MYSQLND_HEADER_SIZE];
+
+	DBG_ENTER("mysqlnd_read_header_name");
+	DBG_INF_FMT("compressed=%u conn_id=%u", net->compressed, conn->thread_id);
+	if (FAIL == net->m.receive(conn, buffer, MYSQLND_HEADER_SIZE TSRMLS_CC)) {
+		DBG_RETURN(FAIL);
+	}
+
+	header->size = uint3korr(buffer);
+	header->packet_no = uint1korr(buffer + 3);
+
+#ifdef MYSQLND_DUMP_HEADER_N_BODY
+	DBG_INF_FMT("HEADER: prot_packet_no=%u size=%3u", header->packet_no, header->size);
+#endif
+	MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats,
+							STAT_PROTOCOL_OVERHEAD_IN, MYSQLND_HEADER_SIZE,
+							STAT_PACKETS_RECEIVED, 1);
+
+	if (net->compressed || net->packet_no == header->packet_no) {
+		/*
+		  Have to increase the number, so we can send correct number back. It will
+		  round at 255 as this is unsigned char. The server needs this for simple
+		  flow control checking.
+		*/
+		net->packet_no++;
+		DBG_RETURN(PASS);
+	}
+
+	DBG_ERR_FMT("Logical link: packets out of order. Expected %u received %u. Packet size="MYSQLND_SZ_T_SPEC,
+				net->packet_no, header->packet_no, header->size);
+
+	php_error(E_WARNING, "Packets out of order. Expected %u received %u. Packet size="MYSQLND_SZ_T_SPEC,
+			  net->packet_no, header->packet_no, header->size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_greet_read */
+static enum_func_status
+php_mysqlnd_greet_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	zend_uchar buf[2048];
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+	MYSQLND_PACKET_GREET *packet= (MYSQLND_PACKET_GREET *) _packet;
+
+	DBG_ENTER("php_mysqlnd_greet_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, sizeof(buf), "greeting", PROT_GREET_PACKET);
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->protocol_version = uint1korr(p);
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	if (ERROR_MARKER == packet->protocol_version) {
+		php_mysqlnd_read_error_from_line(p, packet->header.size - 1,
+										 packet->error, sizeof(packet->error),
+										 &packet->error_no, packet->sqlstate
+										 TSRMLS_CC);
+		/*
+		  The server doesn't send sqlstate in the greet packet.
+		  It's a bug#26426 , so we have to set it correctly ourselves.
+		  It's probably "Too many connections, which has SQL state 08004".
+		*/
+		if (packet->error_no == 1040) {
+			memcpy(packet->sqlstate, "08004", MYSQLND_SQLSTATE_LENGTH);
+		}
+		DBG_RETURN(PASS);
+	}
+
+	packet->server_version = estrdup((char *)p);
+	p+= strlen(packet->server_version) + 1; /* eat the '\0' */
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->thread_id = uint4korr(p);
+	p+=4;
+	BAIL_IF_NO_MORE_DATA;
+
+	memcpy(packet->scramble_buf, p, SCRAMBLE_LENGTH_323);
+	p+= 8;
+	BAIL_IF_NO_MORE_DATA;
+
+	/* pad1 */
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->server_capabilities = uint2korr(p);
+	p+= 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->charset_no = uint1korr(p);
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->server_status = uint2korr(p);
+	p+= 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	/* pad2 */
+	p+= 13;
+	BAIL_IF_NO_MORE_DATA;
+
+	if ((size_t) (p - buf) < packet->header.size) {
+		/* scramble_buf is split into two parts */
+		memcpy(packet->scramble_buf + SCRAMBLE_LENGTH_323,
+				p, SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323);
+	} else {
+		packet->pre41 = TRUE;
+	}
+
+	DBG_INF_FMT("proto=%u server=%s thread_id=%u",
+				packet->protocol_version, packet->server_version, packet->thread_id);
+
+	DBG_INF_FMT("server_capabilities=%u charset_no=%u server_status=%i",
+				packet->server_capabilities, packet->charset_no, packet->server_status);
+
+	DBG_RETURN(PASS);
+premature_end:
+	DBG_ERR_FMT("GREET packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "GREET packet "MYSQLND_SZ_T_SPEC" bytes shorter than expected",
+					 p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_greet_free_mem */
+static
+void php_mysqlnd_greet_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_GREET *p= (MYSQLND_PACKET_GREET *) _packet;
+	if (p->server_version) {
+		efree(p->server_version);
+		p->server_version = NULL;
+	}
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_crypt */
+static void
+php_mysqlnd_crypt(zend_uchar *buffer, const zend_uchar *s1, const zend_uchar *s2, size_t len)
+{
+	const zend_uchar *s1_end = s1 + len;
+	while (s1 < s1_end) {
+		*buffer++= *s1++ ^ *s2++;
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_scramble */
+void php_mysqlnd_scramble(zend_uchar * const buffer, const zend_uchar * const scramble, const zend_uchar * const password)
+{
+	PHP_SHA1_CTX context;
+	zend_uchar sha1[SHA1_MAX_LENGTH];
+	zend_uchar sha2[SHA1_MAX_LENGTH];
+
+
+	/* Phase 1: hash password */
+	PHP_SHA1Init(&context);
+	PHP_SHA1Update(&context, password, strlen((char *)password));
+	PHP_SHA1Final(sha1, &context);
+
+	/* Phase 2: hash sha1 */
+	PHP_SHA1Init(&context);
+	PHP_SHA1Update(&context, (zend_uchar*)sha1, SHA1_MAX_LENGTH);
+	PHP_SHA1Final(sha2, &context);
+
+	/* Phase 3: hash scramble + sha2 */
+	PHP_SHA1Init(&context);
+	PHP_SHA1Update(&context, scramble, SCRAMBLE_LENGTH);
+	PHP_SHA1Update(&context, (zend_uchar*)sha2, SHA1_MAX_LENGTH);
+	PHP_SHA1Final(buffer, &context);
+
+	/* let's crypt buffer now */
+	php_mysqlnd_crypt(buffer, (const zend_uchar *)buffer, (const zend_uchar *)sha1, SHA1_MAX_LENGTH);
+}
+/* }}} */
+
+
+#define AUTH_WRITE_BUFFER_LEN (MYSQLND_HEADER_SIZE + MYSQLND_MAX_ALLOWED_USER_LEN + SHA1_MAX_LENGTH + MYSQLND_MAX_ALLOWED_DB_LEN + 1 + 128)
+
+/* {{{ php_mysqlnd_auth_write */
+static
+size_t php_mysqlnd_auth_write(void *_packet, MYSQLND * conn TSRMLS_DC)
+{
+	char buffer[AUTH_WRITE_BUFFER_LEN];
+	register char *p= buffer + MYSQLND_HEADER_SIZE; /* start after the header */
+	int len;
+	register MYSQLND_PACKET_AUTH *packet= (MYSQLND_PACKET_AUTH *) _packet;
+
+	DBG_ENTER("php_mysqlnd_auth_write");
+
+	int4store(p, packet->client_flags);
+	p+= 4;
+
+	int4store(p, packet->max_packet_size);
+	p+= 4;
+
+	int1store(p, packet->charset_no);
+	p++;
+
+	memset(p, 0, 23); /* filler */
+	p+= 23;
+
+	if (!packet->send_half_packet) {
+		len = MIN(strlen(packet->user), MYSQLND_MAX_ALLOWED_USER_LEN);
+		memcpy(p, packet->user, len);
+		p+= len;
+		*p++ = '\0';
+
+		/* copy scrambled pass*/
+		if (packet->password && packet->password[0]) {
+			/* In 4.1 we use CLIENT_SECURE_CONNECTION and thus the len of the buf should be passed */
+			int1store(p, SHA1_MAX_LENGTH);
+			p++;
+			php_mysqlnd_scramble((zend_uchar*)p, packet->server_scramble_buf, (zend_uchar*)packet->password);
+			p+= SHA1_MAX_LENGTH;
+		} else {
+			/* Zero length */
+			int1store(p, 0);
+			p++;
+		}
+
+		if (packet->db) {
+			size_t real_db_len = MIN(MYSQLND_MAX_ALLOWED_DB_LEN, packet->db_len);
+			memcpy(p, packet->db, real_db_len);
+			p+= real_db_len;
+			*p++= '\0';
+		}
+		/* Handle CLIENT_CONNECT_WITH_DB */
+		/* no \0 for no DB */
+	}
+
+	DBG_RETURN(conn->net->m.send(conn, buffer, p - buffer - MYSQLND_HEADER_SIZE TSRMLS_CC));
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_auth_free_mem */
+static
+void php_mysqlnd_auth_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	if (!stack_allocation) {
+		MYSQLND_PACKET_AUTH * p = (MYSQLND_PACKET_AUTH *) _packet;
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+#define OK_BUFFER_SIZE 2048
+
+/* {{{ php_mysqlnd_ok_read */
+static enum_func_status
+php_mysqlnd_ok_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	zend_uchar local_buf[OK_BUFFER_SIZE];
+	size_t buf_len = conn->net->cmd_buffer.buffer? conn->net->cmd_buffer.length : OK_BUFFER_SIZE;
+	zend_uchar *buf = conn->net->cmd_buffer.buffer? (zend_uchar *) conn->net->cmd_buffer.buffer : local_buf;
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+	unsigned long i;
+	register MYSQLND_PACKET_OK *packet= (MYSQLND_PACKET_OK *) _packet;
+
+	DBG_ENTER("php_mysqlnd_ok_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "OK", PROT_OK_PACKET);
+	BAIL_IF_NO_MORE_DATA;
+
+	/* Should be always 0x0 or ERROR_MARKER for error */
+	packet->field_count = uint1korr(p);
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	if (ERROR_MARKER == packet->field_count) {
+		php_mysqlnd_read_error_from_line(p, packet->header.size - 1,
+										 packet->error, sizeof(packet->error),
+										 &packet->error_no, packet->sqlstate
+										 TSRMLS_CC);
+		DBG_RETURN(PASS);
+	}
+	/* Everything was fine! */
+	packet->affected_rows  = php_mysqlnd_net_field_length_ll(&p);
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->last_insert_id = php_mysqlnd_net_field_length_ll(&p);
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->server_status = uint2korr(p);
+	p+= 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->warning_count = uint2korr(p);
+	p+= 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	/* There is a message */
+	if (packet->header.size > (size_t) (p - buf) && (i = php_mysqlnd_net_field_length(&p))) {
+		packet->message_len = MIN(i, buf_len - (p - begin));
+		packet->message = mnd_pestrndup((char *)p, packet->message_len, FALSE);
+	} else {
+		packet->message = NULL;
+		packet->message_len = 0;
+	}
+
+	DBG_INF_FMT("OK packet: aff_rows=%lld last_ins_id=%ld server_status=%u warnings=%u",
+				packet->affected_rows, packet->last_insert_id, packet->server_status,
+				packet->warning_count);
+
+	BAIL_IF_NO_MORE_DATA;
+
+	DBG_RETURN(PASS);
+premature_end:
+	DBG_ERR_FMT("OK packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "OK packet "MYSQLND_SZ_T_SPEC" bytes shorter than expected",
+					 p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_ok_free_mem */
+static void
+php_mysqlnd_ok_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_OK *p= (MYSQLND_PACKET_OK *) _packet;
+	if (p->message) {
+		mnd_efree(p->message);
+		p->message = NULL;
+	}
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_eof_read */
+static enum_func_status
+php_mysqlnd_eof_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	/*
+	  EOF packet is since 4.1 five bytes long,
+	  but we can get also an error, make it bigger.
+
+	  Error : error_code + '#' + sqlstate + MYSQLND_ERRMSG_SIZE
+	*/
+	MYSQLND_PACKET_EOF *packet= (MYSQLND_PACKET_EOF *) _packet;
+	size_t buf_len = conn->net->cmd_buffer.length;
+	zend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+
+	DBG_ENTER("php_mysqlnd_eof_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "EOF", PROT_EOF_PACKET);
+	BAIL_IF_NO_MORE_DATA;
+
+	/* Should be always EODATA_MARKER */
+	packet->field_count = uint1korr(p);
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	if (ERROR_MARKER == packet->field_count) {
+		php_mysqlnd_read_error_from_line(p, packet->header.size - 1,
+										 packet->error, sizeof(packet->error),
+										 &packet->error_no, packet->sqlstate
+										 TSRMLS_CC);
+		DBG_RETURN(PASS);
+	}
+
+	/*
+		4.1 sends 1 byte EOF packet after metadata of
+		PREPARE/EXECUTE but 5 bytes after the result. This is not
+		according to the Docs@Forge!!!
+	*/
+	if (packet->header.size > 1) {
+		packet->warning_count = uint2korr(p);
+		p+= 2;
+		BAIL_IF_NO_MORE_DATA;
+
+		packet->server_status = uint2korr(p);
+		p+= 2;
+		BAIL_IF_NO_MORE_DATA;
+	} else {
+		packet->warning_count = 0;
+		packet->server_status = 0;
+	}
+
+	BAIL_IF_NO_MORE_DATA;
+
+	DBG_INF_FMT("EOF packet: fields=%u status=%u warnings=%u",
+				packet->field_count, packet->server_status, packet->warning_count);
+
+	DBG_RETURN(PASS);
+premature_end:
+	DBG_ERR_FMT("EOF packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "EOF packet "MYSQLND_SZ_T_SPEC" bytes shorter than expected",
+					 p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_eof_free_mem */
+static
+void php_mysqlnd_eof_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	if (!stack_allocation) {
+		mnd_pefree(_packet, ((MYSQLND_PACKET_EOF *)_packet)->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_cmd_write */
+size_t php_mysqlnd_cmd_write(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	/* Let's have some space, which we can use, if not enough, we will allocate new buffer */
+	MYSQLND_PACKET_COMMAND *packet= (MYSQLND_PACKET_COMMAND *) _packet;
+	MYSQLND_NET *net = conn->net;
+	unsigned int error_reporting = EG(error_reporting);
+	size_t written = 0;
+
+	DBG_ENTER("php_mysqlnd_cmd_write");
+	/*
+	  Reset packet_no, or we will get bad handshake!
+	  Every command starts a new TX and packet numbers are reset to 0.
+	*/
+	net->packet_no = 0;
+	net->compressed_envelope_packet_no = 0; /* this is for the response */
+
+	if (error_reporting) {
+		EG(error_reporting) = 0;
+	}
+
+	MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_PACKETS_SENT_CMD);
+
+#ifdef MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND
+	net->m.consume_uneaten_data(net, packet->command TSRMLS_CC);
+#endif
+
+	if (!packet->argument || !packet->arg_len) {
+		char buffer[MYSQLND_HEADER_SIZE + 1];
+
+		int1store(buffer + MYSQLND_HEADER_SIZE, packet->command);
+		written = conn->net->m.send(conn, buffer, 1 TSRMLS_CC);
+	} else {
+		size_t tmp_len = packet->arg_len + 1 + MYSQLND_HEADER_SIZE, ret;
+		zend_uchar *tmp, *p;
+		tmp = (tmp_len > net->cmd_buffer.length)? mnd_emalloc(tmp_len):net->cmd_buffer.buffer;
+		if (!tmp) {
+			goto end;
+		}
+		p = tmp + MYSQLND_HEADER_SIZE; /* skip the header */
+
+		int1store(p, packet->command);
+		p++;
+
+		memcpy(p, packet->argument, packet->arg_len);
+
+		ret = conn->net->m.send(conn, (char *)tmp, tmp_len - MYSQLND_HEADER_SIZE TSRMLS_CC);
+		if (tmp != net->cmd_buffer.buffer) {
+			MYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_CMD_BUFFER_TOO_SMALL);
+			mnd_efree(tmp);
+		}
+		written = ret;
+	}
+end:
+	if (error_reporting) {
+		/* restore error reporting */
+		EG(error_reporting) = error_reporting;
+	}
+	DBG_RETURN(written);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_cmd_free_mem */
+static
+void php_mysqlnd_cmd_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	if (!stack_allocation) {
+		MYSQLND_PACKET_COMMAND * p = (MYSQLND_PACKET_COMMAND *) _packet;
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rset_header_read */
+static enum_func_status
+php_mysqlnd_rset_header_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	size_t buf_len = conn->net->cmd_buffer.length;
+	zend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+	size_t len;
+	MYSQLND_PACKET_RSET_HEADER *packet= (MYSQLND_PACKET_RSET_HEADER *) _packet;
+
+	DBG_ENTER("php_mysqlnd_rset_header_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "resultset header", PROT_RSET_HEADER_PACKET);
+	BAIL_IF_NO_MORE_DATA;
+
+	/*
+	  Don't increment. First byte is ERROR_MARKER on error, but otherwise is starting byte
+	  of encoded sequence for length.
+	*/
+	if (ERROR_MARKER == *p) {
+		/* Error */
+		p++;
+		BAIL_IF_NO_MORE_DATA;
+		php_mysqlnd_read_error_from_line(p, packet->header.size - 1,
+										 packet->error_info.error, sizeof(packet->error_info.error),
+										 &packet->error_info.error_no, packet->error_info.sqlstate
+										 TSRMLS_CC);
+		DBG_RETURN(PASS);
+	}
+
+	packet->field_count = php_mysqlnd_net_field_length(&p);
+	BAIL_IF_NO_MORE_DATA;
+
+	switch (packet->field_count) {
+		case MYSQLND_NULL_LENGTH:
+			DBG_INF("LOAD LOCAL");
+			/*
+			  First byte in the packet is the field count.
+			  Thus, the name is size - 1. And we add 1 for a trailing \0.
+			  Because we have BAIL_IF_NO_MORE_DATA before the switch, we are guaranteed
+			  that packet->header.size is > 0. Which means that len can't underflow, that
+			  would lead to 0 byte allocation but 2^32 or 2^64 bytes copied.
+			*/
+			len = packet->header.size - 1;
+			packet->info_or_local_file = mnd_emalloc(len + 1);
+			if (packet->info_or_local_file) {
+				memcpy(packet->info_or_local_file, p, len);
+				packet->info_or_local_file[len] = '\0';
+				packet->info_or_local_file_len = len;
+			} else {
+				SET_OOM_ERROR(conn->error_info);
+				ret = FAIL;
+			}
+			break;
+		case 0x00:
+			DBG_INF("UPSERT");
+			packet->affected_rows = php_mysqlnd_net_field_length_ll(&p);
+			BAIL_IF_NO_MORE_DATA;
+
+			packet->last_insert_id = php_mysqlnd_net_field_length_ll(&p);
+			BAIL_IF_NO_MORE_DATA;
+
+			packet->server_status = uint2korr(p);
+			p+=2;
+			BAIL_IF_NO_MORE_DATA;
+
+			packet->warning_count = uint2korr(p);
+			p+=2;
+			BAIL_IF_NO_MORE_DATA;
+			/* Check for additional textual data */
+			if (packet->header.size  > (size_t) (p - buf) && (len = php_mysqlnd_net_field_length(&p))) {
+				packet->info_or_local_file = mnd_emalloc(len + 1);
+				if (packet->info_or_local_file) {
+					memcpy(packet->info_or_local_file, p, len);
+					packet->info_or_local_file[len] = '\0';
+					packet->info_or_local_file_len = len;
+				} else {
+					SET_OOM_ERROR(conn->error_info);
+					ret = FAIL;
+				}
+			}
+			DBG_INF_FMT("affected_rows=%llu last_insert_id=%llu server_status=%u warning_count=%u",
+						packet->affected_rows, packet->last_insert_id,
+						packet->server_status, packet->warning_count);
+			break;
+		default:
+			DBG_INF("SELECT");
+			/* Result set */
+			break;
+	}
+	BAIL_IF_NO_MORE_DATA;
+
+	DBG_RETURN(ret);
+premature_end:
+	DBG_ERR_FMT("RSET_HEADER packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "RSET_HEADER packet "MYSQLND_SZ_T_SPEC" bytes shorter than expected",
+					 p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rset_header_free_mem */
+static
+void php_mysqlnd_rset_header_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_RSET_HEADER *p= (MYSQLND_PACKET_RSET_HEADER *) _packet;
+	DBG_ENTER("php_mysqlnd_rset_header_free_mem");
+	if (p->info_or_local_file) {
+		mnd_efree(p->info_or_local_file);
+		p->info_or_local_file = NULL;
+	}
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+static size_t rset_field_offsets[] =
+{
+	STRUCT_OFFSET(MYSQLND_FIELD, catalog),
+	STRUCT_OFFSET(MYSQLND_FIELD, catalog_length),
+	STRUCT_OFFSET(MYSQLND_FIELD, db),
+	STRUCT_OFFSET(MYSQLND_FIELD, db_length),
+	STRUCT_OFFSET(MYSQLND_FIELD, table),
+	STRUCT_OFFSET(MYSQLND_FIELD, table_length),
+	STRUCT_OFFSET(MYSQLND_FIELD, org_table),
+	STRUCT_OFFSET(MYSQLND_FIELD, org_table_length),
+	STRUCT_OFFSET(MYSQLND_FIELD, name),
+	STRUCT_OFFSET(MYSQLND_FIELD, name_length),
+	STRUCT_OFFSET(MYSQLND_FIELD, org_name),
+	STRUCT_OFFSET(MYSQLND_FIELD, org_name_length)
+};
+
+
+/* {{{ php_mysqlnd_rset_field_read */
+static enum_func_status
+php_mysqlnd_rset_field_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	/* Should be enough for the metadata of a single row */
+	MYSQLND_PACKET_RES_FIELD *packet= (MYSQLND_PACKET_RES_FIELD *) _packet;
+	size_t buf_len = conn->net->cmd_buffer.length, total_len = 0;
+	zend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+	char *root_ptr;
+	unsigned long len;
+	MYSQLND_FIELD *meta;
+	unsigned int i, field_count = sizeof(rset_field_offsets)/sizeof(size_t);
+
+	DBG_ENTER("php_mysqlnd_rset_field_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "field", PROT_RSET_FLD_PACKET);
+
+	if (packet->skip_parsing) {
+		DBG_RETURN(PASS);
+	}
+
+	BAIL_IF_NO_MORE_DATA;
+	if (ERROR_MARKER == *p) {
+		/* Error */
+		p++;
+		BAIL_IF_NO_MORE_DATA;
+		php_mysqlnd_read_error_from_line(p, packet->header.size - 1,
+										 packet->error_info.error, sizeof(packet->error_info.error),
+										 &packet->error_info.error_no, packet->error_info.sqlstate
+										 TSRMLS_CC);
+		DBG_ERR_FMT("Server error : (%u) %s", packet->error_info.error_no, packet->error_info.error);
+		DBG_RETURN(PASS);
+	} else if (EODATA_MARKER == *p && packet->header.size < 8) {
+		/* Premature EOF. That should be COM_FIELD_LIST */
+		DBG_INF("Premature EOF. That should be COM_FIELD_LIST");
+		packet->stupid_list_fields_eof = TRUE;
+		DBG_RETURN(PASS);
+	}
+
+	meta = packet->metadata;
+
+	for (i = 0; i < field_count; i += 2) {
+		len = php_mysqlnd_net_field_length(&p);
+		BAIL_IF_NO_MORE_DATA;
+		switch ((len)) {
+			case 0:
+				*(const char **)(((char*)meta) + rset_field_offsets[i]) = mysqlnd_empty_string;
+				*(unsigned int *)(((char*)meta) + rset_field_offsets[i+1]) = 0;
+				break;
+			case MYSQLND_NULL_LENGTH:
+				goto faulty_or_fake;
+			default:
+				*(const char **)(((char *)meta) + rset_field_offsets[i]) = (const char *)p;
+				*(unsigned int *)(((char*)meta) + rset_field_offsets[i+1]) = len;
+				p += len;
+				total_len += len + 1;
+				break;
+		}
+		BAIL_IF_NO_MORE_DATA;
+	}
+
+	/* 1 byte length */
+	if (12 != *p) {
+		DBG_ERR_FMT("Protocol error. Server sent false length. Expected 12 got %d", (int) *p);
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Protocol error. Server sent false length. Expected 12");
+	}
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	meta->charsetnr = uint2korr(p);
+	p += 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	meta->length = uint4korr(p);
+	p += 4;
+	BAIL_IF_NO_MORE_DATA;
+
+	meta->type = uint1korr(p);
+	p += 1;
+	BAIL_IF_NO_MORE_DATA;
+
+	meta->flags = uint2korr(p);
+	p += 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	meta->decimals = uint1korr(p);
+	p += 1;
+	BAIL_IF_NO_MORE_DATA;
+
+	/* 2 byte filler */
+	p +=2;
+	BAIL_IF_NO_MORE_DATA;
+
+	/* Should we set NUM_FLAG (libmysql does it) ? */
+	if (
+		(meta->type <= MYSQL_TYPE_INT24 &&
+			(meta->type != MYSQL_TYPE_TIMESTAMP || meta->length == 14 || meta->length == 8)
+		) || meta->type == MYSQL_TYPE_YEAR)
+	{
+		meta->flags |= NUM_FLAG;
+	}
+
+
+	/*
+	  def could be empty, thus don't allocate on the root.
+	  NULL_LENGTH (0xFB) comes from COM_FIELD_LIST when the default value is NULL.
+	  Otherwise the string is length encoded.
+	*/
+	if (packet->header.size > (size_t) (p - buf) &&
+		(len = php_mysqlnd_net_field_length(&p)) &&
+		len != MYSQLND_NULL_LENGTH)
+	{
+		BAIL_IF_NO_MORE_DATA;
+		DBG_INF_FMT("Def found, length %lu, persistent=%u", len, packet->persistent_alloc);
+		meta->def = mnd_pemalloc(len + 1, packet->persistent_alloc);
+		if (!meta->def) {
+			SET_OOM_ERROR(conn->error_info);
+			DBG_RETURN(FAIL);
+		}
+		memcpy(meta->def, p, len);
+		meta->def[len] = '\0';
+		meta->def_length = len;
+		p += len;
+	}
+
+	DBG_INF_FMT("allocing root. persistent=%u", packet->persistent_alloc);
+	root_ptr = meta->root = mnd_pemalloc(total_len, packet->persistent_alloc);
+	if (!root_ptr) {
+		SET_OOM_ERROR(conn->error_info);
+		DBG_RETURN(FAIL);
+	}
+
+	meta->root_len = total_len;
+	/* Now do allocs */
+	if (meta->catalog && meta->catalog != mysqlnd_empty_string) {
+		len = meta->catalog_length;
+		meta->catalog = memcpy(root_ptr, meta->catalog, len);
+		*(root_ptr +=len) = '\0';
+		root_ptr++;
+	}
+
+	if (meta->db && meta->db != mysqlnd_empty_string) {
+		len = meta->db_length;
+		meta->db = memcpy(root_ptr, meta->db, len);
+		*(root_ptr +=len) = '\0';
+		root_ptr++;
+	}
+
+	if (meta->table && meta->table != mysqlnd_empty_string) {
+		len = meta->table_length;
+		meta->table = memcpy(root_ptr, meta->table, len);
+		*(root_ptr +=len) = '\0';
+		root_ptr++;
+	}
+
+	if (meta->org_table && meta->org_table != mysqlnd_empty_string) {
+		len = meta->org_table_length;
+		meta->org_table = memcpy(root_ptr, meta->org_table, len);
+		*(root_ptr +=len) = '\0';
+		root_ptr++;
+	}
+
+	if (meta->name && meta->name != mysqlnd_empty_string) {
+		len = meta->name_length;
+		meta->name = memcpy(root_ptr, meta->name, len);
+		*(root_ptr +=len) = '\0';
+		root_ptr++;
+	}
+
+	if (meta->org_name && meta->org_name != mysqlnd_empty_string) {
+		len = meta->org_name_length;
+		meta->org_name = memcpy(root_ptr, meta->org_name, len);
+		*(root_ptr +=len) = '\0';
+		root_ptr++;
+	}
+
+	DBG_INF_FMT("FIELD=[%s.%s.%s]", meta->db? meta->db:"*NA*", meta->table? meta->table:"*NA*",
+				meta->name? meta->name:"*NA*");
+
+	DBG_RETURN(PASS);
+
+faulty_or_fake:
+	DBG_ERR_FMT("Protocol error. Server sent NULL_LENGTH. The server is faulty");
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "Protocol error. Server sent NULL_LENGTH."
+					 " The server is faulty");
+	DBG_RETURN(FAIL);
+premature_end:
+	DBG_ERR_FMT("RSET field packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "Result set field packet "MYSQLND_SZ_T_SPEC" bytes "
+			 		"shorter than expected", p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rset_field_free_mem */
+static
+void php_mysqlnd_rset_field_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_RES_FIELD *p= (MYSQLND_PACKET_RES_FIELD *) _packet;
+	/* p->metadata was passed to us as temporal buffer */
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_read_row_ex */
+static enum_func_status
+php_mysqlnd_read_row_ex(MYSQLND * conn, MYSQLND_MEMORY_POOL * result_set_memory_pool,
+						MYSQLND_MEMORY_POOL_CHUNK **buffer,
+						size_t *data_size, zend_bool persistent_alloc,
+						unsigned int prealloc_more_bytes TSRMLS_DC)
+{
+	enum_func_status ret = PASS;
+	MYSQLND_PACKET_HEADER header;
+	zend_uchar *p = NULL;
+	zend_bool first_iteration = TRUE;
+
+	DBG_ENTER("php_mysqlnd_read_row_ex");
+
+	/*
+	  To ease the process the server splits everything in packets up to 2^24 - 1.
+	  Even in the case the payload is evenly divisible by this value, the last
+	  packet will be empty, namely 0 bytes. Thus, we can read every packet and ask
+	  for next one if they have 2^24 - 1 sizes. But just read the header of a
+	  zero-length byte, don't read the body, there is no such.
+	*/
+
+	*data_size = prealloc_more_bytes;
+	while (1) {
+		if (FAIL == mysqlnd_read_header(conn , &header TSRMLS_CC)) {
+			ret = FAIL;
+			break;
+		}
+
+		*data_size += header.size;
+
+		if (first_iteration) {
+			first_iteration = FALSE;
+			/*
+			  We need a trailing \0 for the last string, in case of text-mode,
+			  to be able to implement read-only variables. Thus, we add + 1.
+			*/
+			*buffer = result_set_memory_pool->get_chunk(result_set_memory_pool, *data_size + 1 TSRMLS_CC);
+			if (!*buffer) {
+				ret = FAIL;
+				break;
+			}
+			p = (*buffer)->ptr;
+		} else if (!first_iteration) {
+			/* Empty packet after MYSQLND_MAX_PACKET_SIZE packet. That's ok, break */
+			if (!header.size) {
+				break;
+			}
+
+			/*
+			  We have to realloc the buffer.
+
+			  We need a trailing \0 for the last string, in case of text-mode,
+			  to be able to implement read-only variables.
+			*/
+			if (FAIL == (*buffer)->resize_chunk((*buffer), *data_size + 1 TSRMLS_CC)) {
+				SET_OOM_ERROR(conn->error_info);
+				ret = FAIL;
+				break;
+			}
+			/* The position could have changed, recalculate */
+			p = (*buffer)->ptr + (*data_size - header.size);
+		}
+
+		if (PASS != (ret = conn->net->m.receive(conn, p, header.size TSRMLS_CC))) {
+			DBG_ERR("Empty row packet body");
+			php_error(E_WARNING, "Empty row packet body");
+			break;
+		}
+
+		if (header.size < MYSQLND_MAX_PACKET_SIZE) {
+			break;
+		}
+	}
+	if (ret == FAIL && *buffer) {
+		(*buffer)->free_chunk((*buffer) TSRMLS_CC);
+		*buffer = NULL;
+	}
+	*data_size -= prealloc_more_bytes;
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rowp_read_binary_protocol */
+enum_func_status
+php_mysqlnd_rowp_read_binary_protocol(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,
+									  unsigned int field_count, MYSQLND_FIELD *fields_metadata,
+									  zend_bool persistent,
+									  zend_bool as_unicode, zend_bool as_int_or_float,
+									  MYSQLND_STATS * stats TSRMLS_DC)
+{
+	unsigned int i;
+	zend_uchar *p = row_buffer->ptr;
+	zend_uchar *null_ptr, bit;
+	zval **current_field, **end_field, **start_field;
+
+	DBG_ENTER("php_mysqlnd_rowp_read_binary_protocol");
+
+	if (!fields) {
+		DBG_RETURN(FAIL);
+	}
+
+	end_field = (start_field = fields) + field_count;
+
+	/* skip the first byte, not EODATA_MARKER -> 0x0, status */
+	p++;
+	null_ptr= p;
+	p += (field_count + 9)/8;	/* skip null bits */
+	bit	= 4;					/* first 2 bits are reserved */
+
+	for (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {
+		DBG_INF("Directly creating zval");
+		MAKE_STD_ZVAL(*current_field);
+		if (!*current_field) {
+			DBG_RETURN(FAIL);
+		}
+	}
+
+	for (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {
+		enum_mysqlnd_collected_stats statistic;
+		zend_uchar * orig_p = p;
+
+		DBG_INF_FMT("Into zval=%p decoding column %u [%s.%s.%s] type=%u field->flags&unsigned=%u flags=%u is_bit=%u as_unicode=%u",
+			*current_field, i,
+			fields_metadata[i].db, fields_metadata[i].table, fields_metadata[i].name, fields_metadata[i].type,
+			fields_metadata[i].flags & UNSIGNED_FLAG, fields_metadata[i].flags, fields_metadata[i].type == MYSQL_TYPE_BIT, as_unicode);
+		if (*null_ptr & bit) {
+			DBG_INF("It's null");
+			ZVAL_NULL(*current_field);
+			statistic = STAT_BINARY_TYPE_FETCHED_NULL;
+		} else {
+			enum_mysqlnd_field_types type = fields_metadata[i].type;
+			mysqlnd_ps_fetch_functions[type].func(*current_field, &fields_metadata[i], 0, &p, as_unicode TSRMLS_CC);
+
+			if (MYSQLND_G(collect_statistics)) {
+				switch (fields_metadata[i].type) {
+					case MYSQL_TYPE_DECIMAL:	statistic = STAT_BINARY_TYPE_FETCHED_DECIMAL; break;
+					case MYSQL_TYPE_TINY:		statistic = STAT_BINARY_TYPE_FETCHED_INT8; break;
+					case MYSQL_TYPE_SHORT:		statistic = STAT_BINARY_TYPE_FETCHED_INT16; break;
+					case MYSQL_TYPE_LONG:		statistic = STAT_BINARY_TYPE_FETCHED_INT32; break;
+					case MYSQL_TYPE_FLOAT:		statistic = STAT_BINARY_TYPE_FETCHED_FLOAT; break;
+					case MYSQL_TYPE_DOUBLE:		statistic = STAT_BINARY_TYPE_FETCHED_DOUBLE; break;
+					case MYSQL_TYPE_NULL:		statistic = STAT_BINARY_TYPE_FETCHED_NULL; break;
+					case MYSQL_TYPE_TIMESTAMP:	statistic = STAT_BINARY_TYPE_FETCHED_TIMESTAMP; break;
+					case MYSQL_TYPE_LONGLONG:	statistic = STAT_BINARY_TYPE_FETCHED_INT64; break;
+					case MYSQL_TYPE_INT24:		statistic = STAT_BINARY_TYPE_FETCHED_INT24; break;
+					case MYSQL_TYPE_DATE:		statistic = STAT_BINARY_TYPE_FETCHED_DATE; break;
+					case MYSQL_TYPE_TIME:		statistic = STAT_BINARY_TYPE_FETCHED_TIME; break;
+					case MYSQL_TYPE_DATETIME:	statistic = STAT_BINARY_TYPE_FETCHED_DATETIME; break;
+					case MYSQL_TYPE_YEAR:		statistic = STAT_BINARY_TYPE_FETCHED_YEAR; break;
+					case MYSQL_TYPE_NEWDATE:	statistic = STAT_BINARY_TYPE_FETCHED_DATE; break;
+					case MYSQL_TYPE_VARCHAR:	statistic = STAT_BINARY_TYPE_FETCHED_STRING; break;
+					case MYSQL_TYPE_BIT:		statistic = STAT_BINARY_TYPE_FETCHED_BIT; break;
+					case MYSQL_TYPE_NEWDECIMAL:	statistic = STAT_BINARY_TYPE_FETCHED_DECIMAL; break;
+					case MYSQL_TYPE_ENUM:		statistic = STAT_BINARY_TYPE_FETCHED_ENUM; break;
+					case MYSQL_TYPE_SET:		statistic = STAT_BINARY_TYPE_FETCHED_SET; break;
+					case MYSQL_TYPE_TINY_BLOB:	statistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_LONG_BLOB:	statistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_BLOB:		statistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_VAR_STRING:	statistic = STAT_BINARY_TYPE_FETCHED_STRING; break;
+					case MYSQL_TYPE_STRING:		statistic = STAT_BINARY_TYPE_FETCHED_STRING; break;
+					case MYSQL_TYPE_GEOMETRY:	statistic = STAT_BINARY_TYPE_FETCHED_GEOMETRY; break;
+					default: statistic = STAT_BINARY_TYPE_FETCHED_OTHER; break;
+				}
+			}
+		}
+		MYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1,
+										STAT_BYTES_RECEIVED_PURE_DATA_PS,
+										(Z_TYPE_PP(current_field) == IS_STRING)?
+											Z_STRLEN_PP(current_field) : (p - orig_p));
+
+		if (!((bit<<=1) & 255)) {
+			bit = 1;	/* to the following byte */
+			null_ptr++;
+		}
+	}
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rowp_read_text_protocol */
+enum_func_status
+php_mysqlnd_rowp_read_text_protocol(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,
+									unsigned int field_count, MYSQLND_FIELD *fields_metadata,
+									zend_bool persistent,
+									zend_bool as_unicode, zend_bool as_int_or_float,
+									MYSQLND_STATS * stats TSRMLS_DC)
+{
+	unsigned int i;
+	zend_bool last_field_was_string = FALSE;
+	zval **current_field, **end_field, **start_field;
+	zend_uchar *p = row_buffer->ptr;
+	size_t data_size = row_buffer->app;
+	zend_uchar *bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1; /* we allocate from here */
+
+	DBG_ENTER("php_mysqlnd_rowp_read_text_protocol");
+
+	if (!fields) {
+		DBG_RETURN(FAIL);
+	}
+
+	end_field = (start_field = fields) + field_count;
+
+	for (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {
+		DBG_INF("Directly creating zval");
+		MAKE_STD_ZVAL(*current_field);
+		if (!*current_field) {
+			DBG_RETURN(FAIL);
+		}
+	}
+
+	for (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {
+		/* Don't reverse the order. It is significant!*/
+		zend_uchar *this_field_len_pos = p;
+		/* php_mysqlnd_net_field_length() call should be after *this_field_len_pos = p; */
+		unsigned long len = php_mysqlnd_net_field_length(&p);
+
+		if (current_field > start_field && last_field_was_string) {
+			/*
+			  Normal queries:
+			  We have to put \0 now to the end of the previous field, if it was
+			  a string. IS_NULL doesn't matter. Because we have already read our
+			  length, then we can overwrite it in the row buffer.
+			  This statement terminates the previous field, not the current one.
+
+			  NULL_LENGTH is encoded in one byte, so we can stick a \0 there.
+			  Any string's length is encoded in at least one byte, so we can stick
+			  a \0 there.
+			*/
+
+			*this_field_len_pos = '\0';
+		}
+
+		/* NULL or NOT NULL, this is the question! */
+		if (len == MYSQLND_NULL_LENGTH) {
+			ZVAL_NULL(*current_field);
+			last_field_was_string = FALSE;
+		} else {
+#if MYSQLND_UNICODE || defined(MYSQLND_STRING_TO_INT_CONVERSION)
+			struct st_mysqlnd_perm_bind perm_bind =
+					mysqlnd_ps_fetch_functions[fields_metadata[i].type];
+#endif
+			if (MYSQLND_G(collect_statistics)) {
+				enum_mysqlnd_collected_stats statistic;
+				switch (fields_metadata[i].type) {
+					case MYSQL_TYPE_DECIMAL:	statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;
+					case MYSQL_TYPE_TINY:		statistic = STAT_TEXT_TYPE_FETCHED_INT8; break;
+					case MYSQL_TYPE_SHORT:		statistic = STAT_TEXT_TYPE_FETCHED_INT16; break;
+					case MYSQL_TYPE_LONG:		statistic = STAT_TEXT_TYPE_FETCHED_INT32; break;
+					case MYSQL_TYPE_FLOAT:		statistic = STAT_TEXT_TYPE_FETCHED_FLOAT; break;
+					case MYSQL_TYPE_DOUBLE:		statistic = STAT_TEXT_TYPE_FETCHED_DOUBLE; break;
+					case MYSQL_TYPE_NULL:		statistic = STAT_TEXT_TYPE_FETCHED_NULL; break;
+					case MYSQL_TYPE_TIMESTAMP:	statistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP; break;
+					case MYSQL_TYPE_LONGLONG:	statistic = STAT_TEXT_TYPE_FETCHED_INT64; break;
+					case MYSQL_TYPE_INT24:		statistic = STAT_TEXT_TYPE_FETCHED_INT24; break;
+					case MYSQL_TYPE_DATE:		statistic = STAT_TEXT_TYPE_FETCHED_DATE; break;
+					case MYSQL_TYPE_TIME:		statistic = STAT_TEXT_TYPE_FETCHED_TIME; break;
+					case MYSQL_TYPE_DATETIME:	statistic = STAT_TEXT_TYPE_FETCHED_DATETIME; break;
+					case MYSQL_TYPE_YEAR:		statistic = STAT_TEXT_TYPE_FETCHED_YEAR; break;
+					case MYSQL_TYPE_NEWDATE:	statistic = STAT_TEXT_TYPE_FETCHED_DATE; break;
+					case MYSQL_TYPE_VARCHAR:	statistic = STAT_TEXT_TYPE_FETCHED_STRING; break;
+					case MYSQL_TYPE_BIT:		statistic = STAT_TEXT_TYPE_FETCHED_BIT; break;
+					case MYSQL_TYPE_NEWDECIMAL:	statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;
+					case MYSQL_TYPE_ENUM:		statistic = STAT_TEXT_TYPE_FETCHED_ENUM; break;
+					case MYSQL_TYPE_SET:		statistic = STAT_TEXT_TYPE_FETCHED_SET; break;
+					case MYSQL_TYPE_TINY_BLOB:	statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_LONG_BLOB:	statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_BLOB:		statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
+					case MYSQL_TYPE_VAR_STRING:	statistic = STAT_TEXT_TYPE_FETCHED_STRING; break;
+					case MYSQL_TYPE_STRING:		statistic = STAT_TEXT_TYPE_FETCHED_STRING; break;
+					case MYSQL_TYPE_GEOMETRY:	statistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY; break;
+					default: statistic = STAT_TEXT_TYPE_FETCHED_OTHER; break;
+				}
+				MYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1, STAT_BYTES_RECEIVED_PURE_DATA_TEXT, len);
+			}
+#ifdef MYSQLND_STRING_TO_INT_CONVERSION
+			if (as_int_or_float && perm_bind.php_type == IS_LONG) {
+				zend_uchar save = *(p + len);
+				/* We have to make it ASCIIZ temporarily */
+				*(p + len) = '\0';
+				if (perm_bind.pack_len < SIZEOF_LONG) {
+					/* direct conversion */
+					int64_t v =
+#ifndef PHP_WIN32
+						atoll((char *) p);
+#else
+						_atoi64((char *) p);
+#endif
+					ZVAL_LONG(*current_field, (long) v); /* the cast is safe */
+				} else {
+					uint64_t v =
+#ifndef PHP_WIN32
+						(uint64_t) atoll((char *) p);
+#else
+						(uint64_t) _atoi64((char *) p);
+#endif
+					zend_bool uns = fields_metadata[i].flags & UNSIGNED_FLAG? TRUE:FALSE;
+					/* We have to make it ASCIIZ temporarily */
+#if SIZEOF_LONG==8
+					if (uns == TRUE && v > 9223372036854775807L)
+#elif SIZEOF_LONG==4
+					if ((uns == TRUE && v > L64(2147483647)) ||
+						(uns == FALSE && (( L64(2147483647) < (int64_t) v) ||
+						(L64(-2147483648) > (int64_t) v))))
+#else
+#error Need fix for this architecture
+#endif /* SIZEOF */
+					{
+						ZVAL_STRINGL(*current_field, (char *)p, len, 0);
+					} else {
+						ZVAL_LONG(*current_field, (long) v); /* the cast is safe */
+					}
+				}
+				*(p + len) = save;
+			} else if (as_int_or_float && perm_bind.php_type == IS_DOUBLE) {
+				zend_uchar save = *(p + len);
+				/* We have to make it ASCIIZ temporarily */
+				*(p + len) = '\0';
+				ZVAL_DOUBLE(*current_field, atof((char *) p));
+				*(p + len) = save;
+			} else
+#endif /* MYSQLND_STRING_TO_INT_CONVERSION */
+			if (fields_metadata[i].type == MYSQL_TYPE_BIT) {
+				/*
+				  BIT fields are specially handled. As they come as bit mask, we have
+				  to convert it to human-readable representation. As the bits take
+				  less space in the protocol than the numbers they represent, we don't
+				  have enough space in the packet buffer to overwrite inside.
+				  Thus, a bit more space is pre-allocated at the end of the buffer,
+				  see php_mysqlnd_rowp_read(). And we add the strings at the end.
+				  Definitely not nice, _hackish_ :(, but works.
+				*/
+				zend_uchar *start = bit_area;
+				ps_fetch_from_1_to_8_bytes(*current_field, &(fields_metadata[i]), 0, &p, as_unicode, len TSRMLS_CC);
+				/*
+				  We have advanced in ps_fetch_from_1_to_8_bytes. We should go back because
+				  later in this function there will be an advancement.
+				*/
+				p -= len;
+				if (Z_TYPE_PP(current_field) == IS_LONG) {
+					bit_area += 1 + sprintf((char *)start, "%ld", Z_LVAL_PP(current_field));
+#if MYSQLND_UNICODE
+					if (as_unicode) {
+						ZVAL_UTF8_STRINGL(*current_field, start, bit_area - start - 1, 0);
+					} else
+#endif
+					{
+						ZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, 0);
+					}
+				} else if (Z_TYPE_PP(current_field) == IS_STRING){
+					memcpy(bit_area, Z_STRVAL_PP(current_field), Z_STRLEN_PP(current_field));
+					bit_area += Z_STRLEN_PP(current_field);
+					*bit_area++ = '\0';
+					zval_dtor(*current_field);
+#if MYSQLND_UNICODE
+					if (as_unicode) {
+						ZVAL_UTF8_STRINGL(*current_field, start, bit_area - start - 1, 0);
+					} else
+#endif
+					{
+						ZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, 0);
+					}
+				}
+				/*
+				  IS_UNICODE should not be specially handled. In unicode mode
+				  the buffers are not referenced - everything is copied.
+				*/
+			} else
+#if MYSQLND_UNICODE == 0
+			{
+				ZVAL_STRINGL(*current_field, (char *)p, len, 0);
+			}
+#else
+			/*
+			  Here we have to convert to UTF16, which means not reusing the buffer.
+			  Which in turn means that we can free the buffers once we have
+			  stored the result set, if we use store_result().
+
+			  Also the destruction of the zvals should not call zval_copy_ctor()
+			  because then we will leak.
+
+			  XXX: Keep in mind that up there there is an open `else` in
+			  #ifdef MYSQLND_STRING_TO_INT_CONVERSION
+			  which will make with this `if` an `else if`.
+			*/
+			if ((perm_bind.is_possibly_blob == TRUE &&
+				 fields_metadata[i].charsetnr == MYSQLND_BINARY_CHARSET_NR) ||
+				(!as_unicode && perm_bind.can_ret_as_str_in_uni == TRUE))
+			{
+				/* BLOB - no conversion please */
+				ZVAL_STRINGL(*current_field, (char *)p, len, 0);
+			} else {
+				ZVAL_UTF8_STRINGL(*current_field, (char *)p, len, 0);
+			}
+#endif
+			p += len;
+			last_field_was_string = TRUE;
+		}
+	}
+	if (last_field_was_string) {
+		/* Normal queries: The buffer has one more byte at the end, because we need it */
+		row_buffer->ptr[data_size] = '\0';
+	}
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rowp_read */
+/*
+  if normal statements => packet->fields is created by this function,
+  if PS => packet->fields is passed from outside
+*/
+static enum_func_status
+php_mysqlnd_rowp_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	MYSQLND_NET *net = conn->net;
+	zend_uchar *p;
+	enum_func_status ret = PASS;
+	size_t old_chunk_size = net->stream->chunk_size;
+	MYSQLND_PACKET_ROW *packet= (MYSQLND_PACKET_ROW *) _packet;
+	size_t post_alloc_for_bit_fields = 0;
+	size_t data_size = 0;
+
+	DBG_ENTER("php_mysqlnd_rowp_read");
+
+	if (!packet->binary_protocol && packet->bit_fields_count) {
+		/* For every field we need terminating \0 */
+		post_alloc_for_bit_fields = packet->bit_fields_total_len + packet->bit_fields_count;
+	}
+
+	ret = php_mysqlnd_read_row_ex(conn, packet->result_set_memory_pool, &packet->row_buffer, &data_size,
+								  packet->persistent_alloc, post_alloc_for_bit_fields
+								  TSRMLS_CC);
+	if (FAIL == ret) {
+		goto end;
+	}
+	MYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, packet_type_to_statistic_byte_count[PROT_ROW_PACKET],
+										MYSQLND_HEADER_SIZE + packet->header.size,
+										packet_type_to_statistic_packet_count[PROT_ROW_PACKET],
+										1);
+
+	/* packet->row_buffer->ptr is of size 'data_size + 1' */
+	packet->header.size = data_size;
+	packet->row_buffer->app = data_size;
+
+	if (ERROR_MARKER == (*(p = packet->row_buffer->ptr))) {
+		/*
+		   Error message as part of the result set,
+		   not good but we should not hang. See:
+		   Bug #27876 : SF with cyrillic variable name fails during execution
+		*/
+		ret = FAIL;
+		php_mysqlnd_read_error_from_line(p + 1, data_size - 1,
+										 packet->error_info.error,
+										 sizeof(packet->error_info.error),
+										 &packet->error_info.error_no,
+										 packet->error_info.sqlstate
+										 TSRMLS_CC);
+	} else if (EODATA_MARKER == *p && data_size < 8) { /* EOF */
+		packet->eof = TRUE;
+		p++;
+		if (data_size > 1) {
+			packet->warning_count = uint2korr(p);
+			p += 2;
+			packet->server_status = uint2korr(p);
+			/* Seems we have 3 bytes reserved for future use */
+			DBG_INF_FMT("server_status=%u warning_count=%u", packet->server_status, packet->warning_count);
+		}
+	} else {
+		MYSQLND_INC_CONN_STATISTIC(conn->stats,
+									packet->binary_protocol? STAT_ROWS_FETCHED_FROM_SERVER_PS:
+															 STAT_ROWS_FETCHED_FROM_SERVER_NORMAL);
+
+		packet->eof = FALSE;
+		/* packet->field_count is set by the user of the packet */
+
+		if (!packet->skip_extraction) {
+			if (!packet->fields) {
+				DBG_INF("Allocating packet->fields");
+				/*
+				  old-API will probably set packet->fields to NULL every time, though for
+				  unbuffered sets it makes not much sense as the zvals in this buffer matter,
+				  not the buffer. Constantly allocating and deallocating brings nothing.
+
+				  For PS - if stmt_store() is performed, thus we don't have a cursor, it will
+				  behave just like old-API buffered. Cursors will behave like a bit different,
+				  but mostly like old-API unbuffered and thus will populate this array with
+				  value.
+				*/
+				packet->fields = (zval **) mnd_pecalloc(packet->field_count, sizeof(zval *),
+														packet->persistent_alloc);
+			}
+		} else {
+			MYSQLND_INC_CONN_STATISTIC(conn->stats,
+										packet->binary_protocol? STAT_ROWS_SKIPPED_PS:
+																 STAT_ROWS_SKIPPED_NORMAL);
+		}
+	}
+
+end:
+	net->stream->chunk_size = old_chunk_size;
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_rowp_free_mem */
+static void
+php_mysqlnd_rowp_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_ROW *p;
+
+	DBG_ENTER("php_mysqlnd_rowp_free_mem");
+	p = (MYSQLND_PACKET_ROW *) _packet;
+	if (p->row_buffer) {
+		p->row_buffer->free_chunk(p->row_buffer TSRMLS_CC);
+		p->row_buffer = NULL;
+	}
+	DBG_INF_FMT("stack_allocation=%u persistent=%u", (int)stack_allocation, (int)p->header.persistent);
+	/*
+	  Don't free packet->fields :
+	  - normal queries -> store_result() | fetch_row_unbuffered() will transfer
+	    the ownership and NULL it.
+	  - PS will pass in it the bound variables, we have to use them! and of course
+	    not free the array. As it is passed to us, we should not clean it ourselves.
+	*/
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_stats_read */
+static enum_func_status
+php_mysqlnd_stats_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	MYSQLND_PACKET_STATS *packet= (MYSQLND_PACKET_STATS *) _packet;
+	size_t buf_len = conn->net->cmd_buffer.length;
+	zend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;
+
+	DBG_ENTER("php_mysqlnd_stats_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "statistics", PROT_STATS_PACKET);
+
+	packet->message = mnd_emalloc(packet->header.size + 1);
+	memcpy(packet->message, buf, packet->header.size);
+	packet->message[packet->header.size] = '\0';
+	packet->message_len = packet->header.size;
+
+	DBG_RETURN(PASS);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_stats_free_mem */
+static
+void php_mysqlnd_stats_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_STATS *p= (MYSQLND_PACKET_STATS *) _packet;
+	if (p->message) {
+		mnd_efree(p->message);
+		p->message = NULL;
+	}
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* 1 + 4 (id) + 2 (field_c) + 2 (param_c) + 1 (filler) + 2 (warnings ) */
+#define PREPARE_RESPONSE_SIZE_41 9
+#define PREPARE_RESPONSE_SIZE_50 12
+
+/* {{{ php_mysqlnd_prepare_read */
+static enum_func_status
+php_mysqlnd_prepare_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	/* In case of an error, we should have place to put it */
+	size_t buf_len = conn->net->cmd_buffer.length;
+	zend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+	unsigned int data_size;
+	MYSQLND_PACKET_PREPARE_RESPONSE *packet= (MYSQLND_PACKET_PREPARE_RESPONSE *) _packet;
+
+	DBG_ENTER("php_mysqlnd_prepare_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "prepare", PROT_PREPARE_RESP_PACKET);
+	BAIL_IF_NO_MORE_DATA;
+
+	data_size = packet->header.size;
+	packet->error_code = uint1korr(p);
+	p++;
+	BAIL_IF_NO_MORE_DATA;
+
+	if (ERROR_MARKER == packet->error_code) {
+		php_mysqlnd_read_error_from_line(p, data_size - 1,
+										 packet->error_info.error,
+										 sizeof(packet->error_info.error),
+										 &packet->error_info.error_no,
+										 packet->error_info.sqlstate
+										 TSRMLS_CC);
+		DBG_RETURN(PASS);
+	}
+
+	if (data_size != PREPARE_RESPONSE_SIZE_41 &&
+		data_size != PREPARE_RESPONSE_SIZE_50 &&
+		!(data_size > PREPARE_RESPONSE_SIZE_50)) {
+		DBG_ERR_FMT("Wrong COM_STMT_PREPARE response size. Received %u", data_size);
+		php_error(E_WARNING, "Wrong COM_STMT_PREPARE response size. Received %u", data_size);
+		DBG_RETURN(FAIL);
+	}
+
+	packet->stmt_id = uint4korr(p);
+	p += 4;
+	BAIL_IF_NO_MORE_DATA;
+
+	/* Number of columns in result set */
+	packet->field_count = uint2korr(p);
+	p += 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	packet->param_count = uint2korr(p);
+	p += 2;
+	BAIL_IF_NO_MORE_DATA;
+
+	if (data_size > 9) {
+		/* 0x0 filler sent by the server for 5.0+ clients */
+		p++;
+		BAIL_IF_NO_MORE_DATA;
+
+		packet->warning_count = uint2korr(p);
+	}
+
+	DBG_INF_FMT("Prepare packet read: stmt_id=%u fields=%u params=%u",
+				packet->stmt_id, packet->field_count, packet->param_count);
+
+	BAIL_IF_NO_MORE_DATA;
+
+	DBG_RETURN(PASS);
+premature_end:
+	DBG_ERR_FMT("PREPARE packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "PREPARE packet "MYSQLND_SZ_T_SPEC" bytes shorter than expected",
+					 p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_prepare_free_mem */
+static void
+php_mysqlnd_prepare_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	MYSQLND_PACKET_PREPARE_RESPONSE *p= (MYSQLND_PACKET_PREPARE_RESPONSE *) _packet;
+	if (!stack_allocation) {
+		mnd_pefree(p, p->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_chg_user_read */
+static enum_func_status
+php_mysqlnd_chg_user_read(void *_packet, MYSQLND *conn TSRMLS_DC)
+{
+	/* There could be an error message */
+	size_t buf_len = conn->net->cmd_buffer.length;
+	zend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;
+	zend_uchar *p = buf;
+	zend_uchar *begin = buf;
+	MYSQLND_PACKET_CHG_USER_RESPONSE *packet= (MYSQLND_PACKET_CHG_USER_RESPONSE *) _packet;
+
+	DBG_ENTER("php_mysqlnd_chg_user_read");
+
+	PACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, "change user response", PROT_CHG_USER_RESP_PACKET);
+	BAIL_IF_NO_MORE_DATA;
+
+	/*
+	  Don't increment. First byte is ERROR_MARKER on error, but otherwise is starting byte
+	  of encoded sequence for length.
+	*/
+
+	/* Should be always 0x0 or ERROR_MARKER for error */
+	packet->field_count= uint1korr(p);
+	p++;
+
+	if (packet->header.size == 1 && buf[0] == EODATA_MARKER && packet->server_capabilities & CLIENT_SECURE_CONNECTION) {
+		/* We don't handle 3.23 authentication */
+		packet->server_asked_323_auth = TRUE;
+		DBG_RETURN(FAIL);
+	}
+
+	if (ERROR_MARKER == packet->field_count) {
+		php_mysqlnd_read_error_from_line(p, packet->header.size - 1,
+										 packet->error_info.error,
+										 sizeof(packet->error_info.error),
+										 &packet->error_info.error_no,
+										 packet->error_info.sqlstate
+										 TSRMLS_CC);
+	}
+	BAIL_IF_NO_MORE_DATA;
+
+	DBG_RETURN(PASS);
+premature_end:
+	DBG_ERR_FMT("CHANGE_USER packet %d bytes shorter than expected", p - begin - packet->header.size);
+	php_error_docref(NULL TSRMLS_CC, E_WARNING, "CHANGE_USER packet "MYSQLND_SZ_T_SPEC" bytes shorter than expected",
+						 p - begin - packet->header.size);
+	DBG_RETURN(FAIL);
+}
+/* }}} */
+
+
+/* {{{ php_mysqlnd_chg_user_free_mem */
+static void
+php_mysqlnd_chg_user_free_mem(void *_packet, zend_bool stack_allocation TSRMLS_DC)
+{
+	if (!stack_allocation) {
+		mnd_pefree(_packet, ((MYSQLND_PACKET_CHG_USER_RESPONSE *)_packet)->header.persistent);
+	}
+}
+/* }}} */
+
+
+/* {{{ packet_methods */
+static
+mysqlnd_packet_methods packet_methods[PROT_LAST] =
+{
+	{
+		sizeof(MYSQLND_PACKET_GREET),
+		php_mysqlnd_greet_read,
+		NULL, /* write */
+		php_mysqlnd_greet_free_mem,
+	}, /* PROT_GREET_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_AUTH),
+		NULL, /* read */
+		php_mysqlnd_auth_write,
+		php_mysqlnd_auth_free_mem,
+	}, /* PROT_AUTH_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_OK),
+		php_mysqlnd_ok_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_ok_free_mem,
+	}, /* PROT_OK_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_EOF),
+		php_mysqlnd_eof_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_eof_free_mem,
+	}, /* PROT_EOF_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_COMMAND),
+		NULL, /* read */
+		php_mysqlnd_cmd_write, /* write */
+		php_mysqlnd_cmd_free_mem,
+	}, /* PROT_CMD_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_RSET_HEADER),
+		php_mysqlnd_rset_header_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_rset_header_free_mem,
+	}, /* PROT_RSET_HEADER_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_RES_FIELD),
+		php_mysqlnd_rset_field_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_rset_field_free_mem,
+	}, /* PROT_RSET_FLD_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_ROW),
+		php_mysqlnd_rowp_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_rowp_free_mem,
+	}, /* PROT_ROW_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_STATS),
+		php_mysqlnd_stats_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_stats_free_mem,
+	}, /* PROT_STATS_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_PREPARE_RESPONSE),
+		php_mysqlnd_prepare_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_prepare_free_mem,
+	}, /* PROT_PREPARE_RESP_PACKET */
+	{
+		sizeof(MYSQLND_PACKET_CHG_USER_RESPONSE),
+		php_mysqlnd_chg_user_read, /* read */
+		NULL, /* write */
+		php_mysqlnd_chg_user_free_mem,
+	} /* PROT_CHG_USER_RESP_PACKET */
+};
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_greet_packet */
+static struct st_mysqlnd_packet_greet *
+MYSQLND_METHOD(mysqlnd_protocol, get_greet_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_greet * packet = mnd_pecalloc(1, packet_methods[PROT_GREET_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_greet_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_GREET_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_auth_packet */
+static struct st_mysqlnd_packet_auth *
+MYSQLND_METHOD(mysqlnd_protocol, get_auth_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_auth * packet = mnd_pecalloc(1, packet_methods[PROT_AUTH_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_auth_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_AUTH_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_ok_packet */
+static struct st_mysqlnd_packet_ok *
+MYSQLND_METHOD(mysqlnd_protocol, get_ok_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_ok * packet = mnd_pecalloc(1, packet_methods[PROT_OK_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_ok_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_OK_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_eof_packet */
+static struct st_mysqlnd_packet_eof *
+MYSQLND_METHOD(mysqlnd_protocol, get_eof_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_eof * packet = mnd_pecalloc(1, packet_methods[PROT_EOF_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_eof_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_EOF_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_command_packet */
+static struct st_mysqlnd_packet_command *
+MYSQLND_METHOD(mysqlnd_protocol, get_command_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_command * packet = mnd_pecalloc(1, packet_methods[PROT_CMD_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_command_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_CMD_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_rset_packet */
+static struct st_mysqlnd_packet_rset_header *
+MYSQLND_METHOD(mysqlnd_protocol, get_rset_header_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_rset_header * packet = mnd_pecalloc(1, packet_methods[PROT_RSET_HEADER_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_rset_header_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_RSET_HEADER_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_result_field_packet */
+static struct st_mysqlnd_packet_res_field *
+MYSQLND_METHOD(mysqlnd_protocol, get_result_field_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_res_field * packet = mnd_pecalloc(1, packet_methods[PROT_RSET_FLD_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_result_field_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_RSET_FLD_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_row_packet */
+static struct st_mysqlnd_packet_row *
+MYSQLND_METHOD(mysqlnd_protocol, get_row_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_row * packet = mnd_pecalloc(1, packet_methods[PROT_ROW_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_row_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_ROW_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_stats_packet */
+static struct st_mysqlnd_packet_stats *
+MYSQLND_METHOD(mysqlnd_protocol, get_stats_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_stats * packet = mnd_pecalloc(1, packet_methods[PROT_STATS_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_stats_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_STATS_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_prepare_response_packet */
+static struct st_mysqlnd_packet_prepare_response *
+MYSQLND_METHOD(mysqlnd_protocol, get_prepare_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_prepare_response * packet = mnd_pecalloc(1, packet_methods[PROT_PREPARE_RESP_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_prepare_response_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_PREPARE_RESP_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol::get_change_user_response_packet */
+static struct st_mysqlnd_packet_chg_user_resp*
+MYSQLND_METHOD(mysqlnd_protocol, get_change_user_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)
+{
+	struct st_mysqlnd_packet_chg_user_resp * packet = mnd_pecalloc(1, packet_methods[PROT_CHG_USER_RESP_PACKET].struct_size, persistent);
+	DBG_ENTER("mysqlnd_protocol::get_change_user_response_packet");
+	if (packet) {
+		packet->header.m = &packet_methods[PROT_CHG_USER_RESP_PACKET];
+		packet->header.persistent = persistent;
+	}
+	DBG_RETURN(packet);
+}
+/* }}} */
+
+
+static
+MYSQLND_CLASS_METHODS_START(mysqlnd_protocol)
+	MYSQLND_METHOD(mysqlnd_protocol, get_greet_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_auth_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_ok_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_command_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_eof_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_rset_header_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_result_field_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_row_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_stats_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_prepare_response_packet),
+	MYSQLND_METHOD(mysqlnd_protocol, get_change_user_response_packet)
+MYSQLND_CLASS_METHODS_END;
+
+
+/* {{{ mysqlnd_protocol_init */
+PHPAPI MYSQLND_PROTOCOL *
+mysqlnd_protocol_init(zend_bool persistent TSRMLS_DC)
+{
+	size_t alloc_size = sizeof(MYSQLND_PROTOCOL) + mysqlnd_plugin_count() * sizeof(void *);
+	MYSQLND_PROTOCOL *ret = mnd_pecalloc(1, alloc_size, persistent);
+
+	DBG_ENTER("mysqlnd_protocol_init");
+	DBG_INF_FMT("persistent=%u", persistent);
+	if (ret) {
+		ret->persistent = persistent;
+		ret->m = mysqlnd_mysqlnd_protocol_methods;
+	}
+
+	DBG_RETURN(ret);
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol_free */
+PHPAPI void
+mysqlnd_protocol_free(MYSQLND_PROTOCOL * const protocol TSRMLS_DC)
+{
+	DBG_ENTER("mysqlnd_protocol_free");
+
+	if (protocol) {
+		zend_bool pers = protocol->persistent;
+		mnd_pefree(protocol, pers);
+	}
+	DBG_VOID_RETURN;
+}
+/* }}} */
+
+
+/* {{{ _mysqlnd_plugin_get_plugin_protocol_data */
+PHPAPI void **
+_mysqlnd_plugin_get_plugin_protocol_data(const MYSQLND_PROTOCOL * protocol, unsigned int plugin_id TSRMLS_DC)
+{
+	DBG_ENTER("_mysqlnd_plugin_get_plugin_protocol_data");
+	DBG_INF_FMT("plugin_id=%u", plugin_id);
+	if (!protocol || plugin_id >= mysqlnd_plugin_count()) {
+		return NULL;
+	}
+	DBG_RETURN((void *)((char *)protocol + sizeof(MYSQLND_PROTOCOL) + plugin_id * sizeof(void *)));
+}
+/* }}} */
+
+
+/* {{{ mysqlnd_protocol_get_methods */
+PHPAPI struct st_mysqlnd_protocol_methods *
+mysqlnd_protocol_get_methods()
+{
+	return &mysqlnd_mysqlnd_protocol_methods;
+}
+/* }}} */
+
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/mysqlnd_wireprotocol.h
@@ -0,0 +1,287 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#ifndef MYSQLND_WIREPROTOCOL_H
+#define MYSQLND_WIREPROTOCOL_H
+
+#include "mysqlnd_net.h"
+
+#define MYSQLND_HEADER_SIZE 4
+#define COMPRESSED_HEADER_SIZE 3
+
+#define MYSQLND_NULL_LENGTH	(unsigned long) ~0
+
+/* Used in mysqlnd_debug.c */
+PHPAPI extern const char mysqlnd_read_header_name[];
+PHPAPI extern const char mysqlnd_read_body_name[];
+
+
+/* Packet handling */
+#define PACKET_WRITE(packet, conn)	((packet)->header.m->write_to_net((packet), (conn) TSRMLS_CC))
+#define PACKET_READ(packet, conn)	((packet)->header.m->read_from_net((packet), (conn) TSRMLS_CC))
+#define PACKET_FREE(packet) \
+	do { \
+		DBG_INF_FMT("PACKET_FREE(%p)", packet); \
+		if ((packet)) { \
+			((packet)->header.m->free_mem((packet), FALSE TSRMLS_CC)); \
+		} \
+	} while (0);
+
+PHPAPI extern const char * const mysqlnd_command_to_text[COM_END];
+
+/* Low-level extraction functionality */
+typedef struct st_mysqlnd_packet_methods {
+	size_t				struct_size;
+	enum_func_status	(*read_from_net)(void *packet, MYSQLND *conn TSRMLS_DC);
+	size_t				(*write_to_net)(void *packet, MYSQLND *conn TSRMLS_DC);
+	void				(*free_mem)(void *packet, zend_bool stack_allocation TSRMLS_DC);
+} mysqlnd_packet_methods;
+
+
+typedef struct st_mysqlnd_packet_header {
+	size_t		size;
+	mysqlnd_packet_methods *m;
+	zend_uchar	packet_no;
+	zend_bool	persistent;
+} MYSQLND_PACKET_HEADER;
+
+/* Server greets the client */
+typedef struct st_mysqlnd_packet_greet {
+	MYSQLND_PACKET_HEADER		header;
+	uint8_t		protocol_version;
+	char		*server_version;
+	uint32_t	thread_id;
+	zend_uchar	scramble_buf[SCRAMBLE_LENGTH];
+	/* 1 byte pad */
+	uint16_t	server_capabilities;
+	uint8_t		charset_no;
+	uint16_t	server_status;
+	/* 13 byte pad*/
+	zend_bool	pre41;
+	/* If error packet, we use these */
+	char 		error[MYSQLND_ERRMSG_SIZE+1];
+	char 		sqlstate[MYSQLND_SQLSTATE_LENGTH + 1];
+	unsigned int 	error_no;
+} MYSQLND_PACKET_GREET;
+
+
+/* Client authenticates */
+typedef struct st_mysqlnd_packet_auth {
+	MYSQLND_PACKET_HEADER		header;
+	uint32_t	client_flags;
+	uint32_t	max_packet_size;
+	uint8_t	charset_no;
+	/* 23 byte pad */
+	const char	*user;
+	/* 8 byte scramble */
+	const char	*db;
+	/* 12 byte scramble */
+
+	/* Here the packet ends. This is user supplied data */
+	const char	*password;
+	/* +1 for \0 because of scramble() */
+	unsigned char	*server_scramble_buf;
+	size_t			db_len;
+	zend_bool		send_half_packet;
+} MYSQLND_PACKET_AUTH;
+
+/* OK packet */
+typedef struct st_mysqlnd_packet_ok {
+	MYSQLND_PACKET_HEADER		header;
+	uint8_t		field_count; /* always 0x0 */
+	uint64_t	affected_rows;
+	uint64_t	last_insert_id;
+	uint16_t	server_status;
+	uint16_t	warning_count;
+	char		*message;
+	size_t		message_len;
+	/* If error packet, we use these */
+	char 		error[MYSQLND_ERRMSG_SIZE+1];
+	char 		sqlstate[MYSQLND_SQLSTATE_LENGTH + 1];
+	unsigned int 	error_no;
+} MYSQLND_PACKET_OK;
+
+
+/* Command packet */
+typedef struct st_mysqlnd_packet_command {
+	MYSQLND_PACKET_HEADER			header;
+	enum php_mysqlnd_server_command	command;
+	const char						*argument;
+	size_t							arg_len;
+} MYSQLND_PACKET_COMMAND;
+
+
+/* EOF packet */
+typedef struct st_mysqlnd_packet_eof {
+	MYSQLND_PACKET_HEADER		header;
+	uint8_t		field_count; /* 0xFE */
+	uint16_t	warning_count;
+	uint16_t	server_status;
+	/* If error packet, we use these */
+	char 		error[MYSQLND_ERRMSG_SIZE+1];
+	char 		sqlstate[MYSQLND_SQLSTATE_LENGTH + 1];
+	unsigned int 	error_no;
+} MYSQLND_PACKET_EOF;
+/* EOF packet */
+
+
+/* Result Set header*/
+typedef struct st_mysqlnd_packet_rset_header {
+	MYSQLND_PACKET_HEADER		header;
+	/*
+	  0x00 => ok
+	  ~0   => LOAD DATA LOCAL
+	  error_no != 0 => error
+	  others => result set -> Read res_field packets up to field_count
+	*/
+	unsigned long		field_count;
+	/*
+	  These are filled if no SELECT query. For SELECT warning_count
+	  and server status are in the last row packet, the EOF packet.
+	*/
+	uint16_t	warning_count;
+	uint16_t	server_status;
+	uint64_t	affected_rows;
+	uint64_t	last_insert_id;
+	/* This is for both LOAD DATA or info, when no result set */
+	char		*info_or_local_file;
+	size_t		info_or_local_file_len;
+	/* If error packet, we use these */
+	MYSQLND_ERROR_INFO	error_info;
+} MYSQLND_PACKET_RSET_HEADER;
+
+
+/* Result set field packet */
+typedef struct st_mysqlnd_packet_res_field {
+	MYSQLND_PACKET_HEADER	header;
+	MYSQLND_FIELD			*metadata;
+	/* For table definitions, empty for result sets */
+	zend_bool				skip_parsing;
+	zend_bool				stupid_list_fields_eof;
+	zend_bool				persistent_alloc;
+
+	MYSQLND_ERROR_INFO		error_info;
+} MYSQLND_PACKET_RES_FIELD;
+
+
+/* Row packet */
+typedef struct st_mysqlnd_packet_row {
+	MYSQLND_PACKET_HEADER	header;
+	zval		**fields;
+	uint32_t	field_count;
+	zend_bool	eof;
+	/*
+	  These are, of course, only for SELECT in the EOF packet,
+	  which is detected by this packet
+	*/
+	uint16_t	warning_count;
+	uint16_t	server_status;
+
+	struct st_mysqlnd_memory_pool_chunk	*row_buffer;
+	MYSQLND_MEMORY_POOL * result_set_memory_pool;
+
+	zend_bool		skip_extraction;
+	zend_bool		binary_protocol;
+	zend_bool		persistent_alloc;
+	MYSQLND_FIELD	*fields_metadata;
+	/* We need this to alloc bigger bufs in non-PS mode */
+	unsigned int	bit_fields_count;
+	size_t			bit_fields_total_len; /* trailing \0 not counted */
+
+	/* If error packet, we use these */
+	MYSQLND_ERROR_INFO	error_info;
+} MYSQLND_PACKET_ROW;
+
+
+/* Statistics packet */
+typedef struct st_mysqlnd_packet_stats {
+	MYSQLND_PACKET_HEADER	header;
+	char *message;
+	/* message_len is not part of the packet*/
+	size_t message_len;
+} MYSQLND_PACKET_STATS;
+
+
+/* COM_PREPARE response packet */
+typedef struct st_mysqlnd_packet_prepare_response {
+	MYSQLND_PACKET_HEADER	header;
+	/* also known as field_count 0x00=OK , 0xFF=error */
+	unsigned char	error_code;
+	unsigned long	stmt_id;
+	unsigned int	field_count;
+	unsigned int	param_count;
+	unsigned int	warning_count;
+
+	/* present in case of error */
+	MYSQLND_ERROR_INFO	error_info;
+} MYSQLND_PACKET_PREPARE_RESPONSE;
+
+
+/* Statistics packet */
+typedef struct st_mysqlnd_packet_chg_user_resp {
+	MYSQLND_PACKET_HEADER	header;
+	uint32_t			field_count;
+
+	/* message_len is not part of the packet*/
+	uint16_t			server_capabilities;
+	/* If error packet, we use these */
+	MYSQLND_ERROR_INFO	error_info;
+	zend_bool			server_asked_323_auth;
+} MYSQLND_PACKET_CHG_USER_RESPONSE;
+
+
+PHPAPI void php_mysqlnd_scramble(zend_uchar * const buffer, const zend_uchar * const scramble, const zend_uchar * const pass);
+
+unsigned long	php_mysqlnd_net_field_length(zend_uchar **packet);
+zend_uchar *	php_mysqlnd_net_store_length(zend_uchar *packet, uint64_t length);
+
+PHPAPI const extern char * const mysqlnd_empty_string;
+
+
+enum_func_status php_mysqlnd_rowp_read_binary_protocol(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,
+										 unsigned int field_count, MYSQLND_FIELD *fields_metadata,
+										 zend_bool persistent,
+										 zend_bool as_unicode, zend_bool as_int_or_float,
+										 MYSQLND_STATS * stats TSRMLS_DC);
+
+
+enum_func_status php_mysqlnd_rowp_read_text_protocol(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,
+										 unsigned int field_count, MYSQLND_FIELD *fields_metadata,
+										 zend_bool persistent,
+										 zend_bool as_unicode, zend_bool as_int_or_float,
+										 MYSQLND_STATS * stats TSRMLS_DC);
+
+
+PHPAPI MYSQLND_PROTOCOL * mysqlnd_protocol_init(zend_bool persistent TSRMLS_DC);
+PHPAPI void mysqlnd_protocol_free(MYSQLND_PROTOCOL * const protocol TSRMLS_DC);
+PHPAPI struct st_mysqlnd_protocol_methods * mysqlnd_protocol_get_methods();
+
+#endif /* MYSQLND_WIREPROTOCOL_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/php_mysqlnd.c
@@ -0,0 +1,315 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@mysql.com>                             |
+  |          Andrey Hristov <andrey@mysql.com>                           |
+  |          Ulf Wendel <uwendel@mysql.com>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+#include "php.h"
+#include "php_ini.h"
+#include "mysqlnd.h"
+#include "mysqlnd_priv.h"
+#include "mysqlnd_debug.h"
+#include "ext/standard/info.h"
+
+/* {{{ mysqlnd_functions[]
+ *
+ * Every user visible function must have an entry in mysqlnd_functions[].
+ */
+static zend_function_entry mysqlnd_functions[] = {
+	{NULL, NULL, NULL}
+};
+/* }}} */
+
+
+/* {{{ mysqlnd_minfo_print_hash */
+#if MYSQLND_UNICODE
+PHPAPI void mysqlnd_minfo_print_hash(zval *values)
+{
+	zval **values_entry;
+	HashPosition pos_values;
+
+	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(values), &pos_values);
+	while (zend_hash_get_current_data_ex(Z_ARRVAL_P(values),
+		(void **)&values_entry, &pos_values) == SUCCESS) {
+		zstr	string_key;
+		uint	string_key_len;
+		ulong	num_key;
+		int		s_len;
+		char	*s = NULL;
+
+		TSRMLS_FETCH();
+		zend_hash_get_current_key_ex(Z_ARRVAL_P(values), &string_key, &string_key_len, &num_key, 0, &pos_values);
+
+		convert_to_string(*values_entry);
+
+		if (zend_unicode_to_string(ZEND_U_CONVERTER(UG(runtime_encoding_conv)),
+								   &s, &s_len, string_key.u, string_key_len TSRMLS_CC) == SUCCESS) {
+			php_info_print_table_row(2, s, Z_STRVAL_PP(values_entry));
+		}
+		if (s) {
+			mnd_efree(s);
+		}
+
+		zend_hash_move_forward_ex(Z_ARRVAL_P(values), &pos_values);
+	}
+}
+#else
+PHPAPI void mysqlnd_minfo_print_hash(zval *values)
+{
+	zval **values_entry;
+	HashPosition pos_values;
+
+	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(values), &pos_values);
+	while (zend_hash_get_current_data_ex(Z_ARRVAL_P(values), (void **)&values_entry, &pos_values) == SUCCESS) {
+		char	*string_key;
+		uint	string_key_len;
+		ulong	num_key;
+
+		zend_hash_get_current_key_ex(Z_ARRVAL_P(values), &string_key, &string_key_len, &num_key, 0, &pos_values);
+
+		convert_to_string(*values_entry);
+		php_info_print_table_row(2, string_key, Z_STRVAL_PP(values_entry));
+
+		zend_hash_move_forward_ex(Z_ARRVAL_P(values), &pos_values);
+	}
+}
+#endif
+/* }}} */
+
+
+/* {{{ PHP_MINFO_FUNCTION
+ */
+PHP_MINFO_FUNCTION(mysqlnd)
+{
+	char buf[32];
+	zval values;
+
+	php_info_print_table_start();
+	php_info_print_table_header(2, "mysqlnd", "enabled");
+	php_info_print_table_row(2, "Version", mysqlnd_get_client_info());
+	php_info_print_table_row(2, "Compression",
+#ifdef MYSQLND_COMPRESSION_ENABLED
+								"supported");
+#else
+								"not supported");
+#endif
+	php_info_print_table_row(2, "SSL",
+#ifdef MYSQLND_SSL_SUPPORTED
+								"supported");
+#else
+								"not supported");
+#endif
+	snprintf(buf, sizeof(buf), "%ld", MYSQLND_G(net_cmd_buffer_size));
+	php_info_print_table_row(2, "Command buffer size", buf);
+	snprintf(buf, sizeof(buf), "%ld", MYSQLND_G(net_read_buffer_size));
+	php_info_print_table_row(2, "Read buffer size", buf);
+	snprintf(buf, sizeof(buf), "%ld", MYSQLND_G(net_read_timeout));
+	php_info_print_table_row(2, "Read timeout", buf);
+	php_info_print_table_row(2, "Collecting statistics", MYSQLND_G(collect_statistics)? "Yes":"No");
+	php_info_print_table_row(2, "Collecting memory statistics", MYSQLND_G(collect_memory_statistics)? "Yes":"No");
+
+	php_info_print_table_row(2, "Tracing", MYSQLND_G(debug)? MYSQLND_G(debug):"n/a");
+	php_info_print_table_end();
+
+	/* Print client stats */
+	php_info_print_table_start();
+	php_info_print_table_header(2, "Client statistics", "");
+	mysqlnd_get_client_stats(&values);
+	mysqlnd_minfo_print_hash(&values);
+
+	zval_dtor(&values);
+	php_info_print_table_end();
+}
+/* }}} */
+
+
+PHPAPI ZEND_DECLARE_MODULE_GLOBALS(mysqlnd)
+
+
+/* {{{ PHP_GINIT_FUNCTION
+ */
+static PHP_GINIT_FUNCTION(mysqlnd)
+{
+	mysqlnd_globals->collect_statistics = TRUE;
+	mysqlnd_globals->collect_memory_statistics = FALSE;
+	mysqlnd_globals->debug = NULL;	/* The actual string */
+	mysqlnd_globals->dbg = NULL;	/* The DBG object*/
+	mysqlnd_globals->net_cmd_buffer_size = MYSQLND_NET_CMD_BUFFER_MIN_SIZE;
+	mysqlnd_globals->net_read_buffer_size = 32768;
+	mysqlnd_globals->net_read_timeout = 31536000;
+	mysqlnd_globals->log_mask = 0;
+	mysqlnd_globals->mempool_default_size = 16000;
+	mysqlnd_globals->debug_emalloc_fail_threshold = -1;
+	mysqlnd_globals->debug_ecalloc_fail_threshold = -1;
+	mysqlnd_globals->debug_erealloc_fail_threshold = -1;
+	mysqlnd_globals->debug_malloc_fail_threshold = -1;
+	mysqlnd_globals->debug_calloc_fail_threshold = -1;
+	mysqlnd_globals->debug_realloc_fail_threshold = -1;
+}
+/* }}} */
+
+
+static PHP_INI_MH(OnUpdateNetCmdBufferSize)
+{
+	long long_value = atol(new_value);
+	if (long_value < MYSQLND_NET_CMD_BUFFER_MIN_SIZE) {
+		return FAILURE;
+	}
+	MYSQLND_G(net_cmd_buffer_size) = long_value;
+
+	return SUCCESS;
+}
+
+/* {{{ PHP_INI_BEGIN
+*/
+PHP_INI_BEGIN()
+	STD_PHP_INI_BOOLEAN("mysqlnd.collect_statistics",	"1", 	PHP_INI_ALL, OnUpdateBool,	collect_statistics, zend_mysqlnd_globals, mysqlnd_globals)
+	STD_PHP_INI_BOOLEAN("mysqlnd.collect_memory_statistics",	"0", 	PHP_INI_SYSTEM, OnUpdateBool,	collect_memory_statistics, zend_mysqlnd_globals, mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.debug",					NULL, 	PHP_INI_SYSTEM, OnUpdateString,	debug, zend_mysqlnd_globals, mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.net_cmd_buffer_size",	MYSQLND_NET_CMD_BUFFER_MIN_SIZE_STR,	PHP_INI_ALL,	OnUpdateNetCmdBufferSize,	net_cmd_buffer_size,	zend_mysqlnd_globals,		mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.net_read_buffer_size",	"32768",PHP_INI_ALL,	OnUpdateLong,	net_read_buffer_size,	zend_mysqlnd_globals,		mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.net_read_timeout",	"31536000",	PHP_INI_SYSTEM, OnUpdateLong,	net_read_timeout, zend_mysqlnd_globals, mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.log_mask",				"0", 	PHP_INI_ALL,	OnUpdateLong,	log_mask, zend_mysqlnd_globals, mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.mempool_default_size","16000",   PHP_INI_ALL,	OnUpdateLong,	mempool_default_size,	zend_mysqlnd_globals,		mysqlnd_globals)
+
+#ifdef PHP_DEBUG
+	STD_PHP_INI_ENTRY("mysqlnd.debug_emalloc_fail_threshold","-1",   PHP_INI_SYSTEM,	OnUpdateLong,	debug_emalloc_fail_threshold,	zend_mysqlnd_globals,		mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.debug_ecalloc_fail_threshold","-1",   PHP_INI_SYSTEM,	OnUpdateLong,	debug_ecalloc_fail_threshold,	zend_mysqlnd_globals,		mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.debug_erealloc_fail_threshold","-1",   PHP_INI_SYSTEM,	OnUpdateLong,	debug_erealloc_fail_threshold,	zend_mysqlnd_globals,		mysqlnd_globals)
+
+	STD_PHP_INI_ENTRY("mysqlnd.debug_malloc_fail_threshold","-1",   PHP_INI_SYSTEM,	OnUpdateLong,	debug_malloc_fail_threshold,	zend_mysqlnd_globals,		mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.debug_calloc_fail_threshold","-1",   PHP_INI_SYSTEM,	OnUpdateLong,	debug_calloc_fail_threshold,	zend_mysqlnd_globals,		mysqlnd_globals)
+	STD_PHP_INI_ENTRY("mysqlnd.debug_realloc_fail_threshold","-1",   PHP_INI_SYSTEM,	OnUpdateLong,	debug_realloc_fail_threshold,	zend_mysqlnd_globals,		mysqlnd_globals)
+#endif
+PHP_INI_END()
+/* }}} */
+
+
+/* {{{ PHP_MINIT_FUNCTION
+ */
+static PHP_MINIT_FUNCTION(mysqlnd)
+{
+	REGISTER_INI_ENTRIES();
+
+	mysqlnd_library_init(TSRMLS_C);
+	return SUCCESS;
+}
+/* }}} */
+
+
+/* {{{ PHP_MSHUTDOWN_FUNCTION
+ */
+static PHP_MSHUTDOWN_FUNCTION(mysqlnd)
+{
+	mysqlnd_library_end(TSRMLS_C);
+
+	UNREGISTER_INI_ENTRIES();
+	return SUCCESS;
+}
+/* }}} */
+
+
+#if defined(PHP_DEBUG)
+/* {{{ PHP_RINIT_FUNCTION
+ */
+static PHP_RINIT_FUNCTION(mysqlnd)
+{
+#if defined(PHP_DEBUG)
+	if (MYSQLND_G(debug)) {
+		MYSQLND_DEBUG *dbg = mysqlnd_debug_init(mysqlnd_debug_std_no_trace_funcs TSRMLS_CC);
+		if (!dbg) {
+			return FAILURE;
+		}
+		dbg->m->set_mode(dbg, MYSQLND_G(debug));
+		MYSQLND_G(dbg) = dbg;
+	}
+#endif
+	return SUCCESS;
+}
+/* }}} */
+#endif
+
+
+#if defined(PHP_DEBUG)
+/* {{{ PHP_RSHUTDOWN_FUNCTION
+ */
+static PHP_RSHUTDOWN_FUNCTION(mysqlnd)
+{
+	MYSQLND_DEBUG *dbg = MYSQLND_G(dbg);
+	DBG_ENTER("RSHUTDOWN");
+	if (dbg) {
+		dbg->m->close(dbg);
+		dbg->m->free_handle(dbg);
+		MYSQLND_G(dbg) = NULL;
+	}
+	return SUCCESS;
+}
+/* }}} */
+#endif
+
+
+
+static const zend_module_dep mysqlnd_deps[] = {
+	ZEND_MOD_REQUIRED("standard")
+	{NULL, NULL, NULL}
+};
+
+/* {{{ mysqlnd_module_entry
+ */
+zend_module_entry mysqlnd_module_entry = {
+	STANDARD_MODULE_HEADER_EX,
+	NULL,
+	mysqlnd_deps,
+	"mysqlnd",
+	mysqlnd_functions,
+	PHP_MINIT(mysqlnd),
+	PHP_MSHUTDOWN(mysqlnd),
+#if defined(PHP_DEBUG)
+	PHP_RINIT(mysqlnd),
+#else
+	NULL,
+#endif
+#ifdef PHP_DEBUG
+	PHP_RSHUTDOWN(mysqlnd),
+#else
+	NULL,
+#endif
+	PHP_MINFO(mysqlnd),
+	MYSQLND_VERSION,
+	PHP_MODULE_GLOBALS(mysqlnd),
+	PHP_GINIT(mysqlnd),
+	NULL,
+	NULL,
+	STANDARD_MODULE_PROPERTIES_EX
+};
+/* }}} */
+
+/* {{{ COMPILE_DL_MYSQLND */
+#ifdef COMPILE_DL_MYSQLND
+ZEND_GET_MODULE(mysqlnd)
+#endif
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- /dev/null
+++ b/ext/mysqlnd/php_mysqlnd.h
@@ -0,0 +1,38 @@
+/*
+  +----------------------------------------------------------------------+
+  | PHP Version 5                                                        |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2006-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt                                  |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Georg Richter <georg@php.net>                               |
+  |          Andrey Hristov <andrey@php.net>                             |
+  |          Ulf Wendel <uw@php.net>                                     |
+  +----------------------------------------------------------------------+
+
+  $Id$ 
+*/
+
+#ifndef PHP_MYSQLND_H
+#define PHP_MYSQLND_H
+
+#define phpext_mysqlnd_ptr &mysqlnd_module_entry
+extern zend_module_entry mysqlnd_module_entry;
+
+#endif	/* PHP_MYSQLND_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
--- a/ext/pdo/php_pdo_driver.h
+++ b/ext/pdo/php_pdo_driver.h
@@ -67,11 +67,16 @@
 	PDO_PARAM_STMT, /* hierarchical result set */
 
 	/* get_col ptr should point to a zend_bool */
-	PDO_PARAM_BOOL
+	PDO_PARAM_BOOL,
+
+	/* get_col ptr should point to a zval*
+	   and the driver is responsible for adding correct type information to get_column_meta()
+	 */
+	PDO_PARAM_ZVAL
 };
 
 /* magic flag to denote a parameter as being input/output */
-#define	PDO_PARAM_INPUT_OUTPUT 	0x80000000	
+#define	PDO_PARAM_INPUT_OUTPUT 	0x80000000
 
 #define PDO_PARAM_FLAGS			0xFFFF0000
 
@@ -219,7 +224,7 @@
 #define PDO_DRIVER_HEADER(name)	\
 	#name, sizeof(#name)-1, \
 	PDO_DRIVER_API
-	
+
 	/* create driver specific portion of the database handle and stash it into
 	 * the dbh.  dbh contains the data source string and flags for this
 	 * instance.  You MUST respect dbh->is_persistent and pass that flag to
@@ -276,7 +281,7 @@
  * scope */
 typedef void (*pdo_dbh_request_shutdown)(pdo_dbh_t *dbh TSRMLS_DC);
 
-/* for adding methods to the dbh or stmt objects 
+/* for adding methods to the dbh or stmt objects
 pointer to a list of driver specific functions. The convention is
 to prefix the function names using the PDO driver name; this will
 reduce the chance of collisions with future functionality in the
@@ -320,7 +325,7 @@
 /* causes the next row in the set to be fetched; indicates if there are no
  * more rows.  The ori and offset params modify which row should be returned,
  * if the stmt represents a scrollable cursor */
-typedef int (*pdo_stmt_fetch_func)(pdo_stmt_t *stmt, 
+typedef int (*pdo_stmt_fetch_func)(pdo_stmt_t *stmt,
 	enum pdo_fetch_orientation ori, long offset TSRMLS_DC);
 
 /* queries information about the type of a column, by index (0 based).
@@ -425,7 +430,7 @@
        to allow the extending class to escape all the custom handlers
 	   that PDO declares.
     */
-	zend_class_entry *ce; 
+	zend_class_entry *ce;
 	HashTable *properties;
 	unsigned int in_get:1;
 	unsigned int in_set:1;
@@ -437,7 +442,7 @@
 
 	/* credentials */
 	char *username, *password;
-	
+
 	/* if true, then data stored and pointed at by this handle must all be
 	 * persistently allocated */
 	unsigned is_persistent:1;
@@ -490,7 +495,7 @@
 	HashTable *cls_methods[PDO_DBH_DRIVER_METHOD_KIND__MAX];
 
 	pdo_driver_t *driver;
-	
+
 	zend_class_entry *def_stmt_ce;
 
 	zval *def_stmt_ctor_args;
@@ -525,7 +530,7 @@
 	int namelen;
 
 	long max_value_len;	/* as a hint for pre-allocation */
-	
+
 	zval *parameter;				/* the variable itself */
 	enum pdo_param_type param_type; /* desired or suggested type */
 
@@ -543,7 +548,7 @@
        to allow the extending class to escape all the custom handlers
 	   that PDO declares.
     */
-	zend_class_entry *ce; 
+	zend_class_entry *ce;
 	HashTable *properties;
 	unsigned int in_get:1;
 	unsigned int in_set:1;
@@ -568,7 +573,7 @@
 	 * */
 	int column_count;
 	struct pdo_column_data *columns;
-	
+
 	/* we want to keep the dbh alive while we live, so we own a reference */
 	zval database_object_handle;
 	pdo_dbh_t *dbh;
@@ -606,9 +611,9 @@
 	union {
 		int column;
 		struct {
-			zend_class_entry *ce;	
+			zend_class_entry *ce;
 			zval *ctor_args;            /* freed */
-			zval *retval_ptr; 
+			zval *retval_ptr;
 			zend_fcall_info fci;
 			zend_fcall_info_cache fcc;
 		} cls;
@@ -649,7 +654,7 @@
 PDO_API zend_class_entry *php_pdo_get_dbh_ce(void);
 PDO_API zend_class_entry *php_pdo_get_exception(void);
 
-PDO_API int pdo_parse_params(pdo_stmt_t *stmt, char *inquery, int inquery_len, 
+PDO_API int pdo_parse_params(pdo_stmt_t *stmt, char *inquery, int inquery_len,
 	char **outquery, int *outquery_len TSRMLS_DC);
 
 PDO_API void pdo_raise_impl_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt,
--- a/ext/pdo_mysql/CREDITS
+++ b/ext/pdo_mysql/CREDITS
@@ -1,3 +1,3 @@
-mySQL driver for PDO
-George Schlossnagle, Wez Furlong, Ilia Alshanetsky
- 
+MySQL driver for PDO
+George Schlossnagle, Wez Furlong, Ilia Alshanetsky, Johannes Schlueter
+
--- a/ext/pdo_mysql/config.m4
+++ b/ext/pdo_mysql/config.m4
@@ -1,21 +1,11 @@
-dnl
-dnl $Id: config.m4 291414 2009-11-29 06:13:22Z rasmus $
-dnl
+dnl $Id$
+dnl config.m4 for extension pdo_mysql
+dnl vim: se ts=2 sw=2 et:
 
-if test "$PHP_PDO" != "no"; then
-
-AC_DEFUN([PDO_MYSQL_LIB_CHK], [
-  str="$PDO_MYSQL_DIR/$1/libmysqlclient*"
-  for j in `echo $str`; do
-    if test -r $j; then
-      PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$1
-      break 2
-    fi
-  done
-])
-
 PHP_ARG_WITH(pdo-mysql, for MySQL support for PDO,
-[  --with-pdo-mysql[=DIR]    PDO: MySQL support. DIR is the MySQL base directory])
+[  --with-pdo-mysql[=DIR]    PDO: MySQL support. DIR is the MySQL base directory
+                                 If mysqlnd is passed as DIR, the MySQL native
+                                 native driver will be used [/usr/local]])
 
 if test -z "$PHP_ZLIB_DIR"; then
   PHP_ARG_WITH(zlib-dir, for the location of libz,
@@ -23,10 +13,21 @@
 fi
 
 if test "$PHP_PDO_MYSQL" != "no"; then
-  AC_DEFINE(HAVE_MYSQL, 1, [Whether you have MySQL])
 
-  AC_MSG_CHECKING([for mysql_config])
+  if test "$PHP_PDO" = "no" && test "$ext_shared" = "no"; then
+    AC_MSG_ERROR([PDO is not enabled! Add --enable-pdo to your configure line.])
+  fi
 
+  AC_DEFUN([PDO_MYSQL_LIB_CHK], [
+    str="$PDO_MYSQL_DIR/$1/libmysqlclient*"
+    for j in `echo $str`; do
+      if test -r $j; then
+        PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$1
+        break 2
+      fi
+    done
+  ])
+
   if test -f $PHP_PDO_MYSQL && test -x $PHP_PDO_MYSQL ; then
     PDO_MYSQL_CONFIG=$PHP_PDO_MYSQL
   elif test "$PHP_PDO_MYSQL" != "yes"; then
@@ -36,9 +37,6 @@
       else
         PDO_MYSQL_DIR="$PHP_PDO_MYSQL"
       fi
-    else
-      AC_MSG_RESULT([$PHP_PDO_MYSQL is not a directory])
-      AC_MSG_ERROR([can not find mysql under the "$PHP_PDO_MYSQL" that you specified])
     fi
   else
     for i in /usr/local /usr ; do
@@ -53,85 +51,90 @@
     done
   fi
 
-  if test -n "$PDO_MYSQL_CONFIG" && test -x "$PDO_MYSQL_CONFIG" ; then
-    AC_MSG_RESULT($PDO_MYSQL_CONFIG)
-    if test "x$SED" = "x"; then
-      AC_PATH_PROG(SED, sed)
-    fi
-    if test "$enable_maintainer_zts" = "yes"; then
-      PDO_MYSQL_LIBNAME=mysqlclient_r
-      PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs_r | $SED -e "s/'//g"`
-    else
-      PDO_MYSQL_LIBNAME=mysqlclient
-      PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs | $SED -e "s/'//g"`
-    fi
-    PDO_MYSQL_INCLUDE=`$PDO_MYSQL_CONFIG --cflags | $SED -e "s/'//g"`
-    PDO_MYSQL_SOCKET=`$PDO_MYSQL_CONFIG --socket` 
-  elif test -z "$PDO_MYSQL_DIR"; then
-    AC_MSG_RESULT([not found])
-    AC_MSG_ERROR([Cannot find MySQL header files under $PDO_MYSQL_DIR])
+  if test "$PHP_PDO_MYSQL" = "mysqlnd"; then
+    dnl enables build of mysqnd library
+    PHP_MYSQLND_ENABLED=yes
+    AC_DEFINE([PDO_USE_MYSQLND], 1, [Whether pdo_mysql uses mysqlnd])
   else
-    AC_MSG_RESULT([not found])
-    AC_MSG_CHECKING([for mysql install under $PDO_MYSQL_DIR])
-    if test -r $PDO_MYSQL_DIR/include/mysql; then
-      PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include/mysql
-    else
-      PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include
-    fi
-    if test -r $PDO_MYSQL_DIR/$PHP_LIBDIR/mysql; then
-      PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR/mysql
-    else
-      PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR
-    fi
+    AC_DEFINE(HAVE_MYSQL, 1, [Whether you have MySQL])
 
-    if test -r "$PDO_MYSQL_LIB_DIR"; then
-      AC_MSG_RESULT([libs under $PDO_MYSQL_LIB_DIR; seems promising])
+    AC_MSG_CHECKING([for mysql_config])
+    if test -n "$PDO_MYSQL_CONFIG"; then
+      AC_MSG_RESULT($PDO_MYSQL_CONFIG)
+      if test "x$SED" = "x"; then
+        AC_PATH_PROG(SED, sed)
+      fi
+      if test "$enable_maintainer_zts" = "yes"; then
+        PDO_MYSQL_LIBNAME=mysqlclient_r
+        PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs_r | $SED -e "s/'//g"`
+      else
+        PDO_MYSQL_LIBNAME=mysqlclient
+        PDO_MYSQL_LIBS=`$PDO_MYSQL_CONFIG --libs | $SED -e "s/'//g"`
+      fi
+      PDO_MYSQL_INCLUDE=`$PDO_MYSQL_CONFIG --cflags | $SED -e "s/'//g"`
+    elif test -n "$PDO_MYSQL_DIR"; then
+      AC_MSG_RESULT([not found])
+      AC_MSG_CHECKING([for mysql install under $PDO_MYSQL_DIR])
+      if test -r $PDO_MYSQL_DIR/include/mysql; then
+        PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include/mysql
+      else
+        PDO_MYSQL_INC_DIR=$PDO_MYSQL_DIR/include
+      fi
+      if test -r $PDO_MYSQL_DIR/$PHP_LIBDIR/mysql; then
+        PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR/mysql
+      else
+        PDO_MYSQL_LIB_DIR=$PDO_MYSQL_DIR/$PHP_LIBDIR
+      fi
+
+      if test -r "$PDO_MYSQL_LIB_DIR"; then
+        AC_MSG_RESULT([libs under $PDO_MYSQL_LIB_DIR; seems promising])
+      else
+        AC_MSG_RESULT([can not find it])
+        AC_MSG_ERROR([Unable to find your mysql installation])
+      fi
+
+      PHP_ADD_INCLUDE($PDO_MYSQL_INC_DIR)
+      PDO_MYSQL_INCLUDE=-I$PDO_MYSQL_INC_DIR
     else
-      AC_MSG_RESULT([can not find it])
+      AC_MSG_RESULT([not found])
       AC_MSG_ERROR([Unable to find your mysql installation])
     fi
 
-    PHP_ADD_LIBRARY_WITH_PATH($PDO_MYSQL_LIBNAME, $PDO_MYSQL_LIB_DIR, PDO_MYSQL_SHARED_LIBADD)
-    PHP_ADD_INCLUDE($PDO_MYSQL_INC_DIR)
-    PDO_MYSQL_INCLUDE=-I$PDO_MYSQL_INC_DIR
-  fi
+    PHP_CHECK_LIBRARY($PDO_MYSQL_LIBNAME, mysql_query,
+    [
+      PHP_EVAL_INCLINE($PDO_MYSQL_INCLUDE)
+      PHP_EVAL_LIBLINE($PDO_MYSQL_LIBS, PDO_MYSQL_SHARED_LIBADD)
+    ],[
+      if test "$PHP_ZLIB_DIR" != "no"; then
+        PHP_ADD_LIBRARY_WITH_PATH(z, $PHP_ZLIB_DIR, PDO_MYSQL_SHARED_LIBADD)
+        PHP_CHECK_LIBRARY($PDO_MYSQL_LIBNAME, mysql_query, [], [
+          AC_MSG_ERROR([PDO_MYSQL configure failed. Please check config.log for more information.])
+        ], [
+          -L$PHP_ZLIB_DIR/$PHP_LIBDIR -L$PDO_MYSQL_LIB_DIR 
+        ])  
+        PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -L$PHP_ZLIB_DIR/$PHP_LIBDIR -lz"
+      else
+        PHP_ADD_LIBRARY(z,, PDO_MYSQL_SHARED_LIBADD)
+        PHP_CHECK_LIBRARY($PDO_MYSQL_LIBNAME, mysql_query, [], [
+          AC_MSG_ERROR([Try adding --with-zlib-dir=<DIR>. Please check config.log for more information.])
+        ], [
+          -L$PDO_MYSQL_LIB_DIR
+        ])   
+        PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -lz"
+      fi
 
-  AC_DEFINE_UNQUOTED(PDO_MYSQL_UNIX_ADDR, "$PDO_MYSQL_SOCKET", [ ])
+      PHP_EVAL_INCLINE($PDO_MYSQL_INCLUDE)
+      PHP_EVAL_LIBLINE($PDO_MYSQL_LIBS, PDO_MYSQL_SHARED_LIBADD)
+    ],[
+      $PDO_MYSQL_LIBS
+    ])
 
+    _SAVE_LIBS=$LIBS
+    LIBS="$LIBS $PDO_MYSQL_LIBS"
+    AC_CHECK_FUNCS([mysql_commit mysql_stmt_prepare mysql_next_result mysql_sqlstate]) 
+    LIBS=$_SAVE_LIBS
+  fi
 
-  PHP_CHECK_LIBRARY($PDO_MYSQL_LIBNAME, mysql_query,
-  [
-    PHP_EVAL_INCLINE($PDO_MYSQL_INCLUDE)
-    PHP_EVAL_LIBLINE($PDO_MYSQL_LIBS, PDO_MYSQL_SHARED_LIBADD)
-  ],[
-    if test "$PHP_ZLIB_DIR" != "no"; then
-      PHP_ADD_LIBRARY_WITH_PATH(z, $PHP_ZLIB_DIR, PDO_MYSQL_SHARED_LIBADD)
-      PHP_CHECK_LIBRARY($PDO_MYSQL_LIBNAME, mysql_query, [], [
-        AC_MSG_ERROR([PDO_MYSQL configure failed. Please check config.log for more information.])
-      ], [
-        -L$PHP_ZLIB_DIR/$PHP_LIBDIR -L$PDO_MYSQL_LIB_DIR 
-      ])  
-      PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -L$PHP_ZLIB_DIR/$PHP_LIBDIR -lz"
-    else
-      PHP_ADD_LIBRARY(z,, PDO_MYSQL_SHARED_LIBADD)
-      PHP_CHECK_LIBRARY($PDO_MYSQL_LIBNAME, mysql_query, [], [
-        AC_MSG_ERROR([Try adding --with-zlib-dir=<DIR>. Please check config.log for more information.])
-      ], [
-        -L$PDO_MYSQL_LIB_DIR
-      ])   
-      PDO_MYSQL_LIBS="$PDO_MYSQL_LIBS -lz"
-    fi
-
-    PHP_EVAL_INCLINE($PDO_MYSQL_INCLUDE)
-    PHP_EVAL_LIBLINE($PDO_MYSQL_LIBS, PDO_MYSQL_SHARED_LIBADD)
-  ],[
-    $PDO_MYSQL_LIBS
-  ])
-  _SAVE_LIBS=$LIBS
-  LIBS="$LIBS $PDO_MYSQL_LIBS"
-  AC_CHECK_FUNCS([mysql_commit mysql_stmt_prepare mysql_next_result mysql_sqlstate]) 
-  LIBS=$_SAVE_LIBS
-
   ifdef([PHP_CHECK_PDO_INCLUDES],
   [
     PHP_CHECK_PDO_INCLUDES
@@ -149,16 +152,22 @@
     AC_MSG_RESULT($pdo_inc_path)
   ])
 
-  PHP_NEW_EXTENSION(pdo_mysql, pdo_mysql.c mysql_driver.c mysql_statement.c, $ext_shared,,-I$pdo_inc_path)
+  if test -n "$PDO_MYSQL_CONFIG"; then
+    PDO_MYSQL_SOCKET=`$PDO_MYSQL_CONFIG --socket`
+    AC_DEFINE_UNQUOTED(PDO_MYSQL_UNIX_ADDR, "$PDO_MYSQL_SOCKET", [ ])
+  fi
+
+  dnl fix after renaming to pdo_mysql
+  PHP_NEW_EXTENSION(pdo_mysql, pdo_mysql.c mysql_driver.c mysql_statement.c, $ext_shared,,-I$pdo_inc_path -I)
   ifdef([PHP_ADD_EXTENSION_DEP],
   [
     PHP_ADD_EXTENSION_DEP(pdo_mysql, pdo)
+    if test "$PHP_MYSQL" = "mysqlnd"; then
+      PHP_ADD_EXTENSION_DEP(pdo_mysql, mysqlnd)
+    fi
   ])
   PDO_MYSQL_MODULE_TYPE=external
 
   PHP_SUBST(PDO_MYSQL_SHARED_LIBADD)
   PHP_SUBST_OLD(PDO_MYSQL_MODULE_TYPE)
 fi
-
-fi
-dnl vim: se ts=2 sw=2 et:
--- a/ext/pdo_mysql/config.w32
+++ b/ext/pdo_mysql/config.w32
@@ -1,14 +1,20 @@
-// $Id: config.w32 212867 2006-05-11 21:43:59Z edink $
+// $Id$
 // vim:ft=javascript
 
 ARG_WITH("pdo-mysql", "MySQL support for PDO", "no");
 
 if (PHP_PDO_MYSQL != "no") {
-	if (CHECK_LIB("libmysql.lib", "pdo_mysql", PHP_PDO_MYSQL) &&
-			CHECK_HEADER_ADD_INCLUDE("mysql.h", "CFLAGS_PDO_MYSQL", PHP_PHP_BUILD + "\\include\\mysql;" + PHP_PDO_MYSQL)) {
+	if (PHP_PDO_MYSQL == "yes" || PHP_PDO_MYSQL == "mysqlnd") {
+		AC_DEFINE('PDO_USE_MYSQLND', 1, 'Using MySQL native driver');
+		STDOUT.WriteLine("INFO: mysqlnd build");
 		EXTENSION("pdo_mysql", "pdo_mysql.c mysql_driver.c mysql_statement.c");
+		ADD_EXTENSION_DEP('pdo_mysql', 'pdo');
 	} else {
-		WARNING("pdo_mysql not enabled; libraries and headers not found");
+		if (CHECK_LIB("libmysql.lib", "pdo_mysql", PHP_PDO_MYSQL) &&
+				CHECK_HEADER_ADD_INCLUDE("mysql.h", "CFLAGS_PDO_MYSQL", PHP_PHP_BUILD + "\\include\\mysql;" + PHP_PDO_MYSQL)) {
+			EXTENSION("pdo_mysql", "pdo_mysql.c mysql_driver.c mysql_statement.c");
+		} else {
+			WARNING("pdo_mysql not enabled; libraries and headers not found");
+		}
 	}
-	ADD_EXTENSION_DEP('pdo_mysql', 'pdo');
 }
--- a/ext/pdo_mysql/get_error_codes.php
+++ b/ext/pdo_mysql/get_error_codes.php
@@ -5,7 +5,7 @@
 	while (!feof(STDIN)) {
 		$line = fgets(STDIN);
 
-		if (ereg('^(ER_.*),[[:space:]]+"(.*)",[[:space:]]+"(.*)"', $line, $matches)) {
+		if (ereg('^\{[[:space:]]+(ER_.*)[[:space:]]+,[[:space:]]*"(.*)",[[:space:]]*"(.*)"', $line, $matches)) {
 			$codes[$matches[1]] = $matches[2];
 			$maxlen = max($maxlen, strlen($matches[1]));
 		}
@@ -24,4 +24,4 @@
 	}
 
 	
-?>
\ No newline at end of file
+?>
--- a/ext/pdo_mysql/mysql_driver.c
+++ b/ext/pdo_mysql/mysql_driver.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -14,10 +14,11 @@
   +----------------------------------------------------------------------+
   | Author: George Schlossnagle <george@omniti.com>                      |
   |         Wez Furlong <wez@php.net>                                    |
+  |         Johannes Schlueter <johannes@mysql.com>                      |
   +----------------------------------------------------------------------+
 */
 
-/* $Id: mysql_driver.c 293447 2010-01-12 12:46:54Z iliaa $ */
+/* $Id$ */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -30,25 +31,38 @@
 #include "pdo/php_pdo_driver.h"
 #include "php_pdo_mysql.h"
 #include "php_pdo_mysql_int.h"
+#ifndef PDO_USE_MYSQLND
 #include <mysqld_error.h>
+#endif
 #include "zend_exceptions.h"
 
+#if PDO_USE_MYSQLND
+#	define pdo_mysql_init(persistent) mysqlnd_init(persistent)
+#else
+#	define pdo_mysql_init(persistent) mysql_init(NULL)
+#endif
 
-const char *pdo_mysql_get_sqlstate(unsigned int my_errno) {
+#if !defined(HAVE_MYSQL_SQLSTATE) && !defined(PDO_USE_MYSQLND)
+static const char *pdo_mysql_get_sqlstate(unsigned int my_errno) { /* {{{ */
 	switch (my_errno) {
 		/* import auto-generated case: code */
 #include "php_pdo_mysql_sqlstate.h"
 	default: return "HY000";
 	}
 }
+/* }}} */
+#endif
 
-int _pdo_mysql_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int line TSRMLS_DC) /* {{{ */
+/* {{{ _pdo_mysql_error */
+int _pdo_mysql_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int line TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 	pdo_error_type *pdo_err; 
 	pdo_mysql_error_info *einfo;
 	pdo_mysql_stmt *S = NULL;
 
+	PDO_DBG_ENTER("_pdo_mysql_error");
+	PDO_DBG_INF_FMT("file=%s line=%d", file, line);
 	if (stmt) {
 		S = (pdo_mysql_stmt*)stmt->driver_data;
 		pdo_err = &stmt->error_code;
@@ -58,7 +72,7 @@
 		einfo   = &H->einfo;
 	}
 
-#if HAVE_MYSQL_STMT_PREPARE
+#if defined(HAVE_MYSQL_STMT_PREPARE) || defined(PDO_USE_MYSQLND)
 	if (S && S->stmt) {
 		einfo->errcode = mysql_stmt_errno(S->stmt);
 	}
@@ -77,23 +91,29 @@
 	}
 
 	if (einfo->errcode) {
-		if (2014 != einfo->errcode) {
-			einfo->errmsg = pestrdup(mysql_error(H->server), dbh->is_persistent);
-		} else {
+		if (einfo->errcode == 2014) {
 			einfo->errmsg = pestrdup(
 				"Cannot execute queries while other unbuffered queries are active.  "
 				"Consider using PDOStatement::fetchAll().  Alternatively, if your code "
 				"is only ever going to run against mysql, you may enable query "
 				"buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute.",
 				dbh->is_persistent);
+		} else if (einfo->errcode == 2057) {
+			einfo->errmsg = pestrdup(
+				"A stored procedure returning result sets of different size was called. "
+				"This is not supported by libmysql",
+				dbh->is_persistent);
+
+		} else {
+			einfo->errmsg = pestrdup(mysql_error(H->server), dbh->is_persistent);
 		}
 	} else { /* no error */
 		strcpy(*pdo_err, PDO_ERR_NONE);
-		return 0;
+		PDO_DBG_RETURN(0);
 	}
 
-#if HAVE_MYSQL_SQLSTATE
-# if HAVE_MYSQL_STMT_PREPARE
+#if defined(HAVE_MYSQL_SQLSTATE) || defined(PDO_USE_MYSQLND)
+# if defined(HAVE_MYSQL_STMT_PREPARE) || defined(PDO_USE_MYSQLND)
 	if (S && S->stmt) {
 		strcpy(*pdo_err, mysql_stmt_sqlstate(S->stmt));
 	} else
@@ -106,20 +126,23 @@
 #endif
 
 	if (!dbh->methods) {
+		PDO_DBG_INF("Throwing exception");
 		zend_throw_exception_ex(php_pdo_get_exception(), einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s",
 				*pdo_err, einfo->errcode, einfo->errmsg);
 	}
-/* printf("** [%s:%d] %s %s\n", file, line, *pdo_err, einfo->errmsg); */
 
-	return einfo->errcode;
+	PDO_DBG_RETURN(einfo->errcode);
 }
 /* }}} */
 
+/* {{{ pdo_mysql_fetch_error_func */
 static int pdo_mysql_fetch_error_func(pdo_dbh_t *dbh, pdo_stmt_t *stmt, zval *info TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 	pdo_mysql_error_info *einfo = &H->einfo;
 
+	PDO_DBG_ENTER("pdo_mysql_fetch_error_func");
+	PDO_DBG_INF_FMT("dbh=%p stmt=%p", dbh, stmt);
 	if (stmt) {
 		pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 		einfo = &S->einfo;
@@ -132,13 +155,17 @@
 		add_next_index_string(info, einfo->errmsg, 1);
 	}
 
-	return 1;
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
-static int mysql_handle_closer(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
+/* {{{ mysql_handle_closer */
+static int mysql_handle_closer(pdo_dbh_t *dbh TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 	
+	PDO_DBG_ENTER("mysql_handle_closer");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
 	if (H) {
 		if (H->server) {
 			mysql_close(H->server);
@@ -151,21 +178,26 @@
 		pefree(H, dbh->is_persistent);
 		dbh->driver_data = NULL;
 	}
-	return 0;
+	PDO_DBG_RETURN(0);
 }
 /* }}} */
 
+/* {{{ mysql_handle_preparer */
 static int mysql_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len, pdo_stmt_t *stmt, zval *driver_options TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 	pdo_mysql_stmt *S = ecalloc(1, sizeof(pdo_mysql_stmt));
-#if HAVE_MYSQL_STMT_PREPARE
+#if defined(HAVE_MYSQL_STMT_PREPARE) || defined(PDO_USE_MYSQLND)
 	char *nsql = NULL;
 	int nsql_len = 0;
 	int ret;
 	int server_version;
 #endif
 	
+	PDO_DBG_ENTER("mysql_handle_preparer");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_INF_FMT("sql=%.*s", sql_len, sql);
+
 	S->H = H;
 	stmt->driver_data = S;
 	stmt->methods = &mysql_stmt_methods;
@@ -174,7 +206,7 @@
 		goto end;
 	}
 
-#if HAVE_MYSQL_STMT_PREPARE
+#if defined(HAVE_MYSQL_STMT_PREPARE) || defined(PDO_USE_MYSQLND)
 	server_version = mysql_get_server_version(H->server);
 	if (server_version < 40100) {
 		goto fallback;
@@ -189,7 +221,7 @@
 	} else if (ret == -1) {
 		/* failed to parse */
 		strcpy(dbh->error_code, stmt->error_code);
-		return 0;
+		PDO_DBG_RETURN(0);
 	}
 
 	if (!(S->stmt = mysql_stmt_init(H->server))) {
@@ -197,7 +229,7 @@
 		if (nsql) {
 			efree(nsql);
 		}
-		return 0;
+		PDO_DBG_RETURN(0);
 	}
 	
 	if (mysql_stmt_prepare(S->stmt, sql, sql_len)) {
@@ -213,7 +245,7 @@
 		if (nsql) {
 			efree(nsql);
 		}
-		return 0;
+		PDO_DBG_RETURN(0);
 	}
 	if (nsql) {
 		efree(nsql);
@@ -222,115 +254,201 @@
 	S->num_params = mysql_stmt_param_count(S->stmt);
 
 	if (S->num_params) {
+		S->params_given = 0;
+#ifdef PDO_USE_MYSQLND
+		S->params = NULL;
+#else
 		S->params = ecalloc(S->num_params, sizeof(MYSQL_BIND));
 		S->in_null = ecalloc(S->num_params, sizeof(my_bool));
 		S->in_length = ecalloc(S->num_params, sizeof(unsigned long));
+#endif
 	}
-
 	dbh->alloc_own_columns = 1;
 
 	S->max_length = pdo_attr_lval(driver_options, PDO_ATTR_MAX_COLUMN_LEN, 0 TSRMLS_CC);
 
-	return 1;
+	PDO_DBG_RETURN(1);
 
 fallback:
 #endif
 end:
 	stmt->supports_placeholders = PDO_PLACEHOLDER_NONE;
 	
-	return 1;
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
+/* {{{ mysql_handle_doer */
 static long mysql_handle_doer(pdo_dbh_t *dbh, const char *sql, long sql_len TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
+	PDO_DBG_ENTER("mysql_handle_doer");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_INF_FMT("sql=%.*s", sql_len, sql);
 
 	if (mysql_real_query(H->server, sql, sql_len)) {
 		pdo_mysql_error(dbh);
-		return -1;
+		PDO_DBG_RETURN(-1);
 	} else {
 		my_ulonglong c = mysql_affected_rows(H->server);
 		if (c == (my_ulonglong) -1) {
 			pdo_mysql_error(dbh);
-			return (H->einfo.errcode ? -1 : 0);
+			PDO_DBG_RETURN(H->einfo.errcode ? -1 : 0);
 		} else {
-			return c;
+
+#if defined(HAVE_MYSQL_NEXT_RESULT) || defined(PDO_USE_MYSQLND)
+			/* MULTI_QUERY support - eat up all unfetched result sets */
+			MYSQL_RES* result;
+			while (mysql_more_results(H->server)) {
+				if (mysql_next_result(H->server)) {
+					PDO_DBG_RETURN(1);
+				}
+				result = mysql_store_result(H->server);
+				if (result) {
+					mysql_free_result(result);
+				}
+			}
+#endif
+			PDO_DBG_RETURN((int)c);
 		}
 	}
 }
+/* }}} */
 
+/* {{{ pdo_mysql_last_insert_id */
 static char *pdo_mysql_last_insert_id(pdo_dbh_t *dbh, const char *name, unsigned int *len TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 	char *id = php_pdo_int64_to_str(mysql_insert_id(H->server) TSRMLS_CC);
+	PDO_DBG_ENTER("pdo_mysql_last_insert_id");
 	*len = strlen(id);
-	return id;
+	PDO_DBG_RETURN(id);
 }
+/* }}} */ 
 
+/* {{{ mysql_handle_quoter */
 static int mysql_handle_quoter(pdo_dbh_t *dbh, const char *unquoted, int unquotedlen, char **quoted, int *quotedlen, enum pdo_param_type paramtype  TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
+	PDO_DBG_ENTER("mysql_handle_quoter");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_INF_FMT("unquoted=%.*s", unquotedlen, unquoted);
 	*quoted = safe_emalloc(2, unquotedlen, 3);
 	*quotedlen = mysql_real_escape_string(H->server, *quoted + 1, unquoted, unquotedlen);
 	(*quoted)[0] =(*quoted)[++*quotedlen] = '\'';
 	(*quoted)[++*quotedlen] = '\0';
-	return 1;
+	PDO_DBG_INF_FMT("quoted=%.*s", *quotedlen, *quoted);
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
+/* {{{ mysql_handle_begin */
 static int mysql_handle_begin(pdo_dbh_t *dbh TSRMLS_DC)
 {
-	return 0 <= mysql_handle_doer(dbh, ZEND_STRL("START TRANSACTION") TSRMLS_CC);
+	PDO_DBG_ENTER("mysql_handle_quoter");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_RETURN(0 <= mysql_handle_doer(dbh, ZEND_STRL("START TRANSACTION") TSRMLS_CC));
 }
+/* }}} */
 
+/* {{{ mysql_handle_commit */
 static int mysql_handle_commit(pdo_dbh_t *dbh TSRMLS_DC)
 {
-	return 0 <= mysql_handle_doer(dbh, ZEND_STRL("COMMIT") TSRMLS_CC);
+	PDO_DBG_ENTER("mysql_handle_commit");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+#if MYSQL_VERSION_ID >= 40100 || defined(PDO_USE_MYSQLND)
+	PDO_DBG_RETURN(0 <= mysql_commit(((pdo_mysql_db_handle *)dbh->driver_data)->server));
+#else
+	PDO_DBG_RETURN(0 <= mysql_handle_doer(dbh, ZEND_STRL("COMMIT") TSRMLS_CC));
+#endif
 }
+/* }}} */
 
+/* {{{ mysql_handle_rollback */
 static int mysql_handle_rollback(pdo_dbh_t *dbh TSRMLS_DC)
 {
-	return 0 <= mysql_handle_doer(dbh, ZEND_STRL("ROLLBACK") TSRMLS_CC);
+	PDO_DBG_ENTER("mysql_handle_rollback");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+#if MYSQL_VERSION_ID >= 40100 || defined(PDO_USE_MYSQLND)
+	PDO_DBG_RETURN(0 <= mysql_rollback(((pdo_mysql_db_handle *)dbh->driver_data)->server));
+#else
+	PDO_DBG_RETURN(0 <= mysql_handle_doer(dbh, ZEND_STRL("ROLLBACK") TSRMLS_CC));
+#endif
 }
+/* }}} */
 
-static int mysql_handle_autocommit(pdo_dbh_t *dbh TSRMLS_DC)
+/* {{{ mysql_handle_autocommit */
+static inline int mysql_handle_autocommit(pdo_dbh_t *dbh TSRMLS_DC)
 {
+	PDO_DBG_ENTER("mysql_handle_autocommit");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_INF_FMT("dbh->autocommit=%d", dbh->auto_commit);
+#if MYSQL_VERSION_ID >= 40100 || defined(PDO_USE_MYSQLND)
+	PDO_DBG_RETURN(0 <= mysql_autocommit(((pdo_mysql_db_handle *)dbh->driver_data)->server, dbh->auto_commit));
+#else
 	if (dbh->auto_commit) {
-		return 0 <= mysql_handle_doer(dbh, ZEND_STRL("SET AUTOCOMMIT=1") TSRMLS_CC);
+		PDO_DBG_RETURN(0 <= mysql_handle_doer(dbh, ZEND_STRL("SET AUTOCOMMIT=1") TSRMLS_CC));
 	} else {
-		return 0 <= mysql_handle_doer(dbh, ZEND_STRL("SET AUTOCOMMIT=0") TSRMLS_CC);
+		PDO_DBG_RETURN(0 <= mysql_handle_doer(dbh, ZEND_STRL("SET AUTOCOMMIT=0") TSRMLS_CC));
 	}
+#endif
 }
+/* }}} */
 
+/* {{{ pdo_mysql_set_attribute */
 static int pdo_mysql_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TSRMLS_DC)
 {
+	PDO_DBG_ENTER("pdo_mysql_set_attribute");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_INF_FMT("attr=%l", attr);
 	switch (attr) {
-	case PDO_ATTR_AUTOCOMMIT:
-		
-		convert_to_boolean(val);
+		case PDO_ATTR_AUTOCOMMIT:		
+			convert_to_boolean(val);
 	
-		/* ignore if the new value equals the old one */			
-		if (dbh->auto_commit ^ Z_BVAL_P(val)) {
-			dbh->auto_commit = Z_BVAL_P(val);
-			mysql_handle_autocommit(dbh TSRMLS_CC);
-		}
-		return 1;
+			/* ignore if the new value equals the old one */			
+			if (dbh->auto_commit ^ Z_BVAL_P(val)) {
+				dbh->auto_commit = Z_BVAL_P(val);
+				mysql_handle_autocommit(dbh TSRMLS_CC);
+			}
+			PDO_DBG_RETURN(1);
 
-	case PDO_MYSQL_ATTR_USE_BUFFERED_QUERY:
-		((pdo_mysql_db_handle *)dbh->driver_data)->buffered = Z_BVAL_P(val);
-		return 1;
-	case PDO_MYSQL_ATTR_DIRECT_QUERY:
-	case PDO_ATTR_EMULATE_PREPARES:
-		((pdo_mysql_db_handle *)dbh->driver_data)->emulate_prepare = Z_BVAL_P(val);
-		return 1;
-	default:
-		return 0;
+		case PDO_MYSQL_ATTR_USE_BUFFERED_QUERY:
+			((pdo_mysql_db_handle *)dbh->driver_data)->buffered = Z_BVAL_P(val);
+			PDO_DBG_RETURN(1);
+		case PDO_MYSQL_ATTR_DIRECT_QUERY:
+		case PDO_ATTR_EMULATE_PREPARES:
+			((pdo_mysql_db_handle *)dbh->driver_data)->emulate_prepare = Z_BVAL_P(val);
+			PDO_DBG_RETURN(1);
+		case PDO_ATTR_FETCH_TABLE_NAMES:
+			((pdo_mysql_db_handle *)dbh->driver_data)->fetch_table_names = Z_BVAL_P(val);
+			PDO_DBG_RETURN(1);
+#ifndef PDO_USE_MYSQLND
+		case PDO_MYSQL_ATTR_MAX_BUFFER_SIZE:
+			if (Z_LVAL_P(val) < 0) {
+				/* TODO: Johannes, can we throw a warning here? */
+ 				((pdo_mysql_db_handle *)dbh->driver_data)->max_buffer_size = 1024*1024;
+				PDO_DBG_INF_FMT("Adjusting invalid buffer size to =%l", ((pdo_mysql_db_handle *)dbh->driver_data)->max_buffer_size);
+			} else {
+				((pdo_mysql_db_handle *)dbh->driver_data)->max_buffer_size = Z_LVAL_P(val);
+			}
+			PDO_DBG_RETURN(1);
+			break;
+#endif
+
+		default:
+			PDO_DBG_RETURN(0);
 	}
 }
+/* }}} */
 
+/* {{{ pdo_mysql_get_attribute */
 static int pdo_mysql_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_value TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 
+	PDO_DBG_ENTER("pdo_mysql_get_attribute");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+	PDO_DBG_INF_FMT("attr=%l", attr);
 	switch (attr) {
 		case PDO_ATTR_CLIENT_VERSION:
 			ZVAL_STRING(return_value, (char *)mysql_get_client_info(), 1);
@@ -343,43 +461,51 @@
 		case PDO_ATTR_CONNECTION_STATUS:
 			ZVAL_STRING(return_value, (char *)mysql_get_host_info(H->server), 1);
 			break;
-
 		case PDO_ATTR_SERVER_INFO: {
 			char *tmp;
+#ifdef PDO_USE_MYSQLND
+			unsigned int tmp_len;
 
+			if (mysqlnd_stat(H->server, &tmp, &tmp_len) == PASS) {
+				ZVAL_STRINGL(return_value, tmp, tmp_len, 0);
+#else
 			if ((tmp = (char *)mysql_stat(H->server))) {
 				ZVAL_STRING(return_value, tmp, 1);
+#endif
 			} else {
 				pdo_mysql_error(dbh);
-				return -1;
+				PDO_DBG_RETURN(-1);
 			}
 		}
 			break;
-
 		case PDO_ATTR_AUTOCOMMIT:
 			ZVAL_LONG(return_value, dbh->auto_commit);
-			return 1;
+			break;
 			
 		case PDO_MYSQL_ATTR_USE_BUFFERED_QUERY:
 			ZVAL_LONG(return_value, H->buffered);
-			return 1;
+			break;
 
 		case PDO_MYSQL_ATTR_DIRECT_QUERY:
 			ZVAL_LONG(return_value, H->emulate_prepare);
-			return 1;
+			break;
 
+#ifndef PDO_USE_MYSQLND
 		case PDO_MYSQL_ATTR_MAX_BUFFER_SIZE:
 			ZVAL_LONG(return_value, H->max_buffer_size);
-			return 1;
+			break;
+#endif
 
 		default:
-			return 0;	
+			PDO_DBG_RETURN(0);	
 	}
 
-	return 1;
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
-static int pdo_mysql_check_liveness(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
+/* {{{ pdo_mysql_check_liveness */
+static int pdo_mysql_check_liveness(pdo_dbh_t *dbh TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
 #if MYSQL_VERSION_ID <= 32230
@@ -387,27 +513,31 @@
 	unsigned int my_errno;
 #endif
 
+	PDO_DBG_ENTER("pdo_mysql_check_liveness");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+
 #if MYSQL_VERSION_ID > 32230
 	if (mysql_ping(H->server)) {
-		return FAILURE;
+		PDO_DBG_RETURN(FAILURE);
 	}
 #else /* no mysql_ping() */
-	handler=signal(SIGPIPE, SIG_IGN);
+	handler = signal(SIGPIPE, SIG_IGN);
 	mysql_stat(H->server);
 	switch (mysql_errno(H->server)) {
 		case CR_SERVER_GONE_ERROR:
-		/* case CR_SERVER_LOST: I'm not sure this means the same as "gone" for us */
+		case CR_SERVER_LOST:
 			signal(SIGPIPE, handler);
-			return FAILURE;
+			PDO_DBG_RETURN(FAILURE);
 		default:
 			break;
 	}
 	signal(SIGPIPE, handler);
 #endif /* end mysql_ping() */
-	return SUCCESS;
+	PDO_DBG_RETURN(SUCCESS);
 } 
 /* }}} */
 
+/* {{{ mysql_methods */
 static struct pdo_dbh_methods mysql_methods = {
 	mysql_handle_closer,
 	mysql_handle_preparer,
@@ -422,16 +552,16 @@
 	pdo_mysql_get_attribute,
 	pdo_mysql_check_liveness
 };
+/* }}} */
 
-#ifndef PDO_MYSQL_UNIX_ADDR
-# ifdef PHP_WIN32
-#  define PDO_MYSQL_UNIX_ADDR	"MySQL"
-# else
-#  define PDO_MYSQL_UNIX_ADDR	"/tmp/mysql.sock"
-# endif
+#ifdef PHP_WIN32
+# define MYSQL_UNIX_ADDR	NULL
+#else
+# define MYSQL_UNIX_ADDR	PDO_MYSQL_G(default_socket)
 #endif
 
-static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_DC) /* {{{ */
+/* {{{ pdo_mysql_handle_factory */
+static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H;
 	int i, ret = 0;
@@ -443,7 +573,7 @@
 		{ "dbname",   "",	0 },
 		{ "host",   "localhost",	0 },
 		{ "port",   "3306",	0 },
-		{ "unix_socket",  PDO_MYSQL_UNIX_ADDR,	0 },
+		{ "unix_socket",  MYSQL_UNIX_ADDR,	0 },
 	};
 	int connect_opts = 0
 #ifdef CLIENT_MULTI_RESULTS
@@ -454,31 +584,51 @@
 #endif
 		;
 
+#ifdef PDO_USE_MYSQLND
+	int dbname_len = 0;
+	int password_len = 0;
+#endif
+	PDO_DBG_ENTER("pdo_mysql_handle_factory");
+	PDO_DBG_INF_FMT("dbh=%p", dbh);
+#ifdef CLIENT_MULTI_RESULTS
+	PDO_DBG_INF("multi results");
+#endif
+
 	php_pdo_parse_data_source(dbh->data_source, dbh->data_source_len, vars, 5);
 
 	H = pecalloc(1, sizeof(pdo_mysql_db_handle), dbh->is_persistent);
-	
+
 	H->einfo.errcode = 0;
 	H->einfo.errmsg = NULL;
 
 	/* allocate an environment */
 
 	/* handle for the server */
-	if (!(H->server = mysql_init(NULL))) {
+	if (!(H->server = pdo_mysql_init(dbh->is_persistent))) {
 		pdo_mysql_error(dbh);
 		goto cleanup;
 	}
 	
 	dbh->driver_data = H;
+
+#ifndef PDO_USE_MYSQLND
 	H->max_buffer_size = 1024*1024;
+#endif
+
 	H->buffered = H->emulate_prepare = 1;
 
 	/* handle MySQL options */
 	if (driver_options) {
 		long connect_timeout = pdo_attr_lval(driver_options, PDO_ATTR_TIMEOUT, 30 TSRMLS_CC);
 		long local_infile = pdo_attr_lval(driver_options, PDO_MYSQL_ATTR_LOCAL_INFILE, 0 TSRMLS_CC);
-		char *init_cmd = NULL, *default_file = NULL, *default_group = NULL;
-
+		char *init_cmd = NULL;
+#ifndef PDO_USE_MYSQLND
+		char *default_file = NULL, *default_group = NULL;
+#endif
+		long compress = 0;
+#if defined(HAVE_MYSQL_STMT_PREPARE) || defined(PDO_USE_MYSQLND)
+		char *ssl_key = NULL, *ssl_cert = NULL, *ssl_ca = NULL, *ssl_capath = NULL, *ssl_cipher = NULL;
+#endif
 		H->buffered = pdo_attr_lval(driver_options, PDO_MYSQL_ATTR_USE_BUFFERED_QUERY, 1 TSRMLS_CC);
 
 		H->emulate_prepare = pdo_attr_lval(driver_options,
@@ -486,17 +636,32 @@
 		H->emulate_prepare = pdo_attr_lval(driver_options, 
 			PDO_ATTR_EMULATE_PREPARES, H->emulate_prepare TSRMLS_CC);
 
+#ifndef PDO_USE_MYSQLND
 		H->max_buffer_size = pdo_attr_lval(driver_options, PDO_MYSQL_ATTR_MAX_BUFFER_SIZE, H->max_buffer_size TSRMLS_CC);
+#endif
 
+		if (pdo_attr_lval(driver_options, PDO_MYSQL_ATTR_FOUND_ROWS, 0 TSRMLS_CC)) {
+			connect_opts |= CLIENT_FOUND_ROWS;
+		}
+
+		if (pdo_attr_lval(driver_options, PDO_MYSQL_ATTR_IGNORE_SPACE, 0 TSRMLS_CC)) {
+			connect_opts |= CLIENT_IGNORE_SPACE;
+		}
+
 		if (mysql_options(H->server, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&connect_timeout)) {
 			pdo_mysql_error(dbh);
 			goto cleanup;
 		}
 
-		if ((PG(open_basedir) && PG(open_basedir)[0] != '\0') || PG(safe_mode)) {
+#if PHP_API_VERSION < 20100412
+		if ((PG(open_basedir) && PG(open_basedir)[0] != '\0') || PG(safe_mode))
+#else
+		if (PG(open_basedir) && PG(open_basedir)[0] != '\0') 
+#endif
+		{
 			local_infile = 0;
 		}
-#ifdef MYSQL_OPT_LOCAL_INFILE
+#if defined(MYSQL_OPT_LOCAL_INFILE) || defined(PDO_USE_MYSQLND)
 		if (mysql_options(H->server, MYSQL_OPT_LOCAL_INFILE, (const char *)&local_infile)) {
 			pdo_mysql_error(dbh);
 			goto cleanup;
@@ -504,13 +669,14 @@
 #endif
 #ifdef MYSQL_OPT_RECONNECT
 		/* since 5.0.3, the default for this option is 0 if not specified.
-		 * we want the old behaviour */
+		 * we want the old behaviour
+		 * mysqlnd doesn't support reconnect, thus we don't have "|| defined(PDO_USE_MYSQLND)"
+		*/
 		{
 			long reconnect = 1;
 			mysql_options(H->server, MYSQL_OPT_RECONNECT, (const char*)&reconnect);
 		}
 #endif
-
 		init_cmd = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_INIT_COMMAND, NULL TSRMLS_CC);
 		if (init_cmd) {
 			if (mysql_options(H->server, MYSQL_INIT_COMMAND, (const char *)init_cmd)) {
@@ -520,7 +686,7 @@
 			}
 			efree(init_cmd);
 		}
-		
+#ifndef PDO_USE_MYSQLND		
 		default_file = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_READ_DEFAULT_FILE, NULL TSRMLS_CC);
 		if (default_file) {
 			if (mysql_options(H->server, MYSQL_READ_DEFAULT_FILE, (const char *)default_file)) {
@@ -540,8 +706,49 @@
 			}
 			efree(default_group);
 		}
+#endif
+		compress = pdo_attr_lval(driver_options, PDO_MYSQL_ATTR_COMPRESS, 0 TSRMLS_CC);
+		if (compress) {
+			if (mysql_options(H->server, MYSQL_OPT_COMPRESS, 0)) {
+				pdo_mysql_error(dbh);
+				goto cleanup;
+			}
+		}
+#if defined(HAVE_MYSQL_STMT_PREPARE) || defined(PDO_USE_MYSQLND)
+		ssl_key = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_KEY, NULL TSRMLS_CC);
+		ssl_cert = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CERT, NULL TSRMLS_CC);
+		ssl_ca = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CA, NULL TSRMLS_CC);
+		ssl_capath = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CAPATH, NULL TSRMLS_CC);
+		ssl_cipher = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CIPHER, NULL TSRMLS_CC);
+		
+		if (ssl_key || ssl_cert || ssl_ca || ssl_capath || ssl_cipher) {
+			mysql_ssl_set(H->server, ssl_key, ssl_cert, ssl_ca, ssl_capath, ssl_cipher);
+			if (ssl_key) {
+				efree(ssl_key);
+			}
+			if (ssl_cert) {
+				efree(ssl_cert);
+			}
+			if (ssl_ca) {
+				efree(ssl_ca);
+			}
+			if (ssl_capath) {
+				efree(ssl_capath);
+			}
+			if (ssl_cipher) {
+				efree(ssl_cipher);
+			}
+		}
+#endif
 	}
 
+#ifdef PDO_MYSQL_HAS_CHARSET
+	if (vars[0].optval && mysql_options(H->server, MYSQL_SET_CHARSET_NAME, vars[0].optval)) {
+		pdo_mysql_error(dbh);
+		goto cleanup;
+	}
+#endif
+
 	dbname = vars[1].optval;
 	host = vars[2].optval;	
 	if(vars[3].optval) {
@@ -550,7 +757,22 @@
 	if (vars[2].optval && !strcmp("localhost", vars[2].optval)) {
 		unix_socket = vars[4].optval;  
 	}
+
+	/* TODO: - Check zval cache + ZTS */
+#ifdef PDO_USE_MYSQLND
+	if (dbname) {
+		dbname_len = strlen(dbname);
+	}
+
+	if (dbh->password) {
+		password_len = strlen(dbh->password);
+	}
+
+	if (mysqlnd_connect(H->server, host, dbh->username, dbh->password, password_len, dbname, dbname_len,
+						port, unix_socket, connect_opts TSRMLS_CC) == NULL) {
+#else
 	if (mysql_real_connect(H->server, host, dbh->username, dbh->password, dbname, port, unix_socket, connect_opts) == NULL) {
+#endif
 		pdo_mysql_error(dbh);
 		goto cleanup;
 	}
@@ -576,7 +798,7 @@
 	
 	dbh->methods = &mysql_methods;
 
-	return ret;
+	PDO_DBG_RETURN(ret);
 }
 /* }}} */
 
--- a/ext/pdo_mysql/mysql_statement.c
+++ b/ext/pdo_mysql/mysql_statement.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -14,10 +14,11 @@
   +----------------------------------------------------------------------+
   | Author: George Schlossnagle <george@omniti.com>                      |
   |         Wez Furlong <wez@php.net>                                    |
+  |         Johannes Schlueter <johannes@mysql.com>                      |
   +----------------------------------------------------------------------+
 */
 
-/* $Id: mysql_statement.c 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -31,11 +32,24 @@
 #include "php_pdo_mysql.h"
 #include "php_pdo_mysql_int.h"
 
+#ifdef PDO_USE_MYSQLND
+#	define pdo_mysql_stmt_execute_prepared(stmt) pdo_mysql_stmt_execute_prepared_mysqlnd(stmt TSRMLS_CC)
+#	define pdo_free_bound_result(res) zval_dtor(res.zv)
+#	define pdo_mysql_stmt_close(stmt) mysqlnd_stmt_close(stmt, 0)
+#else
+#	define pdo_mysql_stmt_execute_prepared(stmt) pdo_mysql_stmt_execute_prepared_libmysql(stmt TSRMLS_CC)
+#	define pdo_free_bound_result(res) efree(res.buffer)
+#	define pdo_mysql_stmt_close(stmt) mysql_stmt_close(stmt)
+#endif
 
-static int pdo_mysql_stmt_dtor(pdo_stmt_t *stmt TSRMLS_DC)
+
+
+static int pdo_mysql_stmt_dtor(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
 {
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 
+	PDO_DBG_ENTER("pdo_mysql_stmt_dtor");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
 	if (S->result) {
 		/* free the resource */
 		mysql_free_result(S->result);
@@ -45,217 +59,360 @@
 		pefree(S->einfo.errmsg, stmt->dbh->is_persistent);
 		S->einfo.errmsg = NULL;
 	}
-#if HAVE_MYSQL_STMT_PREPARE
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
 	if (S->stmt) {
-		mysql_stmt_close(S->stmt);
+		pdo_mysql_stmt_close(S->stmt);
 		S->stmt = NULL;
 	}
+#endif /* HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND */
+
+#ifndef PDO_USE_MYSQLND
 	if (S->params) {
 		efree(S->params);
+	}
+	if (S->in_null) {
 		efree(S->in_null);
+	}
+	if (S->in_length) {
 		efree(S->in_length);
 	}
-	if (S->bound_result) 
+
+#endif /* PDO_USE_MYSQLND */
+
+#ifdef HAVE_MYSQL_STMT_PREPARE
+	if (S->bound_result)
 	{
 		int i;
 		for (i = 0; i < stmt->column_count; i++) {
-			efree(S->bound_result[i].buffer);
+			pdo_free_bound_result(S->bound_result[i]);
 		}
-	
+
 		efree(S->bound_result);
 		efree(S->out_null);
 		efree(S->out_length);
 	}
-#endif
-#if HAVE_MYSQL_NEXT_RESULT
+#endif /* HAVE_MYSQL_STMT_PREPARE */
+
+
+#if HAVE_MYSQL_NEXT_RESULT || PDO_USE_MYSQLND
 	if (S->H->server) {
 		while (mysql_more_results(S->H->server)) {
 			MYSQL_RES *res;
 			if (mysql_next_result(S->H->server) != 0) {
 				break;
 			}
-			
+
 			res = mysql_store_result(S->H->server);
 			if (res) {
 				mysql_free_result(res);
 			}
 		}
 	}
-#endif
+#endif /* HAVE_MYSQL_NEXT_RESULT || PDO_USE_MYSQLND */
+#if PDO_USE_MYSQLND
+	if (!S->stmt && S->current_data) {
+		mnd_free(S->current_data);
+	}
+#endif /* PDO_USE_MYSQLND */
+
 	efree(S);
-	return 1;
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
-static int pdo_mysql_stmt_execute(pdo_stmt_t *stmt TSRMLS_DC)
+static void pdo_mysql_stmt_set_row_count(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
 {
+	long row_count;
+	pdo_mysql_stmt *S = stmt->driver_data;
+	row_count = (long) mysql_stmt_affected_rows(S->stmt);
+	if (row_count != (long)-1) {
+		stmt->row_count = row_count;
+	}
+}
+/* }}} */
+
+static int pdo_mysql_fill_stmt_from_result(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
+{
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 	pdo_mysql_db_handle *H = S->H;
 	my_ulonglong row_count;
-#if HAVE_MYSQL_STMT_PREPARE
-	int i;
+	PDO_DBG_ENTER("pdo_mysql_fill_stmt_from_result");
 
-	if (S->stmt) {
-		/* (re)bind the parameters */
-		if (mysql_stmt_bind_param(S->stmt, S->params)) {
-			pdo_mysql_error_stmt(stmt);
-			return 0;
+	row_count = mysql_affected_rows(H->server);
+	if (row_count == (my_ulonglong)-1) {
+		/* we either have a query that returned a result set or an error occured
+		   lets see if we have access to a result set */
+		if (!H->buffered) {
+			S->result = mysql_use_result(H->server);
+		} else {
+			S->result = mysql_store_result(H->server);
 		}
-
-		if (mysql_stmt_execute(S->stmt)) {
+		if (NULL == S->result) {
 			pdo_mysql_error_stmt(stmt);
-			return 0;
+			PDO_DBG_RETURN(0);
 		}
 
-		if (!S->result) {
-			/* figure out the result set format, if any */
-			S->result = mysql_stmt_result_metadata(S->stmt);
-			if (S->result) {
-				int calc_max_length = H->buffered && S->max_length == 1;
-			
-				S->fields = mysql_fetch_fields(S->result);
+		stmt->row_count = (long) mysql_num_rows(S->result);
+		stmt->column_count = (int) mysql_num_fields(S->result);
+		S->fields = mysql_fetch_fields(S->result);
+	} else {
+		/* this was a DML or DDL query (INSERT, UPDATE, DELETE, ... */
+		stmt->row_count = (long) row_count;
+	}
 
-				if (S->bound_result) {
-					int i;
-					for (i = 0; i < stmt->column_count; i++) {
-						efree(S->bound_result[i].buffer); 
-					}
-					efree(S->bound_result);
-					efree(S->out_null);
-					efree(S->out_length);
-				}
+	PDO_DBG_RETURN(1);
+}
+/* }}} */
 
-				stmt->column_count = (int)mysql_num_fields(S->result);
-				S->bound_result = ecalloc(stmt->column_count, sizeof(MYSQL_BIND));
-				S->out_null = ecalloc(stmt->column_count, sizeof(my_bool));
-				S->out_length = ecalloc(stmt->column_count, sizeof(unsigned long));
+#ifdef HAVE_MYSQL_STMT_PREPARE
+static int pdo_mysql_stmt_execute_prepared_libmysql(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
+{
+	pdo_mysql_stmt *S = stmt->driver_data;
+	pdo_mysql_db_handle *H = S->H;
 
-				/* summon memory to hold the row */
-				for (i = 0; i < stmt->column_count; i++) {
-					if (calc_max_length && S->fields[i].type == FIELD_TYPE_BLOB) {
-						my_bool on = 1;
-						mysql_stmt_attr_set(S->stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);
-						calc_max_length = 0;
-					}
-					switch (S->fields[i].type) {
-						case FIELD_TYPE_INT24:
-							S->bound_result[i].buffer_length = MAX_MEDIUMINT_WIDTH;
-							break;
-						case FIELD_TYPE_LONG:
-							S->bound_result[i].buffer_length = MAX_INT_WIDTH;
-							break;
-						case FIELD_TYPE_LONGLONG:
-							S->bound_result[i].buffer_length = MAX_BIGINT_WIDTH;
-							break;
-						case FIELD_TYPE_TINY:
-							S->bound_result[i].buffer_length = MAX_TINYINT_WIDTH;
-							break;
-						case FIELD_TYPE_SHORT:
-							S->bound_result[i].buffer_length = MAX_SMALLINT_WIDTH;
-							break;
-						default:
-							S->bound_result[i].buffer_length =
-								S->fields[i].max_length? S->fields[i].max_length:
-								S->fields[i].length;
-							/* work-around for longtext and alike */
-							if (S->bound_result[i].buffer_length > H->max_buffer_size) {
-								S->bound_result[i].buffer_length = H->max_buffer_size;
-							}
-					}
-#if 0
-					printf("%d: max_length=%d length=%d buffer_length=%d type=%d\n",
-							i,
-							S->fields[i].max_length,
-						  	S->fields[i].length,
-							S->bound_result[i].buffer_length,
-							S->fields[i].type
-							);
-#endif
+	PDO_DBG_ENTER("pdo_mysql_stmt_execute_prepared_libmysql");
 
-					/* there are cases where the length reported by mysql is too short.
-					 * eg: when describing a table that contains an enum column. Since
-					 * we have no way of knowing the true length either, we'll bump up
-					 * our buffer size to a reasonable size, just in case */
-					if (S->fields[i].max_length == 0 && S->bound_result[i].buffer_length < 128 && MYSQL_TYPE_VAR_STRING) {
-						S->bound_result[i].buffer_length = 128;
-					}
+	/* (re)bind the parameters */
+	if (mysql_stmt_bind_param(S->stmt, S->params) || mysql_stmt_execute(S->stmt)) {
+		if (S->params) {
+			memset(S->params, 0, S->num_params * sizeof(MYSQL_BIND));
+		}
+		pdo_mysql_error_stmt(stmt);
+		if (mysql_stmt_errno(S->stmt) == 2057) {
+			/* CR_NEW_STMT_METADATA makes the statement unusable */
+			S->stmt = NULL;
+		}
+		PDO_DBG_RETURN(0);
+	}
 
-					S->out_length[i] = 0;
+	if (!S->result) {
+		int i;
 
-					S->bound_result[i].buffer = emalloc(S->bound_result[i].buffer_length);
-					S->bound_result[i].is_null = &S->out_null[i];
-					S->bound_result[i].length = &S->out_length[i];
-					S->bound_result[i].buffer_type = MYSQL_TYPE_STRING;
+		/* figure out the result set format, if any */
+		S->result = mysql_stmt_result_metadata(S->stmt);
+		if (S->result) {
+			int calc_max_length = H->buffered && S->max_length == 1;
+			S->fields = mysql_fetch_fields(S->result);
+			if (S->bound_result) {
+				int i;
+				for (i = 0; i < stmt->column_count; i++) {
+					efree(S->bound_result[i].buffer);
 				}
+				efree(S->bound_result);
+				efree(S->out_null);
+				efree(S->out_length);
+			}
 
-				if (mysql_stmt_bind_result(S->stmt, S->bound_result)) {
-					pdo_mysql_error_stmt(stmt);
-					return 0;
+			stmt->column_count = (int)mysql_num_fields(S->result);
+			S->bound_result = ecalloc(stmt->column_count, sizeof(MYSQL_BIND));
+			S->out_null = ecalloc(stmt->column_count, sizeof(my_bool));
+			S->out_length = ecalloc(stmt->column_count, sizeof(unsigned long));
+
+			/* summon memory to hold the row */
+			for (i = 0; i < stmt->column_count; i++) {
+				if (calc_max_length && S->fields[i].type == FIELD_TYPE_BLOB) {
+					my_bool on = 1;
+					mysql_stmt_attr_set(S->stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);
+					calc_max_length = 0;
 				}
+				switch (S->fields[i].type) {
+					case FIELD_TYPE_INT24:
+						S->bound_result[i].buffer_length = MAX_MEDIUMINT_WIDTH + 1;
+						break;
+					case FIELD_TYPE_LONG:
+						S->bound_result[i].buffer_length = MAX_INT_WIDTH + 1;
+						break;
+					case FIELD_TYPE_LONGLONG:
+						S->bound_result[i].buffer_length = MAX_BIGINT_WIDTH + 1;
+						break;
+					case FIELD_TYPE_TINY:
+						S->bound_result[i].buffer_length = MAX_TINYINT_WIDTH + 1;
+						break;
+					case FIELD_TYPE_SHORT:
+						S->bound_result[i].buffer_length = MAX_SMALLINT_WIDTH + 1;
+						break;
+					default:
+						S->bound_result[i].buffer_length =
+							S->fields[i].max_length? S->fields[i].max_length:
+							S->fields[i].length;
+						/* work-around for longtext and alike */
+						if (S->bound_result[i].buffer_length > H->max_buffer_size) {
+							S->bound_result[i].buffer_length = H->max_buffer_size;
+						}
+				}
 
-				/* if buffered, pre-fetch all the data */
-				if (H->buffered) {
-					mysql_stmt_store_result(S->stmt);
+				/* there are cases where the length reported by mysql is too short.
+				 * eg: when describing a table that contains an enum column. Since
+				 * we have no way of knowing the true length either, we'll bump up
+				 * our buffer size to a reasonable size, just in case */
+				if (S->fields[i].max_length == 0 && S->bound_result[i].buffer_length < 128 && MYSQL_TYPE_VAR_STRING) {
+					S->bound_result[i].buffer_length = 128;
 				}
+
+				S->out_length[i] = 0;
+
+				S->bound_result[i].buffer = emalloc(S->bound_result[i].buffer_length);
+				S->bound_result[i].is_null = &S->out_null[i];
+				S->bound_result[i].length = &S->out_length[i];
+				S->bound_result[i].buffer_type = MYSQL_TYPE_STRING;
 			}
-		}
 
-		row_count = mysql_stmt_affected_rows(S->stmt);
-		if (row_count != (my_ulonglong)-1) {
-			stmt->row_count = row_count;
+			if (mysql_stmt_bind_result(S->stmt, S->bound_result)) {
+				pdo_mysql_error_stmt(stmt);
+				PDO_DBG_RETURN(0);
+			}
+
+			/* if buffered, pre-fetch all the data */
+			if (H->buffered) {
+				mysql_stmt_store_result(S->stmt);
+			}
 		}
-		return 1;
 	}
+
+	pdo_mysql_stmt_set_row_count(stmt TSRMLS_CC);
+	PDO_DBG_RETURN(1);
+}
+/* }}} */
 #endif
-	/* ensure that we free any previous unfetched results */
+
+#ifdef PDO_USE_MYSQLND
+static int pdo_mysql_stmt_execute_prepared_mysqlnd(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
+{
+	pdo_mysql_stmt *S = stmt->driver_data;
+	pdo_mysql_db_handle *H = S->H;
+	int i;
+
+	PDO_DBG_ENTER("pdo_mysql_stmt_execute_prepared_mysqlnd");
+
+	if (mysql_stmt_execute(S->stmt)) {
+		pdo_mysql_error_stmt(stmt);
+		PDO_DBG_RETURN(0);
+	}
+
 	if (S->result) {
+		/* TODO: add a test to check if we really have zvals here... */
 		mysql_free_result(S->result);
 		S->result = NULL;
 	}
 
-	if (mysql_real_query(H->server, stmt->active_query_string, stmt->active_query_stringlen) != 0) {
-		pdo_mysql_error_stmt(stmt);
-		return 0;
+	/* for SHOW/DESCRIBE and others the column/field count is not available before execute */
+	stmt->column_count = mysql_stmt_field_count(S->stmt);
+	for (i = 0; i < stmt->column_count; i++) {
+		mysqlnd_stmt_bind_one_result(S->stmt, i);
 	}
 
-	row_count = mysql_affected_rows(H->server);
-	if (row_count == (my_ulonglong)-1) {
-		/* we either have a query that returned a result set or an error occured
-		   lets see if we have access to a result set */
-		if (!H->buffered) {
-			S->result = mysql_use_result(H->server);
-		} else {
-			S->result = mysql_store_result(H->server);
+	S->result = mysqlnd_stmt_result_metadata(S->stmt);
+	if (S->result) {
+		S->fields = mysql_fetch_fields(S->result);
+		/* if buffered, pre-fetch all the data */
+		if (H->buffered) {
+			if (mysql_stmt_store_result(S->stmt)) {
+				PDO_DBG_RETURN(0);
+			}
 		}
-		if (NULL == S->result) {
-			pdo_mysql_error_stmt(stmt);
-			return 0;
-		}
+	}
 
-		stmt->row_count = mysql_num_rows(S->result);
+	pdo_mysql_stmt_set_row_count(stmt TSRMLS_CC);
+	PDO_DBG_RETURN(1);
+}
+/* }}} */
+#endif
 
-		if (!stmt->executed) {
-			stmt->column_count = (int) mysql_num_fields(S->result);
-			S->fields = mysql_fetch_fields(S->result);
-		}
-	} else {
-		/* this was a DML or DDL query (INSERT, UPDATE, DELETE, ... */
-		stmt->row_count = row_count;
+static int pdo_mysql_stmt_execute(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
+{
+	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
+	pdo_mysql_db_handle *H = S->H;
+	PDO_DBG_ENTER("pdo_mysql_stmt_execute");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
+
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
+	if (S->stmt) {
+		PDO_DBG_RETURN(pdo_mysql_stmt_execute_prepared(stmt));
 	}
+#endif
 
-	return 1;
+	/* ensure that we free any previous unfetched results */
+	if (S->result) {
+		mysql_free_result(S->result);
+		S->result = NULL;
+	}
+
+	if (mysql_real_query(H->server, stmt->active_query_string, stmt->active_query_stringlen) != 0) {
+		pdo_mysql_error_stmt(stmt);
+		PDO_DBG_RETURN(0);
+	}
+
+	PDO_DBG_RETURN(pdo_mysql_fill_stmt_from_result(stmt TSRMLS_CC));
 }
+/* }}} */
 
-static int pdo_mysql_stmt_next_rowset(pdo_stmt_t *stmt TSRMLS_DC)
+static int pdo_mysql_stmt_next_rowset(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
 {
-#if HAVE_MYSQL_NEXT_RESULT
+#if HAVE_MYSQL_NEXT_RESULT || PDO_USE_MYSQLND
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 	pdo_mysql_db_handle *H = S->H;
-	my_ulonglong row_count;
+	long row_count;
 	int ret;
+	PDO_DBG_ENTER("pdo_mysql_stmt_next_rowset");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
 
-	/* ensure that we free any previous unfetched results */
+#if PDO_USE_MYSQLND
+	if (!H->emulate_prepare) {
+		if (!mysqlnd_stmt_more_results(S->stmt)) {
+			PDO_DBG_RETURN(0);
+		}
+		if (mysqlnd_stmt_next_result(S->stmt)) {
+			PDO_DBG_RETURN(0);
+		}
+
+		if (!mysqlnd_stmt_more_results(S->stmt)) {
+			/*
+			MySQL gives us n + 1 result sets for
+			CALL proc() and n result sets returned by the proc itself.
+			Result set n + 1 is about the procedure call itself.
+			As the PDO emulation does not return it, we skip it as well
+			*/
+			PDO_DBG_RETURN(0);
+		}
+
+		/* TODO - this code is stolen from execute() - see above */
+		if (S->result) {
+			mysql_free_result(S->result);
+			S->result = NULL;
+		}
+		{
+			/* for SHOW/DESCRIBE and others the column/field count is not available before execute */
+			int i;
+
+			stmt->column_count = mysql_stmt_field_count(S->stmt);
+			for (i = 0; i < stmt->column_count; i++) {
+				mysqlnd_stmt_bind_one_result(S->stmt, i);
+			}
+		}
+
+		S->result = mysqlnd_stmt_result_metadata(S->stmt);
+		if (S->result) {
+			S->fields = mysql_fetch_fields(S->result);
+
+			/* if buffered, pre-fetch all the data */
+			if (H->buffered) {
+				if (mysql_stmt_store_result(S->stmt)) {
+					PDO_DBG_RETURN(1);
+				}
+			}
+		}
+		row_count = (long) mysql_stmt_affected_rows(S->stmt);
+		if (row_count != (long)-1) {
+			stmt->row_count = row_count;
+		}
+		PDO_DBG_RETURN(1);
+	}
+#endif
+
+/* ensure that we free any previous unfetched results */
 #if HAVE_MYSQL_STMT_PREPARE
 	if (S->stmt) {
+		stmt->column_count = (int)mysql_num_fields(S->result);
 		mysql_stmt_free_result(S->stmt);
 	}
 #endif
@@ -265,80 +422,113 @@
 	}
 
 	ret = mysql_next_result(H->server);
-
+#if PDO_USE_MYSQLND
+	/* for whatever reason mysqlnd breaks with libmysql compatibility at the C level, no -1 */
+	if (PASS != ret) {
+		pdo_mysql_error_stmt(stmt);
+		PDO_DBG_RETURN(0);
+	}
+	if (mysql_more_results(H->server)) {
+		PDO_DBG_RETURN(pdo_mysql_fill_stmt_from_result(stmt TSRMLS_CC));
+	} else {
+		/* No more results */
+		PDO_DBG_RETURN(0);
+	}
+#else
 	if (ret > 0) {
 		pdo_mysql_error_stmt(stmt);
-		return 0;
+		PDO_DBG_RETURN(0);
 	} else if (ret < 0) {
 		/* No more results */
-		return 0;
+		PDO_DBG_RETURN(0);
 	} else {
-		if (!H->buffered) {
-			S->result = mysql_use_result(H->server);
-			row_count = 0;
-		} else {
-			S->result = mysql_store_result(H->server);
-			if ((my_ulonglong)-1 == (row_count = mysql_affected_rows(H->server))) {
-				pdo_mysql_error_stmt(stmt);
-				return 0;
-			}
-		}
-
-		if (NULL == S->result) {
-			return 0;
-		}
-
-		stmt->row_count = row_count;
-		stmt->column_count = (int) mysql_num_fields(S->result);
-		S->fields = mysql_fetch_fields(S->result);
-		return 1;
+		PDO_DBG_RETURN(pdo_mysql_fill_stmt_from_result(stmt TSRMLS_CC));
 	}
+#endif
+
 #else
 	strcpy(stmt->error_code, "HYC00");
-	return 0;
-#endif
+	PDO_DBG_RETURN(0);
+#endif /* HAVE_MYSQL_STMT_PREPARE */
 }
+/* }}} */
 
 
-static int pdo_mysql_stmt_param_hook(pdo_stmt_t *stmt, struct pdo_bound_param_data *param,
-		enum pdo_param_event event_type TSRMLS_DC)
+static const char * const pdo_param_event_names[] =
 {
-#if HAVE_MYSQL_STMT_PREPARE
+	"PDO_PARAM_EVT_ALLOC",
+	"PDO_PARAM_EVT_FREE",
+	"PDO_PARAM_EVT_EXEC_PRE",
+	"PDO_PARAM_EVT_EXEC_POST",
+	"PDO_PARAM_EVT_FETCH_PRE",
+	"PDO_PARAM_EVT_FETCH_POST",
+	"PDO_PARAM_EVT_NORMALIZE",
+};
+
+
+static int pdo_mysql_stmt_param_hook(pdo_stmt_t *stmt, struct pdo_bound_param_data *param, enum pdo_param_event event_type TSRMLS_DC) /* {{{ */
+{
+#ifndef PDO_USE_MYSQLND
+	PDO_MYSQL_PARAM_BIND *b;
+#endif
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
-	MYSQL_BIND *b;
 
+	PDO_DBG_ENTER("pdo_mysql_stmt_param_hook");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
+	PDO_DBG_INF_FMT("event = %s", pdo_param_event_names[event_type]);
 	if (S->stmt && param->is_param) {
 		switch (event_type) {
 			case PDO_PARAM_EVT_ALLOC:
 				/* sanity check parameter number range */
 				if (param->paramno < 0 || param->paramno >= S->num_params) {
 					strcpy(stmt->error_code, "HY093");
-					return 0;
+					PDO_DBG_RETURN(0);
 				}
+				S->params_given++;
+
+#ifndef PDO_USE_MYSQLND
 				b = &S->params[param->paramno];
 				param->driver_data = b;
 				b->is_null = &S->in_null[param->paramno];
 				b->length = &S->in_length[param->paramno];
-				return 1;
+				/* recall how many parameters have been provided */
+#endif
+				PDO_DBG_RETURN(1);
 
 			case PDO_PARAM_EVT_EXEC_PRE:
-				b = (MYSQL_BIND*)param->driver_data;
+				if (S->params_given < (unsigned int) S->num_params) {
+					/* too few parameter bound */
+					PDO_DBG_ERR("too few parameters bound");
+					strcpy(stmt->error_code, "HY093");
+					PDO_DBG_RETURN(0);
+				}
 
+#if PDO_USE_MYSQLND
+				if (PDO_PARAM_TYPE(param->param_type) == PDO_PARAM_NULL ||
+						Z_TYPE_P(param->parameter) == IS_NULL) {
+					mysqlnd_stmt_bind_one_param(S->stmt, param->paramno, param->parameter, MYSQL_TYPE_NULL);
+					PDO_DBG_RETURN(1);
+				}
+#else
+				b = (PDO_MYSQL_PARAM_BIND*)param->driver_data;
 				*b->is_null = 0;
-				if (PDO_PARAM_TYPE(param->param_type) == PDO_PARAM_NULL || 
+				if (PDO_PARAM_TYPE(param->param_type) == PDO_PARAM_NULL ||
 						Z_TYPE_P(param->parameter) == IS_NULL) {
 					*b->is_null = 1;
 					b->buffer_type = MYSQL_TYPE_STRING;
 					b->buffer = NULL;
 					b->buffer_length = 0;
 					*b->length = 0;
-					return 1;
+					PDO_DBG_RETURN(1);
 				}
-	
+#endif /* PDO_USE_MYSQLND */
+
 				switch (PDO_PARAM_TYPE(param->param_type)) {
 					case PDO_PARAM_STMT:
-						return 0;
+						PDO_DBG_RETURN(0);
 					case PDO_PARAM_LOB:
+						PDO_DBG_INF("PDO_PARAM_LOB");
 						if (Z_TYPE_P(param->parameter) == IS_RESOURCE) {
 							php_stream *stm;
 							php_stream_from_zval_no_verify(stm, &param->parameter);
@@ -357,131 +547,221 @@
 					default:
 						;
 				}
-			
+
+#if PDO_USE_MYSQLND
+				/* Is it really correct to check the zval's type? - But well, that's what the old code below does, too */
+				PDO_DBG_INF_FMT("param->parameter->type=%d", Z_TYPE_P(param->parameter));
 				switch (Z_TYPE_P(param->parameter)) {
 					case IS_STRING:
+						mysqlnd_stmt_bind_one_param(S->stmt, param->paramno, param->parameter, MYSQL_TYPE_VAR_STRING);
+						break;
+					case IS_LONG:
+#if SIZEOF_LONG==8
+						mysqlnd_stmt_bind_one_param(S->stmt, param->paramno, param->parameter, MYSQL_TYPE_LONGLONG);
+#elif SIZEOF_LONG==4
+						mysqlnd_stmt_bind_one_param(S->stmt, param->paramno, param->parameter, MYSQL_TYPE_LONG);
+#endif /* SIZEOF_LONG */
+						break;
+					case IS_DOUBLE:
+						mysqlnd_stmt_bind_one_param(S->stmt, param->paramno, param->parameter, MYSQL_TYPE_DOUBLE);
+						break;
+					default:
+						PDO_DBG_RETURN(0);
+				}
+
+				PDO_DBG_RETURN(1);
+#else
+				PDO_DBG_INF_FMT("param->parameter->type=%d", Z_TYPE_P(param->parameter));
+				switch (Z_TYPE_P(param->parameter)) {
+					case IS_STRING:
 						b->buffer_type = MYSQL_TYPE_STRING;
 						b->buffer = Z_STRVAL_P(param->parameter);
 						b->buffer_length = Z_STRLEN_P(param->parameter);
 						*b->length = Z_STRLEN_P(param->parameter);
-						return 1;
+						PDO_DBG_RETURN(1);
 
 					case IS_LONG:
 						b->buffer_type = MYSQL_TYPE_LONG;
 						b->buffer = &Z_LVAL_P(param->parameter);
-						return 1;
+						PDO_DBG_RETURN(1);
 
 					case IS_DOUBLE:
 						b->buffer_type = MYSQL_TYPE_DOUBLE;
 						b->buffer = &Z_DVAL_P(param->parameter);
-						return 1;
+						PDO_DBG_RETURN(1);
 
 					default:
-						return 0;
+						PDO_DBG_RETURN(0);
 				}
+#endif /* PDO_USE_MYSQLND */
+		case PDO_PARAM_EVT_FREE:
+		case PDO_PARAM_EVT_EXEC_POST:
+		case PDO_PARAM_EVT_FETCH_PRE:
+		case PDO_PARAM_EVT_FETCH_POST:
+		case PDO_PARAM_EVT_NORMALIZE:
+			/* do nothing */
+			break;
 		}
 	}
-#endif
-	return 1;
+#endif /* HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND */
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
-static int pdo_mysql_stmt_fetch(pdo_stmt_t *stmt,
-	enum pdo_fetch_orientation ori, long offset TSRMLS_DC)
+static int pdo_mysql_stmt_fetch(pdo_stmt_t *stmt, enum pdo_fetch_orientation ori, long offset TSRMLS_DC) /* {{{ */
 {
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
-#if HAVE_MYSQL_STMT_PREPARE
+#if PDO_USE_MYSQLND
+	zend_bool fetched_anything;
+
+	PDO_DBG_ENTER("pdo_mysql_stmt_fetch");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
+	if (S->stmt) {
+		if (FAIL == mysqlnd_stmt_fetch(S->stmt, &fetched_anything) || fetched_anything == FALSE) {
+			PDO_DBG_RETURN(0);
+		}
+
+		PDO_DBG_RETURN(1);
+	}
+#else
+#	if HAVE_MYSQL_STMT_PREPARE
 	int ret;
-	
+
 	if (S->stmt) {
 		ret = mysql_stmt_fetch(S->stmt);
 
-#ifdef MYSQL_DATA_TRUNCATED
+#		ifdef MYSQL_DATA_TRUNCATED
 		if (ret == MYSQL_DATA_TRUNCATED) {
 			ret = 0;
 		}
-#endif
+#		endif
 
 		if (ret) {
 			if (ret != MYSQL_NO_DATA) {
 				pdo_mysql_error_stmt(stmt);
 			}
-			return 0;
+			PDO_DBG_RETURN(0);
 		}
 
-		return 1;
+		PDO_DBG_RETURN(1);
 	}
-#endif
+#	endif /* HAVE_MYSQL_STMT_PREPARE */
+#endif /* PDO_USE_MYSQLND */
 
 	if (!S->result) {
 		strcpy(stmt->error_code, "HY000");
-		return 0;	
+		PDO_DBG_RETURN(0);
 	}
+#if PDO_USE_MYSQLND
+	if (!S->stmt && S->current_data) {
+		mnd_free(S->current_data);
+	}
+#endif /* PDO_USE_MYSQLND */
+
 	if ((S->current_data = mysql_fetch_row(S->result)) == NULL) {
-		if (mysql_errno(S->H->server)) {
+#if PDO_USE_MYSQLND
+		if (S->result->unbuf && !S->result->unbuf->eof_reached && mysql_errno(S->H->server)) {
+#else
+		if (!S->result->eof && mysql_errno(S->H->server)) {
+#endif
 			pdo_mysql_error_stmt(stmt);
 		}
-		return 0;
-	} 
+		PDO_DBG_RETURN(0);
+	}
+
 	S->current_lengths = mysql_fetch_lengths(S->result);
-	return 1;	
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
-static int pdo_mysql_stmt_describe(pdo_stmt_t *stmt, int colno TSRMLS_DC)
+static int pdo_mysql_stmt_describe(pdo_stmt_t *stmt, int colno TSRMLS_DC) /* {{{ */
 {
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 	struct pdo_column_data *cols = stmt->columns;
-	unsigned int i;
+	int i;
 
+	PDO_DBG_ENTER("pdo_mysql_stmt_describe");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
 	if (!S->result) {
-		return 0;	
+		PDO_DBG_RETURN(0);
 	}
 
 	if (colno >= stmt->column_count) {
 		/* error invalid column */
-		return 0;
+		PDO_DBG_RETURN(0);
 	}
 
-	/* fetch all on demand, this seems easiest 
-	** if we've been here before bail out 
+	/* fetch all on demand, this seems easiest
+	** if we've been here before bail out
 	*/
 	if (cols[0].name) {
-		return 1;
+		PDO_DBG_RETURN(1);
 	}
-	for (i=0; i < stmt->column_count; i++) {
+	for (i = 0; i < stmt->column_count; i++) {
 		int namelen;
-		namelen = strlen(S->fields[i].name);
+
+		if (S->H->fetch_table_names) {
+			namelen = spprintf(&cols[i].name, 0, "%s.%s", S->fields[i].table, S->fields[i].name);
+			cols[i].namelen = namelen;
+		} else {
+			namelen = strlen(S->fields[i].name);
+			cols[i].namelen = namelen;
+			cols[i].name = estrndup(S->fields[i].name, namelen);
+		}
+
 		cols[i].precision = S->fields[i].decimals;
 		cols[i].maxlen = S->fields[i].length;
-		cols[i].namelen = namelen;
-		cols[i].name = estrndup(S->fields[i].name, namelen);
-		cols[i].param_type = PDO_PARAM_STR;
+
+#ifdef PDO_USE_MYSQLND
+		if (S->stmt) {
+			cols[i].param_type = PDO_PARAM_ZVAL;
+		} else
+#endif
+		{
+			cols[i].param_type = PDO_PARAM_STR;
+		}
 	}
-	return 1;
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
-static int pdo_mysql_stmt_get_col(pdo_stmt_t *stmt, int colno, char **ptr, unsigned long *len, int *caller_frees TSRMLS_DC)
+static int pdo_mysql_stmt_get_col(pdo_stmt_t *stmt, int colno, char **ptr, unsigned long *len, int *caller_frees TSRMLS_DC) /* {{{ */
 {
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 
-#if HAVE_MYSQL_STMT_PREPARE
+	PDO_DBG_ENTER("pdo_mysql_stmt_get_col");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
+	if (!S->result) {
+		PDO_DBG_RETURN(0);
+	}
+
+	/* With mysqlnd data is stored inside mysqlnd, not S->current_data */
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
 	if (!S->stmt) {
 #endif
 		if (S->current_data == NULL || !S->result) {
-			return 0;
+			PDO_DBG_RETURN(0);
 		}
-#if HAVE_MYSQL_STMT_PREPARE
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
 	}
 #endif
 	if (colno >= stmt->column_count) {
 		/* error invalid column */
-		return 0;
+		PDO_DBG_RETURN(0);
 	}
-#if HAVE_MYSQL_STMT_PREPARE
+#if PDO_USE_MYSQLND
 	if (S->stmt) {
+		S->stmt->data->result_bind[colno].zv->refcount++;
+		*ptr = (char*)&S->stmt->data->result_bind[colno].zv;
+		*len = sizeof(zval);
+		PDO_DBG_RETURN(1);
+	}
+#elif HAVE_MYSQL_STMT_PREPARE
+	if (S->stmt) {
 		if (S->out_null[colno]) {
 			*ptr = NULL;
 			*len = 0;
-			return 1;
+			PDO_DBG_RETURN(1);
 		}
 		*ptr = S->bound_result[colno].buffer;
 		if (S->out_length[colno] > S->bound_result[colno].buffer_length) {
@@ -489,18 +769,18 @@
 			strcpy(stmt->error_code, "01004"); /* truncated */
 			S->out_length[colno] = S->bound_result[colno].buffer_length;
 			*len = S->out_length[colno];
-			return 0;
+			PDO_DBG_RETURN(0);
 		}
 		*len = S->out_length[colno];
-		return 1;
+		PDO_DBG_RETURN(1);
 	}
-#endif
+#endif /* PDO_USE_MYSQLND else HAVE_MYSQL_STMT_PREPARE */
 	*ptr = S->current_data[colno];
 	*len = S->current_lengths[colno];
-	return 1;
-}
+	PDO_DBG_RETURN(1);
+} /* }}} */
 
-static char *type_to_name_native(int type)
+static char *type_to_name_native(int type) /* {{{ */
 {
 #define PDO_MYSQL_NATIVE_TYPE_NAME(x)	case FIELD_TYPE_##x: return #x;
 
@@ -543,21 +823,24 @@
         default:
             return NULL;
     }
-}
+#undef PDO_MYSQL_NATIVE_TYPE_NAME
+} /* }}} */
 
-static int pdo_mysql_stmt_col_meta(pdo_stmt_t *stmt, long colno, zval *return_value TSRMLS_DC)
+static int pdo_mysql_stmt_col_meta(pdo_stmt_t *stmt, long colno, zval *return_value TSRMLS_DC) /* {{{ */
 {
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
-	MYSQL_FIELD *F;
+	const MYSQL_FIELD *F;
 	zval *flags;
 	char *str;
-	
+
+	PDO_DBG_ENTER("pdo_mysql_stmt_col_meta");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
 	if (!S->result) {
-		return FAILURE;
+		PDO_DBG_RETURN(FAILURE);
 	}
 	if (colno >= stmt->column_count) {
 		/* error invalid column */
-		return FAILURE;
+		PDO_DBG_RETURN(FAILURE);
 	}
 
 	array_init(return_value);
@@ -589,33 +872,49 @@
 		add_assoc_string(return_value, "native_type", str, 1);
 	}
 
+#ifdef PDO_USE_MYSQLND
+	switch (F->type) {
+		case MYSQL_TYPE_BIT:
+		case MYSQL_TYPE_YEAR:
+		case MYSQL_TYPE_TINY:
+		case MYSQL_TYPE_SHORT:
+		case MYSQL_TYPE_INT24:
+		case MYSQL_TYPE_LONG:
+#if SIZEOF_LONG==8
+		case MYSQL_TYPE_LONGLONG:
+#endif
+			add_assoc_long(return_value, "pdo_type", PDO_PARAM_INT);
+			break;
+		default:
+			add_assoc_long(return_value, "pdo_type", PDO_PARAM_STR);
+			break;
+	}
+#endif
+
 	add_assoc_zval(return_value, "flags", flags);
-	add_assoc_string(return_value, "table",(F->table?F->table:""), 1);
-	return SUCCESS;
-}
+	add_assoc_string(return_value, "table",(char *) (F->table?F->table:""), 1);
+	PDO_DBG_RETURN(SUCCESS);
+} /* }}} */
 
-static int pdo_mysql_stmt_cursor_closer(pdo_stmt_t *stmt TSRMLS_DC)
+static int pdo_mysql_stmt_cursor_closer(pdo_stmt_t *stmt TSRMLS_DC) /* {{{ */
 {
 	pdo_mysql_stmt *S = (pdo_mysql_stmt*)stmt->driver_data;
 
+	PDO_DBG_ENTER("pdo_mysql_stmt_cursor_closer");
+	PDO_DBG_INF_FMT("stmt=%p", S->stmt);
 	if (S->result) {
 		mysql_free_result(S->result);
 		S->result = NULL;
 	}
-#if HAVE_MYSQL_STMT_PREPARE
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
 	if (S->stmt) {
 		int retval;
-		if (!S->H->buffered) {
-			retval = mysql_stmt_close(S->stmt);
-			S->stmt = NULL;
-		} else {
-			retval = mysql_stmt_free_result(S->stmt);
-		}
-		return retval ? 0 : 1;
+		retval = mysql_stmt_free_result(S->stmt);
+		PDO_DBG_RETURN(retval ? 0 : 1);
 	}
 #endif
 
-#if HAVE_MYSQL_NEXT_RESULT
+#if HAVE_MYSQL_NEXT_RESULT || PDO_USE_MYSQLND
 	while (mysql_more_results(S->H->server)) {
 		MYSQL_RES *res;
 		if (mysql_next_result(S->H->server) != 0) {
@@ -627,8 +926,9 @@
 		}
 	}
 #endif
-	return 1;
+	PDO_DBG_RETURN(1);
 }
+/* }}} */
 
 struct pdo_stmt_methods mysql_stmt_methods = {
 	pdo_mysql_stmt_dtor,
--- a/ext/pdo_mysql/pdo_mysql.c
+++ b/ext/pdo_mysql/pdo_mysql.c
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -13,10 +13,11 @@
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   | Author: George Schlossnagle <george@omniti.com>                      |
+  |         Johannes Schlueter <johannes@mysql.com>                      |
   +----------------------------------------------------------------------+
 */
 
-/* $Id: pdo_mysql.c 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -30,81 +31,196 @@
 #include "php_pdo_mysql.h"
 #include "php_pdo_mysql_int.h"
 
-/* {{{ pdo_mysql_functions[] */
-zend_function_entry pdo_mysql_functions[] = {
-	{NULL, NULL, NULL}
-};
-/* }}} */
+#ifdef COMPILE_DL_PDO_MYSQL
+ZEND_GET_MODULE(pdo_mysql)
+#endif
 
-/* {{{ pdo_mysql_functions[] */
-#if ZEND_MODULE_API_NO >= 20050922
-static zend_module_dep pdo_mysql_deps[] = {
-	ZEND_MOD_REQUIRED("pdo")
-	{NULL, NULL, NULL}
-};
+ZEND_DECLARE_MODULE_GLOBALS(pdo_mysql)
+
+/*
+ The default socket location is sometimes defined by configure.
+ With libmysql `mysql_config --socket` will fill PDO_MYSQL_UNIX_ADDR
+ and the user can use --with-mysql-sock=SOCKET which will fill
+ PDO_MYSQL_UNIX_ADDR. If both aren't set we're using mysqlnd and use
+ /tmp/mysql.sock as default on *nix and NULL for Windows (default
+ named pipe name is set in mysqlnd).
+*/
+#ifndef PDO_MYSQL_UNIX_ADDR
+# ifdef PHP_MYSQL_UNIX_SOCK_ADDR
+#  define PDO_MYSQL_UNIX_ADDR PHP_MYSQL_UNIX_SOCK_ADDR
+# else
+#  if !PHP_WIN32
+#   define PDO_MYSQL_UNIX_ADDR "/tmp/mysql.sock"
+#  else
+#   define PDO_MYSQL_UNIX_ADDR NULL
+#  endif
+# endif
 #endif
-/* }}} */
 
-/* {{{ pdo_mysql_module_entry */
-zend_module_entry pdo_mysql_module_entry = {
-#if ZEND_MODULE_API_NO >= 20050922
-	STANDARD_MODULE_HEADER_EX, NULL,
-	pdo_mysql_deps,
-#else
-	STANDARD_MODULE_HEADER,
+/* {{{ PHP_INI_BEGIN
+*/
+PHP_INI_BEGIN()
+#ifndef PHP_WIN32
+	STD_PHP_INI_ENTRY("pdo_mysql.default_socket", PDO_MYSQL_UNIX_ADDR, PHP_INI_SYSTEM, OnUpdateStringUnempty, default_socket, zend_pdo_mysql_globals, pdo_mysql_globals)
 #endif
-	"pdo_mysql",
-	pdo_mysql_functions,
-	PHP_MINIT(pdo_mysql),
-	PHP_MSHUTDOWN(pdo_mysql),
-	NULL,
-	NULL,
-	PHP_MINFO(pdo_mysql),
-	"1.0.2",
-	STANDARD_MODULE_PROPERTIES
-};
+#if PDO_DBG_ENABLED
+	STD_PHP_INI_ENTRY("pdo_mysql.debug",	NULL, PHP_INI_SYSTEM, OnUpdateString, debug, zend_pdo_mysql_globals, pdo_mysql_globals)
+#endif
+PHP_INI_END()
 /* }}} */
 
-#ifdef COMPILE_DL_PDO_MYSQL
-ZEND_GET_MODULE(pdo_mysql)
-#endif
-
 /* true global environment */
 
 /* {{{ PHP_MINIT_FUNCTION
  */
-PHP_MINIT_FUNCTION(pdo_mysql)
+static PHP_MINIT_FUNCTION(pdo_mysql)
 {
+	REGISTER_INI_ENTRIES();
+
 	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_USE_BUFFERED_QUERY", (long)PDO_MYSQL_ATTR_USE_BUFFERED_QUERY);
 	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_LOCAL_INFILE", (long)PDO_MYSQL_ATTR_LOCAL_INFILE);
 	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_INIT_COMMAND", (long)PDO_MYSQL_ATTR_INIT_COMMAND);
+#ifndef PDO_USE_MYSQLND
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_MAX_BUFFER_SIZE", (long)PDO_MYSQL_ATTR_MAX_BUFFER_SIZE);
 	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_READ_DEFAULT_FILE", (long)PDO_MYSQL_ATTR_READ_DEFAULT_FILE);
 	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_READ_DEFAULT_GROUP", (long)PDO_MYSQL_ATTR_READ_DEFAULT_GROUP);
-	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_MAX_BUFFER_SIZE", (long)PDO_MYSQL_ATTR_MAX_BUFFER_SIZE);
+#endif
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_COMPRESS", (long)PDO_MYSQL_ATTR_COMPRESS);
 	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_DIRECT_QUERY", (long)PDO_MYSQL_ATTR_DIRECT_QUERY);
-
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_FOUND_ROWS", (long)PDO_MYSQL_ATTR_FOUND_ROWS);
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_IGNORE_SPACE", (long)PDO_MYSQL_ATTR_IGNORE_SPACE);
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_SSL_KEY", (long)PDO_MYSQL_ATTR_SSL_KEY);
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_SSL_CERT", (long)PDO_MYSQL_ATTR_SSL_CERT);
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_SSL_CA", (long)PDO_MYSQL_ATTR_SSL_CA);
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_SSL_CAPATH", (long)PDO_MYSQL_ATTR_SSL_CAPATH);
+	REGISTER_PDO_CLASS_CONST_LONG("MYSQL_ATTR_SSL_CIPHER", (long)PDO_MYSQL_ATTR_SSL_CIPHER);
 	return php_pdo_register_driver(&pdo_mysql_driver);
 }
 /* }}} */
 
 /* {{{ PHP_MSHUTDOWN_FUNCTION
  */
-PHP_MSHUTDOWN_FUNCTION(pdo_mysql)
+static PHP_MSHUTDOWN_FUNCTION(pdo_mysql)
 {
 	php_pdo_unregister_driver(&pdo_mysql_driver);
+#if PDO_USE_MYSQLND
+	UNREGISTER_INI_ENTRIES();
+#endif
+
 	return SUCCESS;
 }
 /* }}} */
 
 /* {{{ PHP_MINFO_FUNCTION
  */
-PHP_MINFO_FUNCTION(pdo_mysql)
+static PHP_MINFO_FUNCTION(pdo_mysql)
 {
 	php_info_print_table_start();
-	php_info_print_table_header(2, "PDO Driver for MySQL, client library version", mysql_get_client_info());
+
+	php_info_print_table_header(2, "PDO Driver for MySQL", "enabled");
+	php_info_print_table_row(2, "Client API version", mysql_get_client_info());
+
 	php_info_print_table_end();
+
+#ifndef PHP_WIN32
+	DISPLAY_INI_ENTRIES();
+#endif
 }
 /* }}} */
+
+
+#if PDO_USE_MYSQLND && PDO_DBG_ENABLED
+/* {{{ PHP_RINIT_FUNCTION
+ */
+static PHP_RINIT_FUNCTION(pdo_mysql)
+{
+	if (PDO_MYSQL_G(debug)) {
+		MYSQLND_DEBUG *dbg = mysqlnd_debug_init(mysqlnd_debug_std_no_trace_funcs TSRMLS_CC);
+		if (!dbg) {
+			return FAILURE;
+		}
+		dbg->m->set_mode(dbg, PDO_MYSQL_G(debug));
+		PDO_MYSQL_G(dbg) = dbg;
+	}
+
+	return SUCCESS;
+}
+/* }}} */
+
+/* {{{ PHP_RSHUTDOWN_FUNCTION
+ */
+static PHP_RSHUTDOWN_FUNCTION(pdo_mysql)
+{
+	MYSQLND_DEBUG *dbg = PDO_MYSQL_G(dbg);
+	PDO_DBG_ENTER("RSHUTDOWN");
+	if (dbg) {
+		dbg->m->close(dbg);
+		dbg->m->free_handle(dbg);
+		PDO_MYSQL_G(dbg) = NULL;
+	}
+
+	return SUCCESS;
+}
+/* }}} */
+#endif
+
+/* {{{ PHP_GINIT_FUNCTION
+ */
+static PHP_GINIT_FUNCTION(pdo_mysql)
+{
+#ifndef PHP_WIN32
+	pdo_mysql_globals->default_socket = NULL;
+#endif
+#if PDO_DBG_ENABLED
+	pdo_mysql_globals->debug = NULL;	/* The actual string */
+	pdo_mysql_globals->dbg = NULL;	/* The DBG object*/
+#endif
+}
+/* }}} */
+
+/* {{{ pdo_mysql_functions[] */
+const zend_function_entry pdo_mysql_functions[] = {
+	{NULL, NULL, NULL}
+};
+/* }}} */
+
+/* {{{ pdo_mysql_deps[] */
+#if ZEND_MODULE_API_NO >= 20050922
+static const zend_module_dep pdo_mysql_deps[] = {
+	ZEND_MOD_REQUIRED("pdo")
+#ifdef PDO_USE_MYSQLND
+	ZEND_MOD_REQUIRED("mysqlnd")
+#endif
+	{NULL, NULL, NULL}
+};
+#endif
+/* }}} */
+
+/* {{{ pdo_mysql_module_entry */
+zend_module_entry pdo_mysql_module_entry = {
+	STANDARD_MODULE_HEADER_EX, NULL,
+	pdo_mysql_deps,
+	"pdo_mysql",
+	pdo_mysql_functions,
+	PHP_MINIT(pdo_mysql),
+	PHP_MSHUTDOWN(pdo_mysql),
+#if PDO_USE_MYSQLND && PDO_DBG_ENABLED
+	PHP_RINIT(pdo_mysql),
+	PHP_RSHUTDOWN(pdo_mysql),
+#else
+	NULL,
+	NULL,
+#endif
+	PHP_MINFO(pdo_mysql),
+	"1.0.2",
+	PHP_MODULE_GLOBALS(pdo_mysql),
+	PHP_GINIT(pdo_mysql),
+	NULL,
+	NULL,
+	STANDARD_MODULE_PROPERTIES_EX
+};
+/* }}} */
+
 
 /*
  * Local variables:
--- a/ext/pdo_mysql/php_pdo_mysql.h
+++ b/ext/pdo_mysql/php_pdo_mysql.h
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -16,7 +16,7 @@
   +----------------------------------------------------------------------+
 */
 
-/* $Id: php_pdo_mysql.h 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifndef PHP_PDO_MYSQL_H
 #define PHP_PDO_MYSQL_H
@@ -34,11 +34,6 @@
 #include "TSRM.h"
 #endif
 
-PHP_MINIT_FUNCTION(pdo_mysql);
-PHP_MSHUTDOWN_FUNCTION(pdo_mysql);
-PHP_RINIT_FUNCTION(pdo_mysql);
-PHP_RSHUTDOWN_FUNCTION(pdo_mysql);
-PHP_MINFO_FUNCTION(pdo_mysql);
 
 #endif	/* PHP_PDO_MYSQL_H */
 
--- a/ext/pdo_mysql/php_pdo_mysql_int.h
+++ b/ext/pdo_mysql/php_pdo_mysql_int.h
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2010 The PHP Group                                |
+  | Copyright (c) 1997-2013 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -14,16 +14,81 @@
   +----------------------------------------------------------------------+
   | Author: George Schlossnagle <george@omniti.com>                      |
   |         Wez Furlong <wez@php.net>                                    |
+  |         Johannes Schlueter <johannes@mysql.com>                      |
   +----------------------------------------------------------------------+
 */
 
-/* $Id: php_pdo_mysql_int.h 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifndef PHP_PDO_MYSQL_INT_H
 #define PHP_PDO_MYSQL_INT_H
 
-#include <mysql.h>
+#if defined(PDO_USE_MYSQLND)
+#	include "ext/mysqlnd/mysqlnd.h"
+#	include "ext/mysqlnd/mysqlnd_libmysql_compat.h"
+#	define PDO_MYSQL_PARAM_BIND MYSQLND_PARAM_BIND
+#else
+#	include <mysql.h>
+#	define PDO_MYSQL_PARAM_BIND MYSQL_BIND
+#endif
 
+#if (MYSQL_VERSION_ID >= 40113 && MYSQL_VERSION_ID < 50000) || MYSQL_VERSION_ID >= 50007 || defined(MYSQL_USE_MYSQLND)
+# define PDO_MYSQL_HAS_CHARSET
+#endif
+
+#if defined(PDO_USE_MYSQLND) && PHP_DEBUG && !defined(PHP_WIN32)
+#define PDO_DBG_ENABLED 1
+
+#define PDO_DBG_INF(msg) do { if (dbg_skip_trace == FALSE) PDO_MYSQL_G(dbg)->m->log(PDO_MYSQL_G(dbg), __LINE__, __FILE__, -1, "info : ", (msg)); } while (0)
+#define PDO_DBG_ERR(msg) do { if (dbg_skip_trace == FALSE) PDO_MYSQL_G(dbg)->m->log(PDO_MYSQL_G(dbg), __LINE__, __FILE__, -1, "error: ", (msg)); } while (0)
+#define PDO_DBG_INF_FMT(...) do { if (dbg_skip_trace == FALSE) PDO_MYSQL_G(dbg)->m->log_va(PDO_MYSQL_G(dbg), __LINE__, __FILE__, -1, "info : ", __VA_ARGS__); } while (0)
+#define PDO_DBG_ERR_FMT(...) do { if (dbg_skip_trace == FALSE) PDO_MYSQL_G(dbg)->m->log_va(PDO_MYSQL_G(dbg), __LINE__, __FILE__, -1, "error: ", __VA_ARGS__); } while (0)
+#define PDO_DBG_ENTER(func_name) zend_bool dbg_skip_trace = TRUE; if (PDO_MYSQL_G(dbg)) dbg_skip_trace = !PDO_MYSQL_G(dbg)->m->func_enter(PDO_MYSQL_G(dbg), __LINE__, __FILE__, func_name, strlen(func_name));
+#define PDO_DBG_RETURN(value)	do { if (PDO_MYSQL_G(dbg)) PDO_MYSQL_G(dbg)->m->func_leave(PDO_MYSQL_G(dbg), __LINE__, __FILE__, 0); return (value); } while (0)
+#define PDO_DBG_VOID_RETURN		do { if (PDO_MYSQL_G(dbg)) PDO_MYSQL_G(dbg)->m->func_leave(PDO_MYSQL_G(dbg), __LINE__, __FILE__, 0); return; } while (0)
+
+#else
+#define PDO_DBG_ENABLED 0
+
+static inline void PDO_DBG_INF(char *msg) {}
+static inline void PDO_DBG_ERR(char *msg) {}
+static inline void PDO_DBG_INF_FMT(char *format, ...) {}
+static inline void PDO_DBG_ERR_FMT(char *format, ...) {}
+static inline void PDO_DBG_ENTER(char *func_name) {}
+#define PDO_DBG_RETURN(value)	return (value)
+#define PDO_DBG_VOID_RETURN		return;
+
+#endif
+
+#if defined(PDO_USE_MYSQLND)
+#include "ext/mysqlnd/mysqlnd_debug.h"
+#endif
+
+ZEND_BEGIN_MODULE_GLOBALS(pdo_mysql)
+#ifndef PHP_WIN32
+	char          *default_socket;
+#endif
+#if PDO_DBG_ENABLED
+	char          *debug; /* The actual string */
+	MYSQLND_DEBUG *dbg;	/* The DBG object */
+#endif
+#if defined(PHP_WIN32) && !PDO_DBG_ENABLED
+	/* dummy member so we get at least one member in the struct
+	 * and avoids build errors.
+	 */
+	void *dummymemmber;
+#endif
+ZEND_END_MODULE_GLOBALS(pdo_mysql)
+
+ZEND_EXTERN_MODULE_GLOBALS(pdo_mysql)
+
+#ifdef ZTS
+#define PDO_MYSQL_G(v) TSRMG(pdo_mysql_globals_id, zend_pdo_mysql_globals *, v)
+#else
+#define PDO_MYSQL_G(v) (pdo_mysql_globals.v)
+#endif
+
+
 typedef struct {
 	const char *file;
 	int line;
@@ -38,8 +103,11 @@
 	unsigned attached:1;
 	unsigned buffered:1;
 	unsigned emulate_prepare:1;
-	unsigned _reserved:31;
+	unsigned fetch_table_names:1;
+	unsigned _reserved:31;	
+#if !PDO_USE_MYSQLND
 	unsigned long max_buffer_size;
+#endif
 
 	pdo_mysql_error_info einfo;
 } pdo_mysql_db_handle;
@@ -51,22 +119,31 @@
 typedef struct {
 	pdo_mysql_db_handle 	*H;
 	MYSQL_RES		*result;
-	MYSQL_FIELD	    *fields;
+	const MYSQL_FIELD	*fields;
 	MYSQL_ROW		current_data;
+#if PDO_USE_MYSQLND
+	unsigned long		*current_lengths;
+#else
 	long			*current_lengths;
+#endif
 	pdo_mysql_error_info einfo;
-#if HAVE_MYSQL_STMT_PREPARE
-	MYSQL_STMT 		*stmt;
-	
+#if HAVE_MYSQL_STMT_PREPARE || PDO_USE_MYSQLND
+#if PDO_USE_MYSQLND
+	MYSQLND_STMT 		*stmt;
+#else
+	MYSQL_STMT		*stmt;
+#endif	
 	int num_params;
-	MYSQL_BIND      *params;
+	PDO_MYSQL_PARAM_BIND	*params;
+#ifndef PDO_USE_MYSQLND
 	my_bool			*in_null;
-	unsigned long   *in_length;
-	
-	MYSQL_BIND 		*bound_result;
+	unsigned long		*in_length;
+#endif
+	PDO_MYSQL_PARAM_BIND	*bound_result;
 	my_bool			*out_null;
-	unsigned long   *out_length;
-	unsigned max_length:1;
+	unsigned long		*out_length;
+	unsigned int		params_given;
+	unsigned		max_length:1;
 #endif
 } pdo_mysql_stmt;
 
@@ -82,9 +159,20 @@
 	PDO_MYSQL_ATTR_USE_BUFFERED_QUERY = PDO_ATTR_DRIVER_SPECIFIC,
 	PDO_MYSQL_ATTR_LOCAL_INFILE,
 	PDO_MYSQL_ATTR_INIT_COMMAND,
+#ifndef PDO_USE_MYSQLND
 	PDO_MYSQL_ATTR_READ_DEFAULT_FILE,
 	PDO_MYSQL_ATTR_READ_DEFAULT_GROUP,
 	PDO_MYSQL_ATTR_MAX_BUFFER_SIZE,
+#endif
+	PDO_MYSQL_ATTR_COMPRESS,
 	PDO_MYSQL_ATTR_DIRECT_QUERY,
+	PDO_MYSQL_ATTR_FOUND_ROWS,
+	PDO_MYSQL_ATTR_IGNORE_SPACE,
+	PDO_MYSQL_ATTR_SSL_KEY,
+	PDO_MYSQL_ATTR_SSL_CERT,
+	PDO_MYSQL_ATTR_SSL_CA,
+	PDO_MYSQL_ATTR_SSL_CAPATH,
+	PDO_MYSQL_ATTR_SSL_CIPHER
 };
+
 #endif
--- a/ext/pdo_mysql/php_pdo_mysql_sqlstate.h
+++ b/ext/pdo_mysql/php_pdo_mysql_sqlstate.h
@@ -1,388 +1,646 @@
 /* DO NOT EDIT THIS FILE!!! It is auto generated by get_error_codes.php */
-#ifdef ER_DUP_KEY
-  case ER_DUP_KEY                           : return "23000";
+#ifdef ER_DUP_KEY                             
+  case ER_DUP_KEY                             : return "23000";
 #endif
-#ifdef ER_OUTOFMEMORY
-  case ER_OUTOFMEMORY                       : return "HY001";
+#ifdef ER_OUTOFMEMORY                         
+  case ER_OUTOFMEMORY                         : return "HY001";
 #endif
-#ifdef ER_OUT_OF_SORTMEMORY
-  case ER_OUT_OF_SORTMEMORY                 : return "HY001";
+#ifdef ER_OUT_OF_SORTMEMORY                   
+  case ER_OUT_OF_SORTMEMORY                   : return "HY001";
 #endif
-#ifdef ER_CON_COUNT_ERROR
-  case ER_CON_COUNT_ERROR                   : return "08004";
+#ifdef ER_CON_COUNT_ERROR                     
+  case ER_CON_COUNT_ERROR                     : return "08004";
 #endif
-#ifdef ER_BAD_HOST_ERROR
-  case ER_BAD_HOST_ERROR                    : return "08S01";
+#ifdef ER_BAD_HOST_ERROR                      
+  case ER_BAD_HOST_ERROR                      : return "08S01";
 #endif
-#ifdef ER_HANDSHAKE_ERROR
-  case ER_HANDSHAKE_ERROR                   : return "08S01";
+#ifdef ER_HANDSHAKE_ERROR                     
+  case ER_HANDSHAKE_ERROR                     : return "08S01";
 #endif
-#ifdef ER_DBACCESS_DENIED_ERROR
-  case ER_DBACCESS_DENIED_ERROR             : return "42000";
+#ifdef ER_DBACCESS_DENIED_ERROR               
+  case ER_DBACCESS_DENIED_ERROR               : return "42000";
 #endif
-#ifdef ER_ACCESS_DENIED_ERROR
-  case ER_ACCESS_DENIED_ERROR               : return "28000";
+#ifdef ER_ACCESS_DENIED_ERROR                 
+  case ER_ACCESS_DENIED_ERROR                 : return "28000";
 #endif
-#ifdef ER_NO_DB_ERROR
-  case ER_NO_DB_ERROR                       : return "3D000";
+#ifdef ER_NO_DB_ERROR                         
+  case ER_NO_DB_ERROR                         : return "3D000";
 #endif
-#ifdef ER_UNKNOWN_COM_ERROR
-  case ER_UNKNOWN_COM_ERROR                 : return "08S01";
+#ifdef ER_UNKNOWN_COM_ERROR                   
+  case ER_UNKNOWN_COM_ERROR                   : return "08S01";
 #endif
-#ifdef ER_BAD_NULL_ERROR
-  case ER_BAD_NULL_ERROR                    : return "23000";
+#ifdef ER_BAD_NULL_ERROR                      
+  case ER_BAD_NULL_ERROR                      : return "23000";
 #endif
-#ifdef ER_BAD_DB_ERROR
-  case ER_BAD_DB_ERROR                      : return "42000";
+#ifdef ER_BAD_DB_ERROR                        
+  case ER_BAD_DB_ERROR                        : return "42000";
 #endif
-#ifdef ER_TABLE_EXISTS_ERROR
-  case ER_TABLE_EXISTS_ERROR                : return "42S01";
+#ifdef ER_TABLE_EXISTS_ERROR                  
+  case ER_TABLE_EXISTS_ERROR                  : return "42S01";
 #endif
-#ifdef ER_BAD_TABLE_ERROR
-  case ER_BAD_TABLE_ERROR                   : return "42S02";
+#ifdef ER_BAD_TABLE_ERROR                     
+  case ER_BAD_TABLE_ERROR                     : return "42S02";
 #endif
-#ifdef ER_NON_UNIQ_ERROR
-  case ER_NON_UNIQ_ERROR                    : return "23000";
+#ifdef ER_NON_UNIQ_ERROR                      
+  case ER_NON_UNIQ_ERROR                      : return "23000";
 #endif
-#ifdef ER_SERVER_SHUTDOWN
-  case ER_SERVER_SHUTDOWN                   : return "08S01";
+#ifdef ER_SERVER_SHUTDOWN                     
+  case ER_SERVER_SHUTDOWN                     : return "08S01";
 #endif
-#ifdef ER_BAD_FIELD_ERROR
-  case ER_BAD_FIELD_ERROR                   : return "42S22";
+#ifdef ER_BAD_FIELD_ERROR                     
+  case ER_BAD_FIELD_ERROR                     : return "42S22";
 #endif
-#ifdef ER_WRONG_FIELD_WITH_GROUP
-  case ER_WRONG_FIELD_WITH_GROUP            : return "42000";
+#ifdef ER_WRONG_FIELD_WITH_GROUP              
+  case ER_WRONG_FIELD_WITH_GROUP              : return "42000";
 #endif
-#ifdef ER_WRONG_GROUP_FIELD
-  case ER_WRONG_GROUP_FIELD                 : return "42000";
+#ifdef ER_WRONG_GROUP_FIELD                   
+  case ER_WRONG_GROUP_FIELD                   : return "42000";
 #endif
-#ifdef ER_WRONG_SUM_SELECT
-  case ER_WRONG_SUM_SELECT                  : return "42000";
+#ifdef ER_WRONG_SUM_SELECT                    
+  case ER_WRONG_SUM_SELECT                    : return "42000";
 #endif
-#ifdef ER_WRONG_VALUE_COUNT
-  case ER_WRONG_VALUE_COUNT                 : return "21S01";
+#ifdef ER_WRONG_VALUE_COUNT                   
+  case ER_WRONG_VALUE_COUNT                   : return "21S01";
 #endif
-#ifdef ER_TOO_LONG_IDENT
-  case ER_TOO_LONG_IDENT                    : return "42000";
+#ifdef ER_TOO_LONG_IDENT                      
+  case ER_TOO_LONG_IDENT                      : return "42000";
 #endif
-#ifdef ER_DUP_FIELDNAME
-  case ER_DUP_FIELDNAME                     : return "42S21";
+#ifdef ER_DUP_FIELDNAME                       
+  case ER_DUP_FIELDNAME                       : return "42S21";
 #endif
-#ifdef ER_DUP_KEYNAME
-  case ER_DUP_KEYNAME                       : return "42000";
+#ifdef ER_DUP_KEYNAME                         
+  case ER_DUP_KEYNAME                         : return "42000";
 #endif
-#ifdef ER_DUP_ENTRY
-  case ER_DUP_ENTRY                         : return "23000";
+#ifdef ER_DUP_ENTRY                           
+  case ER_DUP_ENTRY                           : return "23000";
 #endif
-#ifdef ER_WRONG_FIELD_SPEC
-  case ER_WRONG_FIELD_SPEC                  : return "42000";
+#ifdef ER_WRONG_FIELD_SPEC                    
+  case ER_WRONG_FIELD_SPEC                    : return "42000";
 #endif
-#ifdef ER_PARSE_ERROR
-  case ER_PARSE_ERROR                       : return "42000";
+#ifdef ER_PARSE_ERROR                         
+  case ER_PARSE_ERROR                         : return "42000";
 #endif
-#ifdef ER_NONUNIQ_TABLE
-  case ER_NONUNIQ_TABLE                     : return "42000";
+#ifdef ER_EMPTY_QUERY                         
+  case ER_EMPTY_QUERY                         : return "42000";
 #endif
-#ifdef ER_INVALID_DEFAULT
-  case ER_INVALID_DEFAULT                   : return "42000";
+#ifdef ER_NONUNIQ_TABLE                       
+  case ER_NONUNIQ_TABLE                       : return "42000";
 #endif
-#ifdef ER_MULTIPLE_PRI_KEY
-  case ER_MULTIPLE_PRI_KEY                  : return "42000";
+#ifdef ER_INVALID_DEFAULT                     
+  case ER_INVALID_DEFAULT                     : return "42000";
 #endif
-#ifdef ER_TOO_MANY_KEYS
-  case ER_TOO_MANY_KEYS                     : return "42000";
+#ifdef ER_MULTIPLE_PRI_KEY                    
+  case ER_MULTIPLE_PRI_KEY                    : return "42000";
 #endif
-#ifdef ER_TOO_MANY_KEY_PARTS
-  case ER_TOO_MANY_KEY_PARTS                : return "42000";
+#ifdef ER_TOO_MANY_KEYS                       
+  case ER_TOO_MANY_KEYS                       : return "42000";
 #endif
-#ifdef ER_TOO_LONG_KEY
-  case ER_TOO_LONG_KEY                      : return "42000";
+#ifdef ER_TOO_MANY_KEY_PARTS                  
+  case ER_TOO_MANY_KEY_PARTS                  : return "42000";
 #endif
-#ifdef ER_KEY_COLUMN_DOES_NOT_EXITS
-  case ER_KEY_COLUMN_DOES_NOT_EXITS         : return "42000";
+#ifdef ER_TOO_LONG_KEY                        
+  case ER_TOO_LONG_KEY                        : return "42000";
 #endif
-#ifdef ER_BLOB_USED_AS_KEY
-  case ER_BLOB_USED_AS_KEY                  : return "42000";
+#ifdef ER_KEY_COLUMN_DOES_NOT_EXITS           
+  case ER_KEY_COLUMN_DOES_NOT_EXITS           : return "42000";
 #endif
-#ifdef ER_TOO_BIG_FIELDLENGTH
-  case ER_TOO_BIG_FIELDLENGTH               : return "42000";
+#ifdef ER_BLOB_USED_AS_KEY                    
+  case ER_BLOB_USED_AS_KEY                    : return "42000";
 #endif
-#ifdef ER_WRONG_AUTO_KEY
-  case ER_WRONG_AUTO_KEY                    : return "42000";
+#ifdef ER_TOO_BIG_FIELDLENGTH                 
+  case ER_TOO_BIG_FIELDLENGTH                 : return "42000";
 #endif
-#ifdef ER_FORCING_CLOSE
-  case ER_FORCING_CLOSE                     : return "08S01";
+#ifdef ER_WRONG_AUTO_KEY                      
+  case ER_WRONG_AUTO_KEY                      : return "42000";
 #endif
-#ifdef ER_IPSOCK_ERROR
-  case ER_IPSOCK_ERROR                      : return "08S01";
+#ifdef ER_FORCING_CLOSE                       
+  case ER_FORCING_CLOSE                       : return "08S01";
 #endif
-#ifdef ER_NO_SUCH_INDEX
-  case ER_NO_SUCH_INDEX                     : return "42S12";
+#ifdef ER_IPSOCK_ERROR                        
+  case ER_IPSOCK_ERROR                        : return "08S01";
 #endif
-#ifdef ER_WRONG_FIELD_TERMINATORS
-  case ER_WRONG_FIELD_TERMINATORS           : return "42000";
+#ifdef ER_NO_SUCH_INDEX                       
+  case ER_NO_SUCH_INDEX                       : return "42S12";
 #endif
-#ifdef ER_BLOBS_AND_NO_TERMINATED
-  case ER_BLOBS_AND_NO_TERMINATED           : return "42000";
+#ifdef ER_WRONG_FIELD_TERMINATORS             
+  case ER_WRONG_FIELD_TERMINATORS             : return "42000";
 #endif
-#ifdef ER_CANT_REMOVE_ALL_FIELDS
-  case ER_CANT_REMOVE_ALL_FIELDS            : return "42000";
+#ifdef ER_BLOBS_AND_NO_TERMINATED             
+  case ER_BLOBS_AND_NO_TERMINATED             : return "42000";
 #endif
-#ifdef ER_CANT_DROP_FIELD_OR_KEY
-  case ER_CANT_DROP_FIELD_OR_KEY            : return "42000";
+#ifdef ER_CANT_REMOVE_ALL_FIELDS              
+  case ER_CANT_REMOVE_ALL_FIELDS              : return "42000";
 #endif
-#ifdef ER_BLOB_CANT_HAVE_DEFAULT
-  case ER_BLOB_CANT_HAVE_DEFAULT            : return "42000";
+#ifdef ER_CANT_DROP_FIELD_OR_KEY              
+  case ER_CANT_DROP_FIELD_OR_KEY              : return "42000";
 #endif
-#ifdef ER_WRONG_DB_NAME
-  case ER_WRONG_DB_NAME                     : return "42000";
+#ifdef ER_BLOB_CANT_HAVE_DEFAULT              
+  case ER_BLOB_CANT_HAVE_DEFAULT              : return "42000";
 #endif
-#ifdef ER_WRONG_TABLE_NAME
-  case ER_WRONG_TABLE_NAME                  : return "42000";
+#ifdef ER_WRONG_DB_NAME                       
+  case ER_WRONG_DB_NAME                       : return "42000";
 #endif
-#ifdef ER_TOO_BIG_SELECT
-  case ER_TOO_BIG_SELECT                    : return "42000";
+#ifdef ER_WRONG_TABLE_NAME                    
+  case ER_WRONG_TABLE_NAME                    : return "42000";
 #endif
-#ifdef ER_UNKNOWN_PROCEDURE
-  case ER_UNKNOWN_PROCEDURE                 : return "42000";
+#ifdef ER_TOO_BIG_SELECT                      
+  case ER_TOO_BIG_SELECT                      : return "42000";
 #endif
-#ifdef ER_WRONG_PARAMCOUNT_TO_PROCEDURE
-  case ER_WRONG_PARAMCOUNT_TO_PROCEDURE     : return "42000";
+#ifdef ER_UNKNOWN_PROCEDURE                   
+  case ER_UNKNOWN_PROCEDURE                   : return "42000";
 #endif
-#ifdef ER_UNKNOWN_TABLE
-  case ER_UNKNOWN_TABLE                     : return "42S02";
+#ifdef ER_WRONG_PARAMCOUNT_TO_PROCEDURE       
+  case ER_WRONG_PARAMCOUNT_TO_PROCEDURE       : return "42000";
 #endif
-#ifdef ER_FIELD_SPECIFIED_TWICE
-  case ER_FIELD_SPECIFIED_TWICE             : return "42000";
+#ifdef ER_UNKNOWN_TABLE                       
+  case ER_UNKNOWN_TABLE                       : return "42S02";
 #endif
-#ifdef ER_UNSUPPORTED_EXTENSION
-  case ER_UNSUPPORTED_EXTENSION             : return "42000";
+#ifdef ER_FIELD_SPECIFIED_TWICE               
+  case ER_FIELD_SPECIFIED_TWICE               : return "42000";
 #endif
-#ifdef ER_TABLE_MUST_HAVE_COLUMNS
-  case ER_TABLE_MUST_HAVE_COLUMNS           : return "42000";
+#ifdef ER_UNSUPPORTED_EXTENSION               
+  case ER_UNSUPPORTED_EXTENSION               : return "42000";
 #endif
-#ifdef ER_UNKNOWN_CHARACTER_SET
-  case ER_UNKNOWN_CHARACTER_SET             : return "42000";
+#ifdef ER_TABLE_MUST_HAVE_COLUMNS             
+  case ER_TABLE_MUST_HAVE_COLUMNS             : return "42000";
 #endif
-#ifdef ER_TOO_BIG_ROWSIZE
-  case ER_TOO_BIG_ROWSIZE                   : return "42000";
+#ifdef ER_UNKNOWN_CHARACTER_SET               
+  case ER_UNKNOWN_CHARACTER_SET               : return "42000";
 #endif
-#ifdef ER_WRONG_OUTER_JOIN
-  case ER_WRONG_OUTER_JOIN                  : return "42000";
+#ifdef ER_TOO_BIG_ROWSIZE                     
+  case ER_TOO_BIG_ROWSIZE                     : return "42000";
 #endif
-#ifdef ER_NULL_COLUMN_IN_INDEX
-  case ER_NULL_COLUMN_IN_INDEX              : return "42000";
+#ifdef ER_WRONG_OUTER_JOIN                    
+  case ER_WRONG_OUTER_JOIN                    : return "42000";
 #endif
-#ifdef ER_PASSWORD_ANONYMOUS_USER
-  case ER_PASSWORD_ANONYMOUS_USER           : return "42000";
+#ifdef ER_NULL_COLUMN_IN_INDEX                
+  case ER_NULL_COLUMN_IN_INDEX                : return "42000";
 #endif
-#ifdef ER_PASSWORD_NOT_ALLOWED
-  case ER_PASSWORD_NOT_ALLOWED              : return "42000";
+#ifdef ER_PASSWORD_ANONYMOUS_USER             
+  case ER_PASSWORD_ANONYMOUS_USER             : return "42000";
 #endif
-#ifdef ER_PASSWORD_NO_MATCH
-  case ER_PASSWORD_NO_MATCH                 : return "42000";
+#ifdef ER_PASSWORD_NOT_ALLOWED                
+  case ER_PASSWORD_NOT_ALLOWED                : return "42000";
 #endif
-#ifdef ER_WRONG_VALUE_COUNT_ON_ROW
-  case ER_WRONG_VALUE_COUNT_ON_ROW          : return "21S01";
+#ifdef ER_PASSWORD_NO_MATCH                   
+  case ER_PASSWORD_NO_MATCH                   : return "42000";
 #endif
-#ifdef ER_INVALID_USE_OF_NULL
-  case ER_INVALID_USE_OF_NULL               : return "42000";
+#ifdef ER_WRONG_VALUE_COUNT_ON_ROW            
+  case ER_WRONG_VALUE_COUNT_ON_ROW            : return "21S01";
 #endif
-#ifdef ER_REGEXP_ERROR
-  case ER_REGEXP_ERROR                      : return "42000";
+#ifdef ER_INVALID_USE_OF_NULL                 
+  case ER_INVALID_USE_OF_NULL                 : return "22004";
 #endif
-#ifdef ER_NONEXISTING_GRANT
-  case ER_NONEXISTING_GRANT                 : return "42000";
+#ifdef ER_REGEXP_ERROR                        
+  case ER_REGEXP_ERROR                        : return "42000";
 #endif
-#ifdef ER_TABLEACCESS_DENIED_ERROR
-  case ER_TABLEACCESS_DENIED_ERROR          : return "42000";
+#ifdef ER_MIX_OF_GROUP_FUNC_AND_FIELDS        
+  case ER_MIX_OF_GROUP_FUNC_AND_FIELDS        : return "42000";
 #endif
-#ifdef ER_COLUMNACCESS_DENIED_ERROR
-  case ER_COLUMNACCESS_DENIED_ERROR         : return "42000";
+#ifdef ER_NONEXISTING_GRANT                   
+  case ER_NONEXISTING_GRANT                   : return "42000";
 #endif
-#ifdef ER_ILLEGAL_GRANT_FOR_TABLE
-  case ER_ILLEGAL_GRANT_FOR_TABLE           : return "42000";
+#ifdef ER_TABLEACCESS_DENIED_ERROR            
+  case ER_TABLEACCESS_DENIED_ERROR            : return "42000";
 #endif
-#ifdef ER_GRANT_WRONG_HOST_OR_USER
-  case ER_GRANT_WRONG_HOST_OR_USER          : return "42000";
+#ifdef ER_COLUMNACCESS_DENIED_ERROR           
+  case ER_COLUMNACCESS_DENIED_ERROR           : return "42000";
 #endif
-#ifdef ER_NO_SUCH_TABLE
-  case ER_NO_SUCH_TABLE                     : return "42S02";
+#ifdef ER_ILLEGAL_GRANT_FOR_TABLE             
+  case ER_ILLEGAL_GRANT_FOR_TABLE             : return "42000";
 #endif
-#ifdef ER_NONEXISTING_TABLE_GRANT
-  case ER_NONEXISTING_TABLE_GRANT           : return "42000";
+#ifdef ER_GRANT_WRONG_HOST_OR_USER            
+  case ER_GRANT_WRONG_HOST_OR_USER            : return "42000";
 #endif
-#ifdef ER_NOT_ALLOWED_COMMAND
-  case ER_NOT_ALLOWED_COMMAND               : return "42000";
+#ifdef ER_NO_SUCH_TABLE                       
+  case ER_NO_SUCH_TABLE                       : return "42S02";
 #endif
-#ifdef ER_SYNTAX_ERROR
-  case ER_SYNTAX_ERROR                      : return "42000";
+#ifdef ER_NONEXISTING_TABLE_GRANT             
+  case ER_NONEXISTING_TABLE_GRANT             : return "42000";
 #endif
-#ifdef ER_ABORTING_CONNECTION
-  case ER_ABORTING_CONNECTION               : return "08S01";
+#ifdef ER_NOT_ALLOWED_COMMAND                 
+  case ER_NOT_ALLOWED_COMMAND                 : return "42000";
 #endif
-#ifdef ER_NET_PACKET_TOO_LARGE
-  case ER_NET_PACKET_TOO_LARGE              : return "08S01";
+#ifdef ER_SYNTAX_ERROR                        
+  case ER_SYNTAX_ERROR                        : return "42000";
 #endif
-#ifdef ER_NET_READ_ERROR_FROM_PIPE
-  case ER_NET_READ_ERROR_FROM_PIPE          : return "08S01";
+#ifdef ER_ABORTING_CONNECTION                 
+  case ER_ABORTING_CONNECTION                 : return "08S01";
 #endif
-#ifdef ER_NET_FCNTL_ERROR
-  case ER_NET_FCNTL_ERROR                   : return "08S01";
+#ifdef ER_NET_PACKET_TOO_LARGE                
+  case ER_NET_PACKET_TOO_LARGE                : return "08S01";
 #endif
-#ifdef ER_NET_PACKETS_OUT_OF_ORDER
-  case ER_NET_PACKETS_OUT_OF_ORDER          : return "08S01";
+#ifdef ER_NET_READ_ERROR_FROM_PIPE            
+  case ER_NET_READ_ERROR_FROM_PIPE            : return "08S01";
 #endif
-#ifdef ER_NET_UNCOMPRESS_ERROR
-  case ER_NET_UNCOMPRESS_ERROR              : return "08S01";
+#ifdef ER_NET_FCNTL_ERROR                     
+  case ER_NET_FCNTL_ERROR                     : return "08S01";
 #endif
-#ifdef ER_NET_READ_ERROR
-  case ER_NET_READ_ERROR                    : return "08S01";
+#ifdef ER_NET_PACKETS_OUT_OF_ORDER            
+  case ER_NET_PACKETS_OUT_OF_ORDER            : return "08S01";
 #endif
-#ifdef ER_NET_READ_INTERRUPTED
-  case ER_NET_READ_INTERRUPTED              : return "08S01";
+#ifdef ER_NET_UNCOMPRESS_ERROR                
+  case ER_NET_UNCOMPRESS_ERROR                : return "08S01";
 #endif
-#ifdef ER_NET_ERROR_ON_WRITE
-  case ER_NET_ERROR_ON_WRITE                : return "08S01";
+#ifdef ER_NET_READ_ERROR                      
+  case ER_NET_READ_ERROR                      : return "08S01";
 #endif
-#ifdef ER_NET_WRITE_INTERRUPTED
-  case ER_NET_WRITE_INTERRUPTED             : return "08S01";
+#ifdef ER_NET_READ_INTERRUPTED                
+  case ER_NET_READ_INTERRUPTED                : return "08S01";
 #endif
-#ifdef ER_TOO_LONG_STRING
-  case ER_TOO_LONG_STRING                   : return "42000";
+#ifdef ER_NET_ERROR_ON_WRITE                  
+  case ER_NET_ERROR_ON_WRITE                  : return "08S01";
 #endif
-#ifdef ER_TABLE_CANT_HANDLE_BLOB
-  case ER_TABLE_CANT_HANDLE_BLOB            : return "42000";
+#ifdef ER_NET_WRITE_INTERRUPTED               
+  case ER_NET_WRITE_INTERRUPTED               : return "08S01";
 #endif
-#ifdef ER_TABLE_CANT_HANDLE_AUTO_INCREMENT
-  case ER_TABLE_CANT_HANDLE_AUTO_INCREMENT  : return "42000";
+#ifdef ER_TOO_LONG_STRING                     
+  case ER_TOO_LONG_STRING                     : return "42000";
 #endif
-#ifdef ER_WRONG_COLUMN_NAME
-  case ER_WRONG_COLUMN_NAME                 : return "42000";
+#ifdef ER_TABLE_CANT_HANDLE_BLOB              
+  case ER_TABLE_CANT_HANDLE_BLOB              : return "42000";
 #endif
-#ifdef ER_WRONG_KEY_COLUMN
-  case ER_WRONG_KEY_COLUMN                  : return "42000";
+#ifdef ER_TABLE_CANT_HANDLE_AUTO_INCREMENT    
+  case ER_TABLE_CANT_HANDLE_AUTO_INCREMENT    : return "42000";
 #endif
-#ifdef ER_DUP_UNIQUE
-  case ER_DUP_UNIQUE                        : return "23000";
+#ifdef ER_WRONG_COLUMN_NAME                   
+  case ER_WRONG_COLUMN_NAME                   : return "42000";
 #endif
-#ifdef ER_BLOB_KEY_WITHOUT_LENGTH
-  case ER_BLOB_KEY_WITHOUT_LENGTH           : return "42000";
+#ifdef ER_WRONG_KEY_COLUMN                    
+  case ER_WRONG_KEY_COLUMN                    : return "42000";
 #endif
-#ifdef ER_PRIMARY_CANT_HAVE_NULL
-  case ER_PRIMARY_CANT_HAVE_NULL            : return "42000";
+#ifdef ER_DUP_UNIQUE                          
+  case ER_DUP_UNIQUE                          : return "23000";
 #endif
-#ifdef ER_TOO_MANY_ROWS
-  case ER_TOO_MANY_ROWS                     : return "42000";
+#ifdef ER_BLOB_KEY_WITHOUT_LENGTH             
+  case ER_BLOB_KEY_WITHOUT_LENGTH             : return "42000";
 #endif
-#ifdef ER_REQUIRES_PRIMARY_KEY
-  case ER_REQUIRES_PRIMARY_KEY              : return "42000";
+#ifdef ER_PRIMARY_CANT_HAVE_NULL              
+  case ER_PRIMARY_CANT_HAVE_NULL              : return "42000";
 #endif
-#ifdef ER_CHECK_NO_SUCH_TABLE
-  case ER_CHECK_NO_SUCH_TABLE               : return "42000";
+#ifdef ER_TOO_MANY_ROWS                       
+  case ER_TOO_MANY_ROWS                       : return "42000";
 #endif
-#ifdef ER_CHECK_NOT_IMPLEMENTED
-  case ER_CHECK_NOT_IMPLEMENTED             : return "42000";
+#ifdef ER_REQUIRES_PRIMARY_KEY                
+  case ER_REQUIRES_PRIMARY_KEY                : return "42000";
 #endif
-#ifdef ER_CANT_DO_THIS_DURING_AN_TRANSACTION
-  case ER_CANT_DO_THIS_DURING_AN_TRANSACTION: return "25000";
+#ifdef ER_KEY_DOES_NOT_EXITS                  
+  case ER_KEY_DOES_NOT_EXITS                  : return "42000";
 #endif
-#ifdef ER_NEW_ABORTING_CONNECTION
-  case ER_NEW_ABORTING_CONNECTION           : return "08S01";
+#ifdef ER_CHECK_NO_SUCH_TABLE                 
+  case ER_CHECK_NO_SUCH_TABLE                 : return "42000";
 #endif
-#ifdef ER_MASTER_NET_READ
-  case ER_MASTER_NET_READ                   : return "08S01";
+#ifdef ER_CHECK_NOT_IMPLEMENTED               
+  case ER_CHECK_NOT_IMPLEMENTED               : return "42000";
 #endif
-#ifdef ER_MASTER_NET_WRITE
-  case ER_MASTER_NET_WRITE                  : return "08S01";
+#ifdef ER_CANT_DO_THIS_DURING_AN_TRANSACTION  
+  case ER_CANT_DO_THIS_DURING_AN_TRANSACTION  : return "25000";
 #endif
-#ifdef ER_TOO_MANY_USER_CONNECTIONS
-  case ER_TOO_MANY_USER_CONNECTIONS         : return "42000";
+#ifdef ER_NEW_ABORTING_CONNECTION             
+  case ER_NEW_ABORTING_CONNECTION             : return "08S01";
 #endif
-#ifdef ER_READ_ONLY_TRANSACTION
-  case ER_READ_ONLY_TRANSACTION             : return "25000";
+#ifdef ER_MASTER_NET_READ                     
+  case ER_MASTER_NET_READ                     : return "08S01";
 #endif
-#ifdef ER_LOCK_DEADLOCK
-  case ER_LOCK_DEADLOCK                     : return "40001";
+#ifdef ER_MASTER_NET_WRITE                    
+  case ER_MASTER_NET_WRITE                    : return "08S01";
 #endif
-#ifdef ER_NO_REFERENCED_ROW
-  case ER_NO_REFERENCED_ROW                 : return "23000";
+#ifdef ER_TOO_MANY_USER_CONNECTIONS           
+  case ER_TOO_MANY_USER_CONNECTIONS           : return "42000";
 #endif
-#ifdef ER_ROW_IS_REFERENCED
-  case ER_ROW_IS_REFERENCED                 : return "23000";
+#ifdef ER_READ_ONLY_TRANSACTION               
+  case ER_READ_ONLY_TRANSACTION               : return "25000";
 #endif
-#ifdef ER_CONNECT_TO_MASTER
-  case ER_CONNECT_TO_MASTER                 : return "08S01";
+#ifdef ER_NO_PERMISSION_TO_CREATE_USER        
+  case ER_NO_PERMISSION_TO_CREATE_USER        : return "42000";
 #endif
-#ifdef ER_USER_LIMIT_REACHED
-  case ER_USER_LIMIT_REACHED                : return "42000";
+#ifdef ER_LOCK_DEADLOCK                       
+  case ER_LOCK_DEADLOCK                       : return "40001";
 #endif
-#ifdef ER_NO_DEFAULT
-  case ER_NO_DEFAULT                        : return "42000";
+#ifdef ER_NO_REFERENCED_ROW                   
+  case ER_NO_REFERENCED_ROW                   : return "23000";
 #endif
-#ifdef ER_WRONG_VALUE_FOR_VAR
-  case ER_WRONG_VALUE_FOR_VAR               : return "42000";
+#ifdef ER_ROW_IS_REFERENCED                   
+  case ER_ROW_IS_REFERENCED                   : return "23000";
 #endif
-#ifdef ER_WRONG_TYPE_FOR_VAR
-  case ER_WRONG_TYPE_FOR_VAR                : return "42000";
+#ifdef ER_CONNECT_TO_MASTER                   
+  case ER_CONNECT_TO_MASTER                   : return "08S01";
 #endif
-#ifdef ER_CANT_USE_OPTION_HERE
-  case ER_CANT_USE_OPTION_HERE              : return "42000";
+#ifdef ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT   
+  case ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT   : return "21000";
 #endif
-#ifdef ER_NOT_SUPPORTED_YET
-  case ER_NOT_SUPPORTED_YET                 : return "42000";
+#ifdef ER_USER_LIMIT_REACHED                  
+  case ER_USER_LIMIT_REACHED                  : return "42000";
 #endif
-#ifdef ER_WRONG_FK_DEF
-  case ER_WRONG_FK_DEF                      : return "42000";
+#ifdef ER_SPECIFIC_ACCESS_DENIED_ERROR        
+  case ER_SPECIFIC_ACCESS_DENIED_ERROR        : return "42000";
 #endif
-#ifdef ER_OPERAND_COLUMNS
-  case ER_OPERAND_COLUMNS                   : return "21000";
+#ifdef ER_NO_DEFAULT                          
+  case ER_NO_DEFAULT                          : return "42000";
 #endif
-#ifdef ER_SUBQUERY_NO_1_ROW
-  case ER_SUBQUERY_NO_1_ROW                 : return "21000";
+#ifdef ER_WRONG_VALUE_FOR_VAR                 
+  case ER_WRONG_VALUE_FOR_VAR                 : return "42000";
 #endif
-#ifdef ER_ILLEGAL_REFERENCE
-  case ER_ILLEGAL_REFERENCE                 : return "42S22";
+#ifdef ER_WRONG_TYPE_FOR_VAR                  
+  case ER_WRONG_TYPE_FOR_VAR                  : return "42000";
 #endif
-#ifdef ER_DERIVED_MUST_HAVE_ALIAS
-  case ER_DERIVED_MUST_HAVE_ALIAS           : return "42000";
+#ifdef ER_CANT_USE_OPTION_HERE                
+  case ER_CANT_USE_OPTION_HERE                : return "42000";
 #endif
-#ifdef ER_SELECT_REDUCED
-  case ER_SELECT_REDUCED                    : return "01000";
+#ifdef ER_NOT_SUPPORTED_YET                   
+  case ER_NOT_SUPPORTED_YET                   : return "42000";
 #endif
-#ifdef ER_TABLENAME_NOT_ALLOWED_HERE
-  case ER_TABLENAME_NOT_ALLOWED_HERE        : return "42000";
+#ifdef ER_WRONG_FK_DEF                        
+  case ER_WRONG_FK_DEF                        : return "42000";
 #endif
-#ifdef ER_NOT_SUPPORTED_AUTH_MODE
-  case ER_NOT_SUPPORTED_AUTH_MODE           : return "08004";
+#ifdef ER_OPERAND_COLUMNS                     
+  case ER_OPERAND_COLUMNS                     : return "21000";
 #endif
-#ifdef ER_SPATIAL_CANT_HAVE_NULL
-  case ER_SPATIAL_CANT_HAVE_NULL            : return "42000";
+#ifdef ER_SUBQUERY_NO_1_ROW                   
+  case ER_SUBQUERY_NO_1_ROW                   : return "21000";
 #endif
-#ifdef ER_COLLATION_CHARSET_MISMATCH
-  case ER_COLLATION_CHARSET_MISMATCH        : return "42000";
+#ifdef ER_ILLEGAL_REFERENCE                   
+  case ER_ILLEGAL_REFERENCE                   : return "42S22";
 #endif
-#ifdef ER_WARN_TOO_FEW_RECORDS
-  case ER_WARN_TOO_FEW_RECORDS              : return "01000";
+#ifdef ER_DERIVED_MUST_HAVE_ALIAS             
+  case ER_DERIVED_MUST_HAVE_ALIAS             : return "42000";
 #endif
-#ifdef ER_WARN_TOO_MANY_RECORDS
-  case ER_WARN_TOO_MANY_RECORDS             : return "01000";
+#ifdef ER_SELECT_REDUCED                      
+  case ER_SELECT_REDUCED                      : return "01000";
 #endif
-#ifdef ER_WARN_NULL_TO_NOTNULL
-  case ER_WARN_NULL_TO_NOTNULL              : return "01000";
+#ifdef ER_TABLENAME_NOT_ALLOWED_HERE          
+  case ER_TABLENAME_NOT_ALLOWED_HERE          : return "42000";
 #endif
-#ifdef ER_WARN_DATA_OUT_OF_RANGE
-  case ER_WARN_DATA_OUT_OF_RANGE            : return "01000";
+#ifdef ER_NOT_SUPPORTED_AUTH_MODE             
+  case ER_NOT_SUPPORTED_AUTH_MODE             : return "08004";
 #endif
-#ifdef ER_WARN_DATA_TRUNCATED
-  case ER_WARN_DATA_TRUNCATED               : return "01000";
+#ifdef ER_SPATIAL_CANT_HAVE_NULL              
+  case ER_SPATIAL_CANT_HAVE_NULL              : return "42000";
 #endif
-#ifdef ER_WRONG_NAME_FOR_INDEX
-  case ER_WRONG_NAME_FOR_INDEX              : return "42000";
+#ifdef ER_COLLATION_CHARSET_MISMATCH          
+  case ER_COLLATION_CHARSET_MISMATCH          : return "42000";
 #endif
-#ifdef ER_WRONG_NAME_FOR_CATALOG
-  case ER_WRONG_NAME_FOR_CATALOG            : return "42000";
+#ifdef ER_WARN_TOO_FEW_RECORDS                
+  case ER_WARN_TOO_FEW_RECORDS                : return "01000";
 #endif
-#ifdef ER_UNKNOWN_STORAGE_ENGINE
-  case ER_UNKNOWN_STORAGE_ENGINE            : return "42000";
+#ifdef ER_WARN_TOO_MANY_RECORDS               
+  case ER_WARN_TOO_MANY_RECORDS               : return "01000";
+#endif
+#ifdef ER_WARN_NULL_TO_NOTNULL                
+  case ER_WARN_NULL_TO_NOTNULL                : return "22004";
+#endif
+#ifdef ER_WARN_DATA_OUT_OF_RANGE              
+  case ER_WARN_DATA_OUT_OF_RANGE              : return "22003";
+#endif
+#ifdef ER_WRONG_NAME_FOR_INDEX                
+  case ER_WRONG_NAME_FOR_INDEX                : return "42000";
+#endif
+#ifdef ER_WRONG_NAME_FOR_CATALOG              
+  case ER_WRONG_NAME_FOR_CATALOG              : return "42000";
+#endif
+#ifdef ER_UNKNOWN_STORAGE_ENGINE              
+  case ER_UNKNOWN_STORAGE_ENGINE              : return "42000";
+#endif
+#ifdef ER_TRUNCATED_WRONG_VALUE               
+  case ER_TRUNCATED_WRONG_VALUE               : return "22007";
+#endif
+#ifdef ER_SP_NO_RECURSIVE_CREATE              
+  case ER_SP_NO_RECURSIVE_CREATE              : return "2F003";
+#endif
+#ifdef ER_SP_ALREADY_EXISTS                   
+  case ER_SP_ALREADY_EXISTS                   : return "42000";
+#endif
+#ifdef ER_SP_DOES_NOT_EXIST                   
+  case ER_SP_DOES_NOT_EXIST                   : return "42000";
+#endif
+#ifdef ER_SP_LILABEL_MISMATCH                 
+  case ER_SP_LILABEL_MISMATCH                 : return "42000";
+#endif
+#ifdef ER_SP_LABEL_REDEFINE                   
+  case ER_SP_LABEL_REDEFINE                   : return "42000";
+#endif
+#ifdef ER_SP_LABEL_MISMATCH                   
+  case ER_SP_LABEL_MISMATCH                   : return "42000";
+#endif
+#ifdef ER_SP_UNINIT_VAR                       
+  case ER_SP_UNINIT_VAR                       : return "01000";
+#endif
+#ifdef ER_SP_BADSELECT                        
+  case ER_SP_BADSELECT                        : return "0A000";
+#endif
+#ifdef ER_SP_BADRETURN                        
+  case ER_SP_BADRETURN                        : return "42000";
+#endif
+#ifdef ER_SP_BADSTATEMENT                     
+  case ER_SP_BADSTATEMENT                     : return "0A000";
+#endif
+#ifdef ER_UPDATE_LOG_DEPRECATED_IGNORED       
+  case ER_UPDATE_LOG_DEPRECATED_IGNORED       : return "42000";
+#endif
+#ifdef ER_UPDATE_LOG_DEPRECATED_TRANSLATED    
+  case ER_UPDATE_LOG_DEPRECATED_TRANSLATED    : return "42000";
+#endif
+#ifdef ER_QUERY_INTERRUPTED                   
+  case ER_QUERY_INTERRUPTED                   : return "70100";
+#endif
+#ifdef ER_SP_WRONG_NO_OF_ARGS                 
+  case ER_SP_WRONG_NO_OF_ARGS                 : return "42000";
+#endif
+#ifdef ER_SP_COND_MISMATCH                    
+  case ER_SP_COND_MISMATCH                    : return "42000";
+#endif
+#ifdef ER_SP_NORETURN                         
+  case ER_SP_NORETURN                         : return "42000";
+#endif
+#ifdef ER_SP_NORETURNEND                      
+  case ER_SP_NORETURNEND                      : return "2F005";
+#endif
+#ifdef ER_SP_BAD_CURSOR_QUERY                 
+  case ER_SP_BAD_CURSOR_QUERY                 : return "42000";
+#endif
+#ifdef ER_SP_BAD_CURSOR_SELECT                
+  case ER_SP_BAD_CURSOR_SELECT                : return "42000";
+#endif
+#ifdef ER_SP_CURSOR_MISMATCH                  
+  case ER_SP_CURSOR_MISMATCH                  : return "42000";
+#endif
+#ifdef ER_SP_CURSOR_ALREADY_OPEN              
+  case ER_SP_CURSOR_ALREADY_OPEN              : return "24000";
+#endif
+#ifdef ER_SP_CURSOR_NOT_OPEN                  
+  case ER_SP_CURSOR_NOT_OPEN                  : return "24000";
+#endif
+#ifdef ER_SP_UNDECLARED_VAR                   
+  case ER_SP_UNDECLARED_VAR                   : return "42000";
+#endif
+#ifdef ER_SP_FETCH_NO_DATA                    
+  case ER_SP_FETCH_NO_DATA                    : return "02000";
+#endif
+#ifdef ER_SP_DUP_PARAM                        
+  case ER_SP_DUP_PARAM                        : return "42000";
+#endif
+#ifdef ER_SP_DUP_VAR                          
+  case ER_SP_DUP_VAR                          : return "42000";
+#endif
+#ifdef ER_SP_DUP_COND                         
+  case ER_SP_DUP_COND                         : return "42000";
+#endif
+#ifdef ER_SP_DUP_CURS                         
+  case ER_SP_DUP_CURS                         : return "42000";
+#endif
+#ifdef ER_SP_SUBSELECT_NYI                    
+  case ER_SP_SUBSELECT_NYI                    : return "0A000";
+#endif
+#ifdef ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG       
+  case ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG       : return "0A000";
+#endif
+#ifdef ER_SP_VARCOND_AFTER_CURSHNDLR          
+  case ER_SP_VARCOND_AFTER_CURSHNDLR          : return "42000";
+#endif
+#ifdef ER_SP_CURSOR_AFTER_HANDLER             
+  case ER_SP_CURSOR_AFTER_HANDLER             : return "42000";
+#endif
+#ifdef ER_SP_CASE_NOT_FOUND                   
+  case ER_SP_CASE_NOT_FOUND                   : return "20000";
+#endif
+#ifdef ER_DIVISION_BY_ZERO                    
+  case ER_DIVISION_BY_ZERO                    : return "22012";
+#endif
+#ifdef ER_ILLEGAL_VALUE_FOR_TYPE              
+  case ER_ILLEGAL_VALUE_FOR_TYPE              : return "22007";
+#endif
+#ifdef ER_PROCACCESS_DENIED_ERROR             
+  case ER_PROCACCESS_DENIED_ERROR             : return "42000";
+#endif
+#ifdef ER_XAER_NOTA                           
+  case ER_XAER_NOTA                           : return "XAE04";
+#endif
+#ifdef ER_XAER_INVAL                          
+  case ER_XAER_INVAL                          : return "XAE05";
+#endif
+#ifdef ER_XAER_RMFAIL                         
+  case ER_XAER_RMFAIL                         : return "XAE07";
+#endif
+#ifdef ER_XAER_OUTSIDE                        
+  case ER_XAER_OUTSIDE                        : return "XAE09";
+#endif
+#ifdef ER_XAER_RMERR                          
+  case ER_XAER_RMERR                          : return "XAE03";
+#endif
+#ifdef ER_XA_RBROLLBACK                       
+  case ER_XA_RBROLLBACK                       : return "XA100";
+#endif
+#ifdef ER_NONEXISTING_PROC_GRANT              
+  case ER_NONEXISTING_PROC_GRANT              : return "42000";
+#endif
+#ifdef ER_DATA_TOO_LONG                       
+  case ER_DATA_TOO_LONG                       : return "22001";
+#endif
+#ifdef ER_SP_BAD_SQLSTATE                     
+  case ER_SP_BAD_SQLSTATE                     : return "42000";
+#endif
+#ifdef ER_CANT_CREATE_USER_WITH_GRANT         
+  case ER_CANT_CREATE_USER_WITH_GRANT         : return "42000";
+#endif
+#ifdef ER_SP_DUP_HANDLER                      
+  case ER_SP_DUP_HANDLER                      : return "42000";
+#endif
+#ifdef ER_SP_NOT_VAR_ARG                      
+  case ER_SP_NOT_VAR_ARG                      : return "42000";
+#endif
+#ifdef ER_SP_NO_RETSET                        
+  case ER_SP_NO_RETSET                        : return "0A000";
+#endif
+#ifdef ER_CANT_CREATE_GEOMETRY_OBJECT         
+  case ER_CANT_CREATE_GEOMETRY_OBJECT         : return "22003";
+#endif
+#ifdef ER_TOO_BIG_SCALE                       
+  case ER_TOO_BIG_SCALE                       : return "42000";
+#endif
+#ifdef ER_TOO_BIG_PRECISION                   
+  case ER_TOO_BIG_PRECISION                   : return "42000";
+#endif
+#ifdef ER_M_BIGGER_THAN_D                     
+  case ER_M_BIGGER_THAN_D                     : return "42000";
+#endif
+#ifdef ER_TOO_LONG_BODY                       
+  case ER_TOO_LONG_BODY                       : return "42000";
+#endif
+#ifdef ER_TOO_BIG_DISPLAYWIDTH                
+  case ER_TOO_BIG_DISPLAYWIDTH                : return "42000";
+#endif
+#ifdef ER_XAER_DUPID                          
+  case ER_XAER_DUPID                          : return "XAE08";
+#endif
+#ifdef ER_DATETIME_FUNCTION_OVERFLOW          
+  case ER_DATETIME_FUNCTION_OVERFLOW          : return "22008";
+#endif
+#ifdef ER_ROW_IS_REFERENCED_2                 
+  case ER_ROW_IS_REFERENCED_2                 : return "23000";
+#endif
+#ifdef ER_NO_REFERENCED_ROW_2                 
+  case ER_NO_REFERENCED_ROW_2                 : return "23000";
+#endif
+#ifdef ER_SP_BAD_VAR_SHADOW                   
+  case ER_SP_BAD_VAR_SHADOW                   : return "42000";
+#endif
+#ifdef ER_SP_WRONG_NAME                       
+  case ER_SP_WRONG_NAME                       : return "42000";
+#endif
+#ifdef ER_SP_NO_AGGREGATE                     
+  case ER_SP_NO_AGGREGATE                     : return "42000";
+#endif
+#ifdef ER_MAX_PREPARED_STMT_COUNT_REACHED     
+  case ER_MAX_PREPARED_STMT_COUNT_REACHED     : return "42000";
+#endif
+#ifdef ER_NON_GROUPING_FIELD_USED             
+  case ER_NON_GROUPING_FIELD_USED             : return "42000";
+#endif
+#ifdef ER_FOREIGN_DUPLICATE_KEY               
+  case ER_FOREIGN_DUPLICATE_KEY               : return "23000";
+#endif
+#ifdef ER_CANT_CHANGE_TX_ISOLATION            
+  case ER_CANT_CHANGE_TX_ISOLATION            : return "25001";
+#endif
+#ifdef ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT      
+  case ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT      : return "42000";
+#endif
+#ifdef ER_WRONG_PARAMETERS_TO_NATIVE_FCT      
+  case ER_WRONG_PARAMETERS_TO_NATIVE_FCT      : return "42000";
+#endif
+#ifdef ER_WRONG_PARAMETERS_TO_STORED_FCT      
+  case ER_WRONG_PARAMETERS_TO_STORED_FCT      : return "42000";
+#endif
+#ifdef ER_DUP_ENTRY_WITH_KEY_NAME             
+  case ER_DUP_ENTRY_WITH_KEY_NAME             : return "23000";
+#endif
+#ifdef ER_XA_RBTIMEOUT                        
+  case ER_XA_RBTIMEOUT                        : return "XA106";
+#endif
+#ifdef ER_XA_RBDEADLOCK                       
+  case ER_XA_RBDEADLOCK                       : return "XA102";
+#endif
+#ifdef ER_FUNC_INEXISTENT_NAME_COLLISION      
+  case ER_FUNC_INEXISTENT_NAME_COLLISION      : return "42000";
+#endif
+#ifdef ER_DUP_SIGNAL_SET                      
+  case ER_DUP_SIGNAL_SET                      : return "42000";
+#endif
+#ifdef ER_SIGNAL_WARN                         
+  case ER_SIGNAL_WARN                         : return "01000";
+#endif
+#ifdef ER_SIGNAL_NOT_FOUND                    
+  case ER_SIGNAL_NOT_FOUND                    : return "02000";
+#endif
+#ifdef ER_SIGNAL_EXCEPTION                    
+  case ER_SIGNAL_EXCEPTION                    : return "HY000";
+#endif
+#ifdef ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER     
+  case ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER     : return "0K000";
+#endif
+#ifdef ER_SPATIAL_MUST_HAVE_GEOM_COL          
+  case ER_SPATIAL_MUST_HAVE_GEOM_COL          : return "42000";
+#endif
+#ifdef ER_DATA_OUT_OF_RANGE                   
+  case ER_DATA_OUT_OF_RANGE                   : return "22003";
 #endif
--- /dev/null
+++ b/ext/pdo_mysql/tests/README
@@ -0,0 +1,16 @@
+You must set the following environment variables to run the tests:
+
+  PDO_MYSQL_TEST_DSN  - DSN
+    For example: mysql:dbname=test;host=localhost;port=3306
+
+  PDO_MYSQL_TEST_HOST     - database host
+  PDO_MYSQL_TEST_DB      - database (schema) name
+  PDO_MYSQL_TEST_SOCKET  - database server socket
+  PDO_MYSQL_TEST_ENGINE  - storage engine to use
+  PDO_MYSQL_TEST_USER    - database user
+  PDO_MYSQL_TEST_PASS    - database user password
+  PDO_MYSQL_TEST_CHARSET - database charset
+
+  NOTE: if any of PDO_MYSQL_TEST_[HOST|DB|SOCKET|ENGINE|CHARSET] is
+  part of PDO_MYSQL_TEST_DSN, the values must match. That is, for example,
+  for PDO_MYSQL_TEST_DSN = mysql:dbname=test you MUST set PDO_MYSQL_TEST_DB=test.
--- a/ext/pdo_mysql/tests/bug41125.phpt
+++ b/ext/pdo_mysql/tests/bug41125.phpt
@@ -2,16 +2,16 @@
 Bug #41125 (PDO mysql + quote() + prepare() can result in seg fault)
 --SKIPIF--
 <?php
-require dirname(__FILE__) . '/config.inc';
-require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
 MySQLPDOTest::skip();
 
 ?>
 --FILE--
 <?php
 
-require dirname(__FILE__) . '/config.inc';
-require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
 $db = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
 
 $search = "o'";
@@ -85,78 +85,78 @@
 ?>
 --EXPECT--
 1
-00000
+00000 -  - 
 -------------------------------------------------------
 [1] Query: [[SELECT 1 FROM DUAL WHERE 1 = '?\'\'']]
 
-00000
+00000 -  - 
 --------
 [2] Query: [[SELECT 'a\'0' FROM DUAL WHERE 1 = ?]]
 a'0
-00000
+00000 -  - 
 --------
 [3] Query: [[SELECT 'a', 'b\'' FROM DUAL WHERE '''' LIKE '\'' AND ?]]
 a - b'
-00000
+00000 -  - 
 --------
 [4] Query: [[SELECT 'foo?bar', '', '''' FROM DUAL WHERE ?]]
 foo?bar -  - '
-00000
+00000 -  - 
 --------
 Query: [[SELECT upper(:id) FROM DUAL WHERE '1']]
 O'\0
-00000
+00000 -  - 
 -------------------------------------------------------
 [1] Query: [[SELECT 1, 'foo' FROM DUAL WHERE 1 = :id AND '\0' IS NULL AND  2 <> :id]]
 
-00000
+00000 -  - 
 --------
 [2] Query: [[SELECT 1 FROM DUAL WHERE 1 = :id AND '' AND  2 <> :id]]
 
-00000
+00000 -  - 
 --------
 [3] Query: [[SELECT 1 FROM DUAL WHERE 1 = :id AND '\'\'' = '''' AND  2 <> :id]]
 
-00000
+00000 -  - 
 --------
 [4] Query: [[SELECT 1 FROM DUAL WHERE 1 = :id AND '\'' = '''' AND  2 <> :id]]
 1
-00000
+00000 -  - 
 --------
 [5] Query: [[SELECT 'a', 'b\'' FROM DUAL WHERE '''' LIKE '\'' AND 1]]
 a - b'
-00000
+00000 -  - 
 --------
 [6] Query: [[SELECT 'a''', '\'b\'' FROM DUAL WHERE '''' LIKE '\'' AND 1]]
 a' - 'b'
-00000
+00000 -  - 
 --------
 [7] Query: [[SELECT UPPER(:id) FROM DUAL WHERE '1']]
 1
-00000
+00000 -  - 
 --------
 [8] Query: [[SELECT 1 FROM DUAL WHERE '\'']]
 
-00000
+00000 -  - 
 --------
 [9] Query: [[SELECT 1 FROM DUAL WHERE :id AND '\0' OR :id]]
 1
-00000
+00000 -  - 
 --------
 [10] Query: [[SELECT 1 FROM DUAL WHERE 'a\f\n\0' AND 1 >= :id]]
 
-00000
+00000 -  - 
 --------
 [11] Query: [[SELECT 1 FROM DUAL WHERE '\'' = '''']]
 1
-00000
+00000 -  - 
 --------
 [12] Query: [[SELECT '\n' '1 FROM DUAL WHERE '''' and :id']]
 
 1 FROM DUAL WHERE '' and :id
-00000
+00000 -  - 
 --------
 [13] Query: [[SELECT 1 'FROM DUAL WHERE :id AND '''' = '''' OR 1 = 1 AND ':id]]
 1
-00000
+00000 -  - 
 --------
--- a/ext/pdo_mysql/tests/bug44327.phpt
+++ b/ext/pdo_mysql/tests/bug44327.phpt
@@ -2,15 +2,15 @@
 Bug #44327 (PDORow::queryString property & numeric offsets / Crash)
 --SKIPIF--
 <?php
-require dirname(__FILE__) . '/config.inc';
-require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
 MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
 ?>
 --FILE--
 <?php
-	require dirname(__FILE__) . '/config.inc';
-	require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
-	$db = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
 
 	$stmt = $db->prepare("SELECT 1 AS \"one\""); 
 	$stmt->execute(); 
@@ -42,22 +42,22 @@
 ?>
 --EXPECTF--
 object(PDORow)#%d (2) {
-  ["queryString"]=>
-  string(17) "SELECT 1 AS "one""
-  ["one"]=>
-  string(1) "1"
+  [%u|b%"queryString"]=>
+  %unicode|string%(17) "SELECT 1 AS "one""
+  [%u|b%"one"]=>
+  %unicode|string%(1) "1"
 }
-string(1) "1"
-string(1) "1"
-string(17) "SELECT 1 AS "one""
+%unicode|string%(1) "1"
+%unicode|string%(1) "1"
+%unicode|string%(17) "SELECT 1 AS "one""
 ----------------------------------
 object(PDORow)#%d (2) {
-  ["queryString"]=>
-  string(19) "SELECT id FROM test"
-  ["id"]=>
-  string(1) "1"
+  [%u|b%"queryString"]=>
+  %unicode|string%(19) "SELECT id FROM test"
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
 }
-string(19) "SELECT id FROM test"
+%unicode|string%(19) "SELECT id FROM test"
 ----------------------------------
 
 Notice: Trying to get property of non-object in %s on line %d
--- a/ext/pdo_mysql/tests/bug46292.phpt
+++ b/ext/pdo_mysql/tests/bug46292.phpt
@@ -2,18 +2,18 @@
 Bug #46292 (PDO::setFetchMode() shouldn't requires the 2nd arg when using FETCH_CLASSTYPE)
 --SKIPIF--
 <?php
-if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
-require dirname(__FILE__) . '/config.inc';
-require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
-PDOTest::skip();
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (version_compare(PHP_VERSION, '5.1.0', '<'))
+	die("skip Needs 5.1.0 and Interface Serializable");
 ?>
 --FILE--
-<?php
-	require dirname(__FILE__) . '/config.inc';
-	require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
-
-	$pdoDb = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+<?php	
 	
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$pdoDb = MySQLPDOTest::factory();
+	
 
 	class myclass implements Serializable {
 		public function __construct() {
@@ -34,6 +34,7 @@
 	class myclass2 extends myclass { }
 
 	$pdoDb->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
+	$pdoDb->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
 	
 	$pdoDb->query('DROP TABLE IF EXISTS testz');
 	
@@ -49,32 +50,35 @@
 	var_dump($stmt->fetch());
 	var_dump($stmt->fetch());
 	var_dump($stmt->fetchAll());
-	
-	$pdoDb->query('DROP TABLE IF EXISTS testz');
-	
 ?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS testz');
+?>
 --EXPECTF--
 bool(true)
 myclass::__construct()
 object(myclass)#%d (1) {
-  ["value"]=>
-  string(1) "1"
+  [%u|b%"value"]=>
+  %unicode|string%(1) "1"
 }
 myclass::__construct()
 object(myclass2)#%d (1) {
-  ["value"]=>
-  string(1) "2"
+  [%u|b%"value"]=>
+  %unicode|string%(1) "2"
 }
 myclass::__construct()
 array(2) {
   [0]=>
   object(myclass)#%d (1) {
-    ["value"]=>
+    [%u|b%"value"]=>
     NULL
   }
   [1]=>
   object(stdClass)#%d (1) {
-    ["value"]=>
+    [%u|b%"value"]=>
     NULL
   }
 }
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug53551.phpt
@@ -0,0 +1,73 @@
+--TEST--
+Bug #44327 (PDORow::queryString property & numeric offsets / Crash)
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+include __DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+
+$createSql = "CREATE TABLE `bug53551` (
+  `count` bigint(20) unsigned NOT NULL DEFAULT '0'
+)";
+
+$db->exec('drop table if exists bug53551');
+$db->exec($createSql);
+$db->exec("insert into bug53551 set `count` = 1 ");
+$db->exec("SET sql_mode = 'Traditional'");
+$sql = 'UPDATE bug53551 SET `count` = :count';
+$stmt = $db->prepare($sql);
+
+$values = array (
+    'count' => NULL,
+);
+
+echo "1\n";
+$stmt->execute($values);
+var_dump($stmt->errorInfo());
+
+echo "2\n";
+$stmt->execute($values);
+var_dump($stmt->errorInfo());
+
+echo "\ndone\n";
+
+?>
+--CLEAN--
+<?php
+include __DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS bug53551');
+?>
+--EXPECTF--
+1
+
+Warning: PDOStatement::execute(): SQLSTATE[23000]: Integrity constraint violation: 1048 Column 'count' cannot be null in %s on line %d
+array(3) {
+  [0]=>
+  string(5) "23000"
+  [1]=>
+  int(1048)
+  [2]=>
+  string(29) "Column 'count' cannot be null"
+}
+2
+
+Warning: PDOStatement::execute(): SQLSTATE[23000]: Integrity constraint violation: 1048 Column 'count' cannot be null in %s on line %d
+array(3) {
+  [0]=>
+  string(5) "23000"
+  [1]=>
+  int(1048)
+  [2]=>
+  string(29) "Column 'count' cannot be null"
+}
+
+done
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug53782.phpt
@@ -0,0 +1,40 @@
+--TEST--
+PDO MySQL Bug #53782 (foreach throws irrelevant exception)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+PDOTest::skip();
+?>
+--FILE--
+<?php
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+$conn = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+
+$conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+
+$res = $conn->query('SELECT 0');
+
+try {
+    $conn->query('ERROR');
+} catch (PDOException $e) {
+    echo "Caught: ".$e->getMessage()."\n";
+}
+
+foreach ($res as $k => $v) {
+    echo "Value: $v[0]\n";
+}
+
+echo "DONE";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Caught: SQLSTATE[42000]: %s
+Value: 0
+DONE
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug54929.phpt
@@ -0,0 +1,74 @@
+--TEST--
+Bug #54929 (Parse error with single quote in sql comment (pdo-mysql))
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+
+?>
+--FILE--
+<?php
+
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+$pdodb = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+
+
+function testQuery($query) {
+	global $pdodb;
+	$stmt = $pdodb->prepare($query);
+	
+	if (!$stmt->execute(array("foo"))) {
+		var_dump($stmt->errorInfo());
+	} else{
+		var_dump($stmt->fetch(PDO::FETCH_ASSOC));
+	}
+}
+
+testQuery("/* ' */ select ? as f1 /* ' */");
+testQuery("/* '-- */ select ? as f1 /* *' */");
+testQuery("/* ' */ select ? as f1 --';");
+testQuery("/* ' */ select ? as f1 -- 'a;");
+testQuery("/*'**/ select ? as f1 /* ' */");
+testQuery("/*'***/ select ? as f1 /* ' */");
+testQuery("/*'**a ***b / ****
+******
+**/ select ? as f1 /* ' */");
+
+?>
+--EXPECTF--
+array(1) {
+  ["f1"]=>
+  string(3) "foo"
+}
+array(1) {
+  ["f1"]=>
+  string(3) "foo"
+}
+
+Warning: PDOStatement::execute(): SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '--'' at line 1 in %s on line %d
+array(3) {
+  [0]=>
+  string(5) "42000"
+  [1]=>
+  int(1064)
+  [2]=>
+  string(149) "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '--'' at line 1"
+}
+array(1) {
+  ["f1"]=>
+  string(3) "foo"
+}
+array(1) {
+  ["f1"]=>
+  string(3) "foo"
+}
+array(1) {
+  ["f1"]=>
+  string(3) "foo"
+}
+array(1) {
+  ["f1"]=>
+  string(3) "foo"
+}
--- a/ext/pdo_mysql/tests/bug_33689.phpt
+++ b/ext/pdo_mysql/tests/bug_33689.phpt
@@ -24,12 +24,25 @@
 $stmt = $db->prepare('SELECT * from test');
 print_r($stmt->getColumnMeta(0));
 $stmt->execute();
-print_r($stmt->getColumnMeta(0));
+$tmp = $stmt->getColumnMeta(0);
+
+// libmysql and mysqlnd will show the pdo_type entry at a different position in the hash
+if (!isset($tmp['pdo_type']) || (isset($tmp['pdo_type']) && $tmp['pdo_type'] != 2))
+	printf("Expecting pdo_type = 2 got %s\n", $tmp['pdo_type']);
+else
+	unset($tmp['pdo_type']);
+
+print_r($tmp);
 ?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
 --EXPECTF--
 object(PDOStatement)#%d (1) {
-  ["queryString"]=>
-  string(18) "SELECT * from test"
+  [%u|b%"queryString"]=>
+  %unicode|string%(18) "SELECT * from test"
 }
 Array
 (
@@ -48,5 +61,4 @@
     [name] => bar
     [len] => 11
     [precision] => 0
-    [pdo_type] => 2
 )
--- a/ext/pdo_mysql/tests/bug_37445.phpt
+++ b/ext/pdo_mysql/tests/bug_37445.phpt
@@ -15,7 +15,6 @@
 $db->setAttribute(PDO :: ATTR_EMULATE_PREPARES, true);
 $stmt = $db->prepare("SELECT 1");
 $stmt->bindParam(':a', 'b');
-
 ?>
 --EXPECTF--
 Fatal error: Cannot pass parameter 2 by reference in %sbug_37445.php on line %d
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_39858.phpt
@@ -0,0 +1,102 @@
+--TEST--
+Bug #39858 (Lost connection to MySQL server during query by a repeated call stored proced)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 50000)
+	die(sprintf("skip Need MySQL Server 5.0.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+
+function bug_39858($db) {
+
+	$db->exec("DROP PROCEDURE IF EXISTS p");
+	$db->exec("
+		CREATE PROCEDURE p()
+			NOT DETERMINISTIC
+			CONTAINS SQL
+			SQL SECURITY DEFINER
+			COMMENT ''
+		BEGIN
+			SELECT 2 * 2;
+		END;");
+
+	$stmt = $db->prepare("CALL p()");
+	$stmt->execute();
+	do {
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	} while ($stmt->nextRowset());
+
+	$stmt = $db->prepare("CALL p()");
+	$stmt->execute();
+	do {
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	} while ($stmt->nextRowset());
+	$stmt->closeCursor();
+
+}
+
+printf("Emulated Prepared Statements...\n");
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+bug_39858($db);
+
+printf("Native Prepared Statements...\n");
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+bug_39858($db);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec("DROP PROCEDURE IF EXISTS p");
+?>
+--EXPECTF--
+Emulated Prepared Statements...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"2 * 2"]=>
+    %unicode|string%(1) "4"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"2 * 2"]=>
+    %unicode|string%(1) "4"
+  }
+}
+Native Prepared Statements...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"2 * 2"]=>
+    %unicode|string%(1) "4"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"2 * 2"]=>
+    %unicode|string%(1) "4"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_41125.phpt
@@ -0,0 +1,51 @@
+--TEST--
+Bug #41125 (PDO mysql + quote() + prepare() can result in segfault)
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+
+$db = MySQLPDOTest::factory();
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+die("skip $version");
+if ($version < 40100)
+	die(sprintf("skip Need MySQL Server 5.0.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+$db->exec("DROP TABLE IF EXISTS test");
+
+// And now allow the evil to do his work
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+$sql = "CREATE TABLE IF NOT EXISTS test(id INT); INSERT INTO test(id) VALUES (1); SELECT * FROM test; INSERT INTO test(id) VALUES (2); SELECT * FROM test;";
+// NOTE: This will fail, it is OK to fail - you must not mix DML/DDL and SELECT
+// The PDO API does not support multiple queries properly!
+// Read http://blog.ulf-wendel.de/?p=192
+// Compare MySQL C-API documentation
+$stmt = $db->query($sql);
+do {
+	var_dump($stmt->fetchAll());
+} while ($stmt->nextRowset());
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec("DROP TABLE IF EXISTS test");
+?>
+--EXPECTF--
+Warning: PDOStatement::fetchAll(): SQLSTATE[HY000]: General error in %s on line %d
+array(0) {
+}
+done!
--- a/ext/pdo_mysql/tests/bug_41698.phpt
+++ b/ext/pdo_mysql/tests/bug_41698.phpt
@@ -22,16 +22,16 @@
 $stmt->execute(array($value));
 var_dump($db->query('SELECT * from test')->fetchAll(PDO::FETCH_ASSOC));
 ?>
---EXPECT--
+--EXPECTF--
 array(2) {
   [0]=>
   array(1) {
-    ["floatval"]=>
-    string(8) "2.340000"
+    [%u|b%"floatval"]=>
+    %unicode|string%(8) "2.340000"
   }
   [1]=>
   array(1) {
-    ["floatval"]=>
-    string(8) "4.560000"
+    [%u|b%"floatval"]=>
+    %unicode|string%(8) "4.560000"
   }
 }
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_41997.phpt
@@ -0,0 +1,70 @@
+--TEST--
+PDO MySQL Bug #41997 (stored procedure call returning single rowset blocks future queries)
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+
+$db = MySQLPDOTest::factory();
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 50000)
+	die(sprintf("skip Need MySQL Server 5.0.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+
+$db->exec('DROP PROCEDURE IF EXISTS p');
+$db->exec('CREATE PROCEDURE p() BEGIN SELECT 1 AS "one"; END');
+
+$stmt = $db->query("CALL p()");
+do {
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+} while ($stmt->nextRowset());
+var_dump($stmt->errorInfo());
+
+$stmt = $db->query('SELECT 2 AS "two"');
+var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+var_dump($stmt->errorInfo());
+print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"one"]=>
+    %unicode|string%(1) "1"
+  }
+}
+array(3) {
+  [0]=>
+  %unicode|string%(5) "00000"
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"two"]=>
+    %unicode|string%(1) "2"
+  }
+}
+array(3) {
+  [0]=>
+  %unicode|string%(5) "00000"
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_42499.phpt
@@ -0,0 +1,80 @@
+--TEST--
+Bug #42499 (Multi-statement execution via PDO::exec() makes connection unusable)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+MySQLPDOTest::skip();
+
+$db = MySQLPDOTest::factory();
+$stmt = $db->query('SELECT VERSION() as _version');
+$row = $stmt->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 41000)
+	die(sprintf("skip Need MySQL Server 4.1.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+
+function bug_42499($db) {
+
+	$db->exec('DROP TABLE IF EXISTS test');
+	$db->exec("CREATE TABLE test(id CHAR(1)); INSERT INTO test(id) VALUES ('a')");
+
+	$stmt = $db->query('SELECT id AS _id FROM test');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	// You must not use exec() to run statements that create a result set!
+	$db->exec('SELECT id FROM test');
+	// This will bail at you because you have not fetched the SELECT results: this is not a bug!
+	$db->exec("INSERT INTO test(id) VALUES ('b')");
+
+}
+
+print "Emulated Prepared Statements...\n";
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);
+bug_42499($db);
+
+print "Native Prepared Statements...\n";
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);
+bug_42499($db);
+
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+
+print "done!";
+?>
+--EXPECTF--
+Emulated Prepared Statements...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_id"]=>
+    %unicode|string%(1) "a"
+  }
+}
+
+Warning: PDO::exec(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+Native Prepared Statements...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_id"]=>
+    %unicode|string%(1) "a"
+  }
+}
+
+Warning: PDO::exec(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_43371.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Bug #43371 (Memory errors in PDO constructor)
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+$dsn = MySQLPDOTest::getDSN();
+$db = new PDO($dsn, PDO_MYSQL_TEST_USER, PDO_MYSQL_TEST_PASS, array(PDO::ATTR_PERSISTENT => true));
+
+print "done!";
+?>
+--EXPECT--
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_44454.phpt
@@ -0,0 +1,114 @@
+--TEST--
+Bug #44454 (Unexpected exception thrown in foreach() statement)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+PDOTest::skip();
+?>
+--FILE--
+<?php
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+$db = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+
+function bug_44454($db) {
+
+	try {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec('CREATE TABLE test(a INT, b INT, UNIQUE KEY idx_ab (a, b))');
+		$db->exec('INSERT INTO test(a, b) VALUES (1, 1)');
+
+		$stmt = $db->query('SELECT a, b FROM test');
+		printf("... SELECT has returned %d row...\n", $stmt->rowCount());
+		while ($row = $stmt->fetch()) {
+			try {
+				printf("... INSERT should fail...\n");
+				$db->exec('INSERT INTO test(a, b) VALUES (1, 1)');
+			} catch (Exception $e) {
+				printf("... STMT - %s\n", var_export($stmt->errorCode(), true));
+				printf("... PDO  - %s\n", var_export($db->errorInfo(), true));
+			}
+		}
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec('CREATE TABLE test(a INT, b INT, UNIQUE KEY idx_ab (a, b))');
+		$db->exec('INSERT INTO test(a, b) VALUES (1, 1)');
+
+	} catch (Exception $e) {
+		printf("... While error %s\n", $e->getMessage()); ;
+	}
+
+	$stmt = $db->query('SELECT a, b FROM test');
+	printf("... SELECT has returned %d row...\n", $stmt->rowCount());
+	foreach ($stmt as $row) {
+		try {
+			printf("... INSERT should fail...\n");
+			$db->exec('INSERT INTO test(a, b) VALUES (1, 1)');
+		} catch (Exception $e) {
+			printf("... STMT - %s\n", var_export($stmt->errorCode(), true));
+			printf("... PDO  - %s\n", var_export($db->errorInfo(), true));
+		}
+	}
+
+}
+
+$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+
+print "Native Prepared Statements\n";
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+bug_44454($db);
+
+print "\nEmulated Prepared Statements\n";
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+bug_44454($db);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--XFAIL--
+For some reason the exception gets thrown at the wrong place
+--EXPECTF--
+Native Prepared Statements
+... SELECT has returned 1 row...
+... INSERT should fail...
+... STMT - '00000'
+... PDO  - array (
+  0 => '23000',
+  1 => 1062,
+  2 => 'Duplicate entry \'1-1\' for key %s',
+)
+... SELECT has returned 1 row...
+... INSERT should fail...
+... STMT - '00000'
+... PDO  - array (
+  0 => '23000',
+  1 => 1062,
+  2 => 'Duplicate entry \'1-1\' for key %s',
+)
+
+Emulated Prepared Statements
+... SELECT has returned 1 row...
+... INSERT should fail...
+... STMT - '00000'
+... PDO  - array (
+  0 => '23000',
+  1 => 1062,
+  2 => 'Duplicate entry \'1-1\' for key %s',
+)
+... SELECT has returned 1 row...
+... INSERT should fail...
+... STMT - '00000'
+... PDO  - array (
+  0 => '23000',
+  1 => 1062,
+  2 => 'Duplicate entry \'1-1\' for key %s',
+)
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_44707.phpt
@@ -0,0 +1,92 @@
+--TEST--
+Bug #44707 (The MySQL PDO driver resets variable content after bindParam on tinyint field)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+MySQLPDOTest::skip();
+
+$db = MySQLPDOTest::factory();
+$stmt = $db->query('SELECT VERSION() as _version');
+$row = $stmt->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 41000)
+	die(sprintf("skip Will work different with MySQL Server < 4.1.0, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+$db = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+
+function bug_44707($db) {
+
+	$db->exec('DROP TABLE IF EXISTS test');
+	$db->exec('CREATE TABLE test(id INT, mybool TINYINT)');
+
+	$id = 1;
+	$mybool = false;
+	var_dump($mybool);
+
+	$stmt = $db->prepare('INSERT INTO test(id, mybool) VALUES (?, ?)');
+	$stmt->bindParam(1, $id);
+	// From MySQL 4.1 on boolean and TINYINT don't match! INSERT will fail.
+	// Versions prior to 4.1 have a weak test and will accept this.
+	$stmt->bindParam(2, $mybool, PDO::PARAM_BOOL);
+	var_dump($mybool);
+
+	$stmt->execute();
+	var_dump($mybool);
+
+	$stmt = $db->query('SELECT * FROM test');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	$stmt = $db->prepare('INSERT INTO test(id, mybool) VALUES (?, ?)');
+	$stmt->bindParam(1, $id);
+	// INT and integer work well together
+	$stmt->bindParam(2, $mybool, PDO::PARAM_INT);
+	$stmt->execute();
+
+	$stmt = $db->query('SELECT * FROM test');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+}
+
+
+/*
+// This is beyond the control of the driver... - the driver never gets in touch with bound values
+print "Emulated Prepared Statements\n";
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+bug_44707($db);
+*/
+
+print "Native Prepared Statements\n";
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+bug_44707($db);
+
+print "done!";
+?>
+--EXPECTF--
+Native Prepared Statements
+bool(false)
+bool(false)
+bool(false)
+array(0) {
+}
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"mybool"]=>
+    %unicode|string%(1) "0"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_61207.phpt
@@ -0,0 +1,103 @@
+--TEST--
+PDO MySQL Bug #61207 (PDO::nextRowset() after a multi-statement query doesn't always work)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+PDOTest::skip();
+?>
+--FILE--
+<?php
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+
+$link = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+
+$link->query('create table `bug61207`( `id` int )');
+
+$handle1 = $link->prepare('insert into bug61207(id) values(1);
+                          select * from bug61207 where id = ?;
+                          update bug61207 set id = 2 where id = ?;');
+						     
+$handle1->bindValue('1', '1');
+$handle1->bindValue('2', '1');
+				      
+$handle1->execute();   
+$i = 1;
+print("Handle 1:\n");
+do {
+	print('Rowset ' . $i++ . "\n");
+	if ($handle1->columnCount() > 0)
+		print("Results detected\n");
+} while($handle1->nextRowset());
+
+$handle2 = $link->prepare('select * from bug61207 where id = ?;
+                           update bug61207 set id = 1 where id = ?;');
+					        
+$handle2->bindValue('1', '2');
+$handle2->bindValue('2', '2');
+
+$handle2->execute();
+
+$i = 1;
+print("Handle 2:\n");
+do {
+	print('Rowset ' . $i++ . "\n");
+	if ($handle2->columnCount() > 0)
+		print("Results detected\n");
+} while($handle2->nextRowset());
+
+$handle3 = $link->prepare('update bug61207 set id = 2 where id = ?;
+                           select * from bug61207 where id = ?;');
+ 
+$handle3->bindValue('1', '1');
+$handle3->bindValue('2', '2');
+
+$handle3->execute();
+
+$i = 1;
+print("Handle 3:\n");
+do {
+	print('Rowset ' . $i++ . "\n");
+	if ($handle3->columnCount() > 0)
+		print("Results detected\n");
+} while($handle3->nextRowset());
+
+$handle4 = $link->prepare('insert into bug61207(id) values(3);
+                           update bug61207 set id = 2 where id = ?;
+                           select * from bug61207 where id = ?;');
+															      
+$handle4->bindValue('1', '3');
+$handle4->bindValue('2', '2');
+									       
+$handle4->execute();
+      
+$i = 1;
+print("Handle 4:\n");
+do {
+	print('Rowset ' . $i++ . "\n");
+	if ($handle1->columnCount() > 0)
+		print("Results detected\n");
+} while($handle1->nextRowset());
+
+$link->query("DROP TABLE bug61207");
+?>
+--EXPECT--
+Handle 1:
+Rowset 1
+Rowset 2
+Results detected
+Rowset 3
+Handle 2:
+Rowset 1
+Results detected
+Rowset 2
+Handle 3:
+Rowset 1
+Rowset 2
+Results detected
+Handle 4:
+Rowset 1
+Rowset 2
+Rowset 3
+Results detected
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_61411.phpt
@@ -0,0 +1,53 @@
+--TEST--
+Bug #61411 (PDO Segfaults with PERSISTENT == TRUE && EMULATE_PREPARES == FALSE)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 40106)
+	die(sprintf("skip Need MySQL Server 4.1.6+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+$attr	= getenv('PDOTEST_ATTR');
+if (!$attr) {
+	$attr = array();
+} else {
+	$attr = unserialize($attr);
+}
+$attr[PDO::ATTR_PERSISTENT] = true;
+$attr[PDO::ATTR_EMULATE_PREPARES] = false;
+putenv('PDOTEST_ATTR='.serialize($attr));
+
+$db = MySQLPDOTest::factory();
+
+$stmt = $db->prepare("SELECT 1");
+$stmt->execute();
+
+foreach ($stmt as $line) {
+	var_dump($line);
+}
+
+print "done!";
+?>
+--EXPECTF--
+array(2) {
+  [1]=>
+  int(1)
+  [2]=>
+  int(1)
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_61755.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Bug #61755 (A parsing bug in the prepared statements can lead to access violations)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require dirname(__FILE__) . '/config.inc';
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+PDOTest::skip();
+?>
+--FILE--
+<?php
+require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+$db = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+
+$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+
+echo "NULL-Byte before first placeholder:\n";
+$s = $db->prepare("SELECT \"a\0b\", ?");
+$s->bindValue(1,"c");
+$s->execute();
+$r = $s->fetch();
+echo "Length of item 0: ".strlen($r[0]).", Value of item 1: ".$r[1]."\n";
+
+echo "\nOpen comment:\n";
+try {
+    $s = $db->prepare("SELECT /*");
+    $s->execute();
+} catch (Exception $e) {
+    echo "Error code: ".$e->getCode()."\n";
+}
+
+echo "\ndone!\n";
+?>
+--EXPECTF--
+NULL-Byte before first placeholder:
+Length of item 0: 3, Value of item 1: c
+
+Open comment:
+Error code: 42000
+
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_pecl_12925.phpt
@@ -0,0 +1,62 @@
+--TEST--
+PDO MySQL PECL bug #1295 (http://pecl.php.net/bugs/bug.php?id=12925)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+
+function bug_pecl_1295($db) {
+
+	$db->exec('DROP TABLE IF EXISTS test');
+	$db->exec('CREATE TABLE test(id CHAR(1))');
+	$db->exec("INSERT INTO test(id) VALUES ('a')");
+	$stmt = $db->prepare("UPDATE test SET id = 'b'");
+	$stmt->execute();
+	$stmt = $db->prepare("UPDATE test SET id = 'c'");
+	$stmt->execute();
+	$stmt = $db->prepare('SELECT id FROM test');
+	$stmt->execute();
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	$stmt->closeCursor();
+
+}
+
+printf("Emulated...\n");
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+bug_pecl_1295($db);
+
+printf("Native...\n");
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+bug_pecl_1295($db);
+
+$db->exec('DROP TABLE IF EXISTS test');
+print "done!";
+?>
+--EXPECTF--
+Emulated...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "c"
+  }
+}
+Native...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "c"
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/bug_pecl_7976.phpt
@@ -0,0 +1,92 @@
+--TEST--
+PECL Bug #7976 (Calling stored procedure several times)
+--SKIPIF--
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql')) die('skip not loaded');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 50000)
+	die(sprintf("skip Need MySQL Server 5.0.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+
+function bug_pecl_7976($db) {
+
+	$db->exec('DROP PROCEDURE IF EXISTS p');
+	$db->exec('CREATE PROCEDURE p() BEGIN SELECT "1" AS _one; END;');
+
+	$stmt = $db->query('CALL p()');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	$stmt->closeCursor();
+
+	$stmt = $db->query('CALL p()');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	$stmt->closeCursor();
+
+}
+
+printf("Emulated...\n");
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+bug_pecl_7976($db);
+
+printf("Native...\n");
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+bug_pecl_7976($db);
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP PROCEDURE IF EXISTS p');
+?>
+--XFAIL--
+Works with mysqlnd. It is not supported by libmysql. For libmysql is good enough to see no crash.
+--EXPECTF--
+Emulated...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_one"]=>
+    %unicode|string%(1) "1"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_one"]=>
+    %unicode|string%(1) "1"
+  }
+}
+Native...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_one"]=>
+    %unicode|string%(1) "1"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_one"]=>
+    %unicode|string%(1) "1"
+  }
+}
+done!
--- a/ext/pdo_mysql/tests/config.inc
+++ b/ext/pdo_mysql/tests/config.inc
@@ -1,19 +1,52 @@
 <?php
+/* Overrule global settings, if need be */
 
 if (false !== getenv('PDO_MYSQL_TEST_DSN')) {
-    # user set them from their shell
-    $config['ENV']['PDOTEST_DSN'] = getenv('PDO_MYSQL_TEST_DSN');  
-    $config['ENV']['PDOTEST_USER'] = getenv('PDO_MYSQL_TEST_USER');
-    $config['ENV']['PDOTEST_PASS'] = getenv('PDO_MYSQL_TEST_PASS');
-    if (false !== getenv('PDO_MYSQL_TEST_ATTR')) {
-        $config['ENV']['PDOTEST_ATTR'] = getenv('PDO_MYSQL_TEST_ATTR');
-    }   
+	# user set them from their shell
+	$config['ENV']['PDOTEST_DSN'] = getenv('PDO_MYSQL_TEST_DSN');
+	$config['ENV']['PDOTEST_USER'] = getenv('PDO_MYSQL_TEST_USER');
+	$config['ENV']['PDOTEST_PASS'] = getenv('PDO_MYSQL_TEST_PASS');
+	if (false !== getenv('PDO_MYSQL_TEST_ATTR')) {
+		$config['ENV']['PDOTEST_ATTR'] = getenv('PDO_MYSQL_TEST_ATTR');
+	}
 } else {
-    $config['ENV']['PDOTEST_DSN'] = 'mysql:host=localhost;dbname=test';
-    $config['ENV']['PDOTEST_USER'] = 'root';
-    $config['ENV']['PDOTEST_PASS'] = '';
+	$config['ENV']['PDOTEST_DSN'] = 'mysql:host=localhost;dbname=test';
+	$config['ENV']['PDOTEST_USER'] = 'root';
+	$config['ENV']['PDOTEST_PASS'] = '';
 }
 
 foreach ($config['ENV'] as $k => $v) {
 	putenv("$k=$v");
 }
+
+/* MySQL specific settings */
+define('PDO_MYSQL_TEST_ENGINE', (false !== getenv('PDO_MYSQL_TEST_ENGINE')) ? getenv('PDO_MYSQL_TEST_ENGINE') : 'MyISAM');
+define('PDO_MYSQL_TEST_HOST', (false !== getenv('PDO_MYSQL_TEST_HOST')) ? getenv('PDO_MYSQL_TEST_HOST') : 'localhost');
+define('PDO_MYSQL_TEST_PORT', (false !== getenv('PDO_MYSQL_TEST_PORT')) ? getenv('PDO_MYSQL_TEST_PORT') : NULL);
+define('PDO_MYSQL_TEST_DB', (false !== getenv('PDO_MYSQL_TEST_DB')) ? getenv('PDO_MYSQL_TEST_DB') : 'test');
+define('PDO_MYSQL_TEST_SOCKET', (false !== getenv('PDO_MYSQL_TEST_SOCKET')) ? getenv('PDO_MYSQL_TEST_SOCKET') : NULL);
+define('PDO_MYSQL_TEST_DSN', (false !== getenv('PDO_MYSQL_TEST_DSN')) ? getenv('PDO_MYSQL_TEST_DSN') : $config['ENV']['PDOTEST_DSN']);
+define('PDO_MYSQL_TEST_USER', (false !== getenv('PDO_MYSQL_TEST_USER')) ? getenv('PDO_MYSQL_TEST_USER') : $config['ENV']['PDOTEST_USER']);
+define('PDO_MYSQL_TEST_PASS', (false !== getenv('PDO_MYSQL_TEST_PASS')) ? getenv('PDO_MYSQL_TEST_PASS') : $config['ENV']['PDOTEST_PASS']);
+define('PDO_MYSQL_TEST_CHARSET', (false !== getenv('PDO_MYSQL_TEST_CHARSET')) ? getenv('PDO_MYSQL_TEST_CHARSET') : NULL);
+
+if (!function_exists('sys_get_temp_dir')) {
+	function sys_get_temp_dir() {
+
+		if (!empty($_ENV['TMP']))
+			return realpath( $_ENV['TMP'] );
+		if (!empty($_ENV['TMPDIR']))
+			return realpath( $_ENV['TMPDIR'] );
+		if (!empty($_ENV['TEMP']))
+			return realpath( $_ENV['TEMP'] );
+
+		$temp_file = tempnam(md5(uniqid(rand(), TRUE)), '');
+		if ($temp_file) {
+			$temp_dir = realpath(dirname($temp_file));
+			unlink($temp_file);
+			return $temp_dir;
+		}
+		return FALSE;
+	}
+}
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/mysql_pdo_test.inc
@@ -0,0 +1,177 @@
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'config.inc');
+require_once(dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc');
+
+class MySQLPDOTest extends PDOTest {
+
+	static function factory($classname = 'PDO', $drop_test_tables = false, $myattr = null, $mydsn = null) {
+
+		$dsn 	= self::getDSN($mydsn);
+		$user	= PDO_MYSQL_TEST_USER;
+		$pass	= PDO_MYSQL_TEST_PASS;
+		$attr	= getenv('PDOTEST_ATTR');
+
+		if (is_string($attr) && strlen($attr)) {
+			$attr = unserialize($attr);
+		} else {
+			$attr = null;
+		}
+		if ($user === false)
+			$user = NULL;
+		if ($pass === false)
+			$pass = NULL;
+
+		$db = new $classname($dsn, $user, $pass, $attr);
+		if (!$db) {
+			die("Could not create PDO object (DSN=$dsn, user=$user)\n");
+		}
+
+		$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);
+		$db->setAttribute(PDO::ATTR_CASE, PDO::CASE_LOWER);
+
+		return $db;
+	}
+
+	static function createTestTable($db, $engine = null) {
+		if (!$engine)
+			$engine = PDO_MYSQL_TEST_ENGINE;
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec('CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=' . $engine);
+		$db->exec("INSERT INTO test(id, label) VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')");
+	}
+
+	static function getTableEngine() {
+		return PDO_MYSQL_TEST_ENGINE;
+	}
+
+
+	static function getDSN($new_options = null, $addition = '') {
+		if (!$new_options)
+			return PDO_MYSQL_TEST_DSN . $addition;
+
+		$old_options = array();
+		$dsn = substr(PDO_MYSQL_TEST_DSN,
+			strpos(PDO_MYSQL_TEST_DSN, ':') + 1,
+			strlen(PDO_MYSQL_TEST_DSN));
+
+		// no real parser - any excotic setting can fool us
+		$parts = explode(';', $dsn);
+		foreach ($parts as $k => $v) {
+			$tmp = explode('=', $v);
+			if (count($tmp) == 2)
+				$old_options[$tmp[0]] = $tmp[1];
+		}
+
+		$options = $old_options;
+		foreach ($new_options as $k => $v)
+			$options[$k] = $v;
+
+		$dsn = 'mysql:';
+		foreach ($options as $k => $v)
+			$dsn .= sprintf('%s=%s;', $k, $v);
+
+		if ($addition)
+			$dsn .= $addition;
+		else
+			$dsn = substr($dsn, 0, strlen($dsn) -1);
+
+		return $dsn;
+	}
+
+	static function getClientVersion($db) {
+		return self::extractVersion($db->getAttribute(PDO::ATTR_CLIENT_VERSION));
+	}
+
+	static function getServerVersion($db) {
+		return self::extractVersion($db->getAttribute(PDO::ATTR_SERVER_VERSION));
+	}
+
+	static function extractVersion($version_string) {
+		/*
+		TODO:
+		We're a bit in trouble: PDO_MYSQL returns version strings.
+		That's wrong according to the manual. According to the manual
+		integers should be returned. However, this code needs to work
+		with stinky PDO_MYSQL and hopefully better PDO_MYSQLND.
+		*/
+
+		// already an int value?
+		if (is_int($version_string))
+			return $version_string;
+
+		// string but int value?
+		$tmp = (int)$version_string;
+		if (((string)$tmp) === $version_string)
+			return $tmp;
+
+		// stinky string which we need to parse
+		$parts = explode('.', $version_string);
+		if (count($parts) != 3)
+			return -1;
+
+		$version = (int)$parts[0] * 10000;
+		$version+= (int)$parts[1] * 100;
+		$version+= (int)$parts[2];
+
+		return $version;
+	}
+
+	static function getTempDir() {
+
+		if (!function_exists('sys_get_temp_dir')) {
+
+			if (!empty($_ENV['TMP']))
+				return realpath( $_ENV['TMP'] );
+			if (!empty($_ENV['TMPDIR']))
+				return realpath( $_ENV['TMPDIR'] );
+			if (!empty($_ENV['TEMP']))
+				return realpath( $_ENV['TEMP'] );
+
+			$temp_file = tempnam(md5(uniqid(rand(), TRUE)), '');
+			if ($temp_file) {
+				$temp_dir = realpath(dirname($temp_file));
+				unlink($temp_file);
+				return $temp_dir;
+			}
+			return FALSE;
+		} else {
+			return sys_get_temp_dir();
+		}
+
+	}
+
+	static function detect_transactional_mysql_engine($db) {		
+		foreach ($db->query("show variables like 'have%'") as $row) {
+			if (!empty($row) && $row[1] == 'YES' && ($row[0] == 'have_innodb' || $row[0] == 'have_bdb')) {
+				return str_replace("have_", "", $row[0]);
+			}
+		}
+		/* MySQL 5.6.1+ */
+		foreach ($db->query("SHOW ENGINES") as $row) {
+			if (isset($row['engine']) && isset($row['support'])) {
+				 if ('InnoDB' == $row['engine'] && ('YES' == $row['support'] || 'DEFAULT' == $row['support']))
+					return 'innodb';
+			}
+		}
+		return false;
+	}
+
+	static function isPDOMySQLnd() {
+			ob_start();
+			phpinfo();
+			$tmp = ob_get_contents();
+			ob_end_clean();
+			$tmp = stristr($tmp, "PDO Driver for MySQL => enabled");
+			return (bool)preg_match('/Client API version.*mysqlnd/', $tmp);
+	}
+
+	static function dropTestTable($db = NULL) {
+		if (is_null($db))
+			$db = self::factory();
+
+		$db->exec('DROP TABLE IF EXISTS test');
+	}
+
+}
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql___construct.phpt
@@ -0,0 +1,300 @@
+--TEST--
+MySQL PDO->__construct() - Generic + DSN
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function tryandcatch($offset, $code) {
+
+		try {
+			eval($code);
+			assert(sprintf("[%03d] Should have failed\n", $offset) != '');
+		} catch (PDOException $e) {
+			return sprintf("[%03d] %s, [%s] %s\n",
+				$offset,
+				$e->getMessage(),
+				(isset($db) && is_object($db)) ? $db->errorCode() : 'n/a',
+				(isset($db) && is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+		}
+
+		return '';
+	}
+
+	try {
+
+		if (NULL !== ($db = @new PDO()))
+			printf("[001] Too few parameters\n");
+
+		print tryandcatch(2, '$db = new PDO(chr(0));');
+		print tryandcatch(3, '$db = new PDO("a" . chr(0) . "b");');
+		print tryandcatch(4, '$db = new PDO("MYSQL");');
+		print tryandcatch(5, '$db = new PDO("mysql");');
+		print tryandcatch(6, '$db = new PDO("mysql ");');
+		print tryandcatch(7, '$db = new PDO("fantasyandfriends :");');
+
+		$dsn = PDO_MYSQL_TEST_DSN;
+		// MySQL Server might accept anonymous connections, don't
+		// print anything
+		tryandcatch(8, '$db = new PDO("' . $dsn . '");');
+
+		$user = 'dontcreatesuchauser';
+		$pass = 'withthispassword';
+		print tryandcatch(9, '$db = new PDO("' . $dsn . '", "' . $user . '", "' . $pass . '");');
+
+		// should fail
+		$dsn = 'mysql:';
+		print tryandcatch(10, '$db = new PDO("' . $dsn . '", "' . $user . '", "' . $pass . '");');
+
+		$dsn = PDO_MYSQL_TEST_DSN;
+		$user = PDO_MYSQL_TEST_USER;
+		$pass	= PDO_MYSQL_TEST_PASS;
+		// should work...
+		$db = new PDO($dsn, $user, $pass);
+
+		$dsn = 'mysql:invalid=foo';
+		print tryandcatch(11, '$db = new PDO("' . $dsn . '", "' . $user . '", "' . $pass . '");');
+
+		$dsn = 'mysql:' . str_repeat('howmuch=canpdoeat;', 1000);
+		print tryandcatch(12, '$db = new PDO("' . $dsn . '", "' . $user . '", "' . $pass . '");');
+
+		$dsn = 'mysql:' . str_repeat('abcdefghij', 1024 * 10) . '=somevalue';
+		print tryandcatch(13, '$db = new PDO("' . $dsn . '", "' . $user . '", "' . $pass . '");');
+
+		if (PDO_MYSQL_TEST_HOST) {
+			$host = PDO_MYSQL_TEST_HOST;
+			$invalid_host = $host . 'invalid';
+
+			// last host specification should be the one used
+			$dsn = MySQLPDOTest::getDSN(array('host' => $host), 'host=' . $invalid_host);
+			try { $db = @new PDO($dsn, $user, $pass); assert(false); printf("%s\n", $dsn); } catch (PDOException $e) {
+				$tmp = $e->getMessage();
+				if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005') && !stristr($tmp, '2002'))
+					printf("[014] Cannot find proper error codes: %s\n", $tmp);
+			}
+
+			$dsn = MySQLPDOTest::getDSN(array('host' => $invalid_host), 'host=' . $host);
+			try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {
+				printf("[015] DSN=%s, %s\n", $dsn, $e->getMessage());
+			}
+
+			$invalid_host = '-' . chr(0);
+
+			$dsn = MySQLPDOTest::getDSN(array('host' => $invalid_host));
+			try { $db = @new PDO($dsn, $user, $pass); assert(false); printf("%s\n", $dsn); } catch (PDOException $e) {
+				$tmp = $e->getMessage();
+				if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005') && !stristr($tmp, '2002'))
+					printf("[016] Cannot find proper error codes: %s\n", $tmp);
+			}
+
+			// parsing should not get confused by chr(0)
+			$dsn = MySQLPDOTest::getDSN(array('host' => $invalid_host), 'host=' . $host);
+			try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {
+				printf("[017] DSN=%s, %s\n", $dsn, $e->getMessage());
+			}
+
+		}
+
+		// what about long values for a valid option ...
+		// hostnames > 1024 chars break on some NIS-enabled FreeBSD...
+		$dsn = MySQLPDOTest::getDSN(array('host' => str_repeat('0123456789', 100)));
+		try { $db = @new PDO($dsn, $user, $pass); assert(false); printf("%s\n", $dsn); } catch (PDOException $e) {
+			$tmp = $e->getMessage();
+			if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005') && !stristr($tmp, '2002'))
+				printf("[018] Cannot find proper error codes: %s\n", $tmp);
+		}
+
+		if (PDO_MYSQL_TEST_PORT && (PDO_MYSQL_TEST_SOCKET == '')) {
+			// Playing with the port makes only sense if no socket gets used
+
+			$port = PDO_MYSQL_TEST_PORT;
+			// let's hope we don't hit a MySQL running on that port...
+			$invalid_port = $port * 2;
+
+			$dsn = MySQLPDOTest::getDSN(array('port' => $port), 'port=' . $invalid_port);
+			try { $db = @new PDO($dsn, $user, $pass); assert(false); printf("%s\n", $dsn); } catch (PDOException $e) {
+				$tmp = $e->getMessage();
+				if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005'))
+					printf("[019] Cannot find proper error codes: %s\n", $tmp);
+			}
+
+			$dsn = MySQLPDOTest::getDSN(array('port' => $invalid_port), 'port=' . $port);
+			try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {
+				printf("[020] DSN=%s, %s\n", $dsn, $e->getMessage());
+			}
+
+			$invalid_port = 'abc';
+			$dsn = MySQLPDOTest::getDSN(array('port' => $port), 'port=' . $invalid_port);
+			try {
+				$db = @new PDO($dsn, $user, $pass);
+				// atoi('abc') = 0, 0 -> fallback to default 3306 -> may or may not fail!
+			} catch (PDOException $e) {
+			}
+
+		}
+
+		if (PDO_MYSQL_TEST_DB) {
+			$db = PDO_MYSQL_TEST_DB;
+			$invalid_db = 'letshopeitdoesnotexist';
+
+			$dsn = MySQLPDOTest::getDSN(array('dbname' => $db), 'dbname=' . $invalid_db);
+			try { $db = @new PDO($dsn, $user, $pass); assert(false); printf("%s\n", $dsn); } catch (PDOException $e) {
+				$tmp = $e->getMessage();
+				if (!stristr($tmp, '42000') && !stristr($tmp, '1049'))
+					printf("[022] Cannot find proper error codes: %s\n", $tmp);
+			}
+
+			$dsn = MySQLPDOTest::getDSN(array('dbname' => $invalid_db), 'dbname=' . $db);
+			try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {
+				printf("[023] DSN=%s, %s\n", $dsn, $e->getMessage());
+			}
+
+		}
+
+		if (PDO_MYSQL_TEST_SOCKET && (stristr(PDO_MYSQL_TEST_DSN, PDO_MYSQL_TEST_SOCKET) !== false)) {
+			$socket = PDO_MYSQL_TEST_SOCKET;
+			$invalid_socket = '/lets/hope/it/does/not/exist';
+
+			$dsn = MySQLPDOTest::getDSN(array('unix_socket' => $socket), 'unix_socket=' . $invalid_socket);
+			try { $db = @new PDO($dsn, $user, $pass); assert(false); printf("%s\n", $dsn); } catch (PDOException $e) {
+				$tmp = $e->getMessage();
+				if (!stristr($tmp, 'HY000') && !stristr($tmp, '2002'))
+					printf("[024] Cannot find proper error codes: %s\n", $tmp);
+			}
+
+			$dsn = MySQLPDOTest::getDSN(array('unix_socket' => $invalid_socket), 'unix_socket=' . $socket);
+			try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {
+				printf("[025] DSN=%s, %s\n", $dsn, $e->getMessage());
+			}
+
+		}
+
+		$have_charset_support = false;
+		$dsn = MySQLPDOTest::getDSN();
+		try {
+			$db = new PDO($dsn, $user, $pass);
+			$stmt = $db->query('SELECT VERSION() as _version');
+			$version = $stmt->fetch(PDO::FETCH_ASSOC);
+
+			$tmp = explode('.', $version['_version']);
+			if ((count($tmp) == 3) &&
+					(($tmp[0] >= 4 && $tmp[1] >= 1) || ($tmp[0] >= 5))) {
+				// MySQL Server 4.1 - charset support available
+				$have_charset_support = true;
+			}
+
+		} catch (PDOException $e) {
+			printf("[026] DSN=%s, %s\n", $dsn, $e->getMessage());
+		}
+
+		if (PDO_MYSQL_TEST_CHARSET) {
+			$charset = PDO_MYSQL_TEST_CHARSET;
+			$invalid_charset = 'invalid';
+
+			if ($have_charset_support) {
+				$dsn = MySQLPDOTest::getDSN();
+				$db = new PDO($dsn, $user, $pass);
+				$stmt = $db->query(sprintf('SHOW CHARACTER SET LIKE "%s"', $charset));
+				$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+				$have_charset = (empty($tmp)) ? false : true;
+
+				if ($have_charset) {
+					$dsn = MySQLPDOTest::getDSN(array('charset' => $charset), 'charset=' . $invalid_charset);
+					try {
+						$db = @new PDO($dsn, $user, $pass);
+						/* NOTE: MySQL does a fallback to the charset suggested during the handshake - no error - no bug! */
+					} catch (PDOException $e) {
+						$tmp = $e->getMessage();
+						/* TODO: add proper codes */
+						if (!stristr($tmp, 'sqlstatecode') || !stristr($tmp, 'mysqlinternalerrcode'))
+							printf("[027] TODO - Cannot find proper error codes: %s\n", $tmp);
+					}
+
+					$dsn = MySQLPDOTest::getDSN(array('charset' => $invalid_charset), 'charset=' . $charset);
+					try {
+						$db = @new PDO($dsn, $user, $pass);
+						/* Strictly speaking we should test more: character_set_client, character_set_results, and character_set_connection */
+						$stmt = $db->query('SELECT @@character_set_connection AS _charset');
+						$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+						if ($tmp['_charset'] != $charset)
+							printf("[028] Character sets has not been set, @@character_set_connection reports '%s', expecting '%s'",
+								$tmp['_charset'], $charset);
+					} catch (PDOException $e) {
+						printf("[029] DSN=%s, %s\n", $dsn, $e->getMessage());
+					}
+				} else {
+					printf("[030] You're trying to run the tests with charset '%s' which seems not supported by the server!", $charset);
+				}
+
+			}
+
+		}
+
+		if ($have_charset_support) {
+			// In case the PDO_MYSQL_TEST_CHARSET interferes with any defaults
+			// we do another test to verify that the charset has been set.
+			$dsn = MySQLPDOTest::getDSN();
+			$db = new PDO($dsn, $user, $pass);
+			$stmt = $db->query('SHOW CHARACTER SET LIKE "latin1"');
+			$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+			$have_latin1 =(empty($tmp)) ? false : true;
+			$stmt = $db->query('SHOW CHARACTER SET LIKE "latin2"');
+			$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+			$have_latin2 =(empty($tmp)) ? false : true;
+
+			if ($have_latin1 && $have_latin2) {
+				// very likely we do have both of them...
+				try {
+					$dsn = MySQLPDOTest::getDSN(array('charset' => 'latin1'));
+					$db = new PDO($dsn, $user, $pass);
+					$stmt = $db->query('SELECT @@character_set_connection AS _charset');
+					$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+					if ($tmp['_charset'] != 'latin1')
+						printf("[031] DSN = %s, Character sets has not been set, @@character_set_connection reports '%s', expecting '%s'",
+							$dsn, $tmp['_charset'], 'latin1');
+
+				} catch (PDOException $e) {
+					printf("[032] %s\n", $e->getMessage());
+				}
+
+				try {
+					$dsn = MySQLPDOTest::getDSN(array('charset' => 'latin2'));
+					$db = new PDO($dsn, $user, $pass);
+					$stmt = $db->query('SELECT @@character_set_connection AS _charset');
+					$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+					if ($tmp['_charset'] != 'latin2')
+						printf("[033] DSN = %s, character sets has not been set, @@character_set_connection reports '%s', expecting '%s'",
+							$dsn, $tmp['_charset'], 'latin2');
+
+				} catch (PDOException $e) {
+					printf("[034] %s\n", $e->getMessage());
+				}
+
+			}
+		}
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			(is_object($db)) ? $db->errorCode() : 'n/a',
+			(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+[002] invalid data source name, [n/a] n/a
+[003] invalid data source name, [n/a] n/a
+[004] invalid data source name, [n/a] n/a
+[005] invalid data source name, [n/a] n/a
+[006] invalid data source name, [n/a] n/a
+[007] could not find driver, [n/a] n/a
+[009] SQLSTATE[%s] [1045] Access denied for user 'dont%s'@'%s' (using password: YES), [n/a] n/a
+[010] SQLSTATE[%s] [1045] Access denied for user 'dont%s'@'%s' (using password: YES), [n/a] n/a
+[017] DSN=%s, SQLSTATE[%s] [%d] %s
+[033] DSN = mysql:%s, character sets has not been set, @@character_set_connection reports 'latin1', expecting 'latin2'done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql___construct_ini.phpt
@@ -0,0 +1,56 @@
+--TEST--
+MySQL PDO->__construct() - URI
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+/* TODO - fix this limitation */
+if (getenv('PDO_MYSQL_TEST_DSN') !== "mysql:dbname=phptest;unix_socket=/tmp/mysql.sock")
+	die("skip Fix test to run in other environments as well!");
+?>
+--INI--
+pdo.dsn.mysql="mysql:dbname=phptest;socket=/tmp/mysql.sock"
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	$found = false;
+	$values = ini_get_all();
+	foreach ($values as $name => $dsn)
+		if ('pdo.dsn.mysql' == $name) {
+			printf("pdo.dsn.mysql=%s\n", $dsn);
+			$found = true;
+			break;
+		}
+
+	if (!$found) {
+		$dsn = ini_get('pdo.dsn.mysql');
+		$found = ($dsn !== false);
+	}
+
+	if (!$found)
+		printf("pdo.dsn.mysql cannot be accessed through ini_get_all()/ini_get()\n");
+
+	if (MySQLPDOTest::getDSN() == $dsn) {
+		// we are lucky, we can run the test
+		try {
+
+			$user = PDO_MYSQL_TEST_USER;
+			$pass	= PDO_MYSQL_TEST_PASS;
+			$db = new PDO('mysql', $user, $pass);
+
+		} catch (PDOException $e) {
+			printf("[001] %s, [%s] %s\n",
+				$e->getMessage(),
+				(is_object($db)) ? $db->errorCode() : 'n/a',
+				(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+		}
+
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+pdo.dsn.mysql cannot be accessed through ini_get_all()/ini_get()
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql___construct_options.phpt
@@ -0,0 +1,184 @@
+--TEST--
+MySQL PDO->__construct(), options
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function set_option_and_check($offset, $option, $value, $option_desc) {
+
+		$dsn = MySQLPDOTest::getDSN();
+		$user = PDO_MYSQL_TEST_USER;
+		$pass = PDO_MYSQL_TEST_PASS;
+
+		try {
+			$db = new PDO($dsn, $user, $pass, array($option => $value));
+			if (!is_object($db) || ($value !== ($tmp = @$db->getAttribute($option))))
+				printf("[%03d] Execting '%s'/%s got '%s'/%s' for options '%s'\n",
+					$offset,
+					$value, gettype($value),
+					$tmp, gettype($tmp),
+					$option_desc);
+		} catch (PDOException $e) {
+			printf("[%03d] %s\n", $offset, $e->getMessage());
+		}
+
+	}
+
+	try {
+
+		$dsn = MySQLPDOTest::getDSN();
+		$user = PDO_MYSQL_TEST_USER;
+		$pass = PDO_MYSQL_TEST_PASS;
+
+		$valid_options = array(
+			/* pdo_dbh.c */
+			PDO::ATTR_PERSISTENT									=> 'PDO::ATTR_PERSISTENT',
+			PDO::ATTR_AUTOCOMMIT									=> 'PDO::ATTR_AUTOCOMMIT',
+			/* mysql_driver.c */
+			/* TODO Possible bug PDO::ATTR_TIMEOUT != MYSQLI_OPT_CONNECT_TIMEOUT*/
+			PDO::ATTR_TIMEOUT 										=> 'PDO::ATTR_TIMEOUT',
+			PDO::ATTR_EMULATE_PREPARES						=> 'PDO::ATTR_EMULATE_PREPARES',
+
+			PDO::MYSQL_ATTR_USE_BUFFERED_QUERY		=> 'PDO::MYSQL_ATTR_USE_BUFFERED_QUERY',
+			PDO::MYSQL_ATTR_LOCAL_INFILE					=> 'PDO::MYSQL_ATTR_LOCAL_INFILE',
+			PDO::MYSQL_ATTR_DIRECT_QUERY					=> 'PDO::MYSQL_ATTR_DIRECT_QUERY',
+
+			PDO::MYSQL_ATTR_INIT_COMMAND					=> 'PDO::MYSQL_ATTR_INIT_COMMAND',
+		);
+
+		$defaults = array(
+			PDO::ATTR_PERSISTENT									=> false,
+			PDO::ATTR_AUTOCOMMIT									=> 1,
+			/* TODO - why is this a valid option if getAttribute() does not support it?! */
+			PDO::ATTR_TIMEOUT 										=> false,
+			PDO::ATTR_EMULATE_PREPARES						=> 1,
+			PDO::MYSQL_ATTR_USE_BUFFERED_QUERY		=> 1,
+			/* TODO getAttribute() does not handle it */
+			PDO::MYSQL_ATTR_LOCAL_INFILE					=> false,
+			/* TODO getAttribute() does not handle it */
+			PDO::MYSQL_ATTR_DIRECT_QUERY					=> 1,
+			PDO::MYSQL_ATTR_INIT_COMMAND					=> '',
+		);
+
+		if (NULL !== ($db = @new PDO($dsn, $user, $pass, 'wrong type')))
+			printf("[001] Expecting NULL got %s/%s\n", gettype($db), $db);
+
+		if (!is_object($db = new PDO($dsn, $user, $pass, array())))
+			printf("[002] Expecting object got %s/%s\n", gettype($db), $db);
+
+		do {
+			$invalid = mt_rand(-1000, 1000);
+		} while (isset($valid_options[$invalid]));
+		if (is_object($db = new PDO($dsn, $user, $pass, array($invalid => true))))
+			printf("[003] [TODO][CHANGEREQUEST] Please, lets not ignore invalid options and bail out!\n");
+
+		$db = new PDO($dsn, $user, $pass);
+		foreach ($valid_options as $option => $name) {
+			/* TODO getAttribute() is pretty poor in supporting the options, suppress errors */
+			$tmp = @$db->getAttribute($option);
+			if ($tmp !== $defaults[$option])
+				printf("[003a] Expecting default value for '%s' of '%s'/%s, getAttribute() reports setting '%s'/%s\n",
+					$name, $defaults[$option], gettype($defaults[$option]),
+					$tmp, gettype($tmp));
+		}
+
+		$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_AUTOCOMMIT => true));
+		if (!is_object($db) || !$db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+			printf("[004] Autocommit should be on\n");
+
+		$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_AUTOCOMMIT => false));
+		if (!is_object($db) || $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+			printf("[005] Autocommit should be off\n");
+
+		/* TODO: no way to check ATTR_TIMEOUT settings */
+		if (!is_object($db = new PDO($dsn, $user, $pass, array(PDO::ATTR_TIMEOUT => 10))))
+			printf("[006] ATTR_TIMEOUT should be accepted\n");
+
+		if (!is_object($db = new PDO($dsn, $user, $pass, array(PDO::ATTR_TIMEOUT => PHP_INT_MAX))))
+			printf("[007] ATTR_TIMEOUT should be accepted\n");
+
+		if (!is_object($db = new PDO($dsn, $user, $pass, array(PDO::ATTR_TIMEOUT => -PHP_INT_MAX))))
+			printf("[008] ATTR_TIMEOUT should be accepted\n");
+
+		/* TODO: Its ugly that PDO::ATTR_EMULATE_PREPARES == PDO::MYSQL_ATTR_DIRECT_QUERY */
+		$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => true));
+		if (!is_object($db))
+			printf("[009] ATTR_EMULATE_PREPARES should be accepted and on\n");
+		if (!$db->getAttribute(PDO::ATTR_EMULATE_PREPARES))
+			printf("[010] [TODO][CHANGEREQUEST] ATTR_EMULATE_PREPARES should be on\n");
+		if (!$db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[011] As PDO::MYSQL_ATTR_DIRECT_QUERY == PDO::ATTR_EMULATE_PREPARES
+				and PDO::ATTR_EMULATE_PREPARES overrules the other, PDO::MYSQL_ATTR_DIRECT_QUERY should be on\n");
+
+		$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => false));
+		if (!is_object($db))
+			printf("[012] ATTR_EMULATE_PREPARES should be accepted and on\n");
+		if ($db->getAttribute(PDO::ATTR_EMULATE_PREPARES))
+			printf("[013] [TODO][CHANGEREQUEST] ATTR_EMULATE_PREPARES should be off\n");
+		if ($db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[014] As PDO::MYSQL_ATTR_DIRECT_QUERY == PDO::ATTR_EMULATE_PREPARES
+				and PDO::ATTR_EMULATE_PREPARES overrules the other, PDO::MYSQL_ATTR_DIRECT_QUERY should be off\n");
+
+		// PDO::ATTR_EMULATE_PREPARES overrules PDO::MYSQL_ATTR_DIRECT_QUERY
+		// TODO: is it clever that a generic setting overrules a specific setting?
+		$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => true, PDO::MYSQL_ATTR_DIRECT_QUERY => false));
+		if (!$db->getAttribute(PDO::ATTR_EMULATE_PREPARES))
+			printf("[015] PDO::ATTR_EMULATE_PREPARES should be on\n");
+		if (!$db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[016] PDO::MYSQL_ATTR_DIRECT_QUERY should be on\n");
+
+		$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => false, PDO::MYSQL_ATTR_DIRECT_QUERY => true));
+		if ($db->getAttribute(PDO::ATTR_EMULATE_PREPARES))
+			printf("[017] PDO::ATTR_EMULATE_PREPARES should be off\n");
+		if ($db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[018] PDO::MYSQL_ATTR_DIRECT_QUERY should be off\n");
+
+		set_option_and_check(19, PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1, 'PDO::MYSQL_ATTR_USE_BUFFERED_QUERY');
+		set_option_and_check(20, PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 0, 'PDO::MYSQL_ATTR_USE_BUFFERED_QUERY');
+
+		set_option_and_check(21, PDO::MYSQL_ATTR_LOCAL_INFILE, true, 'PDO::MYSQL_ATTR_LOCAL_INFILE');
+		set_option_and_check(22, PDO::MYSQL_ATTR_LOCAL_INFILE, false, 'PDO::MYSQL_ATTR_LOCAL_INFILE');
+
+		set_option_and_check(23, PDO::MYSQL_ATTR_INIT_COMMAND, 'SET @a=1', 'PDO::MYSQL_ATTR_INIT_COMMAND');
+		set_option_and_check(24, PDO::MYSQL_ATTR_INIT_COMMAND, '', 'PDO::MYSQL_ATTR_INIT_COMMAND');
+		set_option_and_check(25, PDO::MYSQL_ATTR_INIT_COMMAND, 'INSERT INTO nonexistent(invalid) VALUES (1)', 'PDO::MYSQL_ATTR_INIT_COMMAND');
+
+		set_option_and_check(33, PDO::MYSQL_ATTR_DIRECT_QUERY, 1, 'PDO::MYSQL_ATTR_DIRECT_QUERY');
+		set_option_and_check(34, PDO::MYSQL_ATTR_DIRECT_QUERY, 0, 'PDO::MYSQL_ATTR_DIRECT_QUERY');
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			(is_object($db)) ? $db->errorCode() : 'n/a',
+			(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+[003] [TODO][CHANGEREQUEST] Please, lets not ignore invalid options and bail out!
+[003a] Expecting default value for 'PDO::ATTR_EMULATE_PREPARES' of '1'/integer, getAttribute() reports setting ''/boolean
+[003a] Expecting default value for 'PDO::MYSQL_ATTR_INIT_COMMAND' of ''/string, getAttribute() reports setting ''/boolean
+
+Warning: PDO::getAttribute(): SQLSTATE[IM001]: Driver does not support this function: driver does not support that attribute in %s on line %d
+[010] [TODO][CHANGEREQUEST] ATTR_EMULATE_PREPARES should be on
+
+Warning: PDO::getAttribute(): SQLSTATE[IM001]: Driver does not support this function: driver does not support that attribute in %s on line %d
+
+Warning: PDO::getAttribute(): SQLSTATE[IM001]: Driver does not support this function: driver does not support that attribute in %s on line %d
+[015] PDO::ATTR_EMULATE_PREPARES should be on
+[016] PDO::MYSQL_ATTR_DIRECT_QUERY should be on
+
+Warning: PDO::getAttribute(): SQLSTATE[IM001]: Driver does not support this function: driver does not support that attribute in %s on line %d
+[018] PDO::MYSQL_ATTR_DIRECT_QUERY should be off
+[021] Execting '1'/boolean got ''/boolean' for options 'PDO::MYSQL_ATTR_LOCAL_INFILE'
+[023] Execting 'SET @a=1'/string got ''/boolean' for options 'PDO::MYSQL_ATTR_INIT_COMMAND'
+[024] SQLSTATE[42000] [1065] Query was empty
+[025] SQLSTATE[42S02] [1146] Table '%s.nonexistent' doesn't exist
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql___construct_options_libmysql.phpt
@@ -0,0 +1,83 @@
+--TEST--
+MySQL PDO->__construct(), libmysql only options
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (MySQLPDOTest::isPDOMySQLnd())
+	die("skip libmysql only options")
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function set_option_and_check($offset, $option, $value, $option_desc, $ignore_diff = false) {
+
+		$dsn = MySQLPDOTest::getDSN();
+		$user = PDO_MYSQL_TEST_USER;
+		$pass = PDO_MYSQL_TEST_PASS;
+
+		try {
+			$db = new PDO($dsn, $user, $pass, array($option => $value));
+			if (!is_object($db) || (!$ignore_diff && ($value !== ($tmp = @$db->getAttribute($option)))))
+				printf("[%03d] Execting '%s'/%s got '%s'/%s' for options '%s'\n",
+					$offset,
+					$value, gettype($value),
+					$tmp, gettype($tmp),
+					$option_desc);
+		} catch (PDOException $e) {
+			printf("[%03d] %s\n", $offset, $e->getMessage());
+		}
+
+	}
+
+	try {
+
+		$dsn = MySQLPDOTest::getDSN();
+		$user = PDO_MYSQL_TEST_USER;
+		$pass = PDO_MYSQL_TEST_PASS;
+
+		$valid_options = array();
+		$valid_options[PDO::MYSQL_ATTR_MAX_BUFFER_SIZE] = 'PDO::MYSQL_ATTR_MAX_BUFFER_SIZE';
+		$valid_options[PDO::MYSQL_ATTR_INIT_COMMAND] = 'PDO::MYSQL_ATTR_INIT_COMMAND';
+		$valid_options[PDO::MYSQL_ATTR_READ_DEFAULT_FILE] = 'PDO::MYSQL_ATTR_READ_DEFAULT_FILE';
+		$valid_options[PDO::MYSQL_ATTR_READ_DEFAULT_GROUP] = 'PDO::MYSQL_ATTR_READ_DEFAULT_GROUP';
+
+		$defaults[PDO::MYSQL_ATTR_MAX_BUFFER_SIZE] = 1048576;
+		/* TODO getAttribute() does not handle it */
+		$defaults[PDO::MYSQL_ATTR_INIT_COMMAND] = '';
+		$defaults[PDO::MYSQL_ATTR_READ_DEFAULT_FILE] = false;
+		$defaults[PDO::MYSQL_ATTR_READ_DEFAULT_GROUP] = false;
+
+		$db = new PDO($dsn, $user, $pass);
+		foreach ($valid_options as $option => $name) {
+			/* TODO getAttribute() is pretty poor in supporting the options, suppress errors */
+			$tmp = @$db->getAttribute($option);
+			if ($tmp !== $defaults[$option])
+				printf("[001] Expecting default value for '%s' of '%s'/%s, getAttribute() reports setting '%s'/%s\n",
+					$name, $defaults[$option], gettype($defaults[$option]),
+					$tmp, gettype($tmp));
+		}
+
+		set_option_and_check(26, PDO::MYSQL_ATTR_READ_DEFAULT_FILE, true, 'PDO::MYSQL_ATTR_READ_DEFAULT_FILE');
+		set_option_and_check(27, PDO::MYSQL_ATTR_READ_DEFAULT_FILE, false, 'PDO::MYSQL_ATTR_READ_DEFAULT_FILE');
+
+		set_option_and_check(30, PDO::MYSQL_ATTR_MAX_BUFFER_SIZE, -1, 'PDO::MYSQL_ATTR_MAX_BUFFER_SIZE', true);
+		set_option_and_check(31, PDO::MYSQL_ATTR_MAX_BUFFER_SIZE, PHP_INT_MAX, 'PDO::MYSQL_ATTR_MAX_BUFFER_SIZE');
+		set_option_and_check(32, PDO::MYSQL_ATTR_MAX_BUFFER_SIZE, 1, 'PDO::MYSQL_ATTR_MAX_BUFFER_SIZE');
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			(is_object($db)) ? $db->errorCode() : 'n/a',
+			(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+[001] Expecting default value for 'PDO::MYSQL_ATTR_INIT_COMMAND' of ''/string, getAttribute() reports setting ''/boolean
+[026] Execting '1'/boolean got ''/boolean' for options 'PDO::MYSQL_ATTR_READ_DEFAULT_FILE'
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql___construct_uri.phpt
@@ -0,0 +1,76 @@
+--TEST--
+MySQL PDO->__construct() - URI
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	try {
+
+		if ($tmp = MySQLPDOTest::getTempDir()) {
+
+			$file = $tmp . DIRECTORY_SEPARATOR . 'pdomuri.tst';
+			$dsn = MySQLPDOTest::getDSN();
+			$user = PDO_MYSQL_TEST_USER;
+			$pass = PDO_MYSQL_TEST_PASS;
+			$uri = sprintf('uri:file:%s', $file);
+
+			if ($fp = @fopen($file, 'w')) {
+				// ok, great we can create a file with a DSN in it
+				fwrite($fp, $dsn);
+				fclose($fp);
+				clearstatcache();
+				assert(file_exists($file));
+				try {
+					$db = new PDO($uri, $user, $pass);
+				} catch (PDOException $e) {
+					printf("[002] URI=%s, DSN=%s, File=%s (%d bytes, '%s'), %s\n",
+						$uri, $dsn,
+						$file, filesize($file), file_get_contents($file),
+						$e->getMessage());
+				}
+				unlink($file);
+			}
+
+			if ($fp = @fopen($file, 'w')) {
+				fwrite($fp, sprintf('mysql:dbname=letshopeinvalid;%s%s',
+					chr(0), $dsn));
+				fclose($fp);
+				clearstatcache();
+				assert(file_exists($file));
+				try {
+					$db = new PDO($uri, $user, $pass);
+				} catch (PDOException $e) {
+					printf("[003] URI=%s, DSN=%s, File=%s (%d bytes, '%s'), chr(0) test, %s\n",
+					$uri, $dsn,
+					$file, filesize($file), file_get_contents($file),
+					$e->getMessage());
+				}
+				unlink($file);
+			}
+
+		}
+
+		/* TODO: safe mode */
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			(is_object($db)) ? $db->errorCode() : 'n/a',
+			(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+Warning: PDO::__construct(%s
+[002] URI=uri:file:%spdomuri.tst, DSN=mysql%sdbname=%s, File=%spdomuri.tst (%d bytes, 'mysql%sdbname=%s'), invalid data source URI
+
+Warning: PDO::__construct(%s
+[003] URI=uri:file:%spdomuri.tst, DSN=mysql%sdbname=%s, File=%spdomuri.tst (%d bytes, 'mysql%sdbname=letshopeinvalid%s'), chr(0) test, invalid data source URI
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_autocommit.phpt
@@ -0,0 +1,98 @@
+--TEST--
+PDO::ATTR_AUTOCOMMIT
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	// autocommit should be on by default
+	if (1 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))
+		printf("[001] Expecting int/1 got %s\n", var_export($tmp, true));
+
+	// lets see if the server agrees to that
+	$row = $db->query('SELECT @@autocommit AS _autocommit')->fetch(PDO::FETCH_ASSOC);
+	if (!$row['_autocommit'])
+		printf("[002] Server autocommit mode should be on, got '%s'\n", var_export($row['_autocommit']));
+
+	// on -> off
+	if (!$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 0))
+		printf("[003] Cannot turn off autocommit\n");
+
+	$row = $db->query('SELECT @@autocommit AS _autocommit')->fetch(PDO::FETCH_ASSOC);
+	if ($row['_autocommit'])
+		printf("[004] Server autocommit mode should be off, got '%s'\n", var_export($row['_autocommit']));
+
+	// PDO thinks autocommit is off, but its manually turned on...
+	if (!$db->query('SET autocommit = 1'))
+		printf("[005] Cannot turn on server autocommit mode, %s\n", var_export($db->errorInfo(), true));
+
+	if (0 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))
+		printf("[006] Expecting int/0 got %s\n", var_export($tmp, true));
+
+	// off -> on
+	if (!$db->query('SET autocommit = 0'))
+		printf("[007] Cannot turn off server autocommit mode, %s\n", var_export($db->errorInfo(), true));
+
+	if (!$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 1))
+		printf("[008] Cannot turn on autocommit\n");
+
+	$row = $db->query('SELECT @@autocommit AS _autocommit')->fetch(PDO::FETCH_ASSOC);
+	if (!$row['_autocommit'])
+		printf("[009] Server autocommit mode should be on, got '%s'\n", var_export($row['_autocommit']));
+
+	if (1 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))
+		printf("[010] Expecting int/1 got %s\n", var_export($tmp, true));
+
+	if (MySQLPDOTest::detect_transactional_mysql_engine($db)) {
+		// nice, we have a transactional engine to play with
+
+		MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+		$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+		$num = $row['_num'];
+
+		$db->query("INSERT INTO test(id, label) VALUES (100, 'z')");
+		$num++;
+		$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+		if ($row['_num'] != $num)
+			printf("[011] Insert has failed, test will fail\n");
+
+		// autocommit is on, no rollback possible
+		$db->query('ROLLBACK');
+		$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+		if ($row['_num'] != $num)
+			printf("[012] ROLLBACK should not have undone anything\n");
+
+		if (!$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 0))
+			printf("[013] Cannot turn off autocommit\n");
+
+		$db->query('DELETE FROM test WHERE id = 100');
+		$db->query('ROLLBACK');
+		$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+		if ($row['_num'] != $num)
+			printf("[014] ROLLBACK should have undone the DELETE\n");
+
+		$db->query('DELETE FROM test WHERE id = 100');
+		$db->query('COMMIT');
+		$num--;
+		$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+		if ($row['_num'] != $num)
+			printf("[015] DELETE should have been committed\n");
+
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_case.phpt
@@ -0,0 +1,224 @@
+--TEST--
+PDO::ATTR_CASE
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	$default =  $db->getAttribute(PDO::ATTR_CASE);
+	$known = array(
+		PDO::CASE_LOWER => 'PDO::CASE_LOWER',
+		PDO::CASE_UPPER => 'PDO::CASE_UPPER',
+		PDO::CASE_NATURAL => 'PDO::CASE_NATURAL'
+	);
+	if (!isset($known[$default]))
+		printf("[001] getAttribute(PDO::ATTR_CASE) returns unknown value '%s'\n",
+			var_export($default, true));
+	else
+		var_dump($known[$default]);
+
+	// lets see what the default is...
+	if (!is_object($stmt = $db->query("SELECT id, id AS 'ID_UPPER', label FROM test ORDER BY id ASC LIMIT 2")))
+		printf("[002] %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	var_dump($stmt->fetchAll(PDO::FETCH_BOTH));
+
+	if (true !== $db->setAttribute(PDO::ATTR_CASE, PDO::CASE_LOWER))
+		printf("[003] Cannot set PDO::ATTR_CASE = PDO::CASE_LOWER, %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	if (($tmp = $db->getAttribute(PDO::ATTR_CASE)) !== PDO::CASE_LOWER)
+		printf("[004] getAttribute(PDO::ATTR_CASE) returns wrong value '%s'\n",
+			var_export($tmp, true));
+
+	if (true === $db->exec('ALTER TABLE test ADD MiXeD CHAR(1)'))
+		printf("[005] Cannot add column %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	if (false === $db->exec('ALTER TABLE test ADD MYUPPER CHAR(1)'))
+		printf("[006] Cannot add column %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	if (!is_object($stmt = $db->query("SELECT id, id AS 'ID_UPPER', label, MiXeD, MYUPPER FROM test ORDER BY id ASC LIMIT 2")))
+		printf("[007] %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	var_dump($stmt->fetchAll(PDO::FETCH_BOTH));
+
+	if (true !== $db->setAttribute(PDO::ATTR_CASE, PDO::CASE_UPPER))
+		printf("[008] Cannot set PDO::ATTR_CASE = PDO::CASE_UPPER %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	if (($tmp = $db->getAttribute(PDO::ATTR_CASE)) !== PDO::CASE_UPPER)
+		printf("[009] getAttribute(PDO::ATTR_CASE) returns wrong value '%s'\n",
+			var_export($tmp, true));
+
+	if (!is_object($stmt = $db->query("SELECT id, label, MiXeD, MYUPPER, MYUPPER AS 'lower' FROM test ORDER BY id ASC LIMIT 1")))
+		printf("[010] %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	var_dump($stmt->fetchAll(PDO::FETCH_BOTH));
+
+	if (true !== $db->setAttribute(PDO::ATTR_CASE, PDO::CASE_NATURAL))
+		printf("[011] Cannot set PDO::ATTR_CASE = PDO::CASE_NATURAL %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	if (($tmp = $db->getAttribute(PDO::ATTR_CASE)) !== PDO::CASE_NATURAL)
+		printf("[012] getAttribute(PDO::ATTR_CASE) returns wrong value '%s'\n",
+			var_export($tmp, true));
+
+	if (!is_object($stmt = $db->query("SELECT id, label, MiXeD, MYUPPER, id AS 'ID' FROM test ORDER BY id ASC LIMIT 1")))
+		printf("[013] %s - %s\n",
+			var_export($db->errorInfo(), true), var_export($db->errorCode(), true));
+
+	var_dump($stmt->fetchAll(PDO::FETCH_BOTH));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+%unicode|string%(15) "PDO::CASE_LOWER"
+array(2) {
+  [0]=>
+  array(6) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"id_upper"]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+    [2]=>
+    %unicode|string%(1) "a"
+  }
+  [1]=>
+  array(6) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [0]=>
+    %unicode|string%(1) "2"
+    [%u|b%"id_upper"]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+    [2]=>
+    %unicode|string%(1) "b"
+  }
+}
+array(2) {
+  [0]=>
+  array(10) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"id_upper"]=>
+    %unicode|string%(1) "1"
+    [1]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+    [2]=>
+    %unicode|string%(1) "a"
+    [%u|b%"mixed"]=>
+    NULL
+    [3]=>
+    NULL
+    [%u|b%"myupper"]=>
+    NULL
+    [4]=>
+    NULL
+  }
+  [1]=>
+  array(10) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [0]=>
+    %unicode|string%(1) "2"
+    [%u|b%"id_upper"]=>
+    %unicode|string%(1) "2"
+    [1]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+    [2]=>
+    %unicode|string%(1) "b"
+    [%u|b%"mixed"]=>
+    NULL
+    [3]=>
+    NULL
+    [%u|b%"myupper"]=>
+    NULL
+    [4]=>
+    NULL
+  }
+}
+array(1) {
+  [0]=>
+  array(10) {
+    [%u|b%"ID"]=>
+    %unicode|string%(1) "1"
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"LABEL"]=>
+    %unicode|string%(1) "a"
+    [1]=>
+    %unicode|string%(1) "a"
+    [%u|b%"MIXED"]=>
+    NULL
+    [2]=>
+    NULL
+    [%u|b%"MYUPPER"]=>
+    NULL
+    [3]=>
+    NULL
+    [%u|b%"LOWER"]=>
+    NULL
+    [4]=>
+    NULL
+  }
+}
+array(1) {
+  [0]=>
+  array(10) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+    [1]=>
+    %unicode|string%(1) "a"
+    [%u|b%"MiXeD"]=>
+    NULL
+    [2]=>
+    NULL
+    [%u|b%"MYUPPER"]=>
+    NULL
+    [3]=>
+    NULL
+    [%u|b%"ID"]=>
+    %unicode|string%(1) "1"
+    [4]=>
+    %unicode|string%(1) "1"
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_client_version.phpt
@@ -0,0 +1,37 @@
+--TEST--
+PDO::ATTR_CLIENT_VERSION
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	assert(('' == $db->errorCode()) || ('00000' == $db->errorCode()));
+
+	$version = $db->getAttribute(PDO::ATTR_CLIENT_VERSION);
+
+	// No more constraints - mysqlnd and libmysql return different strings at least
+	// with mysqli. Return type check is already performed in the generic test.
+	// According to the manual we should get an int but as of today we do get a string...
+	if ('' == $version)
+		printf("[001] Client version must not be empty\n");
+
+
+	// Read-only
+	if (false !== $db->setAttribute(PDO::ATTR_CLIENT_VERSION, '1.0'))
+		printf("[002] Wonderful, I can change the client version!\n");
+
+	$new_version = $db->getAttribute(PDO::ATTR_CLIENT_VERSION);
+	if ($new_version !== $version)
+		printf("[003] Did we change it from '%s' to '%s'?\n", $version, $new_version);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_connection_status.phpt
@@ -0,0 +1,37 @@
+--TEST--
+PDO::ATTR_CONNECTION_STATUS
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	$status = $db->getAttribute(PDO::ATTR_CONNECTION_STATUS);
+	if (ini_get('unicode.semantics')) {
+		if (!is_unicode($status))
+			printf("[001] Expecting unicode, got '%s'\n", var_export($status, true));
+	} else {
+		if (!is_string($status))
+			printf("[002] Expecting string, got '%s'\n", var_export($status, true));
+	}
+
+	if ('' == $status)
+		printf("[003] Connection status string must not be empty\n");
+
+	if (false !== $db->setAttribute(PDO::ATTR_CONNECTION_STATUS, 'my own connection status'))
+		printf("[004] Changing read only attribute\n");
+
+	$status2 = $db->getAttribute(PDO::ATTR_CONNECTION_STATUS);
+	if ($status !== $status2)
+		printf("[005] Connection status should not have changed\n");
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_driver_name.phpt
@@ -0,0 +1,31 @@
+--TEST--
+PDO::ATTR_DRIVER_NAME
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	assert(('' == $db->errorCode()) || ('00000' == $db->errorCode()));
+
+	$name = $db->getAttribute(PDO::ATTR_DRIVER_NAME);
+	var_dump($name);
+
+	if (false !== $db->setAttribute(PDO::ATTR_DRIVER_NAME, 'mydriver'))
+		printf("[001] Wonderful, I can create new PDO drivers!\n");
+
+	$new_name = $db->getAttribute(PDO::ATTR_DRIVER_NAME);
+	if ($name != $new_name)
+		printf("[002] Did we change it from '%s' to '%s'?\n", $name, $new_name);
+
+	print "done!";
+?>
+--EXPECTF--
+%unicode|string%(5) "mysql"
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_errmode.phpt
@@ -0,0 +1,166 @@
+--TEST--
+PDO::ATTR_ERRMODE
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--INI--
+error_reporting=E_ALL
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	$valid = array(PDO::ERRMODE_SILENT, PDO::ERRMODE_WARNING, PDO::ERRMODE_EXCEPTION);
+	do {
+		$invalid = mt_rand(-1000, 1000);
+	} while (in_array($invalid, $valid));
+
+
+	$tmp = array();
+	if (false != @$db->setAttribute(PDO::ATTR_ERRMODE, $tmp))
+		printf("[001] Maybe PDO could indicate that this is not a proper way of setting the ERRMODE...\n");
+
+	$tmp = new stdClass();
+	$ret = @$db->setAttribute(PDO::ATTR_ERRMODE, $tmp);
+	if (false != $ret)
+		printf("[002] Maybe PDO could indicate that this is not a proper way of setting the ERRMODE...%s\n",
+			var_export($ret, true));
+
+	$ret = @$db->setAttribute(PDO::ATTR_ERRMODE, 'pdo');
+	if (false != $ret)
+		printf("[003] Maybe PDO could indicate that this is not a proper way of setting the ERRMODE...%s\n",
+			var_export($ret, true));
+
+	if (false != @$db->setAttribute(PDO::ATTR_ERRMODE, $invalid))
+		printf("[004] Invalid ERRMODE should be rejected\n");
+
+	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);
+	// no message for any PDO call but...
+	$db->query('THIS IS NOT VALID SQL');
+	// ... still messages for everything else
+	$code = $db->errorCode();
+	$info = $db->errorInfo();
+
+	if ($code != '42000')
+		printf("[005] Expecting SQL code 42000 got '%s'\n", $code);
+	if ($code !== $info[0])
+		printf("[006] Code and info should be identical, got errorCode() = %s, errorInfo()[0] = %s\n",
+			$code, $info[0]);
+	if ('' == $info[1])
+		printf("[007] Driver specific error code not set\n");
+	if ('' == $info[2])
+		printf("[008] Driver specific error message not set\n");
+
+	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);
+	$db->query('THIS IS NOT VALID SQL');
+
+	$code = $db->errorCode();
+	$info = $db->errorInfo();
+
+	if ($code != '42000')
+		printf("[009] Expecting SQL code 42000 got '%s'\n", $code);
+	if ($code !== $info[0])
+		printf("[010] Code and info should be identical, got errorCode() = %s, errorInfo()[0] = %s\n",
+			$code, $info[0]);
+	if ('' == $info[1])
+		printf("[011] Driver specific error code not set\n");
+	if ('' == $info[2])
+		printf("[012] Driver specific error message not set\n");
+
+	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+	try {
+		$line = __LINE__ + 1;
+		$db->query('THIS IS NOT VALID SQL');
+	} catch (PDOException $e) {
+
+		$code = $db->errorCode();
+		$info = $db->errorInfo();
+
+		if ($code != '42000')
+			printf("[013] Expecting SQL code 42000 got '%s'\n", $code);
+		if ($code !== $info[0])
+			printf("[014] Code and info should be identical, got errorCode() = %s, errorInfo()[0] = %s\n",
+				$code, $info[0]);
+		if ('' == $info[1])
+			printf("[015] Driver specific error code not set\n");
+		if ('' == $info[2])
+			printf("[016] Driver specific error message not set\n");
+
+		if ($e->getCode() !== $code)
+			printf("[017] Exception code '%s' differs from errorCode '%s'\n",
+				$e->getCode(), $code);
+
+		$msg = $e->getMessage();
+		foreach ($info as $k => $v) {
+			if (false === stristr($msg, (string)$v)) {
+				printf("[018] Cannot find all parts of the error info ('%s') in the exception message '%s'\n",
+					$v, $msg);
+			}
+		}
+
+		if ($e->getLine() !== $line)
+			printf("[019] Exception has been thrown in line %d, exception object reports line %d\n",
+				$line, $e->getLine());
+
+		if ($e->getFile() !== __FILE__)
+			printf("[020] Exception has been thrown in file '%s', exception object reports file '%s'\n",
+				__FILE__, $e->getFile());
+
+	}
+
+	function my_handler($e) {
+		global $db, $line;
+
+		$code = $db->errorCode();
+		$info = $db->errorInfo();
+
+		if ($code != '42000')
+			printf("[021] Expecting SQL code 42000 got '%s'\n", $code);
+		if ($code !== $info[0])
+			printf("[022] Code and info should be identical, got errorCode() = %s, errorInfo()[0] = %s\n",
+				$code, $info[0]);
+		if ('' == $info[1])
+			printf("[023] Driver specific error code not set\n");
+		if ('' == $info[2])
+			printf("[024] Driver specific error message not set\n");
+
+		if ($e->getCode() !== $code)
+			printf("[025] Exception code '%s' differs from errorCode '%s'\n",
+				$e->getCode(), $code);
+
+		$msg = $e->getMessage();
+		foreach ($info as $k => $v) {
+			if (false === stristr($msg, (string)$v)) {
+				printf("[026] Cannot find all parts of the error info ('%s') in the exception message '%s'\n",
+					$v, $msg);
+			}
+		}
+
+		if ($e->getLine() !== $line)
+			printf("[027] Exception has been thrown in line %d, exception object reports line %d\n",
+				$line, $e->getLine());
+
+		if ($e->getFile() !== __FILE__)
+			printf("[028] Exception has been thrown in file '%s', exception object reports file '%s'\n",
+				__FILE__, $e->getFile());
+
+		if (get_class($e) != 'PDOException')
+			printf("[029] Expecting PDO exception got exception of type '%s'\n", get_class($e));
+
+		print "\nend of execution";
+	}
+	set_exception_handler('my_handler');
+	$line = __LINE__ + 1;
+	$db->query('THIS IS NOT VALID SQL');
+
+	print "done!\n";
+--EXPECTF--
+[003] Maybe PDO could indicate that this is not a proper way of setting the ERRMODE...true
+
+Warning: PDO::query(): SQLSTATE[42000]: Syntax error or access violation: %d You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '%s' at line %d in %s on line %d
+
+end of execution
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_fetch_table_names.phpt
@@ -0,0 +1,42 @@
+--TEST--
+PDO::ATTR_FETCH_TABLE_NAMES
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	$db->setAttribute(PDO::ATTR_FETCH_TABLE_NAMES, 1);
+	$stmt = $db->query('SELECT label FROM test LIMIT 1');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	$stmt->closeCursor();
+
+	$db->setAttribute(PDO::ATTR_FETCH_TABLE_NAMES, 0);
+	$stmt = $db->query('SELECT label FROM test LIMIT 1');
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+	$stmt->closeCursor();
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"test.label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_init_command.phpt
@@ -0,0 +1,48 @@
+--TEST--
+PDO::MYSQL_ATTR_INIT_COMMAND
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--INI--
+error_reporting=E_ALL
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	$dsn = MySQLPDOTest::getDSN();
+	$user = PDO_MYSQL_TEST_USER;
+	$pass = PDO_MYSQL_TEST_PASS;
+
+	$table = sprintf("test_%s", md5(mt_rand(0, PHP_INT_MAX)));
+	$db = new PDO($dsn, $user, $pass);
+	$db->exec(sprintf('DROP TABLE IF EXISTS %s', $table));
+
+	$create = sprintf('CREATE TABLE %s(id INT)', $table);
+	var_dump($create);
+	$db = new PDO($dsn, $user, $pass, array(PDO::MYSQL_ATTR_INIT_COMMAND => $create));
+
+	$info = $db->errorInfo();
+	var_dump($info[0]);
+
+	$db->exec(sprintf('INSERT INTO %s(id) VALUES (1)', $table));
+	$stmt = $db->query(sprintf('SELECT id FROM %s', $table));
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	$db->exec(sprintf('DROP TABLE IF EXISTS %s', $table));
+	print "done!";
+?>
+--EXPECTF--
+%unicode|string%(58) "CREATE TABLE test_%s(id INT)"
+%unicode|string%(5) "00000"
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_max_buffer_size.phpt
@@ -0,0 +1,77 @@
+--TEST--
+MySQL PDO->__construct(), PDO::MYSQL_ATTR_MAX_BUFFER_SIZE
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (MySQLPDOTest::isPDOMySQLnd())
+	die("skip PDO::MYSQL_ATTR_MAX_BUFFER_SIZE not supported with mysqlnd");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function try_buffer_size($offset, $buffer_size) {
+
+		try {
+
+			$dsn = MySQLPDOTest::getDSN();
+			$user = PDO_MYSQL_TEST_USER;
+			$pass = PDO_MYSQL_TEST_PASS;
+
+			/* unsigned overflow possible ? */
+			$db = new PDO($dsn, $user, $pass,
+			array(
+				PDO::MYSQL_ATTR_MAX_BUFFER_SIZE => $buffer_size,
+				/* buffer is only relevant with native PS */
+				PDO::MYSQL_ATTR_DIRECT_QUERY => 0,
+				PDO::ATTR_EMULATE_PREPARES => 0,
+			));
+
+			$db->exec('DROP TABLE IF EXISTS test');
+			$db->exec(sprintf('CREATE TABLE test(id INT, val LONGBLOB) ENGINE = %s', PDO_MYSQL_TEST_ENGINE));
+
+			// 10 * (10 * 1024) = 10 * (10 * 1k) = 100k
+			$db->exec('INSERT INTO test(id, val) VALUES (1, REPEAT("01234567890", 10240))');
+
+			$stmt = $db->prepare('SELECT id, val FROM test');
+			$stmt->execute();
+
+			$id = $val = NULL;
+			$stmt->bindColumn(1, $id);
+			$stmt->bindColumn(2, $val);
+			while ($row = $stmt->fetch(PDO::FETCH_BOUND)) {
+				printf("[%03d] id = %d, val = %s... (length: %d)\n",
+					$offset, $id, substr($val, 0, 10), strlen($val));
+			}
+			$db->exec('DROP TABLE IF EXISTS test');
+
+		} catch (PDOException $e) {
+			printf("[%03d] %s, [%s] %s\n",
+				$offset,
+				$e->getMessage(),
+				(is_object($db)) ? $db->errorCode() : 'n/a',
+				(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+		}
+	}
+
+	try_buffer_size(1, -1);
+	try_buffer_size(2, 1000);
+	try_buffer_size(3, NULL);
+	try_buffer_size(4, 2000);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+[001] id = 1, val = 0123456789... (length: %d)
+[002] id = 1, val = 0123456789... (length: 1000)
+[003] id = 1, val = 0123456789... (length: %d)
+[004] id = 1, val = 0123456789... (length: 2000)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_oracle_nulls.phpt
@@ -0,0 +1,121 @@
+--TEST--
+PDO::ATTR_ORACLE_NULLS
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	$tmp = array();
+	if (false !== @$db->setAttribute(PDO::ATTR_ORACLE_NULLS, $tmp))
+		printf("[001] Maybe PDO could indicate that this is not a proper way of setting ATTR_ORACLE_NULLS...\n");
+
+	$tmp = new stdClass();
+	if (false !== @$db->setAttribute(PDO::ATTR_ORACLE_NULLS, $tmp));
+		printf("[002] Maybe PDO could indicate that this is not a proper way of setting ATTR_ORACLE_NULLS...\n");
+
+	if (false !== @$db->setAttribute(PDO::ATTR_ORACLE_NULLS, 'pdo'))
+		printf("[003] Maybe PDO could indicate that this is not a proper way of setting ATTR_ORACLE_NULLS...\n");
+
+	$db->setAttribute(PDO::ATTR_ORACLE_NULLS, 1);
+	$stmt = $db->query("SELECT NULL AS z, '' AS a, ' ' AS b, TRIM(' ') as c, ' d' AS d, '" . chr(0) . " e' AS e");
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	$db->setAttribute(PDO::ATTR_ORACLE_NULLS, 0);
+	$stmt = $db->query("SELECT NULL AS z, '' AS a, ' ' AS b, TRIM(' ') as c, ' d' AS d, '" . chr(0) . " e' AS e");
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	$db->setAttribute(PDO::ATTR_ORACLE_NULLS, 1);
+	$stmt = $db->query('SELECT VERSION() as _version');
+	$row = $stmt->fetch(PDO::FETCH_ASSOC);
+	if ((int)substr($row['_version'], 0, 1) >= 5)
+		$have_procedures = true;
+	else
+		$have_procedures = false;
+
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+	$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+
+	if ($have_procedures && (false !== $db->exec('DROP PROCEDURE IF EXISTS p')) &&
+		(false !== $db->exec("CREATE PROCEDURE p() BEGIN SELECT NULL as z, '' AS a, ' ' AS b, TRIM(' ') as c, ' d' AS d, ' e' AS e; END;"))) {
+		// requires MySQL 5+
+		$stmt = $db->prepare('CALL p()');
+		$stmt->execute();
+		$expected = array(
+			array(
+				"z" => NULL,
+				"a" => NULL,
+				"b" => " ",
+				"c" => NULL,
+				"d" => " d",
+				"e" => " e",
+			),
+		);
+		do {
+			$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if ($tmp != $expected) {
+				printf("[004] Expecting %s got %s\n",
+					var_export($expected, true), var_export($tmp, true));
+			}
+		} while ($stmt->nextRowset());
+
+		$stmt->execute();
+		do {
+			$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if ($tmp != $expected) {
+				printf("[005] Expecting %s got %s\n",
+					var_export($expected, true), var_export($tmp, true));
+			}
+		} while ($stmt->nextRowset());
+
+	}
+
+	if ($have_procedures)
+		@$db->exec('DROP PROCEDURE IF EXISTS p');
+
+	print "done!";
+?>
+--EXPECTF--
+[002] Maybe PDO could indicate that this is not a proper way of setting ATTR_ORACLE_NULLS...
+[003] Maybe PDO could indicate that this is not a proper way of setting ATTR_ORACLE_NULLS...
+array(1) {
+  [0]=>
+  array(6) {
+    [%u|b%"z"]=>
+    NULL
+    [%u|b%"a"]=>
+    NULL
+    [%u|b%"b"]=>
+    %unicode|string%(1) " "
+    [%u|b%"c"]=>
+    NULL
+    [%u|b%"d"]=>
+    %unicode|string%(2) " d"
+    [%u|b%"e"]=>
+    %unicode|string%(3) "%se"
+  }
+}
+array(1) {
+  [0]=>
+  array(6) {
+    [%u|b%"z"]=>
+    NULL
+    [%u|b%"a"]=>
+    %unicode|string%(0) ""
+    [%u|b%"b"]=>
+    %unicode|string%(1) " "
+    [%u|b%"c"]=>
+    %unicode|string%(0) ""
+    [%u|b%"d"]=>
+    %unicode|string%(2) " d"
+    [%u|b%"e"]=>
+    %unicode|string%(3) "%se"
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_prefetch.phpt
@@ -0,0 +1,21 @@
+--TEST--
+PDO::ATTR_PREFETCH
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	var_dump($db->getAttribute(PDO::ATTR_PREFETCH));
+	var_dump($db->setAttribute(PDO::ATTR_PREFETCH, true));
+	print "done!";
+--EXPECTF--
+Warning: PDO::getAttribute(): SQLSTATE[IM001]: Driver does not support this function: driver does not support that attribute in %s on line %d
+bool(false)
+bool(false)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_server_info.phpt
@@ -0,0 +1,48 @@
+--TEST--
+PDO::ATTR_SERVER_INFO
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	assert(('' == $db->errorCode()) || ('00000' == $db->errorCode()));
+
+	$info = $db->getAttribute(PDO::ATTR_SERVER_INFO);
+	if ('' == $info)
+		printf("[001] Server info must not be empty\n");
+
+	// Read-only?
+	if (false !== $db->setAttribute(PDO::ATTR_SERVER_INFO, 'new uptime: 0s'))
+		printf("[002] Wonderful, I can change the client version!\n");
+
+	$new_info = $db->getAttribute(PDO::ATTR_SERVER_INFO);
+	if (soundex($new_info) != soundex($info))
+		printf("[003] Did we change it from '%s' to '%s'?\n", $info, $info);
+
+	// lets hope we always run this in the same second as we did run the server info request...
+	if (!$stmt = $db->query("SHOW STATUS LIKE '%uptime%'"))
+		printf("[004] Cannot run SHOW STATUS, [%s]\n", $db->errorCode());
+	else {
+		if (!$row = $stmt->fetch(PDO::FETCH_NUM))
+			printf("[005] Unable to fetch uptime, [%s]\n", $db->errorCode());
+		else
+			$uptime = $row[1];
+		$stmt->closeCursor();
+	}
+
+	if (!preg_match('/Uptime/i', $info))
+		printf("[006] Can't find uptime in server info '%s'\n", $info);
+
+	if (isset($uptime) && !preg_match(sprintf('/Uptime: %d/i', $uptime), $info))
+		printf("[007] SHOW STATUS and server info have reported a different uptime, please check. Server info: '%s', SHOW STATUS: '%s'\n", $info, $uptime);
+
+	print "done!";
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_server_version.phpt
@@ -0,0 +1,65 @@
+--TEST--
+PDO::ATTR_SERVER_VERSION
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	assert(('' == $db->errorCode()) || ('00000' == $db->errorCode()));
+
+	$version = $db->getAttribute(PDO::ATTR_SERVER_VERSION);
+	if ('' == $version)
+		printf("[001] Server version must not be empty\n");
+
+	// Ideally the server version would be an integer - as documented but BC break!
+	// If its a version string it should be of the format \d+\.\d+\.\d+.*
+
+	if (is_string($version)) {
+		// Its not an int like documented but a string - maybe for BC reasons...
+		if (!preg_match('/(\d+)\.(\d+)\.(\d+)(.*)/', $version, $matches))
+			printf("[002] Client version string seems wrong, got '%s'\n", $version);
+		else {
+			// Difficult to define any meaningful constraints
+			// A possible better check would be calling mysqli_get_server_version() and
+			// comparing what we get. However, mysqli_get_server_version() needs a mysqli handle
+			// for which in turn one needs to parse the PDO test environment variables
+			// for connection parameter...
+			if ($matches[1] < 3)
+				printf("[003] Strange major version: '%s'. Should be more than 3\n", $matches[1]);
+			if ($matches[2] < 0)
+				printf("[004] Minor version should be at least 0, got '%s'\n", $matches[2]);
+			if ($matches[3] < 0)
+				printf("[005] Sub version should be at least 0, got '%s'\n", $matches[2]);
+		}
+	} else if (is_int($version)) {
+		// Lets accept also int if it follows the rules from the original MYSQL C API
+		$major = floor($version / 10000);
+		$minor = floor(($version - ($main * 10000)) / 100);
+		$sub = $version - ($main * 10000) - ($minor * 100);
+		if ($major < 3)
+			printf("[006] Strange major version: '%s'. Should be more than 3\n", $major);
+		if ($minor < 0)
+			printf("[007] Minor version should be at least 0, got '%s'\n", $minor);
+		if ($sub < 0)
+			printf("[008] Sub version should be at least 0, got '%s'\n", $sub);
+	}
+
+	// Read-only?
+	if (false !== $db->setAttribute(PDO::ATTR_CLIENT_VERSION, '1.0'))
+		printf("[009] Wonderful, I can change the client version!\n");
+
+	$new_version = $db->getAttribute(PDO::ATTR_SERVER_VERSION);
+	if ($new_version !== $version)
+		printf("[010] Did we change it from '%s' to '%s'?\n", $version, $new_version);
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_attr_statement_class.phpt
@@ -0,0 +1,155 @@
+--TEST--
+PDO::ATTR_STATEMENT_CLASS
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	$default =  $db->getAttribute(PDO::ATTR_STATEMENT_CLASS);
+	var_dump($default);
+
+	if (false !== ($tmp = @$db->setAttribute(PDO::ATTR_STATEMENT_CLASS)))
+		printf("[001] Expecting boolean/false got %s\n", var_export($tmp, true));
+
+	if (false !== ($tmp = @$db->setAttribute(PDO::ATTR_STATEMENT_CLASS, 'foo')))
+		printf("[002] Expecting boolean/false got %s\n", var_export($tmp, true));
+
+	if (false !== ($tmp = @$db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('classname'))))
+		printf("[003] Expecting boolean/false got %s\n", var_export($tmp, true));
+
+	// unknown class
+	if (false !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('classname', array()))))
+		printf("[004] Expecting boolean/false got %s\n", var_export($tmp, true));
+
+	// class not derived from PDOStatement
+	class myclass {
+		function __construct() {
+			printf("myclass\n");
+		}
+	}
+	if (false !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('myclass', array()))))
+		printf("[005] Expecting boolean/false got %s\n", var_export($tmp, true));
+
+	// public constructor not allowed
+	class mystatement extends PDOStatement {
+		public function __construct() {
+			printf("mystatement\n");
+		}
+	}
+
+	if (false !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('mystatement', array()))))
+		printf("[006] Expecting boolean/false got %s\n", var_export($tmp, true));
+
+	// ... but a public destructor is allowed
+	class mystatement2 extends PDOStatement {
+		public function __destruct() {
+			printf("mystatement\n");
+		}
+	}
+
+	if (true !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('mystatement2', array()))))
+		printf("[007] Expecting boolean/true got %s\n", var_export($tmp, true));
+
+	// private constructor
+	class mystatement3 extends PDOStatement {
+		private function __construct($msg) {
+			printf("mystatement3\n");
+			var_dump($msg);
+		}
+	}
+	if (true !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('mystatement3', array('param1')))))
+		printf("[008] Expecting boolean/true got %s\n", var_export($tmp, true));
+
+	// private constructor
+	class mystatement4 extends PDOStatement {
+		private function __construct($msg) {
+			printf("%s\n", get_class($this));
+			var_dump($msg);
+		}
+	}
+	if (true !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('mystatement4', array('param1')))))
+		printf("[008] Expecting boolean/true got %s\n", var_export($tmp, true));
+
+	var_dump($db->getAttribute(PDO::ATTR_STATEMENT_CLASS));
+	$stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC LIMIT 2');
+
+	class mystatement5 extends mystatement4 {
+		public function fetchAll($fetch_style = 1, $column_index = 1, $ctor_args = array()) {
+			return "no data :)";
+		}
+	}
+
+	if (true !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('mystatement5', array('mystatement5')))))
+		printf("[009] Expecting boolean/true got %s\n", var_export($tmp, true));
+	$stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC LIMIT 2');
+	var_dump($stmt->fetchAll());
+
+	if (true !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('PDOStatement'))))
+		printf("[010] Expecting boolean/true got %s\n", var_export($tmp, true));
+
+	$stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC LIMIT 1');
+	var_dump($stmt->fetchAll());
+
+	// Yes, this is a fatal error and I want it to fail.
+	abstract class mystatement6 extends mystatement5 {
+	}
+	if (true !== ($tmp = $db->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('mystatement6', array('mystatement6')))))
+		printf("[011] Expecting boolean/true got %s\n", var_export($tmp, true));
+	$stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC LIMIT 1');
+
+	print "done!";
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  %unicode|string%(12) "PDOStatement"
+}
+
+Warning: PDO::setAttribute(): SQLSTATE[HY000]: General error: PDO::ATTR_STATEMENT_CLASS requires format array(classname, array(ctor_args)); the classname must be a string specifying an existing class in %s on line %d
+
+Warning: PDO::setAttribute(): SQLSTATE[HY000]: General error in %s on line %d
+
+Warning: PDO::setAttribute(): SQLSTATE[HY000]: General error: user-supplied statement class must be derived from PDOStatement in %s on line %d
+
+Warning: PDO::setAttribute(): SQLSTATE[HY000]: General error in %s on line %d
+
+Warning: PDO::setAttribute(): SQLSTATE[HY000]: General error: user-supplied statement class cannot have a public constructor in %s on line %d
+
+Warning: PDO::setAttribute(): SQLSTATE[HY000]: General error in %s on line %d
+array(2) {
+  [0]=>
+  %unicode|string%(12) "mystatement4"
+  [1]=>
+  array(1) {
+    [0]=>
+    %unicode|string%(6) "param1"
+  }
+}
+mystatement4
+%unicode|string%(6) "param1"
+mystatement5
+%unicode|string%(12) "mystatement5"
+%unicode|string%(10) "no data :)"
+array(1) {
+  [0]=>
+  array(4) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [0]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+    [1]=>
+    %unicode|string%(1) "a"
+  }
+}
+
+Fatal error: Cannot instantiate abstract class mystatement6 in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_begintransaction.phpt
@@ -0,0 +1,206 @@
+--TEST--
+PDO->beginTransaction()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+if (false == MySQLPDOTest::detect_transactional_mysql_engine($db))
+	die("skip Transactional engine not found");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+		printf("[001] Autocommit should be on by default\n");
+
+	if (false == $db->beginTransaction())
+		printf("[002] Cannot start a transaction, [%s] [%s]\n",
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+		printf("[003] Autocommit should be on by default, beginTransaction() shall not impact it\n");
+
+	if (0 == $db->exec('DELETE FROM test'))
+		printf("[004] No rows deleted, can't be true.\n");
+
+	/* This is the PDO way to close a connection */
+	$db = null;
+	$db = MySQLPDOTest::factory();
+
+	/* Autocommit was off - by definition. Commit was not issued. DELETE should have been rolled back. */
+	if (!($stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC')))
+		printf("[005] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$row = $stmt->fetch(PDO::FETCH_ASSOC);
+	var_dump($row);
+
+	if (!$db->beginTransaction())
+		printf("[006] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (1 !== $db->exec(sprintf('DELETE FROM test WHERE id = %d', $row['id'])))
+		printf("[007] DELETE should have indicated 1 deleted row, [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (!$db->commit())
+		printf("[008] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+		printf("[009] Autocommit should be on after commit()\n");
+
+	if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))
+		printf("[010] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	var_dump($stmt->fetch(PDO::FETCH_ASSOC));
+
+	if (!$db->beginTransaction())
+		printf("[011] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$db->exec(sprintf("INSERT INTO test(id, label) VALUES (%d, 'z')", $row['id']));
+
+	if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))
+		printf("[012] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$new_row1 = $stmt->fetch(PDO::FETCH_ASSOC);
+	var_dump($new_row1);
+
+	if (!$db->commit())
+		printf("[013] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))
+		printf("[014] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$new_row2 = $stmt->fetch(PDO::FETCH_ASSOC);
+	if ($new_row1 != $new_row2) {
+		printf("[015] Results must not differ!\n");
+		var_dump($new_row1);
+		var_dump($new_row2);
+	}
+
+	if (!$db->beginTransaction())
+		printf("[016] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (1 !== $db->exec(sprintf('DELETE FROM test WHERE id = %d', $row['id'])))
+		printf("[017] DELETE should have indicated 1 deleted row, [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (!$db->rollback())
+		printf("[018] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+		printf("[019] Autocommit should be on after rollback\n");
+
+	if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))
+		printf("[020] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$new_row2 = $stmt->fetch(PDO::FETCH_ASSOC);
+	if ($new_row1 != $new_row2) {
+		printf("[021] Results must not differ!\n");
+		var_dump($new_row1);
+		var_dump($new_row2);
+	}
+
+	// now, lets check the server variables
+	if (!($stmt = $db->query('SELECT @@autocommit as auto_commit')))
+		printf("[022] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+	if ($tmp['auto_commit'] != 1)
+		printf("[023] MySQL Server should indicate autocommit mode, expecting 1, got '%s', [%d] %s\n",
+			$tmp['auto_commit'], $stmt->errorCode(), $stmt->errorInfo());
+
+	if (!$db->beginTransaction())
+		printf("[024] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (!($stmt = $db->query('SELECT @@autocommit as auto_commit')))
+		printf("[025] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+	if ($tmp['auto_commit'] != 0)
+		printf("[026] Autocommit mode of the MySQL Server should be off, got '%s', [%d] %s\n",
+			$tmp['auto_commit'], $stmt->errorCode(), trim(implode(' ', $stmt->errorInfo())));
+
+	$db->commit();
+	// Now we should be back to autocommit - we've issues a commit
+	if ($tmp['auto_commit'] != 1)
+		printf("[027] MySQL Server should indicate autocommit mode, expecting 1, got '%s', [%d] %s\n",
+			$tmp['auto_commit'], $stmt->errorCode(), $stmt->errorInfo());
+
+	// Turn off autocommit using a server variable
+	$db->exec('SET @@autocommit = 0');
+	if (1 === $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+		printf("[028] I'm confused, how can autocommit be on? Didn't I say I want to manually control transactions?\n");
+
+	if (!$db->beginTransaction())
+		printf("[029] Cannot start a transaction, [%d] %s\n",
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+
+	try {
+		if (false !== $db->beginTransaction()) {
+			printf("[030] No false and no exception - that's wrong.\n");
+		}
+	} catch (PDOException $e) {
+		assert($e->getMessage() != '');
+	}
+
+	// TODO: What about an engine that does not support transactions?
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, 'MyISAM');
+
+	if (false == $db->beginTransaction())
+		printf("[031] Cannot start a transaction, [%s] [%s]\n",
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))
+		printf("[032] Autocommit should be on my default, beginTransaction() should not change that\n");
+
+	if (0 == $db->exec('DELETE FROM test'))
+		printf("[033] No rows deleted, can't be true.\n");
+
+	if (!$db->commit())
+		printf("[034] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (false == $db->beginTransaction())
+		printf("[035] Cannot start a transaction, [%s] [%s]\n",
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+
+	if (0 == $db->exec("INSERT INTO test(id, label) VALUES (1, 'a')"))
+		printf("[036] Cannot insert data, [%s] [%s]\n",
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+
+	// Should cause a Server warning but no error
+	if (!$db->rollback())
+		printf("[037] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	var_dump($db->errorCode());
+
+	if (1 != $db->exec('DELETE FROM test'))
+		printf("[038] No rows deleted, can't be true.\n");
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "a"
+}
+bool(false)
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(1) "1"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "z"
+}
+[026] Autocommit mode of the MySQL Server should be off, got '1', [0] 00000
+[028] I'm confused, how can autocommit be on? Didn't I say I want to manually control transactions?
+%unicode|string%(5) "00000"
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_bit.phpt
@@ -0,0 +1,64 @@
+--TEST--
+MySQL PDO->exec(), BIT columns - remove after fix!
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (MySQLPDOTest::isPDOMySQLnd())
+	die("skip Known bug - mysqlnd handles BIT incorrectly!");
+?>
+--FILE--
+<?php
+	/* TODO: remove this test after fix and enable the BIT test in pdo_mysql_types.phpt again */
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function test_type(&$db, $offset, $sql_type, $value, $ret_value = NULL, $pattern = NULL) {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());
+		@$db->exec($sql);
+		if ($db->errorCode() != 0) {
+			// not all MySQL Server versions and/or engines might support the type
+			return true;
+		}
+
+		$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');
+		$stmt->bindValue(1, $offset);
+		$stmt->bindValue(2, $value);
+		if (!$stmt->execute()) {
+			printf("[%03d + 1] INSERT failed, %s\n", $offset, var_export($stmt->errorInfo(), true));
+			return false;
+		}
+		$stmt = $db->query('SELECT  id, label FROM test');
+		$row = $stmt->fetch(PDO::FETCH_ASSOC);
+		var_dump($row);
+		var_dump($value);
+
+		return true;
+	}
+
+	$db = MySQLPDOTest::factory();
+	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
+	$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+
+	test_type($db, 20, 'BIT(8)', 1);
+
+	echo "done!\n";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+array(2) {
+  [%u|b%"id"]=>
+  %unicode|string%(2) "20"
+  [%u|b%"label"]=>
+  %unicode|string%(1) "1"
+}
+int(1)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_class_constants.phpt
@@ -0,0 +1,85 @@
+--TEST--
+PDO MySQL specific class constants
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	$expected = array(
+		'MYSQL_ATTR_USE_BUFFERED_QUERY'		=> true,
+		'MYSQL_ATTR_LOCAL_INFILE'					=> true,
+		'MYSQL_ATTR_DIRECT_QUERY'					=> true,
+		'MYSQL_ATTR_FOUND_ROWS'						=> true,
+		'MYSQL_ATTR_IGNORE_SPACE'					=> true,
+		'MYSQL_ATTR_INIT_COMMAND'					=> true,
+		"MYSQL_ATTR_SSL_KEY"						=> true,
+		"MYSQL_ATTR_SSL_CERT"						=> true,
+		"MYSQL_ATTR_SSL_CA"							=> true,
+		"MYSQL_ATTR_SSL_CAPATH"						=> true,
+		"MYSQL_ATTR_SSL_CIPHER"						=> true,
+		"MYSQL_ATTR_COMPRESS"						=> true,
+	);
+
+	if (!MySQLPDOTest::isPDOMySQLnd()) {
+		$expected['MYSQL_ATTR_MAX_BUFFER_SIZE']			= true;
+		$expected['MYSQL_ATTR_READ_DEFAULT_FILE']		= true;
+		$expected['MYSQL_ATTR_READ_DEFAULT_GROUP']		= true;
+	}
+
+	/*
+	TODO
+
+		MYSQLI_OPT_CONNECT_TIMEOUT != PDO::ATTR_TIMEOUT  (integer)
+    Sets the timeout value in seconds for communications with the database.
+		^  Potential BUG, PDO::ATTR_TIMEOUT is used in pdo_mysql_handle_factory
+
+		MYSQLI_SET_CHARSET_NAME -> DSN/charset=<charset_name>
+		^ Undocumented and pitfall for ext/mysqli users
+
+		Assorted mysqlnd settings missing
+	*/
+	$ref = new ReflectionClass('PDO');
+	$constants = $ref->getConstants();
+	$values = array();
+
+	foreach ($constants as $name => $value)
+		if (substr($name, 0, 11) == 'MYSQL_ATTR_') {
+			if (!isset($values[$value]))
+				$values[$value] = array($name);
+			else
+				$values[$value][] = $name;
+
+			if (isset($expected[$name])) {
+				unset($expected[$name]);
+				unset($constants[$name]);
+			}
+
+		} else {
+			unset($constants[$name]);
+		}
+
+	if (!empty($constants)) {
+		printf("[001] Dumping list of unexpected constants\n");
+		var_dump($constants);
+	}
+
+	if (!empty($expected)) {
+		printf("[002] Dumping list of missing constants\n");
+		var_dump($expected);
+	}
+
+	if (!empty($values)) {
+		foreach ($values as $value => $constants) {
+			if (count($constants) > 1) {
+				printf("[003] Several constants share the same value '%s'\n", $value);
+				var_dump($constants);
+			}
+		}
+	}
+
+	print "done!";
+--EXPECT--
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_commit.phpt
@@ -0,0 +1,90 @@
+--TEST--
+MySQL PDO->commit()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+if (false == MySQLPDOTest::detect_transactional_mysql_engine($db))
+	die("skip Transactional engine not found");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	try {
+		if (true !== ($tmp = $db->beginTransaction())) {
+			printf("[001] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+		}
+
+		// DDL will issue an implicit commit
+		$db->exec(sprintf('DROP TABLE IF EXISTS test_commit'));
+		$db->exec(sprintf('CREATE TABLE test_commit(id INT) ENGINE=%s', MySQLPDOTest::detect_transactional_mysql_engine($db)));
+		if (true !== ($tmp = $db->commit())) {
+			printf("[002] No commit allowed? [%s] %s\n",
+				$db->errorCode(), implode(' ', $db->errorInfo()));
+		}
+
+		// pdo_transaction_transitions should check this as well...
+		// ... just to be sure the most basic stuff really works we check it again...
+		if (1 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))
+			printf("[003] According to the manual we should be back to autocommit mode, got %s/%s\n",
+				gettype($tmp), var_export($tmp, true));
+
+		if (true !== ($tmp = $db->beginTransaction()))
+			printf("[004] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+		$db->exec("INSERT INTO test(id, label) VALUES (100, 'z')");
+
+		if (true !== ($tmp = $db->commit()))
+			printf("[005] No commit allowed? [%s] %s\n",
+				$db->errorCode(), implode(' ', $db->errorInfo()));
+
+		// a weak test without unicode etc. - lets leave that to dedicated tests
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 100');
+		$rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
+		if (!isset($rows[0]['label']) || ($rows[0]['label'] != 'z')) {
+			printf("[006] Record data is strange, dumping rows\n");
+			var_dump($rows);
+		}
+
+		// Ok, lets check MyISAM resp. any other non-transactional engine
+		// pdo_mysql_begin_transaction has more on this, quick check only
+		$db = MySQLPDOTest::factory();
+		MySQLPDOTest::createTestTable($db, 'MyISAM');
+
+		if (true !== ($tmp = $db->beginTransaction()))
+			printf("[007] Expecting true, got %s/%s\n", gettype($tmp), $tmp);
+
+		$db->exec("INSERT INTO test(id, label) VALUES (100, 'z')");
+		if (true !== ($tmp = $db->commit()))
+			printf("[008] No commit allowed? [%s] %s\n",
+				$db->errorCode(), implode(' ', $db->errorInfo()));
+
+		// a weak test without unicode etc. - lets leave that to dedicated tests
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 100');
+		$rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
+		if (!isset($rows[0]['label']) || ($rows[0]['label'] != 'z')) {
+			printf("[009] Record data is strange, dumping rows\n");
+			var_dump($rows);
+		}
+
+	} catch (PDOException $e) {
+		printf("[002] %s, [%s] %s\n",
+			$e->getMessage(),
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test_commit');
+MySQLPDOTest::dropTestTable($db);
+?>
+--EXPECT--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_connect_charset.phpt
@@ -0,0 +1,33 @@
+--TEST--
+PDO_MYSQL: Defining a connection charset in the DSN
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	/* Connect to mysql to determine the current charset so we can diffinate it */
+	$link 		= MySQLPDOTest::factory();
+	$charset 	= $link->query("SHOW VARIABLES LIKE 'character_set_connection'")->fetchObject()->value;
+
+	/* Make sure that we don't attempt to set the current character set to make this case useful */
+	$new_charset	= ($charset == 'latin1' ? 'ascii' : 'latin1');
+
+	/* Done with the original connection, create a second link to test the character set being defined */
+	unset($link);
+
+	$link 		= MySQLPDOTest::factory('PDO', false, null, Array('charset' => $new_charset));
+	$conn_charset 	= $link->query("SHOW VARIABLES LIKE 'character_set_connection'")->fetchObject()->value;
+
+	if ($charset !== $conn_charset) {
+		echo "done!\n";
+	} else {
+		echo "failed!\n";
+	}
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_errorcode.phpt
@@ -0,0 +1,86 @@
+--TEST--
+MySQL PDO->errorCode()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	function check_error($offset, &$obj, $expected = '00000') {
+
+		$code = $obj->errorCode();
+		if (($code != $expected) && (($expected != '00000') && ($code != ''))) {
+			printf("[%03d] Expecting error code '%s' got code '%s'\n",
+				$offset, $expected, $code);
+		}
+
+	}
+
+	try {
+
+		/*
+		If you create a PDOStatement object through PDO->prepare()
+		or PDO->query() and invoke an error on the statement handle,
+		PDO->errorCode() will not reflect that error. You must call
+		PDOStatement->errorCode() to return the error code for an
+		operation performed on a particular statement handle.
+		*/
+		$code = $db->errorCode();
+		check_error(2, $db);
+
+		$stmt = $db->query('SELECT id, label FROM test');
+		$stmt2 = &$stmt;
+		check_error(3, $db);
+		check_error(4, $stmt);
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		@$stmt->execute();
+		check_error(4, $db);
+		check_error(5, $stmt, '42S02');
+		check_error(6, $stmt2, '42S02');
+
+		$db->exec('DROP TABLE IF EXISTS unknown');
+		@$stmt = $db->query('SELECT id, label FROM unknown');
+		check_error(7, $db, '42S02');
+
+		MySQLPDOTest::createTestTable($db);
+		$stmt = $db->query('SELECT id, label FROM test');
+		check_error(8, $db);
+		check_error(9, $stmt);
+
+		$db2 = &$db;
+		@$db->query('SELECT id, label FROM unknown');
+		check_error(10, $db, '42S02');
+		check_error(11, $db2, '42S02');
+		check_error(12, $stmt);
+		check_error(13, $stmt2);
+
+		// lets hope this is an invalid attribute code
+		$invalid_attr = -1 * PHP_INT_MAX + 3;
+		$tmp = @$db->getAttribute($invalid_attr);
+		check_error(14, $db, 'IM001');
+		check_error(15, $db2, 'IM001');
+		check_error(16, $stmt);
+		check_error(17, $stmt2);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_errorinfo.phpt
@@ -0,0 +1,111 @@
+--TEST--
+MySQL PDO->errorInfo()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	function check_error($offset, &$obj, $expected = '00000') {
+		$info = $obj->errorInfo();
+		$code = $info[0];
+
+		if (($code != $expected) && (($expected != '00000') && ($code != ''))) {
+			printf("[%03d] Expecting error code '%s' got code '%s'\n",
+				$offset, $expected, $code);
+		}
+
+		if ($expected != '00000') {
+			if (!isset($info[1]) || $info[1] == '')
+				printf("[%03d] Driver-specific error code not set\n", $offset);
+			if (!isset($info[2]) || $info[2] == '')
+				printf("[%03d] Driver-specific error message.not set\n", $offset);
+		}
+
+	}
+
+	function pdo_mysql_errorinfo($db, $offset) {
+
+		try {
+
+			/*
+			If you create a PDOStatement object through PDO->prepare()
+			or PDO->query() and invoke an error on the statement handle,
+			PDO->errorCode() will not reflect that error. You must call
+			PDOStatement->errorCode() to return the error code for an
+			operation performed on a particular statement handle.
+			*/
+			$code = $db->errorCode();
+			check_error($offset + 2, $db);
+
+			$stmt = $db->query('SELECT id, label FROM test');
+			$stmt2 = &$stmt;
+			check_error($offset + 3, $db);
+			check_error($offset + 4, $stmt);
+
+			$db->exec('DROP TABLE IF EXISTS test');
+			@$stmt->execute();
+			check_error($offset + 5, $db);
+			check_error($offset + 6, $stmt, '42S02');
+			check_error($offset + 7, $stmt2, '42S02');
+
+			@$stmt = $db->query('SELECT id, label FROM unknown');
+			check_error($offset + 8, $db, '42S02');
+
+			MySQLPDOTest::createTestTable($db);
+			$stmt = $db->query('SELECT id, label FROM test');
+			check_error($offset + 9, $db);
+			check_error($offset + 10, $stmt);
+
+			$db2 = &$db;
+			$db->exec('DROP TABLE IF EXISTS unknown');
+			@$db->query('SELECT id, label FROM unknown');
+			check_error($offset + 11, $db, '42S02');
+			check_error($offset + 12, $db2, '42S02');
+			check_error($offset + 13, $stmt);
+			check_error($offset + 14, $stmt2);
+
+			// lets hope this is an invalid attribute code
+			$invalid_attr = -1 * PHP_INT_MAX + 3;
+			$tmp = @$db->getAttribute($invalid_attr);
+			check_error($offset + 15, $db, 'IM001');
+			check_error($offset + 16, $db2, 'IM001');
+			check_error($offset + 17, $stmt);
+			check_error($offset + 18, $stmt2);
+
+		} catch (PDOException $e) {
+			printf("[%03d] %s [%s] %s\n",
+				$offset + 19, $e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+		}
+	}
+
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+	printf("Emulated Prepared Statements...\n");
+	pdo_mysql_errorinfo($db, 0);
+
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+	printf("Native Prepared Statements...\n");
+	pdo_mysql_errorinfo($db, 20);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Emulated Prepared Statements...
+[015] Driver-specific error code not set
+[015] Driver-specific error message.not set
+[016] Driver-specific error code not set
+[016] Driver-specific error message.not set
+Native Prepared Statements...
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_exec.phpt
@@ -0,0 +1,185 @@
+--TEST--
+MySQL PDO->exec(), affected rows
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	function exec_and_count($offset, &$db, $sql, $exp = NULL) {
+
+		try {
+
+			$ret = $db->exec($sql);
+			if (!is_null($exp) && ($ret !== $exp)) {
+				printf("[%03d] Expecting '%s'/%s got '%s'/%s when running '%s', [%s] %s\n",
+					$offset, $exp, gettype($exp), $ret, gettype($ret), $sql,
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+				return false;
+			}
+
+		} catch (PDOException $e) {
+			printf("[%03d] '%s' has failed, [%s] %s\n",
+				$offset, $sql, $db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return true;
+	}
+
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	/* affected rows related */
+	try {
+
+		exec_and_count(2, $db, 'DROP TABLE IF EXISTS test', 0);
+		exec_and_count(3, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);
+		exec_and_count(4, $db, "INSERT INTO test(id, col1) VALUES (1, 'a')", 1);
+		exec_and_count(5, $db, "INSERT INTO test(id, col1) VALUES (2, 'b'), (3, 'c')", 2);
+		exec_and_count(6, $db, "UPDATE test SET id = 4 WHERE id = 3", 1);
+		exec_and_count(7, $db, "INSERT INTO test(id, col1) VALUES (1, 'd') ON DUPLICATE KEY UPDATE id = 3", 2);
+		exec_and_count(8, $db, "UPDATE test SET id = 5 WHERE id = 5", 0);
+		exec_and_count(9, $db, "INSERT INTO test(id, col1) VALUES (5, 'e') ON DUPLICATE KEY UPDATE id = 6", 1);
+		exec_and_count(10, $db, "REPLACE INTO test(id, col1) VALUES (5, 'f')", 2);
+		exec_and_count(11, $db, "REPLACE INTO test(id, col1) VALUES (6, 'g')", 1);
+		exec_and_count(12, $db, 'DELETE FROM test WHERE id > 2', 4);
+		exec_and_count(13, $db, 'DROP TABLE test', 0);
+		exec_and_count(14, $db, 'SET @myvar = 1', 0);
+
+		exec_and_count(15, $db, 'THIS IS NOT VALID SQL, I HOPE', false);
+		printf("[016] [%s] %s\n", $db->errorCode(), implode(' ', $db->errorInfo()));
+
+		exec_and_count(36, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);
+		exec_and_count(37, $db, "INSERT INTO test(id, col1) VALUES (1, 'a')", 1);
+		// Results may vary. Typically you will get 1. But the MySQL 5.1 manual states: Truncation operations do not return the number of deleted rows.
+		// Don't rely on any return value!
+		exec_and_count(38, $db, 'TRUNCATE TABLE test', NULL);
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+
+	/* CREATE, DROP, CALL SP and SF */
+	if (MySQLPDOTest::getServerVersion($db) > 50000) {
+		// let's try to play with stored procedures
+		try {
+			$ignore_exception = true;
+			exec_and_count(18, $db, 'DROP PROCEDURE IF EXISTS p', 0);
+			exec_and_count(19, $db, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(255)) BEGIN SELECT VERSION() INTO ver_param; END;', 0);
+			// we got this far without problems. If there's an issue from now on, its a failure
+			$ignore_exception = false;
+			exec_and_count(20, $db, 'CALL p(@version)', 0);
+			$stmt = $db->query('SELECT @version AS p_version');
+			$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if (count($tmp) > 1 || !isset($tmp[0]['p_version'])) {
+				printf("[022] Data seems wrong, dumping\n");
+				var_dump($tmp);
+			} else {
+				$p_version = $tmp[0]['p_version'];
+			}
+
+			$stmt = $db->query('SELECT VERSION() AS _version');
+			$tmp  = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if (count($tmp) > 1 || !isset($tmp[0]['_version'])) {
+				printf("[023] Data seems wrong, dumping\n");
+				var_dump($tmp);
+			} else {
+				if ($p_version !== $tmp[0]['_version']) {
+					printf("[024] Found different version strings, SP returned '%s'/%s, SELECT returned '%s'/%s\n",
+						$p_version, gettype($p_version),
+						$tmp[0]['_version'], gettype($tmp[0]['_version']));
+				}
+			}
+			exec_and_count(25, $db, 'DROP PROCEDURE IF EXISTS p', 0);
+
+		} catch (PDOException $e) {
+			// ignore it, we might not have sufficient permissions
+			if (!$ignore_exception)
+				printf("[021] %s, [%s] %s\n",
+					$e->getMessage(),
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+		}
+
+		// stored function
+		try {
+			$ignore_exception = true;
+			exec_and_count(27, $db, 'DROP FUNCTION IF EXISTS f', 0);
+			exec_and_count(28, $db, 'CREATE FUNCTION f( ver_param VARCHAR(255)) RETURNS VARCHAR(255) DETERMINISTIC RETURN ver_param;', 0);
+			// we got this far without problems. If there's an issue from now on, its a failure
+			$ignore_exception = false;
+			$stmt = $db->query('SELECT f(VERSION()) AS f_version');
+			$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if (count($tmp) > 1 || !isset($tmp[0]['f_version'])) {
+				printf("[029] Data seems wrong, dumping\n");
+				var_dump($tmp);
+			} else {
+				$f_version = $tmp[0]['f_version'];
+			}
+			$stmt = $db->query('SELECT VERSION() AS _version');
+			$tmp  = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if (count($tmp) > 1 || !isset($tmp[0]['_version'])) {
+				printf("[030] Data seems wrong, dumping\n");
+				var_dump($tmp);
+			} else {
+				if ($f_version !== $tmp[0]['_version']) {
+					printf("[031] Found different version strings, SF returned '%s'/%s, SELECT returned '%s'/%s\n",
+						$f_version, gettype($f_version),
+						$tmp[0]['_version'], gettype($tmp[0]['_version']));
+				}
+			}
+			exec_and_count(32, $db, 'DROP FUNCTION IF EXISTS f', 0);
+
+		} catch (PDOException $e) {
+			// ignore it, we might not have sufficient permissions
+			if (!$ignore_exception)
+				printf("[026] %s, [%s] %s\n",
+					$e->getMessage(),
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+		}
+	}
+
+	// multi query
+	try {
+
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		$exp = 0;
+
+		$tmp = @$db->exec(sprintf('DROP TABLE IF EXISTS test; CREATE TABLE test(id INT) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		if ($exp !== $tmp)
+			printf("[034] Expecting %s/%s got %s/%s, [%s] %s\n",
+				$exp, gettype($exp),
+				$tmp, gettype($tmp),
+				$db->errorCode(), var_export($db->errorInfo(), true));
+
+		// this is interesting: if we get sort of affected rows, what will happen now?
+		$tmp = @$db->exec('INSERT INTO test(id) VALUES (1); INSERT INTO test(id) VALUES (2)');
+		printf("[035] With emulated PS it works but makes no sense given that exec() returns sort of affected rows...\n");
+
+
+	} catch (PDOException $e) {
+		printf("[033] %s, [%s] %s\n",
+			$e->getMessage(),
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+@$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Warning: PDO::exec(): SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'THIS IS NOT VALID SQL, I HOPE' at line 1 in %s on line %d
+[016] [42000] 42000 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'THIS IS NOT VALID SQL, I HOPE' at line %d
+[035] With emulated PS it works but makes no sense given that exec() returns sort of affected rows...
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_exec_ddl.phpt
@@ -0,0 +1,92 @@
+--TEST--
+MySQL PDO->exec(), affected rows
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	function exec_and_count($offset, &$db, $sql, $exp, $suppress_warning = false) {
+
+		try {
+
+			if ($suppress_warning)
+				$ret = @$db->exec($sql);
+			else
+				$ret = $db->exec($sql);
+
+			if ($ret !== $exp) {
+				printf("[%03d] Expecting '%s'/%s got '%s'/%s when running '%s', [%s] %s\n",
+					$offset, $exp, gettype($exp), $ret, gettype($ret), $sql,
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+				return false;
+			}
+
+		} catch (PDOException $e) {
+			printf("[%03d] '%s' has failed, [%s] %s\n",
+				$offset, $sql, $db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return true;
+	}
+
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	/* affected rows related */
+	try {
+
+		@$db->exec('DROP DATABASE IF EXISTS pdo_exec_ddl');
+		@$db->exec('DROP DATABASE IF EXISTS pdo_exec_ddl2');
+		if (1 === @$db->exec('CREATE DATABASE pdo_exec_ddl')) {
+			// yippie - we can create databases etc.
+			exec_and_count(3, $db, 'ALTER DATABASE pdo_exec_ddl CHARACTER SET latin1', 1);
+		}
+
+		exec_and_count(4, $db, 'DROP TABLE IF EXISTS pdo_exec_ddl', 0);
+		exec_and_count(5, $db, 'DROP TABLE IF EXISTS pdo_exec_ddl2', 0);
+		if (0 === $db->exec('CREATE TABLE pdo_exec_ddl(id INT, col1 CHAR(2))')) {
+			exec_and_count(5, $db, 'CREATE INDEX idx1 ON pdo_exec_ddl(id)', 0);
+			exec_and_count(6, $db, 'DROP INDEX idx1 ON pdo_exec_ddl', 0);
+			exec_and_count(7, $db, 'ALTER TABLE pdo_exec_ddl DROP id', 0);
+			exec_and_count(8, $db, 'ALTER TABLE pdo_exec_ddl ADD id INT', 0);
+			exec_and_count(9, $db, 'ALTER TABLE pdo_exec_ddl ALTER id SET DEFAULT 1', 0);
+			exec_and_count(10, $db, 'RENAME TABLE pdo_exec_ddl TO pdo_exec_ddl2', 0);
+		}
+
+		/*
+		11.1.2. ALTER LOGFILE GROUP Syntax
+		11.1.3. ALTER SERVER Syntax
+		11.1.5. ALTER TABLESPACE Syntax
+		11.1.8. CREATE LOGFILE GROUP Syntax
+		11.1.9. CREATE SERVER Syntax
+		11.1.11. CREATE TABLESPACE Syntax
+		11.1.14. DROP LOGFILE GROUP Syntax
+		11.1.15. DROP SERVER Syntax
+		11.1.17. DROP TABLESPACE Syntax
+		*/
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+MySQLPDOTest::dropTestTable($db);
+// clean up
+@$db->exec('DROP TABLE IF EXISTS pdo_exec_ddl');
+@$db->exec('DROP TABLE IF EXISTS pdo_exec_ddl2');
+@$db->exec('DROP DATABASE IF EXISTS pdo_exec_ddl');
+@$db->exec('DROP DATABASE IF EXISTS pdo_exec_ddl2');
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_exec_load_data.phpt
@@ -0,0 +1,108 @@
+--TEST--
+MySQL PDO->exec(), affected rows
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+
+// Run test only locally - not against remote hosts
+$db = MySQLPDOTest::factory();
+$stmt = $db->query('SELECT USER() as _user');
+$row = $stmt->fetch(PDO::FETCH_ASSOC);
+$tmp = explode('@', $row['_user']);
+if (count($tmp) < 2)
+	die("skip Cannot detect if test is run against local or remote database server");
+if (($tmp[1] !== 'localhost') && ($tmp[1] !== '127.0.0.1'))
+	die("skip Test cannot be run against remote database server");
+
+?>
+--FILE--
+<?php
+	function exec_and_count($offset, &$db, $sql, $exp) {
+
+		try {
+
+			$ret = $db->exec($sql);
+			if ($ret !== $exp) {
+				printf("[%03d] Expecting '%s'/%s got '%s'/%s when running '%s', [%s] %s\n",
+					$offset, $exp, gettype($exp), $ret, gettype($ret), $sql,
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+				return false;
+			}
+
+		} catch (PDOException $e) {
+
+			if (42000 == $db->errorCode()) {
+				// Error: 1148 SQLSTATE: 42000  (ER_NOT_ALLOWED_COMMAND)
+				// Load data infile not allowed
+				return false;
+			}
+
+			printf("[%03d] '%s' has failed, [%s] %s\n",
+				$offset, $sql, $db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return true;
+	}
+
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	/* affected rows related */
+	try {
+
+		exec_and_count(2, $db, 'DROP TABLE IF EXISTS test', 0);
+		exec_and_count(3, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);
+
+		$stmt = $db->query("SHOW VARIABLES LIKE 'secure_file_priv'");
+		if (($row = $stmt->fetch(PDO::FETCH_ASSOC)) && ($row['value'] != '')) {
+			$filename = $row['value'] . DIRECTORY_SEPARATOR  . "pdo_mysql_exec_load_data.csv";
+		} else {
+			$filename =  MySQLPDOTest::getTempDir() . DIRECTORY_SEPARATOR  . "pdo_mysql_exec_load_data.csv";
+		}
+
+		$fp = fopen($filename, "w");
+		fwrite($fp, b"1;foo\n");
+		fwrite($fp, b"2;bar");
+		fclose($fp);
+
+		$sql = sprintf("LOAD DATA INFILE %s INTO TABLE test FIELDS TERMINATED BY ';' LINES TERMINATED  BY '\n'", $db->quote($filename));
+
+		if (exec_and_count(4, $db, $sql, 2)) {
+
+			$stmt = $db->query('SELECT id, col1 FROM test ORDER BY id ASC');
+			$expected = array(array("id" => 1, "col1" => "foo"), array("id" => 2, "col1" => "bar"));
+			$ret = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			foreach ($expected as $offset => $exp) {
+				foreach ($exp as $key => $value) {
+					if ($ret[$offset][$key] != $value) {
+						printf("Results seem wrong, check manually\n");
+						var_dump($ret);
+						var_dump($expected);
+						break 2;
+					}
+				}
+			}
+		}
+
+		unlink($filename);
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_exec_select.phpt
@@ -0,0 +1,65 @@
+--TEST--
+MySQL PDO->exec(), SELECT
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	function exec_and_count($offset, &$db, $sql, $exp) {
+
+		try {
+
+			$ret = $db->exec($sql);
+			if ($ret !== $exp) {
+				printf("[%03d] Expecting '%s'/%s got '%s'/%s when running '%s', [%s] %s\n",
+					$offset, $exp, gettype($exp), $ret, gettype($ret), $sql,
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+				return false;
+			}
+
+		} catch (PDOException $e) {
+			printf("[%03d] '%s' has failed, [%s] %s\n",
+				$offset, $sql, $db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return true;
+	}
+
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	/* affected rows related */
+	try {
+
+		exec_and_count(2, $db, 'DROP TABLE IF EXISTS test', 0);
+		exec_and_count(3, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);
+		exec_and_count(4, $db, "INSERT INTO test(id, col1) VALUES (1, 'a')", 1);
+		// question is: will the result set be cleaned up, will it be possible to run more queries on the line?
+		// buffered or unbuffered does not matter!
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		exec_and_count(5, $db, 'SELECT id FROM test', 0);
+		exec_and_count(6, $db, "INSERT INTO test(id, col1) VALUES (2, 'b')", 1);
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			$db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+@$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Warning: PDO::exec(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+[006] Expecting '1'/integer got ''/boolean when running 'INSERT INTO test(id, col1) VALUES (2, 'b')', [HY000] HY000 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute.
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_fetch_both.phpt
@@ -0,0 +1,88 @@
+--TEST--
+MySQL PDOStatement->fetch()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	function fetch($offset, &$db, $query, $expect = null) {
+
+		try {
+			$stmt = $db->query('SELECT 1');
+			$num = $stmt->fetch(PDO::FETCH_NUM);
+
+			$stmt = $db->query('SELECT 1');
+			$assoc = $stmt->fetch(PDO::FETCH_ASSOC);
+
+			$stmt = $db->query('SELECT 1');
+			$both = $stmt->fetch(PDO::FETCH_BOTH);
+
+			$computed_both = array_merge($num, $assoc);
+			if ($computed_both != $both) {
+				printf("[%03d] Suspicious FETCH_BOTH result, dumping\n", $offset);
+				var_dump($computed_both);
+				var_dump($both);
+			}
+
+			if (!is_null($expect) && ($expect != $both)) {
+				printf("[%03d] Expected differes from returned data, dumping\n", $offset);
+				var_dump($expect);
+				var_dump($both);
+			}
+
+		} catch (PDOException $e) {
+
+			printf("[%03d] %s, [%s] %s\n",
+				$offset,
+				$e->getMessage(), $db->errroCode(), implode(' ', $db->errorInfo()));
+
+		}
+
+	}
+
+	try {
+
+		fetch(2, $db, 'SELECT 1', array(0 => '1', '1' => '1'));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+[002] Suspicious FETCH_BOTH result, dumping
+array(2) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "1"
+}
+array(2) {
+  [1]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "1"
+}
+[002] Expected differes from returned data, dumping
+array(2) {
+  [0]=>
+  %unicode|string%(1) "1"
+  [1]=>
+  %unicode|string%(1) "1"
+}
+array(2) {
+  [1]=>
+  %unicode|string%(1) "1"
+  [2]=>
+  %unicode|string%(1) "1"
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_get_attribute.phpt
@@ -0,0 +1,106 @@
+--TEST--
+MySQL PDO->getAttribute()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+if (false == MySQLPDOTest::detect_transactional_mysql_engine($db))
+	die("skip Transactional engine not found");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	function find_invalid_int($valid_options) {
+		do {
+			$invalid = mt_rand(-10000, 10000);
+		} while (in_array($invalid, $valid_options));
+		return $invalid;
+	}
+
+	function set_and_get($offset, $db, $attribute, $value) {
+
+		$value_type = gettype($value);
+		try {
+
+			if (!$db->setAttribute($attribute, $value)) {
+				printf("[%03d] Cannot set attribute '%s' to value '%s'\n",
+					$offset, $attribute, var_export($tmp, true));
+				return false;
+			}
+
+			if (gettype($value) != $value_type) {
+				printf("[%03d] Call to PDO::setAttribute(int attribute, mixed value) has changed the type of value from %s to %s, test will not work properly\n",
+					$offset, $value_type, gettype($value));
+				return false;
+			}
+
+			$tmp = $db->getAttribute($attribute);
+			if ($tmp !== $value) {
+				printf("[%03d] Attribute '%s' was set to '%s'/%s but getAttribute() reports '%s'/%s\n",
+					$offset, $attribute, var_export($value, true), gettype($value), var_export($tmp, true), gettype($tmp));
+				return false;
+			}
+
+		} catch (PDOException $e) {
+			printf("[%03d] %s, [%s] %s\n",
+				$offset, $e->getMessage(),
+				$db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return true;
+	}
+
+	set_and_get(1, $db, PDO::ATTR_AUTOCOMMIT, 1);
+/*
+	set_and_get(2, $db, PDO::ATTR_AUTOCOMMIT, 0);
+	set_and_get(3, $db, PDO::ATTR_AUTOCOMMIT, -1);
+	$obj = new stdClass();
+	set_and_get(4, $db, PDO::ATTR_AUTOCOMMIT, $obj);
+
+	set_and_get(5, $db, PDO::MYSQL_ATTR_LOCAL_INFILE, 1);
+	set_and_get(6, $db, PDO::MYSQL_ATTR_LOCAL_INFILE, 0);
+	set_and_get(7, $db, PDO::MYSQL_ATTR_LOCAL_INFILE, -1);
+	$tmp = array();
+	set_and_get(8, $db, PDO::MYSQL_ATTR_LOCAL_INFILE, $tmp);
+
+	set_and_get(9, $db, PPDO::MYSQL_ATTR_INIT_COMMAND, '');
+	set_and_get(10, $db, PPDO::MYSQL_ATTR_INIT_COMMAND, 'SOME SQL');
+	set_and_get(11, $db, PPDO::MYSQL_ATTR_INIT_COMMAND, -1);
+
+*/
+/*
+PDO::MYSQL_ATTR_READ_DEFAULT_FILE (integer)
+
+    Read options from the named option file instead of from my.cnf.
+PDO::MYSQL_ATTR_READ_DEFAULT_GROUP (integer)
+
+    Read options from the named group from my.cnf or the file specified with MYSQL_READ_DEFAULT_FILE.
+PDO::MYSQL_ATTR_MAX_BUFFER_SIZE (integer)
+
+    Maximum buffer size. Defaults to 1 MiB.
+PDO::MYSQL_ATTR_DIRECT_QUERY (integer)
+
+    Perform direct queries, don't use prepared statements.
+*/
+/*
+TODO - read only
+PDO::ATTR_CONNECTION_STATUS
+PDO::ATTR_SERVER_INFO
+*/
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+[001] Call to PDO::setAttribute(int attribute, mixed value) has changed the type of value from integer to boolean, test will not work properly
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_interface.phpt
@@ -0,0 +1,60 @@
+--TEST--
+MySQL PDO class interface
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+if (false == MySQLPDOTest::detect_transactional_mysql_engine($db))
+	die("skip Transactional engine not found");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	$expected = array(
+		'__construct'							=> true,
+		'prepare' 							=> true,
+		'beginTransaction'						=> true,
+		'commit'							=> true,
+		'rollBack'							=> true,
+		'setAttribute'							=> true,
+		'exec'								=> true,
+		'query'								=> true,
+		'lastInsertId'							=> true,
+		'errorCode'							=> true,
+		'errorInfo'							=> true,
+		'getAttribute'							=> true,
+		'quote'								=> true,
+		'inTransaction'							=> true,
+		'__wakeup'							=> true,
+		'__sleep'							=> true,
+		'getAvailableDrivers'	=> true,
+	);
+	$classname = get_class($db);
+
+	$methods = get_class_methods($classname);
+	foreach ($methods as $k => $method) {
+		if (isset($expected[$method])) {
+			unset($expected[$method]);
+			unset($methods[$k]);
+		}
+		if ($method == $classname) {
+			unset($expected['__construct']);
+			unset($methods[$k]);
+		}
+	}
+	if (!empty($expected)) {
+		printf("Dumping missing class methods\n");
+		var_dump($expected);
+	}
+	if (!empty($methods)) {
+		printf("Found more methods than expected, dumping list\n");
+		var_dump($methods);
+	}
+
+	print "done!";
+--EXPECT--
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_last_insert_id.phpt
@@ -0,0 +1,119 @@
+--TEST--
+MySQL PDO->lastInsertId()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[001] No query has been run, lastInsertId() should return '0'/string got '%s'/%s\n",
+				var_export($tmp, true), gettype($tmp));
+
+		if ('0' !== ($tmp = $db->lastInsertId('sequence_name')))
+			printf("[002] MySQL does not support sequences, expecting '0'/string got '%s'/%s\n",
+				var_export($tmp, true), gettype($tmp));
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[003] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		$db->exec(sprintf('CREATE TABLE test(id INT, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[004] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		$stmt = $db->query('SELECT id FROM test LIMIT 1');
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[005] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		// no auto increment column
+		$db->exec("INSERT INTO test(id, col1) VALUES (100, 'a')");
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[006] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		$db->exec('ALTER TABLE test MODIFY id INT AUTO_INCREMENT PRIMARY KEY');
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[006] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		// duplicate key
+		@$db->exec("INSERT INTO test(id, col1) VALUES (100, 'a')");
+		if ('0' !== ($tmp = $db->lastInsertId()))
+			printf("[007] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		$db->exec("INSERT INTO test(id, col1) VALUES (101, 'b')");
+		if ('101' !== ($tmp = $db->lastInsertId()))
+			printf("[008] Expecting '0'/string got '%s'/%s", var_export($tmp, true), gettype($tmp));
+
+		$db->exec('ALTER TABLE test MODIFY col1 CHAR(10) UNIQUE');
+		// replace = delete + insert -> new auto increment value
+		$db->exec("REPLACE INTO test(col1) VALUES ('b')");
+		$next_id = (int)$db->lastInsertId();
+
+		if ($next_id <= 101)
+			printf("[009] Expecting at least 102, got %d\n",$next_id);
+
+		$stmt = $db->query('SELECT LAST_INSERT_ID() as _last_id');
+		$row = $stmt->fetch(PDO::FETCH_ASSOC);
+		$last_id = $row['_last_id'];
+		if ($next_id != $last_id) {
+			printf("[010] LAST_INSERT_ID() = %d and lastInserId() = %d differ\n",
+				$last_id, $next_id);
+		}
+
+		$db->exec("INSERT INTO test(col1) VALUES ('c'), ('d'), ('e')");
+		$next_id = (int)$db->lastInsertId();
+		if ($next_id <= $last_id)
+			printf("[011] Expecting at least %d, got %d\n", $last_id + 1, $next_id);
+
+		// warnings are unhandy, lets go for exceptions for a second
+		$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+		try {
+			$ignore_exception = true;
+			$db->exec('LOCK TABLE test WRITE');
+			$ignore_exception = false;
+
+			if (MySQLPDOTest::getServerVersion($db) >= 50000) {
+				$stmt = $db->query('SELECT @@auto_increment_increment AS inc');
+				$row = $stmt->fetch(PDO::FETCH_ASSOC);
+				$inc = $row['inc'];
+			} else {
+				$inc = 1;
+			}
+
+			$stmt = $db->query('SELECT LAST_INSERT_ID() as _last_id');
+			$row = $stmt->fetch(PDO::FETCH_ASSOC);
+			$last_id = $row['_last_id'];
+
+			$db->exec("INSERT INTO test(col1) VALUES ('z')");
+			$next_id = (int)$db->lastInsertId();
+			if ($next_id < ($last_id + $inc))
+				printf("[012] Expecting at least %d, got %d\n", $last_id + $inc, $next_id);
+
+		} catch (PDOException $e) {
+			if (!$ignore_exception)
+				printf("[014] %s, [%s} %s\n", $e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+		}
+		$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);
+		@$db->exec('UNLOCK TABLE test');
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_pconnect.phpt
@@ -0,0 +1,97 @@
+--TEST--
+MySQL PDO->__construct(), PDO::ATTR_PERSISTENT
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	try {
+
+		$dsn = MySQLPDOTest::getDSN();
+		$user = PDO_MYSQL_TEST_USER;
+		$pass = PDO_MYSQL_TEST_PASS;
+
+		$db1 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));
+		$db2 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));
+		$db1->exec('SET @pdo_persistent_connection=1');
+		$stmt = $db2->query('SELECT @pdo_persistent_connection as _pers');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		if ($tmp['_pers'] !== '1')
+			printf("[001] Both handles should use the same connection.");
+
+		$stmt = $db1->query('SELECT CONNECTION_ID() as _con1');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		$con1 = $tmp['_con1'];
+
+		$stmt = $db2->query('SELECT CONNECTION_ID() as _con2');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		$con2 = $tmp['_con2'];
+
+		if ($con1 !== $con2)
+			printf("[002] Both handles should report the same MySQL thread ID");
+
+		$db1 = NULL; /* should be equal to closing to my understanding */
+		$db1 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));
+		$stmt = $db1->query('SELECT CONNECTION_ID() as _con1');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		$con1 = $tmp['_con1'];
+
+		if ($con1 !== $con2)
+			printf("[003] Both handles should report the same MySQL thread ID");
+
+		$affected = $db1->exec(sprintf('KILL %d', $con1));
+		// Server needs some think-time sometimes
+		sleep(1);
+		if ('00000' == $db1->errorCode()) {
+			// looks like KILL has worked ? Or not... TODO: why no warning with libmysql?!
+			@$db1->exec("SET @pdo_persistent_connection=2");
+			// but now I want to see some error...
+			if ('HY000' != $db1->errorCode())
+				printf("[004] Wrong error code %s\n", $db1->errorCode());
+
+			$tmp = implode(' ', $db1->errorInfo());
+			if (!strstr($tmp, '2006'))
+				printf("[005] Wrong error info %s\n", $tmp);
+		}
+
+		$db1 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => false));
+		$stmt = $db1->query('SELECT CONNECTION_ID() as _con1');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		$con1 = $tmp['_con1'];
+
+		$db2 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));
+		$stmt = $db2->query('SELECT CONNECTION_ID() as _con2');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		$con2 = $tmp['_con2'];
+
+		if ($con1 == $con2)
+			printf("[006] Looks like the persistent and the non persistent connection are using the same link?!\n");
+
+		// lets go crazy and create a few pconnections...
+		$connections = array();
+		for ($i = 0; $i <= 20; $i++) {
+			$connections[$i] = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));
+		}
+		do {
+			$i = mt_rand(0, 20);
+			if (isset($connections[$i]))
+				unset($connections[$i]);
+		} while (!empty($connections));
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s\n",
+			$e->getMessage(),
+			(is_object($db)) ? $db->errorCode() : 'n/a',
+			(is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_phpinfo.phpt
@@ -0,0 +1,31 @@
+--TEST--
+MySQL PDO phpinfo() output
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	ob_start();
+	phpinfo();
+	$tmp = ob_get_contents();
+	ob_end_clean();
+
+	/*	PDO Driver for MySQL, client library version => 6.0.3-alpha	*/
+	$expected = sprintf('Client API version => %s',
+		$db->getAttribute(PDO::ATTR_CLIENT_VERSION));
+
+	if (false === stristr($tmp, $expected)) {
+		printf("[001] Cannot find MySQL PDO driver line in phpinfo() output\n");
+	}
+
+	print "done!";
+?>
+--EXPECT--
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_emulated.phpt
@@ -0,0 +1,419 @@
+--TEST--
+MySQL PDO->prepare(), emulated PS
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	function prepex($offset, &$db, $query, $input_params = null, $error_info = null) {
+
+		try {
+
+			if (is_array($error_info) && isset($error_info['prepare']))
+				$stmt = @$db->prepare($query);
+			else
+				$stmt = $db->prepare($query);
+
+			if (is_array($error_info) && isset($error_info['prepare'])) {
+				$tmp = $db->errorInfo();
+
+				if (isset($error_info['prepare']['sqlstate']) &&
+					($error_info['prepare']['sqlstate'] !== $tmp[0])) {
+					printf("[%03d] prepare() - expecting SQLSTATE '%s' got '%s'\n",
+						$offset, $error_info['prepare']['sqlstate'], $tmp[0]);
+					return false;
+				}
+
+				if (isset($error_info['prepare']['mysql']) &&
+					($error_info['prepare']['mysql'] !== $tmp[1])) {
+					printf("[%03d] prepare() - expecting MySQL Code '%s' got '%s'\n",
+						$offset, $error_info['prepare']['mysql'], $tmp[0]);
+					return false;
+				}
+
+				return false;
+			}
+
+			if (is_null($input_params))
+				$input_params = array();
+
+			if (is_array($error_info) && isset($error_info['execute']))
+				$ret = @$stmt->execute($input_params);
+			else
+				$ret = $stmt->execute($input_params);
+
+			if (!is_bool($ret))
+				printf("[%03d] PDO::execute() should return a boolean value, got %s/%s\n",
+					var_export($ret, true), $ret);
+
+			if (is_array($error_info) && isset($error_info['execute'])) {
+				$tmp = $stmt->errorInfo();
+
+				if (isset($error_info['execute']['sqlstate']) &&
+					($error_info['execute']['sqlstate'] !== $tmp[0])) {
+					printf("[%03d] execute() - expecting SQLSTATE '%s' got '%s'\n",
+						$offset, $error_info['execute']['sqlstate'], $tmp[0]);
+					return false;
+				}
+
+				if (isset($error_info['execute']['mysql']) &&
+					($error_info['execute']['mysql'] !== $tmp[1])) {
+					printf("[%03d] execute() - expecting MySQL Code '%s' got '%s'\n",
+						$offset, $error_info['execute']['mysql'], $tmp[0]);
+					return false;
+				}
+
+				return false;
+			}
+
+		} catch (PDOException $e) {
+			printf("[%03d] %s, [%s} %s\n",
+				$offset, $e->getMessage(),
+				$db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return $stmt;
+	}
+
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to switch to emulated prepared statements, test will fail\n");
+
+		// TODO - that's PDO - you can prepare empty statements!
+		prepex(3, $db, '',
+			array(), array('execute' => array('sqlstate' => '42000')));
+
+		// lets be fair and do the most simple SELECT first
+		$stmt = prepex(4, $db, 'SELECT 1 as "one"');
+		var_dump($stmt->fetch(PDO::FETCH_ASSOC));
+
+		prepex(5, $db, 'DROP TABLE IF EXISTS test');
+		prepex(6, $db, sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		prepex(7, $db, "INSERT INTO test(id, label) VALUES(1, ':placeholder')");
+		$stmt = prepex(8, $db, 'SELECT label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		prepex(9, $db, 'DELETE FROM test');
+		prepex(10, $db, "INSERT INTO test(id, label) VALUES(1, ':placeholder')",
+			array(':placeholder' => 'first row'));
+		$stmt = prepex(11, $db, 'SELECT label FROM test');
+
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		prepex(12, $db, 'DELETE FROM test');
+		prepex(13, $db, 'INSERT INTO test(id, label) VALUES(1, :placeholder)',
+			array(':placeholder' => 'first row'));
+		prepex(14, $db, 'INSERT INTO test(id, label) VALUES(2, :placeholder)',
+			array(':placeholder' => 'second row'));
+		$stmt = prepex(15, $db, 'SELECT label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Is PDO fun?
+		prepex(16, $db, 'SELECT label FROM test WHERE :placeholder > 1',
+			array(':placeholder' => 'id'));
+		prepex(17, $db, 'SELECT :placeholder FROM test WHERE id > 1',
+			array(':placeholder' => 'id'));
+		prepex(18, $db, 'SELECT :placeholder FROM test WHERE :placeholder > :placeholder',
+			array(':placeholder' => 'test'));
+
+		for ($num_params = 2; $num_params < 100; $num_params++) {
+			$params = array(':placeholder' => 'a');
+			for ($i = 1; $i < $num_params; $i++) {
+				$params[str_repeat('a', $i)] = 'some data';
+			}
+			prepex(19, $db, 'SELECT id, label FROM test WHERE label > :placeholder',
+				$params, array('execute' => array('sqlstate' => 'HY093')));
+		}
+
+		prepex(20, $db, 'DELETE FROM test');
+		prepex(21, $db, 'INSERT INTO test(id, label) VALUES (1, :placeholder), (2, :placeholder)',
+			array(':placeholder' => 'row'));
+		$stmt = prepex(22, $db, 'SELECT id, label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		$stmt = prepex(23, $db, 'SELECT id, label FROM test WHERE :placeholder IS NOT NULL',
+			array(':placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+			printf("[024] '1' IS NOT NULL evaluates to true, expecting two rows, got %d rows\n", $tmp);
+
+		$stmt = prepex(25, $db, 'SELECT id, label FROM test WHERE :placeholder IS NULL',
+			array(':placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+			printf("[026] '1' IS NOT NULL evaluates to true, expecting zero rows, got %d rows\n", $tmp);
+
+		prepex(27, $db, 'DROP TABLE IF EXISTS test');
+		prepex(28, $db, 'CREATE TABLE test(id INT, label CHAR(255)) ENGINE=MyISAM');
+		if (is_object(prepex(29, $db, 'CREATE FULLTEXT INDEX idx1 ON test(label)'))) {
+			prepex(30, $db, 'INSERT INTO test(id, label) VALUES (1, :placeholder)',
+				array(':placeholder' => 'MySQL is the best database in the world!'));
+			prepex(31, $db, 'INSERT INTO test(id, label) VALUES (1, :placeholder)',
+				array(':placeholder' => 'If I have the freedom to choose, I would always go again for the MySQL Server'));
+			$stmt = prepex(32, $db, 'SELECT id, label FROM test WHERE MATCH label AGAINST (:placeholder)',
+				array(':placeholder' => 'mysql'));
+			/*
+			Lets ignore this
+			if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+				printf("[033] Expecting two rows, got %d rows\n", $tmp);
+			*/
+		}
+		prepex(34, $db, 'DELETE FROM test');
+		prepex(35, $db, 'INSERT INTO test(id, label) VALUES (1, :placeholder), (2, :placeholder)',
+			array(':placeholder' => 'row'));
+/*
+		$stmt = prepex(36, $db, 'SELECT id, label FROM "test WHERE MATCH label AGAINST (:placeholder)',
+			array(':placeholder' => 'row'),
+			array('execute' => array('sqlstate' => '42000', 'mysql' => 1064)));
+*/
+		$stmt = prepex(37, $db, 'SELECT id, label FROM \'test WHERE MATCH label AGAINST (:placeholder)',
+			array(':placeholder' => 'row'),
+			array('execute' => array('sqlstate' => '42000', 'mysql' => 1064)));
+
+		$stmt = prepex(38, $db, 'SELECT id, label AS "label" FROM test WHERE label = :placeholder',
+			array(':placeholder' => 'row'));
+
+		$sql = sprintf("SELECT id, label FROM test WHERE (label LIKE %s) AND (id = :placeholder)",
+			$db->quote('%ro%'));
+		$stmt = prepex(39, $db, $sql,	array('placeholder' => -1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+				printf("[040] Expecting zero rows, got %d rows\n", $tmp);
+
+
+		$sql = sprintf("SELECT id, label FROM test WHERE  (id = :placeholder) OR (label LIKE %s)",
+			$db->quote('%ro%'));
+		$stmt = prepex(41, $db, $sql,	array('placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+				printf("[042] Expecting two rows, got %d rows\n", $tmp);
+
+		$sql = "SELECT id, label FROM test WHERE id = :placeholder AND label = (SELECT label AS 'SELECT' FROM test WHERE id = :placeholder)";
+		$stmt = prepex(43, $db, $sql,	array('placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 1)
+				printf("[044] Expecting onw row, got %d rows\n", $tmp);
+
+		// and now, the same with anonymous placeholders...
+		prepex(45, $db, 'DROP TABLE IF EXISTS test');
+		prepex(46, $db, sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		prepex(47, $db, "INSERT INTO test(id, label) VALUES(1, '?')");
+		$stmt = prepex(48, $db, 'SELECT label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		prepex(49, $db, 'DELETE FROM test');
+		prepex(50, $db, "INSERT INTO test(id, label) VALUES(1, '?')",
+			array('first row'));
+		$stmt = prepex(51, $db, 'SELECT label FROM test');
+
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		prepex(52, $db, 'DELETE FROM test');
+		prepex(53, $db, 'INSERT INTO test(id, label) VALUES(1, ?)',
+			array('first row'));
+		prepex(54, $db, 'INSERT INTO test(id, label) VALUES(2, ?)',
+			array('second row'));
+		$stmt = prepex(55, $db, 'SELECT label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Is PDO fun?
+		prepex(56, $db, 'SELECT label FROM test WHERE ? > 1',
+			array('id'));
+		prepex(57, $db, 'SELECT ? FROM test WHERE id > 1',
+			array('id'));
+		prepex(58, $db, 'SELECT ? FROM test WHERE ? > ?',
+			array('test'), array('execute' => array('sqlstate' => 'HY093')));
+
+		prepex(59, $db, 'SELECT ? FROM test WHERE ? > ?',
+			array('id', 'label', 'value'));
+
+		for ($num_params = 2; $num_params < 100; $num_params++) {
+			$params = array('a');
+			for ($i = 1; $i < $num_params; $i++) {
+				$params[] = 'some data';
+			}
+			prepex(60, $db, 'SELECT id, label FROM test WHERE label > ?',
+				$params, array('execute' => array('sqlstate' => 'HY093')));
+		}
+
+		prepex(61, $db, 'DELETE FROM test');
+		prepex(62, $db, 'INSERT INTO test(id, label) VALUES (1, ?), (2, ?)',
+			array('row', 'row'));
+		$stmt = prepex(63, $db, 'SELECT id, label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		$stmt = prepex(64, $db, 'SELECT id, label FROM test WHERE ? IS NOT NULL',
+			array(1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+			printf("[065] '1' IS NOT NULL evaluates to true, expecting two rows, got %d rows\n", $tmp);
+
+		$stmt = prepex(66, $db, 'SELECT id, label FROM test WHERE ? IS NULL',
+			array(1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+			printf("[067] '1' IS NOT NULL evaluates to true, expecting zero rows, got %d rows\n", $tmp);
+
+		prepex(68, $db, 'DROP TABLE IF EXISTS test');
+		prepex(69, $db, 'CREATE TABLE test(id INT, label CHAR(255)) ENGINE=MyISAM');
+		if (is_object(prepex(70, $db, 'CREATE FULLTEXT INDEX idx1 ON test(label)'))) {
+			prepex(71, $db, 'INSERT INTO test(id, label) VALUES (1, ?)',
+				array('MySQL is the best database in the world!'));
+			prepex(72, $db, 'INSERT INTO test(id, label) VALUES (1, ?)',
+				array('If I have the freedom to choose, I would always go again for the MySQL Server'));
+			$stmt = prepex(73, $db, 'SELECT id, label FROM test WHERE MATCH label AGAINST (?)',
+				array('mysql'));
+			/*
+			Lets ignore that
+			if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+				printf("[074] Expecting two rows, got %d rows\n", $tmp);
+			*/
+		}
+
+		prepex(74, $db, 'DELETE FROM test');
+		prepex(75, $db, 'INSERT INTO test(id, label) VALUES (1, ?), (2, ?)',
+			array('row', 'row'));
+
+		$stmt = prepex(76, $db, 'SELECT id, label FROM "test WHERE MATCH label AGAINST (?)',
+			array('row'),
+			array('execute' => array('sqlstate' => '42000', 'mysql' => 1064)));
+
+		/*
+		TODO enable after fix
+		$stmt = prepex(37, $db, 'SELECT id, label FROM \'test WHERE MATCH label AGAINST (:placeholder)',
+			array(':placeholder' => 'row'),
+			array('execute' => array('sqlstate' => '42000', 'mysql' => 1064)));
+		*/
+
+		$stmt = prepex(78, $db, 'SELECT id, label AS "label" FROM test WHERE label = ?',
+			array('row'));
+
+		$sql = sprintf("SELECT id, label FROM test WHERE (label LIKE %s) AND (id = ?)",
+			$db->quote('%ro%'));
+		$stmt = prepex(79, $db, $sql,	array(-1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+				printf("[080] Expecting zero rows, got %d rows\n", $tmp);
+
+
+		$sql = sprintf("SELECT id, label FROM test WHERE  (id = ?) OR (label LIKE %s)",
+			$db->quote('%ro%'));
+		$stmt = prepex(81, $db, $sql,	array(1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+				printf("[082] Expecting two rows, got %d rows\n", $tmp);
+
+		$sql = "SELECT id, label FROM test WHERE id = ? AND label = (SELECT label AS 'SELECT' FROM test WHERE id = ?)";
+		$stmt = prepex(83, $db, $sql,	array(1, 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 1)
+				printf("[084] Expecting one row, got %d rows\n", $tmp);
+
+		$sql = "SELECT id, label FROM test WHERE id = :placeholder AND label = (SELECT label AS 'SELECT' FROM test WHERE id = ?)";
+		$stmt = prepex(85, $db, $sql,	array(1, 1), array('execute' => array('sqlstate' => 'HY093')));
+		if (is_object($stmt) && count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+				printf("[086] Expecting no rows, got %d rows\n", $tmp);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--XFAIL--
+PDO's PS parser has some problems with invalid SQL and crashes from time to time
+(check with valgrind...)
+--EXPECTF--
+array(1) {
+  [%u|b%"one"]=>
+  %unicode|string%(1) "1"
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(12) ":placeholder"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(12) ":placeholder"
+  }
+}
+array(2) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(9) "first row"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(10) "second row"
+  }
+}
+array(2) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(3) "row"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(3) "row"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(1) "?"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(1) "?"
+  }
+}
+array(2) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(9) "first row"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(10) "second row"
+  }
+}
+array(2) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(3) "row"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(3) "row"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_emulated_anonymous.phpt
@@ -0,0 +1,85 @@
+--TEST--
+MySQL PDO->prepare(), emulated PS, anonymous placeholder
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to switch to emulated prepared statements, test will fail\n");
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+
+		$stmt = $db->prepare("INSERT INTO test(id, label) VALUES(1, '?')");
+		// you can bind as many values as you want no matter if they can be replaced or not
+		$stmt->execute(array('first row'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[003] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		$stmt = $db->prepare('SELECT id, label FROM test');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// now the same with native PS
+		printf("now the same with native PS\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to switch off emulated prepared statements, test will fail\n");
+
+		$db->exec('DELETE FROM test');
+		$stmt = $db->prepare("INSERT INTO test(id, label) VALUES(1, '?')");
+		// you can bind as many values as you want no matter if they can be replaced or not
+		$stmt->execute(array('first row'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[005] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		$stmt = $db->prepare('SELECT id, label FROM test');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "?"
+  }
+}
+now the same with native PS
+[005] Execute has failed, 'HY093' array (
+  0 => 'HY093',
+  1 => NULL,
+  2 => NULL,
+)
+array(0) {
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_emulated_placeholder_everywhere.phpt
@@ -0,0 +1,84 @@
+--TEST--
+MySQL PDO->prepare(), emulated PS, anonymous placeholder
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+// TODO: This test is MySQL version specific - for whatever reason
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+		// native PS
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to switch off emulated prepared statements, test will fail\n");
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		$db->exec("INSERT INTO test(id, label) VALUES (1, 'row1')");
+
+		// So, what will happen? More placeholder but values and
+		// placeholders in interesting places...
+		$stmt = $db->prepare('SELECT ? FROM test WHERE ? > ?');
+		$stmt->execute(array('test'));
+		if ('00000' !== $stmt->errorCode()) {
+			printf("[003] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		}
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// now the same with emulated PS
+		printf("now the same with emulated PS\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to switch on emulated prepared statements, test will fail\n");
+
+		$stmt = $db->prepare('SELECT ? FROM test WHERE ? > ?');
+		$stmt->execute(array('test'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[005] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number in %s on line %d
+[003] Execute has failed, 'HY093' array (
+  0 => 'HY093',
+  1 => NULL,
+  2 => NULL,
+)
+array(0) {
+}
+now the same with emulated PS
+
+Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number: number of bound variables does not match number of tokens in %s on line %d
+
+Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number in %s on line 33
+[005] Execute has failed, 'HY093' array (
+  0 => 'HY093',
+  1 => NULL,
+  2 => NULL,
+)
+array(0) {
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_load_data.phpt
@@ -0,0 +1,118 @@
+--TEST--
+MySQL PDO->prepare() and 1295 (ER_UNSUPPORTED_PS)
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+
+// Run test only locally - not against remote hosts
+$db = MySQLPDOTest::factory();
+$stmt = $db->query('SELECT USER() as _user');
+$row = $stmt->fetch(PDO::FETCH_ASSOC);
+$tmp = explode('@', $row['_user']);
+if (count($tmp) < 2)
+	die("skip Cannot detect if test is run against local or remote database server");
+if (($tmp[1] !== 'localhost') && ($tmp[1] !== '127.0.0.1'))
+	die("skip Test cannot be run against remote database server");
+
+?>
+--FILE--
+<?php
+	function exec_and_count($offset, &$db, $sql, $exp) {
+
+		try {
+
+			$ret = $db->exec($sql);
+			if ($ret !== $exp) {
+				printf("[%03d] Expecting '%s'/%s got '%s'/%s when running '%s', [%s] %s\n",
+					$offset, $exp, gettype($exp), $ret, gettype($ret), $sql,
+					$db->errorCode(), implode(' ', $db->errorInfo()));
+				return false;
+			}
+
+		} catch (PDOException $e) {
+
+			if (42000 == $db->errorCode()) {
+				// Error: 1148 SQLSTATE: 42000  (ER_NOT_ALLOWED_COMMAND)
+				// Load data infile not allowed
+				return false;
+			}
+
+			printf("[%03d] '%s' has failed, [%s] %s\n",
+				$offset, $sql, $db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return true;
+	}
+
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	// Run with native PS.
+	// The test is about checking the fallback to emulation
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	/* affected rows related */
+	try {
+
+		exec_and_count(2, $db, 'DROP TABLE IF EXISTS test', 0);
+		exec_and_count(3, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);
+
+		$stmt = $db->query("SHOW VARIABLES LIKE 'secure_file_priv'");
+		if (($row = $stmt->fetch(PDO::FETCH_ASSOC)) && ($row['value'] != '')) {
+			$filename = $row['value'] . DIRECTORY_SEPARATOR  . "pdo_mysql_exec_load_data.csv";
+		} else {
+			$filename =  MySQLPDOTest::getTempDir() . DIRECTORY_SEPARATOR  . "pdo_mysql_exec_load_data.csv";
+		}
+
+		$fp = fopen($filename, "w");
+		fwrite($fp, b"1;foo\n");
+		fwrite($fp, b"2;bar");
+		fclose($fp);
+
+		// This should fail, the PS protocol should not support it.
+		// mysqlnd will give 2014 as a follow-up of the fallback logic
+		// libmysql will give a little more precise 2030 error code
+		// However, you get an error and the big question is what happens to the line
+		$stmt = $db->prepare(sprintf("LOAD DATA INFILE %s INTO TABLE test FIELDS TERMINATED BY ';' LINES TERMINATED  BY '\n'", $db->quote($filename)));
+		if (!$stmt->execute()) {
+			printf("[004] [%d] %s\n", $stmt->errorCode(), var_export($stmt->errorInfo(), true));
+		}
+
+		// Check the line
+		$stmt = $db->query("SELECT 1 as 'one'");
+		if ($stmt->errorCode() != '0000') {
+			printf("[005] [%d] %s\n", $stmt->errorCode(), var_export($stmt->errorInfo(), true));
+		} else {
+			$rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
+			if (!isset($rows[0]['one']) || $rows[0]['one'] != 1)
+				printf("[006] [%d] %s\n",  $stmt->errorCode(), var_export($stmt->errorInfo(), true));
+		}
+
+		unlink($filename);
+
+	} catch (PDOException $e) {
+		printf("[001] %s, [%s] %s (%s)\n",
+			$e->getMessage(),
+			$db->errorCode(),
+			implode(' ', $db->errorInfo()),
+			(isset($stmt)) ? implode(' ', $stmt->errorInfo()) : 'N/A');
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Warning: PDOStatement::execute(): SQLSTATE[HY000]: General error: %s in %s on line %d
+[004] [0] array (
+  0 => 'HY000',
+  1 => %d,
+  2 => %s,
+)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_match_against.phpt
@@ -0,0 +1,54 @@
+--TEST--
+Bug #41876 (bindParam() and bindValue() do not work with MySQL MATCH () AGAINST ())
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=MyISAM');
+		$db->exec('CREATE FULLTEXT INDEX idx1 ON test(label)');
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE MATCH label AGAINST (:placeholder)');
+		$stmt->execute(array(':placeholder' => 'row'));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE MATCH label AGAINST (:placeholder)');
+		$stmt->execute(array('placeholder' => 'row'));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE MATCH label AGAINST (?)');
+		$stmt->execute(array('row'));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	} catch (PDOException $e) {
+
+		printf("[001] %s, [%s} %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+array(0) {
+}
+array(0) {
+}
+array(0) {
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native.phpt
@@ -0,0 +1,385 @@
+--TEST--
+MySQL PDO->prepare(), native PS
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	function prepex($offset, &$db, $query, $input_params = null, $error_info = null, $suppress_warning = false) {
+
+		try {
+
+			if ($suppress_warning || (is_array($error_info) && isset($error_info['prepare'])))
+				$stmt = @$db->prepare($query);
+			else
+				$stmt = $db->prepare($query);
+
+			if (is_array($error_info) && isset($error_info['prepare'])) {
+				$tmp = $db->errorInfo();
+
+				if (isset($error_info['prepare']['sqlstate']) &&
+					($error_info['prepare']['sqlstate'] !== $tmp[0])) {
+					printf("[%03d] prepare() - expecting SQLSTATE '%s' got '%s'\n",
+						$offset, $error_info['prepare']['sqlstate'], $tmp[0]);
+					return false;
+				}
+
+				if (isset($error_info['prepare']['mysql']) &&
+					($error_info['prepare']['mysql'] !== $tmp[1])) {
+					printf("[%03d] prepare() - expecting MySQL Code '%s' got '%s'\n",
+						$offset, $error_info['prepare']['mysql'], $tmp[0]);
+					return false;
+				}
+
+				return false;
+			}
+
+			if (!is_object($stmt))
+				return false;
+
+			if (is_null($input_params))
+				$input_params = array();
+// 5.0.18, 5.1.14 @ 15
+// printf("[%03d]\n", $offset);
+			if ($suppress_warning || (is_array($error_info) && isset($error_info['execute'])))
+				$ret = @$stmt->execute($input_params);
+			else
+				$ret = $stmt->execute($input_params);
+
+			if (!is_bool($ret))
+				printf("[%03d] PDO::execute() should return a boolean value, got %s/%s\n",
+					var_export($ret, true), $ret);
+
+			$tmp = $stmt->errorInfo();
+			if (isset($tmp[1]) && ($tmp[1] == 2030)) {
+				// Trying to hack around MySQL Server version dependent features
+				// 2030 This command is not supported in the prepared statement protocol yet
+				return false;
+			}
+
+			if (is_array($error_info) && isset($error_info['execute'])) {
+
+				if (isset($error_info['execute']['sqlstate']) &&
+					($error_info['execute']['sqlstate'] !== $tmp[0])) {
+					printf("[%03d] execute() - expecting SQLSTATE '%s' got '%s'\n",
+						$offset, $error_info['execute']['sqlstate'], $tmp[0]);
+					return false;
+				}
+
+				if (isset($error_info['execute']['mysql']) &&
+					($error_info['execute']['mysql'] !== $tmp[1])) {
+					printf("[%03d] execute() - expecting MySQL Code '%s' got '%s'\n",
+						$offset, $error_info['execute']['mysql'], $tmp[0]);
+					return false;
+				}
+
+				return false;
+
+			}
+
+		} catch (PDOException $e) {
+			printf("[%03d] %s, [%s} %s\n",
+				$offset, $e->getMessage(),
+				$db->errorCode(), implode(' ', $db->errorInfo()));
+			return false;
+		}
+
+		return $stmt;
+	}
+
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+
+		// TODO - that's PDO - you can prepare empty statements!
+		prepex(3, $db, '',
+			array(), array('prepare' => array('sqlstate' => '42000')));
+
+		// lets be fair and do the most simple SELECT first
+		$stmt = prepex(4, $db, 'SELECT 1 as "one"');
+		if (MySQLPDOTest::isPDOMySQLnd())
+			// native types - int
+			$expected = array('one' => 1);
+		else
+			// always strings, like STRINGIFY flag
+			$expected = array('one' => '1');
+
+		$row = $stmt->fetch(PDO::FETCH_ASSOC);
+		if ($row !== $expected) {
+			printf("[004a] Expecting %s got %s\n", var_export($expected, true), var_export($row, true));
+		}
+
+		prepex(5, $db, 'DROP TABLE IF EXISTS test');
+		prepex(6, $db, sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		prepex(7, $db, "INSERT INTO test(id, label) VALUES(1, ':placeholder')");
+		$stmt = prepex(8, $db, 'SELECT label FROM test ORDER BY id ASC');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		prepex(9, $db, 'DELETE FROM test');
+		prepex(10, $db, 'INSERT INTO test(id, label) VALUES(1, :placeholder)',
+			array(':placeholder' => 'first row'));
+		prepex(11, $db, 'INSERT INTO test(id, label) VALUES(2, :placeholder)',
+			array(':placeholder' => 'second row'));
+		$stmt = prepex(12, $db, 'SELECT label FROM test ORDER BY id ASC');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Is PDO fun?
+		$stmt = prepex(13, $db, 'SELECT label FROM test WHERE :placeholder > 1',
+			array(':placeholder' => 'id'));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		for ($num_params = 2; $num_params < 100; $num_params++) {
+			$params = array(':placeholder' => 'a');
+			for ($i = 1; $i < $num_params; $i++) {
+				$params[str_repeat('a', $i)] = 'some data';
+			}
+			prepex(16, $db, 'SELECT id, label FROM test WHERE label > :placeholder',
+				$params, array('execute' => array('sqlstate' => 'HY093')));
+		}
+
+		$stmt = prepex(16, $db, 'SELECT id, label FROM test WHERE :placeholder IS NOT NULL',
+			array(':placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+			printf("[017] '1' IS NOT NULL evaluates to true, expecting two rows, got %d rows\n", $tmp);
+
+		$stmt = prepex(18, $db, 'SELECT id, label FROM test WHERE :placeholder IS NULL',
+			array(':placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+			printf("[019] '1' IS NOT NULL evaluates to true, expecting zero rows, got %d rows\n", $tmp);
+
+		prepex(20, $db, 'DROP TABLE IF EXISTS test');
+		prepex(21, $db, 'CREATE TABLE test(id INT, label CHAR(255)) ENGINE=MyISAM');
+		// Not every MySQL Server version supports this
+		if (is_object(prepex(22, $db, 'CREATE FULLTEXT INDEX idx1 ON test(label)', null, null, true))) {
+			prepex(23, $db, 'INSERT INTO test(id, label) VALUES (1, :placeholder)',
+				array(':placeholder' => 'MySQL is the best database in the world!'));
+			prepex(24, $db, 'INSERT INTO test(id, label) VALUES (2, :placeholder)',
+				array(':placeholder' => 'If I have the freedom to choose, I would always go again for the MySQL Server'));
+			$stmt = prepex(25, $db, 'SELECT id, label FROM test WHERE MATCH label AGAINST (:placeholder)',
+				array(':placeholder' => 'mysql'), null, true);
+			if (is_object($stmt)) {
+				/*
+				Lets ignore this
+				if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+					printf("[033] Expecting two rows, got %d rows\n", $tmp);
+				*/
+				$stmt = prepex(26, $db, 'SELECT id, label FROM test ORDER BY id ASC');
+				if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+					printf("[027] Expecting two rows, got %d rows\n", $tmp);
+
+				if ($tmp[0]['label'] !== 'MySQL is the best database in the world!') {
+					printf("[028] INSERT seems to have failed, dumping data, check manually\n");
+					var_dump($tmp);
+				}
+			}
+		}
+
+		$db->exec('DELETE FROM test');
+		$db->exec("INSERT INTO test(id, label) VALUES (1, 'row1')");
+		$db->exec("INSERT INTO test(id, label) VALUES (2, 'row2')");
+
+		$sql = sprintf("SELECT id, label FROM test WHERE (label LIKE %s) AND (id = :placeholder)",
+			$db->quote('%ro%'));
+		$stmt = prepex(29, $db, $sql,	array('placeholder' => -1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+				printf("[030] Expecting zero rows, got %d rows\n", $tmp);
+
+		$sql = sprintf("SELECT id, label FROM test WHERE  (id = :placeholder) OR (label LIKE %s)",
+			$db->quote('%go%'));
+		$stmt = prepex(31, $db, $sql,	array('placeholder' => 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 1)
+				printf("[032] Expecting one row, got %d rows\n", $tmp);
+
+		// and now, the same with anonymous placeholders...
+		prepex(33, $db, 'DROP TABLE IF EXISTS test');
+		prepex(34, $db, sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		prepex(35, $db, "INSERT INTO test(id, label) VALUES(1, '?')");
+		$stmt = prepex(36, $db, 'SELECT label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		prepex(37, $db, 'DELETE FROM test');
+		prepex(38, $db, 'INSERT INTO test(id, label) VALUES(1, ?)',
+			array('first row'));
+		prepex(39, $db, 'INSERT INTO test(id, label) VALUES(2, ?)',
+			array('second row'));
+		$stmt = prepex(40, $db, 'SELECT label FROM test');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Is PDO fun?
+		prepex(40, $db, 'SELECT label FROM test WHERE ? > 1',
+			array('id'));
+		prepex(41, $db, 'SELECT ? FROM test WHERE id > 1',
+			array('id'));
+		prepex(42, $db, 'SELECT ? FROM test WHERE ? > ?',
+			array('id', 'label', 'value'));
+
+		for ($num_params = 2; $num_params < 100; $num_params++) {
+			$params = array('a');
+			for ($i = 1; $i < $num_params; $i++) {
+				$params[] = 'some data';
+			}
+			prepex(43, $db, 'SELECT id, label FROM test WHERE label > ?',
+				$params, array('execute' => array('sqlstate' => 'HY093')));
+		}
+
+		prepex(44, $db, 'DELETE FROM test');
+		prepex(45, $db, 'INSERT INTO test(id, label) VALUES (1, ?), (2, ?)',
+			array('row', 'row'));
+		$stmt = prepex(46, $db, 'SELECT id, label FROM test');
+		$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+		$exp = array(
+			0 => array(
+				"id"  => "1",
+				"label" => "row"
+			),
+			1 => array(
+				"id" => "2",
+				"label" => "row"
+			),
+		);
+
+		if (MySQLPDOTest::isPDOMySQLnd()) {
+			// mysqlnd returns native types
+			$exp[0]['id'] = 1;
+			$exp[1]['id'] = 2;
+		}
+		if ($tmp !== $exp) {
+			printf("[064] Results seem wrong. Please check dumps manually.\n");
+			var_dump($exp);
+			var_dump($tmp);
+		}
+
+		$stmt = prepex(47, $db, 'SELECT id, label FROM test WHERE ? IS NOT NULL',
+			array(1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+			printf("[048] '1' IS NOT NULL evaluates to true, expecting two rows, got %d rows\n", $tmp);
+
+		$stmt = prepex(49, $db, 'SELECT id, label FROM test WHERE ? IS NULL',
+			array(1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+			printf("[050] '1' IS NOT NULL evaluates to true, expecting zero rows, got %d rows\n", $tmp);
+
+		prepex(51, $db, 'DROP TABLE IF EXISTS test');
+		prepex(52, $db, 'CREATE TABLE test(id INT, label CHAR(255)) ENGINE=MyISAM');
+		if (is_object(prepex(53, $db, 'CREATE FULLTEXT INDEX idx1 ON test(label)', null, null, true))) {
+			prepex(54, $db, 'INSERT INTO test(id, label) VALUES (1, ?)',
+				array('MySQL is the best database in the world!'));
+			prepex(55, $db, 'INSERT INTO test(id, label) VALUES (1, ?)',
+				array('If I have the freedom to choose, I would always go again for the MySQL Server'));
+			$stmt = prepex(56, $db, 'SELECT id, label FROM test WHERE MATCH label AGAINST (?)',
+				array('mysql'), null, true);
+			/*
+			Lets ignore that
+			if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+				printf("[074] Expecting two rows, got %d rows\n", $tmp);
+			*/
+		}
+
+		prepex(57, $db, 'DELETE FROM test');
+		prepex(58, $db, 'INSERT INTO test(id, label) VALUES (1, ?), (2, ?)',
+			array('row1', 'row2'));
+
+		/*
+		TODO enable after fix
+		$stmt = prepex(37, $db, 'SELECT id, label FROM \'test WHERE MATCH label AGAINST (:placeholder)',
+			array(':placeholder' => 'row'),
+			array('execute' => array('sqlstate' => '42000', 'mysql' => 1064)));
+		*/
+
+		$stmt = prepex(59, $db, 'SELECT id, label AS "label" FROM test WHERE label = ?',
+			array('row1'));
+		$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+		$exp = array(
+			0 => array("id" => "1", "label" => "row1")
+		);
+
+		if (MySQLPDOTest::isPDOMySQLnd()) {
+			// mysqlnd returns native types
+			$exp[0]['id'] = 1;
+		}
+		if ($tmp !== $exp) {
+			printf("[065] Results seem wrong. Please check dumps manually.\n");
+			var_dump($exp);
+			var_dump($tmp);
+		}
+
+		$sql = sprintf("SELECT id, label FROM test WHERE (label LIKE %s) AND (id = ?)",
+			$db->quote('%ro%'));
+		$stmt = prepex(60, $db, $sql,	array(-1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 0)
+				printf("[061] Expecting zero rows, got %d rows\n", $tmp);
+
+		$sql = sprintf("SELECT id, label FROM test WHERE  (id = ?) OR (label LIKE %s)",
+			$db->quote('%ro%'));
+		$stmt = prepex(61, $db, $sql,	array(1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 2)
+				printf("[062] Expecting two rows, got %d rows\n", $tmp);
+
+		$sql = "SELECT id, label FROM test WHERE id = ? AND label = (SELECT label AS 'SELECT' FROM test WHERE id = ?)";
+		$stmt = prepex(63, $db, $sql,	array(1, 1));
+		if (count(($tmp = $stmt->fetchAll(PDO::FETCH_ASSOC))) != 1)
+				printf("[064] Expecting one row, got %d rows\n", $tmp);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  array(1) {
+    ["label"]=>
+    string(12) ":placeholder"
+  }
+}
+array(2) {
+  [0]=>
+  array(1) {
+    ["label"]=>
+    string(9) "first row"
+  }
+  [1]=>
+  array(1) {
+    ["label"]=>
+    string(10) "second row"
+  }
+}
+array(0) {
+}
+array(1) {
+  [0]=>
+  array(1) {
+    ["label"]=>
+    string(1) "?"
+  }
+}
+array(2) {
+  [0]=>
+  array(1) {
+    ["label"]=>
+    string(9) "first row"
+  }
+  [1]=>
+  array(1) {
+    ["label"]=>
+    string(10) "second row"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native_clear_error.phpt
@@ -0,0 +1,96 @@
+--TEST--
+MySQL PDO->prepare(), native PS, clear line after error
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+
+		// We need to run the emulated version first. Native version will cause a fatal error
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		// INSERT a single row
+		$db->exec("INSERT INTO test(id, label) VALUES (1, 'row1')");
+
+		$stmt = $db->prepare('SELECT unknown_column FROM test WHERE id > :placeholder ORDER BY id ASC');
+		$stmt->execute(array(':placeholder' => 0));
+		if ('00000' !== $stmt->errorCode())
+			printf("[003] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > :placeholder ORDER BY id ASC');
+		$stmt->execute(array(':placeholder' => 0));
+		if ('00000' !== $stmt->errorCode())
+			printf("[004] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Native PS
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[005] Unable to turn off emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT unknown_column FROM test WHERE id > :placeholder ORDER BY id ASC');
+		$stmt->execute(array(':placeholder' => 0));
+		if ('00000' !== $stmt->errorCode())
+			printf("[006] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > :placeholder ORDER BY id ASC');
+		$stmt->execute(array(':placeholder' => 0));
+		if ('00000' !== $stmt->errorCode())
+			printf("[007] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Warning: PDOStatement::execute(): SQLSTATE[42S22]: Column not found: 1054 Unknown column 'unknown_column' in 'field list' in %s on line %d
+[003] Execute has failed, '42S22' array (
+  0 => '42S22',
+  1 => 1054,
+  2 => 'Unknown column \'unknown_column\' in \'field list\'',
+)
+array(1) {
+  [0]=>
+  array(2) {
+    ["id"]=>
+    string(1) "1"
+    ["label"]=>
+    string(4) "row1"
+  }
+}
+
+Warning: PDO::prepare(): SQLSTATE[42S22]: Column not found: 1054 Unknown column 'unknown_column' in 'field list' in %s on line %d
+
+Fatal error: Call to a member function execute() on a non-object in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native_column.phpt
@@ -0,0 +1,49 @@
+--TEST--
+MySQL PDO->prepare(), native PS, named placeholder
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+	if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+		printf("[002] Unable to turn off emulated prepared statements\n");
+
+	$stmt = $db->prepare("SELECT :param FROM test ORDER BY id ASC LIMIT 1");
+	$stmt->execute(array(':param' => 'id'));
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	$db->prepare('SELECT :placeholder FROM test WHERE :placeholder > :placeholder');
+	$stmt->execute(array(':placeholder' => 'test'));
+
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  array(1) {
+    ["?"]=>
+    string(2) "id"
+  }
+}
+
+Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number: parameter was not defined in %s on line %d
+array(0) {
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native_dup_named_placeholder.phpt
@@ -0,0 +1,145 @@
+--TEST--
+MySQL PDO->prepare(), native PS, named placeholder II
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label1 CHAR(255), label2 CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+		printf("Native...\n");
+
+		// INSERT a single row
+		$stmt = $db->prepare('INSERT INTO test(id, label1, label2) VALUES (1, :placeholder, :placeholder)');
+
+		$stmt->execute(array(':placeholder' => 'row1'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[003] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		// Ok, what has happened: anything inserted into the DB?
+		$stmt = $db->prepare('SELECT id, label1, label2 FROM test WHERE id = 1');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Now the same with emulated PS.
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn on emulated prepared statements\n");
+		printf("Emulated...\n");
+
+		$stmt = $db->prepare('INSERT INTO test(id, label1, label2) VALUES(2, :placeholder, :placeholder)');
+		// No replacement shall be made
+		$stmt->execute(array(':placeholder' => 'row2'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[005] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		// Now, what do we have in the DB?
+		$stmt = $db->prepare('SELECT id, label1, label2 FROM test WHERE id = 2');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		//
+		// Another variation of the theme
+		//
+
+		$db->exec('DELETE FROM test');
+		$db->exec("INSERT INTO test (id, label1, label2) VALUES (1, 'row1', 'row2')");
+		$sql = "SELECT id, label1 FROM test WHERE id = :placeholder AND label1 = (SELECT label1 AS 'SELECT' FROM test WHERE id = :placeholder)";
+
+		// emulated...
+		$stmt = $db->prepare($sql);
+		$stmt->execute(array(':placeholder' => 1));
+		if ('00000' !== $stmt->errorCode())
+			printf("[006] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// native...
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[007] Unable to turn off emulated prepared statements\n");
+		printf("Native...\n");
+
+		$stmt = $db->prepare($sql);
+		$stmt->execute(array(':placeholder' => 1));
+		if ('00000' !== $stmt->errorCode())
+			printf("[008] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Native...
+
+Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number in %s on line %d
+[003] Execute has failed, 'HY093' array (
+  0 => 'HY093',
+  1 => NULL,
+  2 => NULL,
+)
+array(0) {
+}
+Emulated...
+array(1) {
+  [0]=>
+  array(3) {
+    ["id"]=>
+    string(1) "2"
+    ["label1"]=>
+    string(4) "row2"
+    ["label2"]=>
+    string(4) "row2"
+  }
+}
+array(1) {
+  [0]=>
+  array(2) {
+    ["id"]=>
+    string(1) "1"
+    ["label1"]=>
+    string(4) "row1"
+  }
+}
+Native...
+
+Warning: PDOStatement::execute(): SQLSTATE[HY093]: Invalid parameter number in %s on line %d
+[008] Execute has failed, 'HY093' array (
+  0 => 'HY093',
+  1 => NULL,
+  2 => NULL,
+)
+array(0) {
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native_mixed_style.phpt
@@ -0,0 +1,39 @@
+--TEST--
+MySQL PDO->prepare(), native PS, mixed, wired style
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+	if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+		printf("[002] Unable to turn off emulated prepared statements\n");
+
+	$stmt = $db->query('DELETE FROM test');
+	$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (1, ?), (2, ?)');
+	$stmt->execute(array('a', 'b'));
+	$stmt = $db->prepare("SELECT id, label FROM test WHERE id = :placeholder AND label = (SELECT label AS 'SELECT' FROM test WHERE id = ?)");
+	$stmt->execute(array(1, 1));
+	var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Warning: PDO::prepare(): SQLSTATE[HY093]: Invalid parameter number: mixed named and positional parameters in %s on line %d
+
+Warning: PDO::prepare(): SQLSTATE[HY093]: Invalid parameter number in %s on line %d
+
+Fatal error: Call to a member function execute() on a non-object in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native_named_placeholder.phpt
@@ -0,0 +1,92 @@
+--TEST--
+MySQL PDO->prepare(), native PS, named placeholder
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+
+		// INSERT a single row
+		$stmt = $db->prepare("INSERT INTO test(id, label) VALUES (100, ':placeholder')");
+
+		// Yes, there is no placeholder to bind to and named placeholder
+		// do not work with MySQL native PS, but lets see what happens!
+		// The ':placeholder' is a string constant in the INSERT statement.
+		// I would expect to get an error message, but this is not what happens.
+		$stmt->execute(array(':placeholder' => 'row1'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[003] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		// Ok, what has happened: anything inserted into the DB?
+		$stmt = $db->prepare('SELECT id, label FROM test');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// Now the same with emulated PS.
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn on emulated prepared statements\n");
+
+		// Note that the "named placeholder" is enclosed by double quotes.
+		$stmt = $db->prepare("INSERT INTO test(id, label) VALUES(101, ':placeholder')");
+		// No replacement shall be made
+		$stmt->execute(array(':placeholder' => 'row1'));
+		// Again, I'd like to see an error message
+		if ('00000' !== $stmt->errorCode())
+			printf("[005] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		// Now, what do we have in the DB?
+		$stmt = $db->prepare('SELECT id, label FROM test ORDER BY id');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+[003] Execute has failed, 'HY093' array (
+  0 => 'HY093',
+  1 => NULL,
+  2 => NULL,
+)
+array(0) {
+}
+array(1) {
+  [0]=>
+  array(2) {
+    ["id"]=>
+    string(3) "101"
+    ["label"]=>
+    string(12) ":placeholder"
+  }
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_prepare_native_placeholder_everywhere.phpt
@@ -0,0 +1,90 @@
+--TEST--
+MySQL PDO->prepare(),native PS, anonymous placeholder
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to switch on emulated prepared statements, test will fail\n");
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label CHAR(255)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));
+		$db->exec("INSERT INTO test(id, label) VALUES (1, 'row1')");
+
+		$stmt = $db->prepare('SELECT ?, id, label FROM test WHERE ? = ? ORDER BY id ASC');
+		$stmt->execute(array('id', 'label', 'label'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[003] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		// now the same with native PS
+		printf("now the same with native PS\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to switch off emulated prepared statements, test will fail\n");
+
+		$stmt = $db->prepare('SELECT ?, id, label FROM test WHERE ? = ? ORDER BY id ASC');
+		$stmt->execute(array('id', 'label', 'label'));
+		if ('00000' !== $stmt->errorCode())
+			printf("[005] Execute has failed, %s %s\n",
+				var_export($stmt->errorCode(), true),
+				var_export($stmt->errorInfo(), true));
+
+		$tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);
+		if (!MySQLPDOTest::isPDOMySQLnd()) {
+			if (isset($tmp[0]['id'])) {
+				// libmysql should return a string here whereas mysqlnd returns a native int
+				if (gettype($tmp[0]['id']) == 'string')
+					// convert to int for the test output...
+					settype($tmp[0]['id'], 'integer');
+			}
+		}
+		var_dump($tmp);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+array(1) {
+  [0]=>
+  array(2) {
+    ["id"]=>
+    string(1) "1"
+    ["label"]=>
+    string(4) "row1"
+  }
+}
+now the same with native PS
+array(1) {
+  [0]=>
+  array(3) {
+    ["?"]=>
+    string(2) "id"
+    ["id"]=>
+    int(1)
+    ["label"]=>
+    string(4) "row1"
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_rollback.phpt
@@ -0,0 +1,96 @@
+--TEST--
+PDO::rollBack()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+if (false == MySQLPDOTest::detect_transactional_mysql_engine($db))
+	die("skip Transactional engine not found");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));
+
+	$db->beginTransaction();
+
+	$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+	$num = $row['_num'];
+
+	$db->query("INSERT INTO test(id, label) VALUES (100, 'z')");
+	$num++;
+	$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+	if ($row['_num'] != $num)
+		printf("[001] INSERT has failed, test will fail\n");
+
+	$db->rollBack();
+	$num--;
+	$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+	if ($row['_num'] != $num)
+		printf("[002] ROLLBACK has failed\n");
+
+	$db->beginTransaction();
+	$db->query("INSERT INTO test(id, label) VALUES (100, 'z')");
+	$db->query('DROP TABLE IF EXISTS test2');
+	$db->query('CREATE TABLE test2(id INT)');
+	$num++;
+	$db->rollBack();
+	$row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);
+	if ($row['_num'] != $num)
+		printf("[002] ROLLBACK should have no effect because of the implicit COMMIT
+			triggered by DROP/CREATE TABLE\n");
+
+
+	$db->query('DROP TABLE IF EXISTS test2');
+	$db->query('CREATE TABLE test2(id INT) ENGINE=MyISAM');
+	$db->beginTransaction();
+	$db->query('INSERT INTO test2(id) VALUES (1)');
+	$db->rollBack();
+	$row = $db->query('SELECT COUNT(*) AS _num FROM test2')->fetch(PDO::FETCH_ASSOC);
+	if ($row['_num'] != 1)
+		printf("[003] ROLLBACK should have no effect\n");
+
+	$db->query('DROP TABLE IF EXISTS test2');
+
+	$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 1);
+	$db->beginTransaction();
+	$db->query('DELETE FROM test');
+	$db->rollBack();
+	var_dump($db->getAttribute(PDO::ATTR_AUTOCOMMIT));
+
+	$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 0);
+	$db->beginTransaction();
+	$db->query('DELETE FROM test');
+	$db->rollBack();
+	var_dump($db->getAttribute(PDO::ATTR_AUTOCOMMIT));
+
+	$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 1);
+	$db->beginTransaction();
+	$db->query('DELETE FROM test');
+	$db->commit();
+	var_dump($db->getAttribute(PDO::ATTR_AUTOCOMMIT));
+
+	$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 0);
+	$db->beginTransaction();
+	$db->query('DELETE FROM test');
+	$db->commit();
+	var_dump($db->getAttribute(PDO::ATTR_AUTOCOMMIT));
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+$db->exec('DROP TABLE IF EXISTS test2');
+?>
+--EXPECTF--
+int(1)
+int(0)
+int(1)
+int(0)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_bindcolumn.phpt
@@ -0,0 +1,115 @@
+--TEST--
+MySQL PDOStatement->bindColumn()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT id, label FROM test ORDER BY id ASC LIMIT 2');
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[003] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[004] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$data = array();
+		while ($stmt->fetch(PDO::FETCH_BOUND)) {
+			printf("id = %s (%s) / label = %s (%s)\n",
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+			$data[] = array('id' => $id, 'label' => $label);
+		}
+
+		$stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC LIMIT 2');
+		$index = 0;
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+			if ($row['id'] != $data[$index]['id']) {
+				printf("[005] Fetch bound and fetch assoc differ - column 'id', bound: %s/%s, assoc: %s/%s\n",
+					var_export($data[$index]['id'], true), gettype($data[$index]['id']),
+					var_export($row['id'], true), gettype($row['id']));
+			}
+			if ($row['label'] != $data[$index]['label']) {
+				printf("[006] Fetch bound and fetch assoc differ - column 'label', bound: %s/%s, assoc: %s/%s\n",
+					var_export($data[$index]['label'], true), gettype($data[$index]['label']),
+					var_export($row['label'], true), gettype($row['label']));
+			}
+			$index++;
+		}
+
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[007] Unable to turn off emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT id, label FROM test ORDER BY id ASC LIMIT 2, 2');
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[008] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[009] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$data = array();
+		while ($stmt->fetch(PDO::FETCH_BOUND)) {
+			printf("id = %s (%s) / label = %s (%s)\n",
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+			$data[] = array('id' => $id, 'label' => $label);
+		}
+
+		$stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC LIMIT 2, 2');
+		$index = 0;
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+			if ($row['id'] != $data[$index]['id']) {
+				printf("[010] Fetch bound and fetch assoc differ - column 'id', bound: %s/%s, assoc: %s/%s\n",
+					var_export($data[$index]['id'], true), gettype($data[$index]['id']),
+					var_export($row['id'], true), gettype($row['id']));
+			}
+			if ($row['label'] != $data[$index]['label']) {
+				printf("[011] Fetch bound and fetch assoc differ - column 'label', bound: %s/%s, assoc: %s/%s\n",
+					var_export($data[$index]['label'], true), gettype($data[$index]['label']),
+					var_export($row['label'], true), gettype($row['label']));
+			}
+			$index++;
+		}
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+id = 1 (integer) / label = 'a' (string)
+id = 2 (integer) / label = 'b' (string)
+id = 3 (integer) / label = 'c' (string)
+id = 4 (integer) / label = 'd' (string)
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_bindparam.phpt
@@ -0,0 +1,159 @@
+--TEST--
+MySQL PDOStatement->bindParam()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);
+
+	MySQLPDOTest::createTestTable($db);
+
+	function pdo_mysql_stmt_bindparam($db, $offset) {
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindParam(1, $in))
+			printf("[%03d + 1] Cannot bind parameter, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[%03d + 2] Cannot bind integer column, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[%03d + 3] Cannot bind string column, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Same again...\n");
+		$stmt->execute();
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		// NULL values
+		printf("NULL...\n");
+		$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (100, ?)');
+		$label = null;
+		if (!$stmt->bindParam(1, $label))
+			printf("[%03d + 4] Cannot bind parameter, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->execute())
+			printf("[%03d + 5] Cannot execute statement, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		/* NOTE: you cannot use PDO::query() with unbuffered, native PS - see extra test */
+		$stmt = $db->prepare('SELECT id, NULL AS _label FROM test WHERE label IS NULL');
+		$stmt->execute();
+
+		$id = $label = 'bogus';
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[%03d + 6] Cannot bind NULL column, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[%03d + 3] Cannot bind string column, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+	}
+
+	try {
+		printf("Emulated PS...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		printf("Buffered...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		pdo_mysql_stmt_bindparam($db, 3);
+
+		printf("Unbuffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		pdo_mysql_stmt_bindparam($db, 4);
+
+		printf("Native PS...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn off emulated prepared statements\n");
+
+		printf("Buffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		pdo_mysql_stmt_bindparam($db, 5);
+
+		printf("Unbuffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		pdo_mysql_stmt_bindparam($db, 6);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Emulated PS...
+Buffered...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Same again...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+NULL...
+in = 0 -> id = 100 (integer) / label = NULL (NULL)
+Unbuffered...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Same again...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+NULL...
+in = 0 -> id = 100 (integer) / label = NULL (NULL)
+Native PS...
+Buffered...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Same again...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+NULL...
+in = 0 -> id = 100 (integer) / label = NULL (NULL)
+Unbuffered...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Same again...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+NULL...
+in = 0 -> id = 100 (integer) / label = NULL (NULL)
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_bindparam_types.phpt
@@ -0,0 +1,173 @@
+--TEST--
+MySQL PDOStatement->bindParam() - SQL column types
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	function pdo_mysql_stmt_bindparam_types_do($db, $offset, $native, $sql_type, $value) {
+
+			if ($native)
+				$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+			else
+				$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+
+			$db->exec('DROP TABLE IF EXISTS test');
+			$sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());
+			if ((!$stmt = @$db->prepare($sql)) || (!@$stmt->execute()))
+				// Server might not support column type - skip it
+				return true;
+
+			$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (1, ?)');
+			if (!$stmt->bindParam(1, $value)) {
+				printf("[%03d/%s + 1] %s\n", $offset, ($native) ? 'native' : 'emulated',
+					var_export($stmt->errorInfo(), true));
+				return false;
+			}
+			if (!$stmt->execute()) {
+				printf("[%03d/%s + 2] %s\n", $offset, ($native) ? 'native' : 'emulated',
+					var_export($stmt->errorInfo(), true));
+				return false;
+			}
+
+			$stmt = $db->query('SELECT id, label FROM test');
+			$id = $label = null;
+			if (!$stmt->bindColumn(1, $id)) {
+				printf("[%03d/%s + 3] %s\n", $offset, ($native) ? 'native' : 'emulated',
+					var_export($stmt->errorInfo(), true));
+				return false;
+			}
+			if (!$stmt->bindColumn(2, $label)) {
+				printf("[%03d/%s + 4] %s\n", $offset, ($native) ? 'native' : 'emulated',
+					var_export($stmt->errorInfo(), true));
+				return false;
+			}
+
+			if (!$stmt->fetch(PDO::FETCH_BOUND)) {
+				printf("[%03d/%s + 5] %s\n", $offset, ($native) ? 'native' : 'emulated',
+					var_export($stmt->errorInfo(), true));
+				return false;
+			}
+			$stmt->closeCursor();
+
+			if ($label != $value) {
+				printf("[%03d/%s + 6] Got %s expecting %s - plase check manually\n",
+					$offset, ($native) ? 'native' : 'emulated',
+					var_export($label, true), var_export($value, true));
+				// fall through
+			}
+
+			$stmt->execute();
+			$row = $stmt->fetch(PDO::FETCH_ASSOC);
+			if (empty($row)) {
+				printf("[%03d/%s + 7] %s\n", $offset, ($native) ? 'native' : 'emulated',
+					var_export($stmt->errorInfo(), true));
+				return false;
+			}
+
+			if ($row['label'] != $value) {
+				printf("[%03d/%s + 8] Got %s expecting %s - plase check manually\n",
+					$offset, ($native) ? 'native' : 'emulated',
+					var_export($row['label'], true), var_export($value, true));
+				return false;
+			}
+
+			if ($row['label'] != $label) {
+				printf("[%03d/%s + 9] Got %s from FETCH_ASSOC and %s from FETCH_BOUND- plase check manually\n",
+					$offset, ($native) ? 'native' : 'emulated',
+					var_export($row['label'], true), var_export($value, true));
+				return false;
+			}
+
+			$db->exec('DROP TABLE IF EXISTS test');
+			return true;
+	}
+
+	function pdo_mysql_stmt_bindparam_types($db, $offset, $sql_type, $value) {
+
+		pdo_mysql_stmt_bindparam_types_do($db, $offset, true, $sql_type, $value);
+		pdo_mysql_stmt_bindparam_types_do($db, $offset, false, $sql_type, $value);
+
+	}
+
+	try {
+
+		// pdo_mysql_stmt_bindparam_types($db, 2, 'BIT(8)', 1);
+		pdo_mysql_stmt_bindparam_types($db, 3, 'TINYINT', -127);
+		pdo_mysql_stmt_bindparam_types($db, 4, 'TINYINT UNSIGNED', 255);
+		pdo_mysql_stmt_bindparam_types($db, 5, 'BOOLEAN', 1);
+		pdo_mysql_stmt_bindparam_types($db, 6, 'SMALLINT', -32768);
+		pdo_mysql_stmt_bindparam_types($db, 7, 'SMALLINT UNSIGNED', 65535);
+		pdo_mysql_stmt_bindparam_types($db, 8, 'MEDIUMINT', -8388608);
+		pdo_mysql_stmt_bindparam_types($db, 9, 'MEDIUMINT UNSIGNED', 16777215);
+		pdo_mysql_stmt_bindparam_types($db, 10, 'INT', -2147483648);
+		pdo_mysql_stmt_bindparam_types($db, 11, 'INT UNSIGNED', 4294967295);
+		pdo_mysql_stmt_bindparam_types($db, 12, 'BIGINT',  -1000);
+		pdo_mysql_stmt_bindparam_types($db, 13, 'BIGINT UNSIGNED', 1000);
+		pdo_mysql_stmt_bindparam_types($db, 14, 'REAL', -1000);
+		pdo_mysql_stmt_bindparam_types($db, 15, 'REAL UNSIGNED', 1000);
+		pdo_mysql_stmt_bindparam_types($db, 16, 'REAL ZEROFILL', '0000000000000000000000');
+		pdo_mysql_stmt_bindparam_types($db, 17, 'REAL UNSIGNED ZEROFILL', '0000000000000000000010');
+		pdo_mysql_stmt_bindparam_types($db, 18, 'DOUBLE', -1000);
+		pdo_mysql_stmt_bindparam_types($db, 19, 'DOUBLE UNSIGNED', 1000);
+		pdo_mysql_stmt_bindparam_types($db, 20, 'DOUBLE ZEROFILL', '000000000000');
+		pdo_mysql_stmt_bindparam_types($db, 21, 'DOUBLE ZEROFILL UNSIGNED', '000000001000');
+		pdo_mysql_stmt_bindparam_types($db, 22, 'FLOAT', -1000);
+		pdo_mysql_stmt_bindparam_types($db, 23, 'FLOAT UNSIGNED', 1000);
+		pdo_mysql_stmt_bindparam_types($db, 24, 'FLOAT ZEROFILL', '000000000000');
+		pdo_mysql_stmt_bindparam_types($db, 25, 'FLOAT ZEROFILL UNSIGNED', '000000001000');
+		pdo_mysql_stmt_bindparam_types($db, 26, 'DECIMAL', -1000);
+		pdo_mysql_stmt_bindparam_types($db, 27, 'DECIMAL UNSIGNED', 1000);
+		pdo_mysql_stmt_bindparam_types($db, 28, 'DECIMAL ZEROFILL', '000000000000');
+		pdo_mysql_stmt_bindparam_types($db, 29, 'DECIMAL ZEROFILL UNSIGNED', '000000001000');
+		pdo_mysql_stmt_bindparam_types($db, 30, 'NUMERIC', -1000);
+		pdo_mysql_stmt_bindparam_types($db, 31, 'NUMERIC UNSIGNED', 1000);
+		pdo_mysql_stmt_bindparam_types($db, 32, 'NUMERIC ZEROFILL', '000000000000');
+		pdo_mysql_stmt_bindparam_types($db, 33, 'NUMERIC ZEROFILL UNSIGNED', '000000001000');
+		pdo_mysql_stmt_bindparam_types($db, 34, 'DATE', '2008-04-23');
+		pdo_mysql_stmt_bindparam_types($db, 35, 'TIME', '16:43:12');
+		pdo_mysql_stmt_bindparam_types($db, 36, 'TIMESTAMP', '2008-04-23 16:44:53');
+		pdo_mysql_stmt_bindparam_types($db, 37, 'DATETIME', '2008-04-23 16:44:53');
+		pdo_mysql_stmt_bindparam_types($db, 38, 'YEAR', '2008');
+		pdo_mysql_stmt_bindparam_types($db, 39, 'CHAR(1)', 'a');
+		pdo_mysql_stmt_bindparam_types($db, 40, 'CHAR(255)', 'abc');
+		pdo_mysql_stmt_bindparam_types($db, 41, 'VARCHAR(255)', str_repeat('a', 255));
+		pdo_mysql_stmt_bindparam_types($db, 42, 'BINARY(255)', str_repeat('a', 255));
+		pdo_mysql_stmt_bindparam_types($db, 43, 'VARBINARY(255)', str_repeat('a', 255));
+		pdo_mysql_stmt_bindparam_types($db, 44, 'TINYBLOB', str_repeat('a', 255));
+		pdo_mysql_stmt_bindparam_types($db, 45, 'BLOB', str_repeat('b', 300));
+		pdo_mysql_stmt_bindparam_types($db, 46, 'MEDIUMBLOB', str_repeat('b', 300));
+		pdo_mysql_stmt_bindparam_types($db, 47, 'LONGBLOB', str_repeat('b', 300));
+		pdo_mysql_stmt_bindparam_types($db, 48, 'TINYTEXT', str_repeat('c', 255));
+		pdo_mysql_stmt_bindparam_types($db, 49, 'TINYTEXT BINARY', str_repeat('c', 255));
+		pdo_mysql_stmt_bindparam_types($db, 50, 'TEXT', str_repeat('d', 300));
+		pdo_mysql_stmt_bindparam_types($db, 51, 'TEXT BINARY', str_repeat('d', 300));
+		pdo_mysql_stmt_bindparam_types($db, 52, 'MEDIUMTEXT', str_repeat('d', 300));
+		pdo_mysql_stmt_bindparam_types($db, 53, 'MEDIUMTEXT BINARY', str_repeat('d', 300));
+		pdo_mysql_stmt_bindparam_types($db, 54, 'LONGTEXT', str_repeat('d', 300));
+		pdo_mysql_stmt_bindparam_types($db, 55, 'LONGTEXT BINARY', str_repeat('d', 300));
+		pdo_mysql_stmt_bindparam_types($db, 56, "ENUM('yes', 'no') DEFAULT 'yes'", "no");
+		pdo_mysql_stmt_bindparam_types($db, 57, "SET('yes', 'no') DEFAULT 'yes'", "no");
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_bindvalue.phpt
@@ -0,0 +1,336 @@
+--TEST--
+MySQL PDOStatement->bindValue()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	printf("Testing native PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+
+		printf("Binding variable...\n");
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindValue(1, $in))
+			printf("[003] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[004] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[005] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Binding value and not variable...\n");
+		if (!$stmt->bindValue(1, 0))
+			printf("[006] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[007] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[008] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Binding variable which references another variable...\n");
+		$in = 0;
+		$in_ref = &$in;
+		if (!$stmt->bindValue(1, $in_ref))
+			printf("[009] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[010] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[011] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+
+		printf("Binding a variable and a value...\n");
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? AND id <= ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindValue(1, $in))
+			printf("[012] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindValue(2, 2))
+			printf("[013] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[014] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[015] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Binding a variable to two placeholders and changing the variable value in between the binds...\n");
+		// variable value change shall have no impact
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? AND id <= ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindValue(1, $in))
+			printf("[016] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$in = 2;
+		if (!$stmt->bindValue(2, $in))
+			printf("[017] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[018] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[019] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	printf("Testing emulated PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		printf("Binding variable...\n");
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindValue(1, $in))
+			printf("[003] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[004] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[005] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Binding value and not variable...\n");
+		if (!$stmt->bindValue(1, 0))
+			printf("[006] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[007] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[008] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Binding variable which references another variable...\n");
+		$in = 0;
+		$in_ref = &$in;
+		if (!$stmt->bindValue(1, $in_ref))
+			printf("[009] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[010] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[011] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+
+		printf("Binding a variable and a value...\n");
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? AND id <= ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindValue(1, $in))
+			printf("[012] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindValue(2, 2))
+			printf("[013] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[014] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[015] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		printf("Binding a variable to two placeholders and changing the variable value in between the binds...\n");
+		// variable value change shall have no impact
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? AND id <= ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindValue(1, $in))
+			printf("[016] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$in = 2;
+		if (!$stmt->bindValue(2, $in))
+			printf("[017] Cannot bind value, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[018] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[019] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Testing native PS...
+Binding variable...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding value and not variable...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding variable which references another variable...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding a variable and a value...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding a variable to two placeholders and changing the variable value in between the binds...
+in = 2 -> id = 1 (integer) / label = 'a' (string)
+in = 2 -> id = 2 (integer) / label = 'b' (string)
+Testing emulated PS...
+Binding variable...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding value and not variable...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding variable which references another variable...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding a variable and a value...
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Binding a variable to two placeholders and changing the variable value in between the binds...
+in = 2 -> id = 1 (integer) / label = 'a' (string)
+in = 2 -> id = 2 (integer) / label = 'b' (string)
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_blobfromsteam.phpt
@@ -0,0 +1,148 @@
+--TEST--
+MySQL PDOStatement - inserting BLOB from stream
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+
+$tmp = MySQLPDOTest::getTempDir();
+if (!$tmp)
+	die("skip Can't create temporary file");
+
+$file = $tmp . DIRECTORY_SEPARATOR . 'pdoblob.tst';
+$fp = fopen($file, 'w');
+if (!$fp)
+	die("skip Can't create temporary file");
+
+if (4 != fwrite($fp, 'test')) {
+	die("skip Can't create temporary file");
+}
+fclose($fp);
+clearstatcache();
+
+if (!file_exists($file))
+	die("skip Can't create temporary file");
+
+unlink($file);
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function blob_from_stream($offset, $db, $file, $blob) {
+
+			@unlink($file);
+			clearstatcache();
+			if (file_exists($file)) {
+				printf("[%03d + 1] Cannot remove old test file\n", $offset);
+				return false;
+			}
+
+			$fp = fopen($file, 'w');
+			if (!$fp || !fwrite($fp, $blob)) {
+				printf("[%03d + 2] Cannot create test file '%s'\n", $offset, $file);
+				return false;
+			}
+
+			fclose($fp);
+			clearstatcache();
+			if (!file_exists($file)) {
+				printf("[%03d + 3] Failed to create test file '%s'\n", $offset, $file);
+				return false;
+			}
+
+			$db->exec('DROP TABLE IF EXISTS test');
+			$sql = sprintf('CREATE TABLE test(id INT, label BLOB) ENGINE=%s', PDO_MYSQL_TEST_ENGINE);
+			$db->exec($sql);
+
+			if (!$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)')) {
+				printf("[%03d + 4] %s\n", $offset, var_export($db->errorInfo(), true));
+				return false;
+			}
+
+			$fp = fopen($file, 'r');
+			if (!$fp) {
+				printf("[%03d + 5] Cannot create test file '%s'\n", $offset, $file);
+				return false;
+			}
+
+
+			$id = 1;
+			$stmt->bindParam(1, $id);
+			if (true !== ($tmp = $stmt->bindParam(2, $fp, PDO::PARAM_LOB))) {
+				printf("[%03d + 6] Expecting true, got %s. %s\n",
+					$offset,
+					var_export($tmp, true),
+					var_export($db->errorInfo(), true));
+				return false;
+			}
+
+			if (true !== $stmt->execute()) {
+				printf("[%03d + 7] Failed to INSERT data, %s\n", $offset, var_export($stmt->errorInfo(), true));
+				return false;
+			}
+
+			$stmt2 = $db->query('SELECT id, label FROM test WHERE id = 1');
+			$row = $stmt2->fetch(PDO::FETCH_ASSOC);
+			if ($row['label'] != $blob) {
+				printf("[%03d + 8] INSERT and/or SELECT has failed, dumping data.\n", $offset);
+				var_dump($row);
+				var_dump($blob);
+				return false;
+			}
+
+			// Lets test the chr(0) handling in case the streaming has failed:
+			// is the bug about chr(0) or the streaming...
+			$db->exec('DELETE FROM test');
+			$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');
+			$stmt->bindParam(1, $id);
+			$stmt->bindParam(2, $blob);
+			if (true !== $stmt->execute())
+				printf("[%03d + 9] %s\n", $offset, var_export($stmt->errorInfo(), true));
+
+			$stmt2 = $db->query('SELECT id, label FROM test WHERE id = 1');
+			$row = $stmt2->fetch(PDO::FETCH_ASSOC);
+			if ($row['label'] != $blob) {
+				printf("[%03d + 10] INSERT and/or SELECT has failed, dumping data.\n", $offset);
+				var_dump($row);
+				var_dump($blob);
+				return false;
+			}
+
+			return true;
+	}
+
+	$db = MySQLPDOTest::factory();
+	$blob = 'I am a mighty BLOB!' . chr(0) . "I am a binary thingie!";
+	$tmp = MySQLPDOTest::getTempDir();
+	$file = $tmp . DIRECTORY_SEPARATOR . 'pdoblob.tst';
+
+	try {
+
+		printf("Emulated PS...\n");
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		blob_from_stream(10, $db, $file, $blob);
+
+		printf("Native PS...\n");
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+		blob_from_stream(30, $db, $file, $blob);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+	
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+@unlink(MySQLPDOTest::getTempDir() . DIRECTORY_SEPARATOR . 'pdoblob.tst');
+?>
+--EXPECTF--
+Emulated PS...
+Native PS...
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_blobs.phpt
@@ -0,0 +1,98 @@
+--TEST--
+MySQL Prepared Statements and BLOBs
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	$blobs = array(
+		'TINYBLOB'		=> 255,
+		'TINYTEXT'		=> 255,
+		'BLOB'				=> 32767,
+		'TEXT'				=> 32767,
+		'MEDIUMBLOB'	=> 100000,
+		'MEDIUMTEXT'	=> 100000,
+		'LONGBLOB'		=> 100000,
+		'LONGTEXT'		=> 100000,
+	);
+
+	function test_blob($db, $offset, $sql_type, $test_len) {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, PDO_MYSQL_TEST_ENGINE));
+
+		$value = str_repeat('a', $test_len);
+		$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');
+		$stmt->bindValue(1, 1);
+		$stmt->bindValue(2, $value);
+		if (!$stmt->execute()) {
+			printf("[%03d + 1] %d %s\n",
+				$offset, $stmt->errorCode(), var_export($stmt->errorInfo(), true));
+			return false;
+		}
+
+		$stmt = $db->query('SELECT id, label FROM test');
+		$id = $label = NULL;
+		$stmt->bindColumn(1, $id, PDO::PARAM_INT);
+		$stmt->bindColumn(2, $label, PDO::PARAM_LOB);
+
+		if (!$stmt->fetch(PDO::FETCH_BOUND)) {
+			printf("[%03d + 2] %d %s\n",
+				$offset, $stmt->errorCode(), var_export($stmt->errorInfo(), true));
+			return false;
+		}
+
+		if ($label !== $value) {
+			printf("[%03d + 3] Returned value seems to be wrong (%d vs. %d charachters). Check manually\n",
+				$offset, strlen($label), strlen($value));
+			return false;
+		}
+
+		if (1 != $id) {
+			printf("[%03d + 3] Returned id column value seems wrong, expecting 1 got %s.\n",
+				$offset, var_export($id, true));
+			return false;
+		}
+
+		$stmt = $db->query('SELECT id, label FROM test');
+		$ret = $stmt->fetch(PDO::FETCH_ASSOC);
+
+		if ($ret['label'] !== $value) {
+			printf("[%03d + 3] Returned value seems to be wrong (%d vs. %d charachters). Check manually\n",
+				$offset, strlen($ret['label']), strlen($value));
+			return false;
+		}
+
+		if (1 != $ret['id']) {
+			printf("[%03d + 3] Returned id column value seems wrong, expecting 1 got %s.\n",
+				$offset, var_export($ret['id'], true));
+			return false;
+		}
+
+		return true;
+	}
+
+	$offset = 0;
+	foreach ($blobs as $sql_type => $test_len) {
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		test_blob($db, ++$offset, $sql_type, $test_len);
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+		test_blob($db, ++$offset, $sql_type, $test_len);
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_closecursor.phpt
@@ -0,0 +1,176 @@
+--TEST--
+MySQL PDOStatement->closeCursor()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	/* TODO the results look wrong, why do we get 2014 with buffered AND unbuffered queries */
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	function pdo_mysql_stmt_closecursor($db) {
+
+		// This one should fail. I let it fail to prove that closeCursor() makes a difference.
+		// If no error messages gets printed do not know if proper usage of closeCursor() makes any
+		// difference or not. That's why we need to cause an error here.
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		$stmt1 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		// query() shall fail!
+		$stmt2 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		$stmt1->closeCursor();
+
+		// This is proper usage of closeCursor(). It shall prevent any further error messages.
+		if (MySQLPDOTest::isPDOMySQLnd()) {
+			$stmt1 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		} else {
+			// see pdo_mysql_stmt_unbuffered_2050.phpt for an explanation
+			unset($stmt1);
+			$stmt1 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		}
+		// fetch only the first rows and let closeCursor() clean up
+		$row1 = $stmt1->fetch(PDO::FETCH_ASSOC);
+		$stmt1->closeCursor();
+
+		$stmt2 = $db->prepare('UPDATE test SET label = ? WHERE id = ?');
+		$stmt2->bindValue(1, "z");
+
+		$stmt2->bindValue(2, $row1['id']);
+		$stmt2->execute();
+		$stmt2->closeCursor();
+
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		// check if changing the fetch mode from unbuffered to buffered will
+		// cause any harm to a statement created prior to the change
+		$stmt1->execute();
+		$row2 = $stmt1->fetch(PDO::FETCH_ASSOC);
+		$stmt1->closeCursor();
+		if (!isset($row2['label']) || ('z' !== $row2['label']))
+			printf("Expecting array(id => 1, label => z) got %s\n", var_export($row2, true));
+		unset($stmt1);
+
+		$stmt1 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		// should work
+		$stmt2 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		$stmt1->closeCursor();
+
+		$stmt1 = $db->query('SELECT id, label FROM test ORDER BY id ASC');
+		// fetch only the first rows and let closeCursor() clean up
+		$row3 = $stmt1->fetch(PDO::FETCH_ASSOC);
+		$stmt1->closeCursor();
+		assert($row3 == $row2);
+
+		$stmt2 = $db->prepare('UPDATE test SET label = ? WHERE id = ?');
+		$stmt2->bindValue(1, "a");
+		$stmt2->bindValue(2, $row1['id']);
+		$stmt2->execute();
+		$stmt2->closeCursor();
+
+		$stmt1->execute();
+		$row4 = $stmt1->fetch(PDO::FETCH_ASSOC);
+		$stmt1->closeCursor();
+		assert($row4 == $row1);
+
+		$offset = 0;
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindParam(1, $in))
+			printf("[%03d + 1] Cannot bind parameter, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[%03d + 2] Cannot bind integer column, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[%03d + 3] Cannot bind string column, %s %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		$stmt->closeCursor();
+		$stmt->execute();
+
+	}
+
+
+	try {
+
+		printf("Testing emulated PS...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		printf("Buffered...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		MySQLPDOTest::createTestTable($db);
+		pdo_mysql_stmt_closecursor($db);
+
+		printf("Unbuffered...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		MySQLPDOTest::createTestTable($db);
+		pdo_mysql_stmt_closecursor($db);
+
+		printf("Testing native PS...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+
+		printf("Buffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		pdo_mysql_stmt_closecursor($db);
+
+		printf("Unbuffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		pdo_mysql_stmt_closecursor($db);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Testing emulated PS...
+Buffered...
+
+Warning: PDO::query(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Unbuffered...
+
+Warning: PDO::query(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Testing native PS...
+Buffered...
+
+Warning: PDO::query(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+Unbuffered...
+
+Warning: PDO::query(): SQLSTATE[HY000]: General error: 2014 Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute. in %s on line %d
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_closecursor_empty.phpt
@@ -0,0 +1,74 @@
+--TEST--
+MySQL PDOStatement->closeCursor()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+
+	try {
+
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		MySQLPDOTest::createTestTable($db);
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id > ? ORDER BY id ASC LIMIT 2');
+		$in = 0;
+		if (!$stmt->bindParam(1, $in))
+			printf("[003] Cannot bind parameter, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		$stmt->execute();
+		$id = $label = null;
+
+		if (!$stmt->bindColumn(1, $id, PDO::PARAM_INT))
+			printf("[004] Cannot bind integer column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		if (!$stmt->bindColumn(2, $label, PDO::PARAM_STR))
+			printf("[005] Cannot bind string column, %s %s\n",
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+		$stmt->closeCursor();
+		$stmt->execute();
+		while ($stmt->fetch(PDO::FETCH_BOUND))
+			printf("in = %d -> id = %s (%s) / label = %s (%s)\n",
+				$in,
+				var_export($id, true), gettype($id),
+				var_export($label, true), gettype($label));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	$db->exec('DROP TABLE IF EXISTS test');
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+in = 0 -> id = 1 (integer) / label = 'a' (string)
+in = 0 -> id = 2 (integer) / label = 'b' (string)
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_columncount.phpt
@@ -0,0 +1,69 @@
+--TEST--
+MySQL PDOStatement->columnCount()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	// The only purpose of this is to check if emulated and native PS
+  // return the same. If it works for one, it should work for all.
+	// Internal data structures should be the same in both cases.
+	printf("Testing emulated PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		$stmt = $db->prepare("SELECT id, label, '?' as foo FROM test");
+		$stmt->execute();
+		var_dump($stmt->columnCount());
+
+		$stmt = $db->query('SELECT * FROM test');
+		var_dump($stmt->columnCount());
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	printf("Testing native PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn off emulated prepared statements\n");
+
+		$stmt = $db->prepare("SELECT id, label, '?' as foo, 'TODO - Stored Procedure' as bar FROM test");
+		$stmt->execute();
+		var_dump($stmt->columnCount());
+
+		$stmt = $db->query('SELECT * FROM test');
+		var_dump($stmt->columnCount());
+
+	} catch (PDOException $e) {
+		printf("[003] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Testing emulated PS...
+int(3)
+int(2)
+Testing native PS...
+int(4)
+int(2)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_errorcode.phpt
@@ -0,0 +1,59 @@
+--TEST--
+MySQL PDOStatement->errorCode();
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	$db->exec('DROP TABLE IF EXISTS ihopeitdoesnotexist');
+
+	printf("Testing emulated PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT id FROM ihopeitdoesnotexist ORDER BY id ASC');
+		$stmt->execute();
+		var_dump($stmt->errorCode());
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	printf("Testing native PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn off emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT id FROM ihopeitdoesnotexist ORDER BY id ASC');
+		$stmt->execute();
+		var_dump($stmt->errorCode());
+
+	} catch (PDOException $e) {
+		printf("[003] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+Testing emulated PS...
+
+Warning: PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table '%s.ihopeitdoesnotexist' doesn't exist in %s on line %d
+string(5) "42S02"
+Testing native PS...
+
+Warning: PDO::prepare(): SQLSTATE[42S02]: Base table or view not found: 1146 Table '%s.ihopeitdoesnotexist' doesn't exist in %s on line %d
+
+Fatal error: Call to a member function execute() on a non-object in %s on line %d
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_errorinfo.phpt
@@ -0,0 +1,136 @@
+--TEST--
+MySQL PDOStatement->errorInfo();
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	printf("Testing emulated PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT id FROM ihopeitdoesnotexist ORDER BY id ASC');
+		var_dump($stmt->errorInfo());
+		$stmt->execute();
+		var_dump($stmt->errorInfo());
+
+		MySQLPDOTest::createTestTable($db);
+		$stmt = $db->prepare('SELECT label FROM test ORDER BY id ASC LIMIT 1');
+		$db->exec('DROP TABLE test');
+		var_dump($stmt->execute());
+		var_dump($stmt->errorInfo());
+		var_dump($db->errorInfo());
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorInfo(), implode(' ', $db->errorInfo()));
+	}
+
+	printf("Testing native PS...\n");
+	try {
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn off emulated prepared statements\n");
+
+		$stmt = $db->prepare('SELECT id FROM ihopeitdoesnotexist ORDER BY id ASC');
+		var_dump($stmt);
+
+		MySQLPDOTest::createTestTable($db);
+		$stmt = $db->prepare('SELECT label FROM test ORDER BY id ASC LIMIT 1');
+		var_dump($stmt->errorInfo());
+		$db->exec('DROP TABLE test');
+		$stmt->execute();
+		var_dump($stmt->errorInfo());
+		var_dump($db->errorInfo());
+
+	} catch (PDOException $e) {
+		printf("[003] %s [%s] %s\n",
+			$e->getMessage(), $db->errorInfo(), implode(' ', $db->errorInfo()));
+	}
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Testing emulated PS...
+array(3) {
+  [0]=>
+  %unicode|string%(0) ""
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+
+Warning: PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table '%s.ihopeitdoesnotexist' doesn't exist in %s on line %d
+array(3) {
+  [0]=>
+  %unicode|string%(5) "42S02"
+  [1]=>
+  int(1146)
+  [2]=>
+  %unicode|string%(%d) "Table '%s.ihopeitdoesnotexist' doesn't exist"
+}
+
+Warning: PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table '%s.test' doesn't exist in %s on line %d
+bool(false)
+array(3) {
+  [0]=>
+  %unicode|string%(5) "42S02"
+  [1]=>
+  int(1146)
+  [2]=>
+  %unicode|string%(%d) "Table '%s.test' doesn't exist"
+}
+array(3) {
+  [0]=>
+  %unicode|string%(5) "00000"
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+Testing native PS...
+
+Warning: PDO::prepare(): SQLSTATE[42S02]: Base table or view not found: 1146 Table '%s.ihopeitdoesnotexist' doesn't exist in %s on line %d
+bool(false)
+array(3) {
+  [0]=>
+  %unicode|string%(0) ""
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+
+Warning: PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table '%s.test' doesn't exist in %s on line %d
+array(3) {
+  [0]=>
+  %unicode|string%(5) "42S02"
+  [1]=>
+  int(1146)
+  [2]=>
+  %unicode|string%(%d) "Table '%s.test' doesn't exist"
+}
+array(3) {
+  [0]=>
+  %unicode|string%(5) "00000"
+  [1]=>
+  int(1146)
+  [2]=>
+  %unicode|string%(%d) "Table '%s.ihopeitdoesnotexist' doesn't exist"
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_fetch_non_select.phpt
@@ -0,0 +1,191 @@
+--TEST--
+MySQL PDOStatement->execute()/fetch(), Non-SELECT
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	try {
+
+		// Emulated PS first
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);
+		if (1 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn on emulated prepared statements\n");
+
+		if (!is_object($stmt = $db->query('DESCRIBE test id')))
+			printf("[003] Emulated PS, DESCRIBE failed, %s\n", var_export($db->errorInfo(), true));
+
+		$describe = array();
+		$valid = false;
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+			$describe[] = $row;
+			foreach ($row as $column => $value)
+			if (isset($row['field']) && ($row['field'] == 'id'))
+				$valid = true;
+		}
+		if (empty($describe))
+			printf("[004] Emulated PS, DESCRIBE returned no results\n");
+		else if (!$valid)
+			printf("[005] Emulated PS, DESCRIBE, returned data seems wrong, dumping %s\n",
+				var_export($describe, true));
+
+		if (!is_object($stmt = $db->query('SHOW ENGINES')))
+			printf("[006] Emulated PS, SHOW failed, %s\n", var_export($db->errorInfo(), true));
+
+		$show = array();
+		$valid = false;
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+			$show[] = $row;
+			foreach ($row as $column => $value)
+				// MyISAM engine should be part of _every_ MySQL today
+				if ($value == 'MyISAM')
+					$valid = true;
+		}
+		if (empty($show))
+			printf("[007] Emulated PS, SHOW returned no results\n");
+		else if (!$valid)
+			printf("[008] Emulated PS, SHOW data seems wrong, dumping %s\n",
+				var_export($show, true));
+
+		if (!is_object($stmt = $db->query("EXPLAIN SELECT id FROM test")))
+			printf("[009] Emulated PS, EXPLAIN returned no results\n");
+
+		$explain = array();
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC))
+			$explain[] = $row;
+
+		if (empty($explain))
+			printf("[010] Emulated PS, EXPLAIN returned no results\n");
+
+		// And now native PS
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[011] Unable to turn off emulated prepared statements\n");
+
+		$native_support = 'no';
+		if ($db->exec("PREPARE mystmt FROM 'DESCRIBE test id'")) {
+			$native_support = 'yes';
+			$db->exec('DEALLOCATE PREPARE mystmt');
+		}
+
+		if (!is_object($stmt = $db->query('DESCRIBE test id')))
+			printf("[012] Native PS (native support: %s), DESCRIBE failed, %s\n",
+				$native_support,
+				var_export($db->errorInfo(), true));
+
+		$describe_native = array();
+		$valid = false;
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+			$describe_native[] = $row;
+			foreach ($row as $column => $value)
+			if (isset($row['field']) && ($row['field'] == 'id'))
+				$valid = true;
+		}
+		if (empty($describe_native))
+			printf("[013] Native PS (native support: %s), DESCRIBE returned no results\n",
+				$native_support);
+		else if (!$valid)
+			printf("[014] Native PS (native support: %s), DESCRIBE, returned data seems wrong, dumping %s\n",
+				$native_support,
+				var_export($describe_native, true));
+
+		if ($describe != $describe_native)
+			printf("[015] Emulated and native PS (native support: %s) results of DESCRIBE differ: %s vs. %s\n",
+				$native_support,
+				var_export($describe, true),
+				var_export($describe_native, true));
+
+
+		$native_support = 'no';
+		if ($db->exec("PREPARE mystmt FROM 'SHOW ENGINES'")) {
+			$native_support = 'yes';
+			$db->exec('DEALLOCATE PREPARE mystmt');
+		}
+
+		if (!is_object($stmt = $db->query('SHOW ENGINES')))
+			printf("[016] Native PS (native support: %s), SHOW failed, %s\n",
+				$native_support,
+				var_export($db->errorInfo(), true));
+
+		$show_native = array();
+		$valid = false;
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+			$show_native[] = $row;
+			foreach ($row as $column => $value)
+				// MyISAM engine should be part of _every_ MySQL today
+				if ($value == 'MyISAM')
+					$valid = true;
+		}
+		if (empty($show_native))
+			printf("[017] Native PS (native support: %s), SHOW returned no results\n",
+				$native_support);
+		else if (!$valid)
+			printf("[018] Native PS (native support: %s), SHOW data seems wrong, dumping %s\n",
+				var_export($show_native, true));
+
+		if ($show != $show_native)
+			printf("Native PS (native support: %s) and emulated PS returned different data for SHOW: %s vs. %s\n",
+				$native_support,
+				var_export($show, true),
+				var_export($show_native, true));
+
+		$native_support = 'no';
+		if ($db->exec("PREPARE mystmt FROM 'EXPLAIN SELECT id FROM test'")) {
+			$native_support = 'yes';
+			$db->exec('DEALLOCATE PREPARE mystmt');
+		}
+
+		if (!is_object($stmt = $db->query("EXPLAIN SELECT id FROM test")))
+			printf("[012] Native PS (native support: %s), EXPLAIN failed, %s\n",
+				$native_support,
+				var_export($db->errorInfo(), true));
+
+		$explain_native = array();
+		while ($row = $stmt->fetch(PDO::FETCH_ASSOC))
+			$explain_native[] = $row;
+
+		if (empty($explain_native))
+			printf("[013] Native PS (native support: %s), EXPLAIN returned no results\n",
+				$native_support);
+
+		if ($explain != $explain_native)
+			printf("Native PS (native support: %s) and emulated PS returned different data for EXPLAIN: %s vs. %s\n",
+				$native_support,
+				var_export($explain, true),
+				var_export($explain_native, true));
+
+		$stmt->execute();
+		$explain_native = $stmt->fetchAll(PDO::FETCH_ASSOC);
+		if ($explain != $explain_native)
+			printf("Native PS (native support: %s) and emulated PS returned different data for EXPLAIN: %s vs. %s\n",
+				$native_support,
+				var_export($explain, true),
+				var_export($explain_native, true));
+
+		$stmt->execute();
+		$stmt->execute();
+		// libmysql needs this - otherwise we get a 2015 error
+		if (!MYSQLPDOTest::isPDOMySQLnd())
+			$stmt->fetchAll(PDO::FETCH_ASSOC);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!\n";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_fetch_serialize.phpt
@@ -0,0 +1,153 @@
+--TEST--
+MySQL PDOStatement->fetch(), PDO::FETCH_SERIALIZE
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (version_compare(PHP_VERSION, '5.1.0', '<'))
+	die("skip Needs 5.1.0 and Interface Serializable");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		class myclass implements Serializable {
+
+			private static $instance = null;
+			protected $myprotected = 'a protected propery';
+
+			// Good old magic stuff
+			private function __construct($caller = NULL) {
+				printf("%s(%s)\n", __METHOD__, $caller);
+			}
+
+
+			public function __destruct() {
+				// printf("%s()\n", __METHOD__);
+			}
+
+			public function __sleep() {
+				printf("%s()\n", __METHOD__);
+			}
+
+			public function __wakeup() {
+				printf("%s()\n", __METHOD__);
+			}
+
+			public function __call($method, $params) {
+				printf("%s(%s, %s)\n", __METHOD__, $method, var_export($params, true));
+			}
+
+			public function __set($prop, $value) {
+				printf("%s(%s, %s)\n", __METHOD__, $prop, var_export($value, true));
+				$this->{$prop} = $value;
+			}
+
+			public function __get($prop) {
+				printf("%s(%s)\n", __METHOD__, $prop);
+				return NULL;
+			}
+
+			// Singleton
+			public static function singleton($caller) {
+				printf("%s(%s)\n", __METHOD__, $caller);
+
+				if (!self::$instance) {
+					$c = __CLASS__;
+					self::$instance = new $c($caller);
+				}
+				return self::$instance;
+			}
+
+			// Serializable
+			public function serialize() {
+				printf("%s()\n", __METHOD__);
+				return 'Data from serialize';
+			}
+
+			public function unserialize($data) {
+				printf("%s(%s)\n", __METHOD__, var_export($data, true));
+			}
+
+		}
+
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[002] Unable to turn off emulated prepared statements\n");
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(id INT, myobj BLOB) ENGINE=%s',
+			MySQLPDOTest::getTableEngine()));
+
+		printf("Creating an object, serializing it and writing it to DB...\n");
+		$id = 1;
+		$obj = myclass::singleton('Creating object');
+		$myobj = serialize($obj);
+		$stmt = $db->prepare('INSERT INTO test(id, myobj) VALUES (?, ?)');
+		$stmt->bindValue(1, $id);
+		$stmt->bindValue(2, $myobj);
+		$stmt->execute();
+
+		printf("\nUnserializing the previously serialized object...\n");
+		var_dump(unserialize($myobj));
+
+		printf("\nUsing PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE to fetch the object from DB and unserialize it...\n");
+		$stmt = $db->prepare('SELECT myobj FROM test');
+		$stmt->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass', array('PDO shall not call __construct()'));
+		$stmt->execute();
+		var_dump($stmt->fetch());
+
+		printf("\nUsing PDO::FETCH_CLASS to fetch the object from DB and unserialize it...\n");
+		$stmt = $db->prepare('SELECT myobj FROM test');
+		$stmt->setFetchMode(PDO::FETCH_CLASS, 'myclass', array('PDO shall call __construct()'));
+		$stmt->execute();
+		var_dump($stmt->fetch());
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!\n";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+Creating an object, serializing it and writing it to DB...
+myclass::singleton(Creating object)
+myclass::__construct(Creating object)
+myclass::serialize()
+
+Unserializing the previously serialized object...
+myclass::unserialize('Data from serialize')
+object(myclass)#4 (1) {
+  [%u|b%"myprotected":protected]=>
+  %unicode|string%(19) "a protected propery"
+}
+
+Using PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE to fetch the object from DB and unserialize it...
+myclass::unserialize('C:7:"myclass":19:{Data from serialize}')
+object(myclass)#%d (1) {
+  [%u|b%"myprotected":protected]=>
+  %unicode|string%(19) "a protected propery"
+}
+
+Using PDO::FETCH_CLASS to fetch the object from DB and unserialize it...
+myclass::__set(myobj, 'C:7:"myclass":19:{Data from serialize}')
+myclass::__construct(PDO shall call __construct())
+object(myclass)#%d (2) {
+  [%u|b%"myprotected":protected]=>
+  %unicode|string%(19) "a protected propery"
+  [%u|b%"myobj"]=>
+  %unicode|string%(38) "C:7:"myclass":19:{Data from serialize}"
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_fetch_serialize_simple.phpt
@@ -0,0 +1,93 @@
+--TEST--
+MySQL PDOStatement->fetch(), PDO::FETCH_SERIALIZE
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (version_compare(PHP_VERSION, '5.1.0', '<'))
+	die("skip Needs 5.1.0 and Interface Serializable");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		class myclass implements Serializable {
+
+			public function __construct($caller = null) {
+				printf("%s(%s) - note that it must not be called when unserializing\n", __METHOD__, var_export($caller, true));
+			}
+
+			public function __set($prop, $value) {
+				printf("%s(%s, %s)\n", __METHOD__, var_export($prop, true), var_export($value, true));
+				$this->{$prop} = $value;
+			}
+
+			public function serialize() {
+				printf("%s()\n", __METHOD__);
+				return 'Value from serialize()';
+			}
+
+			public function unserialize($data) {
+				printf("%s(%s)\n", __METHOD__, var_export($data, true));
+			}
+
+		}
+
+		printf("Lets see what the Serializeable interface makes our object behave like...\n");
+		$obj = new myclass('Called by script');
+		$tmp = unserialize(serialize($obj));
+		var_dump($tmp);
+
+		printf("\nAnd now magic PDO using fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE)...\n");
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec(sprintf('CREATE TABLE test(myobj BLOB) ENGINE=%s', MySQLPDOTest::getTableEngine()));
+		$db->exec("INSERT INTO test(myobj) VALUES ('Data fetched from DB to be given to unserialize()')");
+
+		$stmt = $db->prepare('SELECT myobj FROM test');
+		$stmt->execute();
+		$rows = $stmt->fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass', array('Called by PDO'));
+		var_dump($rows[0]);
+
+		$stmt->execute();
+		$rows = $stmt->fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass');
+		var_dump($rows[0]);
+
+		printf("\nAnd now PDO using setFetchMode(PDO::FETCH:CLASS|PDO::FETCH_SERIALIZE) + fetch()...\n");
+		$stmt = $db->prepare('SELECT myobj FROM test');
+		$stmt->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass', array('Called by PDO'));
+		$stmt->execute();
+		var_dump($stmt->fetch());
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	$db->exec('DROP TABLE IF EXISTS test');
+	print "done!\n";
+?>
+--EXPECTF--
+Lets see what the Serializeable interface makes our object behave like...
+myclass::__construct('Called by script') - note that it must not be called when unserializing
+myclass::serialize()
+myclass::unserialize('Value from serialize()')
+object(myclass)#%d (0) {
+}
+
+And now magic PDO using fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE)...
+myclass::unserialize('Data fetched from DB to be given to unserialize()')
+object(myclass)#%d (0) {
+}
+myclass::unserialize('Data fetched from DB to be given to unserialize()')
+object(myclass)#%d (0) {
+}
+
+And now PDO using setFetchMode(PDO::FETCH:CLASS|PDO::FETCH_SERIALIZE) + fetch()...
+myclass::unserialize('Data fetched from DB to be given to unserialize()')
+object(myclass)#%d (0) {
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_fetchobject.phpt
@@ -0,0 +1,109 @@
+--TEST--
+MySQL PDO: PDOStatement->fetchObject()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+
+try {
+	$query = "SELECT '', NULL, \"\" FROM DUAL";
+	$stmt = $db->prepare($query);
+	$ok = @$stmt->execute();
+} catch (PDOException $e) {
+	die("skip: Test cannot be run with SQL mode ANSI");
+}
+if (!$ok)
+	die("skip: Test cannot be run with SQL mode ANSI");
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+MySQLPDOTest::createTestTable($db);
+
+try {
+
+	$query = "SELECT id, '', NULL, \"\" FROM test ORDER BY id ASC LIMIT 3";
+	$stmt = $db->prepare($query);
+
+	class myclass {
+
+		private $set_calls = 0;
+		protected static $static_set_calls = 0;
+
+		// NOTE: PDO does not care about protected
+		protected $grp;
+
+		// NOTE: PDO does not care about private and calls __construct() after __set()
+		private function __construct($param1, $param2) {
+			printf("myclass::__construct(%s, %s): %d / %d\n",
+				$param1, $param2,
+				self::$static_set_calls, $this->set_calls);
+		}
+
+		// NOTE: PDO will call __set() prior to calling __construct()
+		public function __set($prop, $value) {
+			$this->not_a_magic_one();
+			printf("myclass::__set(%s, -%s-) %d\n",
+				$prop, var_export($value, true), $this->set_calls, self::$static_set_calls);
+			if ("" != $prop)
+				$this->{$prop} = $value;
+		}
+
+		// NOTE: PDO can call regular methods prior to calling __construct()
+		public function not_a_magic_one() {
+			$this->set_calls++;
+			self::$static_set_calls++;
+		}
+
+	}
+	$stmt->execute();
+	$rowno = 0;
+	$rows[] = array();
+	while (is_object($rows[] = $stmt->fetchObject('myclass', array($rowno++, $rowno))))
+		;
+
+	var_dump($rows[$rowno - 1]);
+
+} catch (PDOException $e) {
+	// we should never get here, we use warnings, but never trust a system...
+	printf("[001] %s, [%s} %s\n",
+		$e->getMessage(), $db->errorInfo(), implode(' ', $db->errorInfo()));
+}
+
+print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+myclass::__set(id, -'1'-) 1
+myclass::__set(, -''-) 2
+myclass::__set(null, -NULL-) 3
+myclass::__set(, -''-) 4
+myclass::__construct(0, 1): 4 / 4
+myclass::__set(id, -'2'-) 1
+myclass::__set(, -''-) 2
+myclass::__set(null, -NULL-) 3
+myclass::__set(, -''-) 4
+myclass::__construct(1, 2): 8 / 4
+myclass::__set(id, -'3'-) 1
+myclass::__set(, -''-) 2
+myclass::__set(null, -NULL-) 3
+myclass::__set(, -''-) 4
+myclass::__construct(2, 3): 12 / 4
+object(myclass)#%d (4) {
+  [%u|b%"set_calls":"myclass":private]=>
+  int(4)
+  [%u|b%"grp":protected]=>
+  NULL
+  [%u|b%"id"]=>
+  %unicode|string%(1) "3"
+  [%u|b%"null"]=>
+  NULL
+}
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_getcolumnmeta.phpt
@@ -0,0 +1,314 @@
+--TEST--
+MySQL: PDOStatement->getColumnMeta()
+--SKIPIF--
+<?php # vim:ft=php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+// Too many differences among MySQL version - run only with a recent one
+$db = MySQLPDOTest::factory();
+$stmt = $db->query('SELECT VERSION() as _version');
+$row = $stmt->fetch(PDO::FETCH_ASSOC);
+$version = ((int)substr($row['_version'], 0, 1) * 10) + (int)substr($row['_version'], 2, 1);
+if ($version < 51)
+	die("skip Test needs MySQL 5.1+");
+?>
+--FILE--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+$db = MySQLPDOTest::factory();
+$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+MySQLPDOTest::createTestTable($db);
+
+try {
+
+	$stmt = $db->prepare('SELECT id FROM test ORDER BY id ASC');
+
+	// execute() has not been called yet
+	// NOTE: no warning
+	if (false !== ($tmp = $stmt->getColumnMeta(0)))
+		printf("[002] Expecting false got %s\n", var_export($tmp, true));
+
+	$stmt->execute();
+	// Warning: PDOStatement::getColumnMeta() expects exactly 1 parameter, 0 given in
+	if (false !== ($tmp = @$stmt->getColumnMeta()))
+		printf("[003] Expecting false got %s\n", var_export($tmp, true));
+
+	// invalid offset
+	if (false !== ($tmp = @$stmt->getColumnMeta(-1)))
+		printf("[004] Expecting false got %s\n", var_export($tmp, true));
+
+	// Warning: PDOStatement::getColumnMeta() expects parameter 1 to be long, array given in
+	if (false !== ($tmp = @$stmt->getColumnMeta(array())))
+		printf("[005] Expecting false got %s\n", var_export($tmp, true));
+
+	// Warning: PDOStatement::getColumnMeta() expects exactly 1 parameter, 2 given in
+	if (false !== ($tmp = @$stmt->getColumnMeta(1, 1)))
+		printf("[006] Expecting false got %s\n", var_export($tmp, true));
+
+	$emulated =  $stmt->getColumnMeta(0);
+
+	printf("Testing native PS...\n");
+	$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[007] Unable to turn off emulated prepared statements\n");
+
+	$stmt = $db->prepare('SELECT id FROM test ORDER BY id ASC');
+	$stmt->execute();
+	$native = $stmt->getColumnMeta(0);
+	if (count($native) == 0) {
+		printf("[008] Meta data seems wrong, %s / %s\n",
+			var_export($native, true), var_export($emulated, true));
+	}
+
+	// invalid offset
+	if (false !== ($tmp = $stmt->getColumnMeta(1)))
+		printf("[009] Expecting false because of invalid offset got %s\n", var_export($tmp, true));
+
+
+	function test_meta(&$db, $offset, $sql_type, $value, $native_type, $pdo_type) {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+
+		$sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());
+		if (!($stmt = @$db->prepare($sql)) || (!@$stmt->execute())) {
+			// Some engines and/or MySQL server versions might not support the data type
+			return true;
+		}
+
+		if (!$db->exec(sprintf("INSERT INTO test(id, label) VALUES (1, '%s')", $value))) {
+			printf("[%03d] + 1] Insert failed, %d - %s\n", $offset,
+				$db->errorCode(), var_export($db->errorInfo(), true));
+			return false;
+		}
+
+		$stmt = $db->prepare('SELECT id, label FROM test');
+		$stmt->execute();
+		$meta = $stmt->getColumnMeta(1);
+		$row = $stmt->fetch(PDO::FETCH_ASSOC);
+
+		if (empty($meta)) {
+			printf("[%03d + 2] getColumnMeta() failed, %d - %s\n", $offset,
+				$stmt->errorCode(), var_export($stmt->errorInfo(), true));
+			return false;
+		}
+
+		$elements = array('flags', 'table', 'name', 'len', 'precision', 'pdo_type');
+		foreach ($elements as $k => $element)
+			if (!isset($meta[$element])) {
+				printf("[%03d + 3] Element %s missing, %s\n", $offset,
+					$element, var_export($meta, true));
+				return false;
+			}
+
+		if (($meta['table'] != 'test') || ($meta['name'] != 'label')) {
+			printf("[%03d + 4] Table or field name is wrong, %s\n", $offset,
+				var_export($meta, true));
+			return false;
+		}
+
+		if (!is_null($native_type)) {
+			if (!isset($meta['native_type'])) {
+				printf("[%03d + 5] Element native_type missing, %s\n", $offset,
+					var_export($meta, true));
+				return false;
+			}
+
+			if (!is_array($native_type))
+				$native_type = array($native_type);
+
+			$found = false;
+			foreach ($native_type as $k => $type) {
+				if ($meta['native_type'] == $type) {
+					$found = true;
+					break;
+				}
+			}
+
+			if (!$found) {
+			 	printf("[%03d + 6] Expecting native type %s, %s\n", $offset,
+					var_export($native_type, true), var_export($meta, true));
+				return false;
+			}
+		}
+
+		if (!is_null($pdo_type) && ($meta['pdo_type'] != $pdo_type)) {
+			printf("[%03d + 6] Expecting PDO type %s got %s (%s)\n", $offset,
+				$pdo_type, var_export($meta, true), var_export($meta['native_type']));
+			return false;
+		}
+
+		return true;
+	}
+
+	$stmt = $db->prepare('SELECT @@sql_mode AS _mode');
+	$stmt->execute();
+	$row = $stmt->fetch(PDO::FETCH_ASSOC);
+	$real_as_float = (false === stristr($row['_mode'], "REAL_AS_FLOAT")) ? false : true;
+
+	$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);
+	$is_mysqlnd = MySQLPDOTest::isPDOMySQLnd();
+	test_meta($db, 20, 'BIT(8)', 1, NULL, ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+	test_meta($db, 30, 'TINYINT', -127, NULL, ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+	test_meta($db, 40, 'TINYINT UNSIGNED', 255, NULL, ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+	test_meta($db, 50, 'BOOLEAN', 1, NULL, ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+
+	test_meta($db, 60, 'SMALLINT', -32768, 'SHORT', ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+	test_meta($db, 70, 'SMALLINT UNSIGNED', 65535, 'SHORT', ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+
+	test_meta($db, 80, 'MEDIUMINT', -8388608, 'INT24', ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+	test_meta($db, 90, 'MEDIUMINT UNSIGNED', 16777215, 'INT24', ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+
+	test_meta($db, 100, 'INT', -2147483648, 'LONG', ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+	test_meta($db, 110, 'INT UNSIGNED', 4294967295, 'LONG', ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+
+	test_meta($db, 120, 'BIGINT', -9223372036854775808, 'LONGLONG', ($is_mysqlnd) ? ((PHP_INT_SIZE == 4) ? PDO::PARAM_STR : PDO::PARAM_INT) : PDO::PARAM_STR);
+	test_meta($db, 130, 'BIGINT UNSIGNED', 18446744073709551615, 'LONGLONG', ($is_mysqlnd) ? ((PHP_INT_SIZE == 4) ? PDO::PARAM_STR : PDO::PARAM_INT) : PDO::PARAM_STR);
+
+	test_meta($db, 130, 'REAL', -1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);
+	test_meta($db, 140, 'REAL UNSIGNED', 1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);
+	test_meta($db, 150, 'REAL ZEROFILL', -1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);
+	test_meta($db, 160, 'REAL UNSIGNED ZEROFILL', 1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);
+
+	test_meta($db, 170, 'DOUBLE', -1.01, 'DOUBLE', PDO::PARAM_STR);
+	test_meta($db, 180, 'DOUBLE UNSIGNED', 1.01, 'DOUBLE', PDO::PARAM_STR);
+	test_meta($db, 190, 'DOUBLE ZEROFILL', -1.01, 'DOUBLE', PDO::PARAM_STR);
+	test_meta($db, 200, 'DOUBLE UNSIGNED ZEROFILL', 1.01, 'DOUBLE', PDO::PARAM_STR);
+
+	test_meta($db, 210, 'FLOAT', -1.01, 'FLOAT', PDO::PARAM_STR);
+	test_meta($db, 220, 'FLOAT UNSIGNED', 1.01, 'FLOAT', PDO::PARAM_STR);
+	test_meta($db, 230, 'FLOAT ZEROFILL', -1.01, 'FLOAT', PDO::PARAM_STR);
+	test_meta($db, 240, 'FLOAT UNSIGNED ZEROFILL', 1.01, 'FLOAT', PDO::PARAM_STR);
+
+	test_meta($db, 250, 'DECIMAL', -1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+	test_meta($db, 260, 'DECIMAL UNSIGNED', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+	test_meta($db, 270, 'DECIMAL ZEROFILL', -1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+	test_meta($db, 280, 'DECIMAL UNSIGNED ZEROFILL', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+
+	test_meta($db, 290, 'NUMERIC', -1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+	test_meta($db, 300, 'NUMERIC UNSIGNED', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+	test_meta($db, 310, 'NUMERIC ZEROFILL', -1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+	test_meta($db, 320, 'NUMERIC UNSIGNED ZEROFILL', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);
+
+	test_meta($db, 330, 'DATE', '2008-04-23', array('DATE', 'NEWDATE'), PDO::PARAM_STR);
+	test_meta($db, 340, 'TIME', '14:37:00', 'TIME', PDO::PARAM_STR);
+	test_meta($db, 350, 'TIMESTAMP', time(), 'TIMESTAMP', PDO::PARAM_STR);
+	test_meta($db, 360, 'DATETIME', '2008-03-23 14:38:00', 'DATETIME', PDO::PARAM_STR);
+	test_meta($db, 370, 'YEAR', '2008', NULL, ($is_mysqlnd) ? PDO::PARAM_INT : PDO::PARAM_STR);
+
+	test_meta($db, 380, 'CHAR(1)', 'a', 'STRING', PDO::PARAM_STR);
+	test_meta($db, 390, 'CHAR(10)', '0123456789', 'STRING', PDO::PARAM_STR);
+	test_meta($db, 400, 'CHAR(255)', str_repeat('z', 255), 'STRING', PDO::PARAM_STR);
+	test_meta($db, 410, 'VARCHAR(1)', 'a', 'VAR_STRING', PDO::PARAM_STR);
+	test_meta($db, 420, 'VARCHAR(10)', '0123456789', 'VAR_STRING', PDO::PARAM_STR);
+	test_meta($db, 430, 'VARCHAR(255)', str_repeat('z', 255), 'VAR_STRING', PDO::PARAM_STR);
+
+	test_meta($db, 440, 'BINARY(1)', str_repeat('a', 1), 'STRING', PDO::PARAM_STR);
+	test_meta($db, 450, 'BINARY(255)', str_repeat('b', 255), 'STRING', PDO::PARAM_STR);
+	test_meta($db, 460, 'VARBINARY(1)', str_repeat('a', 1), 'VAR_STRING', PDO::PARAM_STR);
+	test_meta($db, 470, 'VARBINARY(255)', str_repeat('b', 255), 'VAR_STRING', PDO::PARAM_STR);
+
+	test_meta($db, 480, 'TINYBLOB', str_repeat('b', 255), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 490, 'BLOB', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 500, 'MEDIUMBLOB', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 510, 'LONGBLOB', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+
+	test_meta($db, 520, 'TINYTEXT', str_repeat('b', 255), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 530, 'TINYTEXT BINARY', str_repeat('b', 255), 'BLOB', PDO::PARAM_STR);
+
+	test_meta($db, 560, 'TEXT', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 570, 'TEXT BINARY', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+
+	test_meta($db, 580, 'MEDIUMTEXT', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 590, 'MEDIUMTEXT BINARY', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+
+	test_meta($db, 600, 'LONGTEXT', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+	test_meta($db, 610, 'LONGTEXT BINARY', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);
+
+	test_meta($db, 620, "ENUM('yes', 'no') DEFAULT 'yes'", 'no', NULL, PDO::PARAM_STR);
+	test_meta($db, 630, "SET('yes', 'no') DEFAULT 'yes'", 'no', NULL, PDO::PARAM_STR);
+
+/*
+  | spatial_type
+*/
+
+	// unique key
+	$db->exec('DROP TABLE IF EXISTS test');
+	$sql = sprintf('CREATE TABLE test(id INT, label INT UNIQUE) ENGINE = %s', MySQLPDOTest::getTableEngine());
+	if (($stmt = @$db->prepare($sql)) && @$stmt->execute()) {
+		$db->exec('INSERT INTO test(id, label) VALUES (1, 2)');
+		$stmt = $db->query('SELECT id, label FROM test');
+		$meta = $stmt->getColumnMeta(1);
+		if (!isset($meta['flags'])) {
+			printf("[1000] No flags contained in metadata %s\n", var_export($meta, true));
+		} else {
+			$flags = $meta['flags'];
+			$found = false;
+			foreach ($flags as $k => $flag) {
+				if ($flag == 'unique_key')
+					$found = true;
+			}
+			if (!$found)
+				printf("[1001] Flags seem wrong %s\n", var_export($meta, true));
+		}
+	}
+
+	// primary key
+	$db->exec('DROP TABLE IF EXISTS test');
+	$sql = sprintf('CREATE TABLE test(id INT PRIMARY KEY NOT NULL AUTO_INCREMENT) ENGINE = %s', MySQLPDOTest::getTableEngine());
+	if (($stmt = @$db->prepare($sql)) && @$stmt->execute()) {
+		$db->exec('INSERT INTO test(id) VALUES (1)');
+		$stmt = $db->query('SELECT id FROM test');
+		$meta = $stmt->getColumnMeta(0);
+		if (!isset($meta['flags'])) {
+			printf("[1002] No flags contained in metadata %s\n", var_export($meta, true));
+		} else {
+			$flags = $meta['flags'];
+			$found = false;
+			foreach ($flags as $k => $flag) {
+				if ($flag == 'primary_key')
+					$found = true;
+			}
+			if (!$found)
+				printf("[1003] Flags seem wrong %s\n", var_export($meta, true));
+		}
+	}
+
+	// multiple key
+	$db->exec('DROP TABLE IF EXISTS test');
+	$sql = sprintf('CREATE TABLE test(id INT, label1 INT, label2 INT, INDEX idx1(label1, label2)) ENGINE = %s', MySQLPDOTest::getTableEngine());
+	if (($stmt = @$db->prepare($sql)) && @$stmt->execute()) {
+		$db->exec('INSERT INTO test(id, label1, label2) VALUES (1, 2, 3)');
+		$stmt = $db->query('SELECT id, label1, label2 FROM test');
+		$meta = $stmt->getColumnMeta(1);
+		if (!isset($meta['flags'])) {
+			printf("[1004] No flags contained in metadata %s\n", var_export($meta, true));
+		} else {
+			$flags = $meta['flags'];
+			$found = false;
+			foreach ($flags as $k => $flag) {
+				if ($flag == 'multiple_key')
+					$found = true;
+			}
+			if (!$found)
+				printf("[1005] Flags seem wrong %s\n", var_export($meta, true));
+		}
+	}
+
+	$stmt = $db->query('SELECT NULL AS col1');
+	$meta = $stmt->getColumnMeta(0);
+	if ('NULL' !== $meta['native_type'])
+		printf("[1006] Expecting NULL got %s\n", $meta['native_type']);
+
+} catch (PDOException $e) {
+	// we should never get here, we use warnings, but never trust a system...
+	printf("[001] %s, [%s} %s\n",
+		$e->getMessage(), $db->errorInfo(), implode(' ', $db->errorInfo()));
+}
+
+$db->exec('DROP TABLE IF EXISTS test');
+print "done!";
+?>
+--EXPECTF--
+Testing native PS...
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_multiquery.phpt
@@ -0,0 +1,102 @@
+--TEST--
+PDOStatements and multi query
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function mysql_stmt_multiquery_wrong_usage($db) {
+
+		$stmt = $db->query('SELECT label FROM test ORDER BY id ASC LIMIT 1; SELECT label FROM test ORDER BY id ASC LIMIT 1');
+		var_dump($stmt->errorInfo());
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		var_dump($stmt->errorInfo());
+
+	}
+
+	function mysql_stmt_multiquery_proper_usage($db) {
+
+		$stmt = $db->query('SELECT label FROM test ORDER BY id ASC LIMIT 1; SELECT label FROM test ORDER BY id ASC LIMIT 1');
+		do {
+			var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		} while ($stmt->nextRowset());
+
+	}
+
+	try {
+
+		printf("Emulated Prepared Statements...\n");
+		$db = MySQLPDOTest::factory();
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		mysql_stmt_multiquery_wrong_usage($db);
+		mysql_stmt_multiquery_proper_usage($db);
+
+		printf("Native Prepared Statements...\n");
+		$db = MySQLPDOTest::factory();
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+		mysql_stmt_multiquery_wrong_usage($db);
+		mysql_stmt_multiquery_proper_usage($db);
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Emulated Prepared Statements...
+array(3) {
+  [0]=>
+  %unicode|string%(5) "00000"
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(3) {
+  [0]=>
+  %unicode|string%(5) "00000"
+  [1]=>
+  NULL
+  [2]=>
+  NULL
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+Native Prepared Statements...
+
+Warning: PDO::query(): SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '%SSELECT label FROM test ORDER BY id ASC LIMIT 1' at line %d in %s on line %d
+
+Fatal error: Call to a member function errorInfo() on a non-object in %s on line %d
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_nextrowset.phpt
@@ -0,0 +1,313 @@
+--TEST--
+MySQL PDOStatement->nextRowSet()
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 50000)
+	die(sprintf("skip Need MySQL Server 5.0.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+
+if (!MySQLPDOTest::isPDOMySQLnd())
+	die("skip This will not work with libmysql");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+
+	MySQLPDOTest::createTestTable($db);
+
+	$stmt = $db->query('SELECT id FROM test');
+	if (false !== ($tmp = $stmt->nextRowSet()))
+		printf("[002] Expecting false got %s\n", var_export($tmp, true));
+
+	// TODO: should give a warning, but its PDO, let's ignore the missing warning for now
+	if (false !== ($tmp = $stmt->nextRowSet(1)))
+		printf("[003] Expecting false got %s\n", var_export($tmp, true));
+
+	function test_proc1($db) {
+
+		$stmt = $db->query('SELECT @VERSION as _version');
+		$tmp = $stmt->fetch(PDO::FETCH_ASSOC);
+		assert($tmp['_version'] === NULL);
+		while ($stmt->fetch()) ;
+
+		$db->exec('DROP PROCEDURE IF EXISTS p');
+		$db->exec('CREATE PROCEDURE p(OUT ver_param VARCHAR(25)) BEGIN SELECT VERSION() INTO ver_param; END;');
+		$db->exec('CALL p(@VERSION)');
+		$stmt = $db->query('SELECT @VERSION as _version');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		var_dump($stmt->nextRowSet());
+
+	}
+
+	function test_proc2($db) {
+
+		$db->exec('DROP PROCEDURE IF EXISTS p');
+		$db->exec('CREATE PROCEDURE p() BEGIN SELECT id FROM test ORDER BY id ASC LIMIT 3; SELECT id, label FROM test WHERE id < 4 ORDER BY id DESC LIMIT 3; END;');
+		$stmt = $db->query('CALL p()');
+		do {
+			var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		} while ($stmt->nextRowSet());
+		var_dump($stmt->nextRowSet());
+
+	}
+
+	try {
+
+		// Emulated PS
+		printf("Emulated PS...\n");
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);
+		test_proc1($db);
+		test_proc2($db);
+
+		$db = MySQLPDOTest::factory();
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 0);
+		test_proc1($db);
+		test_proc2($db);
+
+		// Native PS
+		printf("Native PS...\n");
+		$db = MySQLPDOTest::factory();
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+		test_proc1($db);
+		test_proc2($db);
+
+		$db = MySQLPDOTest::factory();
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 0);
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+
+		test_proc1($db);
+		test_proc2($db);
+
+		@$db->exec('DROP PROCEDURE IF EXISTS p');
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Emulated PS...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_version"]=>
+    %unicode|string%(%d) "%s"
+  }
+}
+bool(false)
+array(3) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+  }
+  [2]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+  }
+}
+array(3) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "c"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+  [2]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+bool(false)
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_version"]=>
+    %unicode|string%(%d) "%s"
+  }
+}
+bool(false)
+array(3) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+  }
+  [2]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+  }
+}
+array(3) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "c"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+  [2]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+bool(false)
+Native PS...
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_version"]=>
+    %unicode|string%(%d) "%s"
+  }
+}
+bool(false)
+array(3) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+  }
+  [2]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+  }
+}
+array(3) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "c"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+  [2]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+bool(false)
+array(1) {
+  [0]=>
+  array(1) {
+    [%u|b%"_version"]=>
+    %unicode|string%(%d) "%s"
+  }
+}
+bool(false)
+array(3) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+  }
+  [2]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+  }
+}
+array(3) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "3"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "c"
+  }
+  [1]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "b"
+  }
+  [2]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+bool(false)
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_rowcount.phpt
@@ -0,0 +1,36 @@
+--TEST--
+MySQL PDOStatement->rowCount() @ SELECT
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+	MySQLPDOTest::createTestTable($db);
+
+	try {
+
+		if (0 !== ($tmp = $db->query('SELECT id FROM test WHERE 1 = 0')->rowCount()))
+			printf("[002] Expecting 0 got %s", var_export($tmp, true));
+
+		if (1 !== ($tmp = $db->query('SELECT id FROM test WHERE id = 1')->rowCount()))
+			printf("[003] Expecting 1 got %s", var_export($tmp, true));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_unbuffered_2050.phpt
@@ -0,0 +1,184 @@
+--TEST--
+MySQL PDO:query() vs. PDO::prepare() and MySQL error 2050
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+if (MYSQLPDOTest::isPDOMySQLnd())
+	die("skip libmysql only test");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	try {
+
+		printf("Native PS...\n");
+		$db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
+		if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))
+			printf("[004] Unable to turn off emulated prepared statements\n");
+
+		printf("Buffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 1');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 1');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		printf("Unbuffered...\n");
+		MySQLPDOTest::createTestTable($db);
+		$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 1');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		/*
+		NOTE - this will cause an error and it OK
+		When using unbuffered prepared statements MySQL expects you to
+		fetch all data from the row before sending new data to the server.
+		PDO::query() will prepare and execute a statement in one step.
+		After the execution of PDO::query(), MySQL expects you to fetch
+		the results from the line before sending new commands. However,
+		PHP/PDO will send a CLOSE message as part of the PDO::query() call.
+
+		The following happens:
+
+			$stmt = PDO::query(<some query>)
+				mysql_stmt_prepare()
+				mysql_stmt_execute()
+
+			$stmt->fetchAll()
+				mysql_stmt_fetch()
+
+			And now the right side of the expression will be executed first:
+				$stmt = PDO::query(<some query>)
+					PDO::query(<some query>)
+						mysql_stmt_prepare
+						mysql_stmt_execute
+
+			PHP continues at the left side of the expression:
+
+				$stmt = PDO::query(<some query>)
+
+					What happens is that $stmt gets overwritten. The reference counter of the
+					zval representing the current value of $stmt. PDO gets a callback that
+					it has to free the resources associated with the zval representing the
+					current value of stmt:
+						mysql_stmt_close
+							---> ERROR
+							---> execute() has been send on the line, you are supposed to fetch
+							---> you must not try to send a CLOSE after execute()
+							---> Error: 2050 (CR_FETCH_CANCELED)
+							---> Message: Row retrieval was canceled by mysql_stmt_close() call
+							---> MySQL does its best to recover the line and cancels the retrieval
+
+					PHP proceeds and assigns the new statement object/zval obtained from
+					PDO to $stmt.
+
+		Solutions:
+				- use mysqlnd
+				- use prepare() + execute() instead of query()
+				- as there is no explicit close() in PDO, try unset($stmt) before the new assignment
+				- fix PDO::query() [not the driver, fix PDO itself]
+		*/
+
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 1');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id = 1');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		$stmt = $db->prepare('SELECT id, label FROM test WHERE id = 1');
+		$stmt->execute();
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		unset($stmt);
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 1');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+		unset($stmt);
+		$stmt = $db->query('SELECT id, label FROM test WHERE id = 1');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+MySQLPDOTest::dropTestTable();
+?>
+--EXPECTF--
+Native PS...
+Buffered...
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+Unbuffered...
+
+Warning: PDOStatement::fetchAll(): SQLSTATE[HY000]: General error: 2050  in %s on line %d
+array(0) {
+}
+
+Warning: PDOStatement::fetchAll(): SQLSTATE[HY000]: General error: 2050  in %s on line %d
+array(0) {
+}
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+array(1) {
+  [0]=>
+  array(2) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+    [%u|b%"label"]=>
+    %unicode|string%(1) "a"
+  }
+}
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_stmt_variable_columncount.phpt
@@ -0,0 +1,123 @@
+--TEST--
+MySQL Prepared Statements and different column counts
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+$db = MySQLPDOTest::factory();
+
+$row = $db->query('SELECT VERSION() as _version')->fetch(PDO::FETCH_ASSOC);
+$matches = array();
+if (!preg_match('/^(\d+)\.(\d+)\.(\d+)/ismU', $row['_version'], $matches))
+	die(sprintf("skip Cannot determine MySQL Server version\n"));
+
+$version = $matches[0] * 10000 + $matches[1] * 100 + $matches[2];
+if ($version < 50000)
+	die(sprintf("skip Need MySQL Server 5.0.0+, found %d.%02d.%02d (%d)\n",
+		$matches[0], $matches[1], $matches[2], $version));
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+	$db = MySQLPDOTest::factory();
+
+	function check_result($offset, $stmt, $columns) {
+
+		do {
+				$row = $stmt->fetch(PDO::FETCH_ASSOC);
+		} while ($stmt->nextRowSet());
+
+		if (!isset($row['one']) || ($row['one'] != 1)) {
+				printf("[%03d + 1] Expecting array('one' => 1), got %s\n", $offset, var_export($row, true));
+				return false;
+		}
+
+		if (($columns == 2) &&
+			(!isset($row['two']) || ($row['two'] != 2))) {
+				printf("[%03d + 2] Expecting array('one' => 1, 'two' => 2), got %s\n", $offset, var_export($row, true));
+				return false;
+		} else if (($columns == 1) && isset($row['two'])) {
+				printf("[%03d + 3] Expecting one array element got two\n", $offset);
+				return false;
+		}
+
+		return true;
+	}
+
+	try {
+
+		// What will happen if a PS returns a differen number of result set column upon each execution?
+		// Lets try with a SP accepting parameters...
+		$db->exec('DROP PROCEDURE IF EXISTS p');
+		$db->exec('CREATE PROCEDURE p(IN cols INT) BEGIN IF cols < 2 THEN SELECT cols AS "one"; ELSE SELECT 1 AS "one", cols AS "two"; END IF; END;');
+
+		// Emulates PS first
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		$stmt = $db->prepare('CALL p(?)');
+
+		$columns = null;
+		$stmt->bindParam(1, $columns);
+		for ($i = 0; $i < 5; $i++) {
+			$columns = ($i % 2) + 1;
+			$stmt->execute();
+			check_result($i, $stmt, $columns);
+		}
+
+		if (MySQLPDOTest::isPDOMySQLnd()) {
+			// Native PS
+			// Libmysql cannot handle such a stored procedure. You will see leaks with libmysql
+			$db = MySQLPDOTest::factory();
+			$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+			$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);
+			$stmt = $db->prepare('CALL p(?)');
+			$stmt->bindParam(1, $columns);
+			for ($i = 5; $i < 10; $i++) {
+				$columns = ($i % 2) + 1;
+				$stmt->execute();
+				check_result($i, $stmt, $columns);
+			}
+		}
+
+		// And now without parameters... - this gives a different control flow inside PDO
+		$db->exec('DROP PROCEDURE IF EXISTS p');
+		$db->exec('CREATE PROCEDURE p() BEGIN DECLARE cols INT; SELECT @numcols INTO cols; IF cols < 2 THEN SET @numcols = 2; SELECT cols AS "one"; ELSE SET @numcols = 1; SELECT 1 AS "one", cols AS "two"; END IF; END;');
+
+				// Emulates PS first
+		$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);
+		$db->exec('SET @numcols = 1');
+		$stmt = $db->prepare('CALL p()');
+		$stmt->execute();
+		check_result(11, $stmt, 1);
+		$stmt->execute();
+		check_result(12, $stmt, 2);
+		$db->exec('SET @numcols = 1');
+		$stmt->execute();
+		check_result(13, $stmt, 1);
+
+		if (MySQLPDOTest::isPDOMySQLnd()) {
+			// Native PS
+			// Libmysql cannot handle such a stored procedure. You will see leaks with libmysql
+			$db = MySQLPDOTest::factory();
+			$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);
+			$db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);
+			$db->exec('SET @numcols = 1');
+			$stmt = $db->prepare('CALL p()');
+			$stmt->execute();
+			check_result(14, $stmt, 1);
+			$stmt->execute();
+			check_result(15, $stmt, 2);
+			$db->exec('SET @numcols = 1');
+			$stmt->execute();
+			check_result(16, $stmt, 1);
+		}
+
+	} catch (PDOException $e) {
+		printf("[99] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	print "done!";
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_subclass.phpt
@@ -0,0 +1,105 @@
+--TEST--
+MySQL PDOStatement->execute()/fetch(), Non-SELECT
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+if (version_compare(PHP_VERSION, '5.0.0', '<'))
+	die("skip Requires PHP 5.0+");
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	// No silly strict mode warnings, please!
+	error_reporting(E_ALL^E_STRICT);
+	ini_set('display_errors', false);
+
+	try {
+
+		class MyPDO extends PDO {
+
+			public function __construct() {
+				$this->protocol();
+				return call_user_func_array(array($this, 'parent::__construct'), func_get_args());
+			}
+
+			public function exec() {
+				$this->protocol();
+				return call_user_func_array(array($this, 'parent::exec'), func_get_args());
+			}
+
+			public function query() {
+				$this->protocol();
+				return call_user_func_array(array($this, 'parent::query'), func_get_args());
+			}
+
+			public function __call($method, $args) {
+				print "__call(".var_export($method,true).", ".var_export($args, true).")\n";
+				// $this->protocol();
+			}
+
+			private function protocol() {
+				$stack = debug_backtrace();
+				if (!isset($stack[1]))
+					return;
+
+				printf("%s(", $stack[1]['function']);
+				$args = '';
+				foreach ($stack[1]['args'] as $k => $v)
+					$args .= sprintf("%s, ", var_export($v, true));
+				if ($args != '')
+					printf("%s", substr($args, 0, -2));
+				printf(")\n");
+			}
+
+		}
+
+		$db = new MyPDO(PDO_MYSQL_TEST_DSN, PDO_MYSQL_TEST_USER, PDO_MYSQL_TEST_PASS);
+		$db->exec('DROP TABLE IF EXISTS test');
+		$db->exec('CREATE TABLE test(id INT)');
+		$db->exec('INSERT INTO test(id) VALUES (1), (2)');
+		$stmt = $db->query('SELECT * FROM test ORDER BY id ASC');
+		var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
+		var_dump($stmt->fetch());
+		$db->intercept_call();
+
+
+	} catch (PDOException $e) {
+		printf("[001] %s [%s] %s\n",
+			$e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));
+	}
+
+	$db->exec('DROP TABLE IF EXISTS test');
+	print "done!\n";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+__construct('%S', '%S', %s)
+exec('DROP TABLE IF EXISTS test')
+exec('CREATE TABLE test(id INT)')
+exec('INSERT INTO test(id) VALUES (1), (2)')
+query('SELECT * FROM test ORDER BY id ASC')
+array(2) {
+  [0]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "1"
+  }
+  [1]=>
+  array(1) {
+    [%u|b%"id"]=>
+    %unicode|string%(1) "2"
+  }
+}
+bool(false)
+__call('intercept_call', array (
+))
+exec('DROP TABLE IF EXISTS test')
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_types.phpt
@@ -0,0 +1,184 @@
+--TEST--
+MySQL PDO->exec(), native types wo ZEROFILL
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function test_type(&$db, $offset, $sql_type, $value, $ret_value = NULL, $pattern = NULL, $alternative_type = NULL) {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());
+		@$db->exec($sql);
+		if ($db->errorCode() != 0) {
+			// not all MySQL Server versions and/or engines might support the type
+			return true;
+		}
+
+		$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');
+		$stmt->bindValue(1, $offset);
+		$stmt->bindValue(2, $value);
+		if (!$stmt->execute()) {
+			printf("[%03d + 1] INSERT failed, %s\n", $offset, var_export($stmt->errorInfo(), true));
+			return false;
+		}
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);
+		$stmt = $db->query('SELECT  id, label FROM test');
+		$row = $stmt->fetch(PDO::FETCH_ASSOC);
+		$stmt->closeCursor();
+
+		if (!isset($row['id']) || !isset($row['label'])) {
+			printf("[%03d + 2] Fetched result seems wrong, dumping result: %s\n", $offset, var_export($row, true));
+			return false;
+		}
+
+		if ($row['id'] != $offset) {
+			printf("[%03d + 3] Expecting %s got %s\n", $offset, $row['id']);
+			return false;
+		}
+
+		if (!is_null($pattern)) {
+			if (!preg_match($pattern, $row['label'])) {
+				printf("[%03d + 5] Value seems wrong, accepting pattern %s got %s, check manually\n",
+					$offset, $pattern, var_export($row['label'], true));
+				return false;
+			}
+
+		} else {
+
+			$exp = $value;
+			if (!is_null($ret_value)) {
+				// we expect a different return value than our input value
+				// typically the difference is only the type
+				$exp = $ret_value;
+			}
+			if ($row['label'] !== $exp && !is_null($alternative_type) && gettype($row['label']) != $alternative_type) {
+				printf("[%03d + 4] %s - input = %s/%s, output = %s/%s (alternative type: %s)\n", $offset,
+					$sql_type, var_export($exp, true), gettype($exp),
+					var_export($row['label'], true), gettype($row['label']),
+					$alternative_type);
+				return false;
+			}
+
+		}
+
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+		$stmt = $db->query('SELECT id, label FROM test');
+		$row_string = $stmt->fetch(PDO::FETCH_ASSOC);
+		$stmt->closeCursor();
+		if (is_null($pattern) && ($row['label'] != $row_string['label'])) {
+			printf("%s - STRINGIGY = %s, NATIVE = %s\n", $sql_type, var_export($row_string['label'], true), var_export($row['label'], true));
+			return false;
+		} else if (!is_null($pattern) && !preg_match($pattern, $row_string['label'])) {
+			printf("%s - STRINGIGY = %s, NATIVE = %s, pattern '%s'\n", $sql_type, var_export($row_string['label'], true), var_export($row['label'], true), $pattern);
+			return false;
+		}
+
+
+		return true;
+	}
+
+	$db = MySQLPDOTest::factory();
+	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
+	$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);
+
+/*
+	test_type($db, 20, 'BIT(8)', 1);
+*/
+	$is_mysqlnd = MySQLPDOTest::isPDOMySQLnd();
+
+	test_type($db, 30, 'TINYINT', -127, ($is_mysqlnd) ? -127: '-127');
+	test_type($db, 40, 'TINYINT UNSIGNED', 255, ($is_mysqlnd) ? 255 : '255');
+	test_type($db, 50, 'BOOLEAN', 1, ($is_mysqlnd) ? 1 : '1');
+
+	test_type($db, 60, 'SMALLINT', -32768, ($is_mysqlnd) ? -32768 : '-32768');
+	test_type($db, 70, 'SMALLINT UNSIGNED', 65535, ($is_mysqlnd) ? 65535 : '65535');
+
+	test_type($db, 80, 'MEDIUMINT', -8388608, ($is_mysqlnd) ? -8388608 : '-8388608');
+	test_type($db, 90, 'MEDIUMINT UNSIGNED', 16777215, ($is_mysqlnd) ? 16777215 : '16777215');
+
+	test_type($db, 100, 'INT', -2147483648,
+		($is_mysqlnd) ? ((PHP_INT_SIZE > 4) ? (int)-2147483648 : (double)-2147483648) : '-2147483648',
+		NULL, ($is_mysqlnd) ? 'integer' : NULL);
+
+	test_type($db, 110, 'INT UNSIGNED', 4294967295, ($is_mysqlnd) ? ((PHP_INT_SIZE > 4) ? 4294967295 : '4294967295') : '4294967295');
+
+	// no chance to return int with the current PDO version - we are forced to return strings
+	test_type($db, 120, 'BIGINT', 1, ($is_mysqlnd) ? 1 : '1');
+	// to avoid trouble with  numeric ranges, lets pass the numbers as a string
+	test_type($db, 130, 'BIGINT', '-9223372036854775808', NULL, '/^\-9[\.]*22/');
+	test_type($db, 140, 'BIGINT UNSIGNED', '18446744073709551615', NULL, '/^1[\.]*844/');
+
+	test_type($db, 150, 'REAL', -1.01, ($is_mysqlnd) ? -1.01 : '-1.01');
+	test_type($db, 160, 'REAL UNSIGNED', 1.01, ($is_mysqlnd) ? 1.01 : '1.01');
+
+	test_type($db, 170, 'DOUBLE', -1.01, ($is_mysqlnd) ? -1.01 : '-1.01');
+	test_type($db, 180, 'DOUBLE UNSIGNED', 1.01, ($is_mysqlnd) ? 1.01 : '1.01');
+
+	test_type($db, 210, 'FLOAT', -1.01, NULL, '/^\-1.0\d+/');
+	test_type($db, 220, 'FLOAT UNSIGNED', 1.01, NULL, '/^1.0\d+/');
+
+	test_type($db, 250, 'DECIMAL', -1.01, '-1');
+	test_type($db, 260, 'DECIMAL UNSIGNED', 1.01, '1');
+
+
+	test_type($db, 290, 'NUMERIC', -1.01, '-1');
+	test_type($db, 300, 'NUMERIC UNSIGNED', 1.01, '1');
+
+	test_type($db, 330, 'DATE', '2008-04-23');
+	test_type($db, 340, 'TIME', '14:37:00');
+	test_type($db, 350, 'TIMESTAMP', '2008-05-06 21:09:00');
+	test_type($db, 360, 'DATETIME', '2008-03-23 14:38:00');
+	test_type($db, 370, 'YEAR', 2008, ($is_mysqlnd) ? 2008 : '2008');
+
+	test_type($db, 380, 'CHAR(1)', 'a');
+	test_type($db, 390, 'CHAR(10)', '0123456789');
+	test_type($db, 400, 'CHAR(255)', str_repeat('z', 255));
+	test_type($db, 410, 'VARCHAR(1)', 'a');
+	test_type($db, 420, 'VARCHAR(10)', '0123456789');
+	test_type($db, 430, 'VARCHAR(255)', str_repeat('z', 255));
+
+	test_type($db, 440, 'BINARY(1)', str_repeat('a', 1));
+	test_type($db, 450, 'BINARY(255)', str_repeat('b', 255));
+	test_type($db, 460, 'VARBINARY(1)', str_repeat('a', 1));
+	test_type($db, 470, 'VARBINARY(255)', str_repeat('b', 255));
+
+	test_type($db, 480, 'TINYBLOB', str_repeat('b', 255));
+	test_type($db, 490, 'BLOB', str_repeat('b', 256));
+	test_type($db, 500, 'MEDIUMBLOB', str_repeat('b', 256));
+	test_type($db, 510, 'LONGBLOB', str_repeat('b', 256));
+
+	test_type($db, 520, 'TINYTEXT', str_repeat('b', 255));
+	test_type($db, 530, 'TINYTEXT BINARY', str_repeat('b', 255));
+
+	test_type($db, 560, 'TEXT', str_repeat('b', 256));
+	test_type($db, 570, 'TEXT BINARY', str_repeat('b', 256));
+
+	test_type($db, 580, 'MEDIUMTEXT', str_repeat('b', 256));
+	test_type($db, 590, 'MEDIUMTEXT BINARY', str_repeat('b', 256));
+
+	test_type($db, 600, 'LONGTEXT', str_repeat('b', 256));
+	test_type($db, 610, 'LONGTEXT BINARY', str_repeat('b', 256));
+
+	test_type($db, 620, "ENUM('yes', 'no') DEFAULT 'yes'", 'no');
+	test_type($db, 630, "SET('yes', 'no') DEFAULT 'yes'", 'no');
+
+	test_type($db, 640, 'DECIMAL(3,2)', -1.01, '-1.01');
+
+
+	echo "done!\n";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+done!
--- /dev/null
+++ b/ext/pdo_mysql/tests/pdo_mysql_types_zerofill.phpt
@@ -0,0 +1,128 @@
+--TEST--
+MySQL PDO->exec(), native types - ZEROFILL
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'skipif.inc');
+require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+MySQLPDOTest::skip();
+?>
+--FILE--
+<?php
+	require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');
+
+	function test_type(&$db, $offset, $sql_type, $value, $ret_value = NULL, $pattern = NULL) {
+
+		$db->exec('DROP TABLE IF EXISTS test');
+		$sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());
+		@$db->exec($sql);
+		if ($db->errorCode() != 0) {
+			// not all MySQL Server versions and/or engines might support the type
+			return true;
+		}
+
+		$stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');
+		$stmt->bindValue(1, $offset);
+		$stmt->bindValue(2, $value);
+		try {
+			if (!$stmt->execute()) {
+				printf("[%03d + 1] INSERT failed, %s\n", $offset, var_export($stmt->errorInfo(), true));
+				return false;
+			}
+		} catch (PDOException $e) {
+			// This might be a SQL warning on signed values inserted in unsigned columns
+			// Zerofill implies unsigned but the test plays with signed = negative values as well!
+			return true;
+		}
+
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);
+		$stmt = $db->query('SELECT id, label FROM test');
+		$row = $stmt->fetch(PDO::FETCH_ASSOC);
+		$stmt->closeCursor();
+		if (!isset($row['id']) || !isset($row['label'])) {
+			printf("[%03d + 2] Fetched result seems wrong, dumping result: %s\n", $offset, var_export($row, true));
+			return false;
+		}
+
+		if ($row['id'] != $offset) {
+			printf("[%03d + 3] Expecting %s got %s\n", $offset, $row['id']);
+			return false;
+		}
+
+		if (!is_null($pattern)) {
+
+			if (!preg_match($pattern, $row['label'])) {
+				printf("[%03d + 5] Value seems wrong, accepting pattern %s got %s, check manually\n",
+					$offset, $pattern, var_export($row['label'], true));
+				return false;
+			}
+
+		} else {
+
+			$exp = $value;
+			if (!is_null($ret_value)) {
+				// we expect a different return value than our input value
+				// typically the difference is only the type
+				$exp = $ret_value;
+			}
+
+			if ($row['label'] !== $exp) {
+				printf("[%03d + 4] %s - input = %s/%s, output = %s/%s\n", $offset,
+					$sql_type, var_export($exp, true), gettype($exp),
+					var_export($row['label'], true), gettype($row['label']));
+				return false;
+			}
+
+		}
+
+		$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);
+		$stmt = $db->query('SELECT id, label FROM test');
+		$row_string = $stmt->fetch(PDO::FETCH_ASSOC);
+		$stmt->closeCursor();
+		if ($row['label'] != $row_string['label']) {
+			printf("%s - STRINGIGY = %s, NATIVE = %s\n", $sql_type, var_export($row_string['label'], true), var_export($row['label'], true));
+			return false;
+		}
+
+		return true;
+	}
+
+	$db = MySQLPDOTest::factory();
+	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+	$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
+	$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);
+
+	$stmt = $db->prepare('SELECT @@sql_mode AS _mode');
+	$stmt->execute();
+	$row = $stmt->fetch(PDO::FETCH_ASSOC);
+	$real_as_float = (false === stristr($row['_mode'], "REAL_AS_FLOAT")) ? false : true;
+
+	test_type($db, 100, 'REAL ZEROFILL', -1.01, NULL, '/^[0]*0$/');
+	test_type($db, 110, 'REAL ZEROFILL', 1.01, NULL, ($real_as_float) ? '/^[0]*1\.0.*$/' : '/^[0]*1\.01$/');
+	test_type($db, 120, 'REAL UNSIGNED ZEROFILL', 1.01, NULL, ($real_as_float) ? '/^[0]*1\..*$/' : '/^[0]*1\.01$/');
+
+	test_type($db, 130, 'DOUBLE ZEROFILL', -1.01, NULL, '/^[0]*0$/');
+	test_type($db, 140, 'DOUBLE ZEROFILL', 1.01, NULL, '/^[0]*1\.01$/');
+	test_type($db, 150, 'DOUBLE UNSIGNED ZEROFILL', 1.01, NULL, '/^[0]*1\.01$/');
+
+	test_type($db, 160, 'FLOAT ZEROFILL', -1.01, NULL, '/^[0]*0$/');
+	test_type($db, 170, 'FLOAT ZEROFILL', 1, NULL, '/^[0]*1$/');
+	test_type($db, 180, 'FLOAT UNSIGNED ZEROFILL', -1, NULL, '/^[0]*0$/');
+
+	test_type($db, 190, 'DECIMAL ZEROFILL', -1.01, NULL, '/^[0]*0$/');
+	test_type($db, 200, 'DECIMAL ZEROFILL', 1.01, NULL, '/^[0]*1$/');
+	test_type($db, 210, 'DECIMAL UNSIGNED ZEROFILL', 1.01, NULL, '/^[0]*1$/');
+
+	test_type($db, 220, 'NUMERIC ZEROFILL', -1, NULL, '/^[0]*0$/');
+	test_type($db, 230, 'NUMERIC ZEROFILL', 1, NULL, '/^[0]*1$/');
+	test_type($db, 240, 'NUMERIC UNSIGNED ZEROFILL', 1.01, NULL, '/^[0]*1$/');
+
+	echo "done!\n";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
+done!
\ No newline at end of file
--- a/ext/pdo_mysql/tests/pecl_bug_5200.phpt
+++ b/ext/pdo_mysql/tests/pecl_bug_5200.phpt
@@ -17,7 +17,13 @@
 foreach ($db->query('DESCRIBE test phase')->fetchAll(PDO::FETCH_ASSOC) as $row) {
 	print_r($row);
 }
-
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
 --EXPECT--
 Array
 (
--- a/ext/pdo_mysql/tests/pecl_bug_5780.phpt
+++ b/ext/pdo_mysql/tests/pecl_bug_5780.phpt
@@ -25,15 +25,25 @@
 $info = $logstmt->errorInfo();
 unset($info[2]);
 var_dump($info);
---EXPECT--
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+$db->exec('DROP TABLE IF EXISTS test2');
+?>
+--EXPECTF--
 array(2) {
   [0]=>
-  string(7) "testing"
+  %unicode|string%(7) "testing"
   [1]=>
-  string(7) "testing"
+  %unicode|string%(7) "testing"
 }
 bool(true)
-array(1) {
+array(2) {
   [0]=>
-  string(5) "00000"
+  %unicode|string%(5) "00000"
+  [1]=>
+  NULL
 }
--- a/ext/pdo_mysql/tests/pecl_bug_5802.phpt
+++ b/ext/pdo_mysql/tests/pecl_bug_5802.phpt
@@ -32,21 +32,30 @@
 if($stmt) $stmt->execute();
 if($stmt) var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));
 
---EXPECT--
+print "done!";
+?>
+--CLEAN--
+<?php
+require dirname(__FILE__) . '/mysql_pdo_test.inc';
+$db = MySQLPDOTest::factory();
+$db->exec('DROP TABLE IF EXISTS test');
+?>
+--EXPECTF--
 array(3) {
   [0]=>
   array(1) {
-    ["bar"]=>
-    string(3) "foo"
+    [%u|b%"bar"]=>
+    %unicode|string%(3) "foo"
   }
   [1]=>
   array(1) {
-    ["bar"]=>
+    [%u|b%"bar"]=>
     NULL
   }
   [2]=>
   array(1) {
-    ["bar"]=>
-    string(3) "qaz"
+    [%u|b%"bar"]=>
+    %unicode|string%(3) "qaz"
   }
 }
+done!
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/skipif.inc
@@ -0,0 +1,7 @@
+<?php
+if (!extension_loaded('pdo') || !extension_loaded('pdo_mysql'))
+	die('skip PDO_MySQL driver not loaded');
+
+if (version_compare(PHP_VERSION, '5.1.0') < 0)
+	die('skip Most tests assume PHP 5.1+');
+?>
\ No newline at end of file
--- /dev/null
+++ b/ext/pdo_mysql/tests/table.inc
@@ -0,0 +1,9 @@
+<?php
+if (!$db) {
+	require dirname(__FILE__) . '/../../../ext/pdo/tests/pdo_test.inc';
+	$db = PDOTest::test_factory(dirname(__FILE__) . '/common.phpt');
+}
+// $db->exec('DROP TABLE IF EXISTS test');
+$db->exec('CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=' . $engine);
+$db->exec('INSERT INTO test(id, label) VALUES (1, "a"), (2, "b"), (3, "c"), (4, "d"), (5, "e"), (6, "f")');
+?>
\ No newline at end of file
--- a/main/php_config.h.in
+++ b/main/php_config.h.in
@@ -1100,6 +1100,18 @@
 /* Whether strtok_r is declared */
 #undef MISSING_STRTOK_R_DECL
 
+/* Whether mysqlnd is enabled */
+#undef MYSQLI_USE_MYSQLND
+
+/* Enable compressed protocol support */
+#undef MYSQLND_COMPRESSION_WANTED
+
+/* Enable SSL support */
+#undef MYSQLND_SSL_SUPPORTED
+
+/* Whether mysqlnd is enabled */
+#undef MYSQL_USE_MYSQLND
+
 /*   */
 #undef MISSING_FCLOSE_DECL
 
@@ -1895,6 +1907,9 @@
 /*   */
 #undef HAVE_FREETDS
 
+/* Whether to build mysql as dynamic module */
+#undef COMPILE_DL_MYSQL
+
 /* Whether you have MySQL */
 #undef HAVE_MYSQL
 
@@ -1904,9 +1919,6 @@
 /*   */
 #undef MYSQL_UNIX_ADDR
 
-/* Whether to build mysql as dynamic module */
-#undef COMPILE_DL_MYSQL
-
 /* embedded MySQL support enabled */
 #undef HAVE_EMBEDDED_MYSQLI
 
@@ -1916,6 +1928,9 @@
 /* Whether to build mysqli as dynamic module */
 #undef COMPILE_DL_MYSQLI
 
+/* Whether to build mysqlnd as dynamic module */
+#undef COMPILE_DL_MYSQLND
+
 /*   */
 #undef HAVE_NCURSES_H
 
@@ -2162,14 +2177,17 @@
 /* Whether to build pdo_firebird as dynamic module */
 #undef COMPILE_DL_PDO_FIREBIRD
 
+/* Whether to build pdo_mysql as dynamic module */
+#undef COMPILE_DL_PDO_MYSQL
+
 /* Whether you have MySQL */
 #undef HAVE_MYSQL
 
 /*   */
 #undef PDO_MYSQL_UNIX_ADDR
 
-/* Whether to build pdo_mysql as dynamic module */
-#undef COMPILE_DL_PDO_MYSQL
+/* Whether pdo_mysql uses mysqlnd */
+#undef PDO_USE_MYSQLND
 
 /*   */
 #undef HAVE_OCIENVCREATE
@@ -2566,6 +2584,9 @@
 
 /* Whether the system supports MD5 salt */
 #undef PHP_MD5_CRYPT
+
+/* */
+#undef PHP_MYSQL_UNIX_SOCK_ADDR
 
 /* Whether the system supports BlowFish salt */
 #undef PHP_BLOWFISH_CRYPT
